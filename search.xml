<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言中的#ifndef和#endif</title>
    <url>/2025/07/25/C_C++/C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%20#ifndef%20%E5%92%8C%20#endif/</url>
    <content><![CDATA[<h1 id="C语言中的-ifndef和-endif"><a href="#C语言中的-ifndef和-endif" class="headerlink" title="C语言中的#ifndef和#endif"></a>C语言中的#ifndef和#endif</h1><h2 id="ifndef-指令"><a href="#ifndef-指令" class="headerlink" title="#ifndef 指令"></a>#ifndef 指令</h2><p>#ifndef 是 “if not defined” 的缩写，意思是“如果未定义”。它用于检查某个宏是否已经被定义。如果没有定义，编译器会处理其后的代码；如果已经定义，编译器会忽略这些代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef 宏名</span><br><span class="line">    // 如果没有定义该宏时，执行这里的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MY_HEADER_FILE_H</span><br><span class="line">#define MY_HEADER_FILE_H</span><br><span class="line"></span><br><span class="line">// 这里是头文件内容</span><br><span class="line">void foo();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>这段代码检查是否定义了 MY_HEADER_FILE_H 这个宏。<br>如果 MY_HEADER_FILE_H 没有被定义，#ifndef 之后的代码将会被编译，并且在此之后会定义 MY_HEADER_FILE_H。<br>这样，如果其他文件再包含这个头文件时，由于 MY_HEADER_FILE_H 已经被定义，#ifndef 语句就会跳过，避免头文件内容被多次定义。</p>
<h2 id="endif-指令"><a href="#endif-指令" class="headerlink" title="#endif 指令"></a>#endif 指令</h2><p>#endif 是 #if、#ifndef 或 #ifdef 等条件编译指令的结束标志，表示条件编译块的结束。它用于标记条件编译的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef 宏名</span><br><span class="line">    // 条件为真的时候编译的代码</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h2><p>考虑到实际应用中的情况，#ifndef 和 #endif 一般与 #define 结合使用，特别是在头文件中，以防止头文件被重复包含。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// example.h</span><br><span class="line"></span><br><span class="line">#ifndef EXAMPLE_H  // 检查 EXAMPLE_H 是否被定义</span><br><span class="line">#define EXAMPLE_H  // 如果没有定义 EXAMPLE_H，则定义它</span><br><span class="line"></span><br><span class="line">// 头文件的内容</span><br><span class="line">void example_function();</span><br><span class="line"></span><br><span class="line">#endif  // 结束条件编译</span><br></pre></td></tr></table></figure>



<p>当 example.h 头文件第一次被包含时，EXAMPLE_H 还没有定义，所以 #ifndef EXAMPLE_H 为真，编译器会继续执行，并定义 EXAMPLE_H。<br>当同一个头文件再次被包含时，由于 EXAMPLE_H 已经定义，#ifndef EXAMPLE_H 条件不成立，#define EXAMPLE_H 和后续的代码都会被跳过，从而避免了重复定义。</p>
<h2 id="常见用法：头文件保护（Include-Guard）"><a href="#常见用法：头文件保护（Include-Guard）" class="headerlink" title="常见用法：头文件保护（Include Guard）"></a>常见用法：头文件保护（Include Guard）</h2><p>在大型 C 项目中，头文件常常被多个源文件引用。如果头文件没有适当的保护机制，可能会发生以下情况：</p>
<p>重复定义：同一个头文件可能会被多次包含，导致符号、变量等重复定义的错误。<br>性能问题：每次头文件被包含时，都会编译头文件内容，增加编译时间。<br>通过 #ifndef 和 #endif 可以防止这些问题，通常称为“头文件保护”。</p>
<p>头文件保护的标准写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// header.h</span><br><span class="line">#ifndef HEADER_H  // 如果 HEADER_H 没有被定义</span><br><span class="line">#define HEADER_H  // 定义 HEADER_H</span><br><span class="line"></span><br><span class="line">// 头文件的内容</span><br><span class="line">void some_function();</span><br><span class="line"></span><br><span class="line">#endif  // 结束条件编译</span><br></pre></td></tr></table></figure>



<p>#ifndef HEADER_H 检查是否已经定义了 HEADER_H。<br>如果没有定义，定义它并编译头文件内容。<br>如果已经定义，编译器会跳过整个头文件的内容。</p>
<h2 id="相关的预处理指令"><a href="#相关的预处理指令" class="headerlink" title="相关的预处理指令"></a>相关的预处理指令</h2><p>除了 #ifndef，C 语言还提供了其他条件编译指令，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef：检查某个宏是否已定义（如果定义了，条件成立）。</span><br><span class="line">#else：与 #if 或 #ifdef 配合使用，指定条件不成立时执行的代码。</span><br><span class="line">#elif：在 #if 或 #ifdef 条件不成立时，检查其他条件。</span><br><span class="line">#if：如果条件成立，编译器会处理其后的代码。</span><br><span class="line">#define：用于定义宏或常量。</span><br><span class="line">#undef：用于取消宏的定义。</span><br><span class="line">#ifdef 和 #ifndef 的区别：</span><br><span class="line">#ifdef 用来检查宏是否已经定义，而 #ifndef 则是检查宏是否未定义。</span><br><span class="line"></span><br><span class="line">#ifdef MY_MACRO  // 如果 MY_MACRO 已经定义</span><br><span class="line">// 执行一些操作</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef MY_MACRO  // 如果 MY_MACRO 未定义</span><br><span class="line">// 执行一些操作</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>多平台支持：在跨平台开发中，常常使用条件编译来根据操作系统或硬件平台选择性地编译代码。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef _WIN32</span><br><span class="line">// Windows 平台下的代码</span><br><span class="line">#elif defined(__linux__)</span><br><span class="line">// Linux 平台下的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>调试信息控制：通过条件编译，可以在开发过程中打开调试信息，在发布版本中禁用调试代码。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">printf(&quot;Debugging information...\n&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>#ifndef 和 #endif 是 C 语言中的条件编译指令，主要用于防止头文件的重复包含，以及在编译时根据不同条件选择性地包含代码。它们是编写高效、可维护 C 代码的基础工具之一，特别是在多文件、大型项目中尤为重要。通过合理使用这些指令，我们可以避免编译冲突、提高编译效率，并能在不同的环境下灵活控制代码的执行。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出C++11新特性：核心功能与实战示例</title>
    <url>/2025/09/16/C_C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>C++11是C++语言发展史上的里程碑版本，引入了数十项新特性，从语法简化到性能优化，从内存安全到并发编程，全方位提升了语言的易用性、安全性和高效性。对于嵌入式开发、服务器开发、游戏引擎等领域的开发者而言，掌握C++11是提升编码效率和代码质量的关键。本文将从<strong>语法简化</strong>、<strong>类型增强</strong>、<strong>内存管理</strong>、<strong>并发编程</strong>、<strong>通用编程</strong>五大维度，结合实战示例讲解C++11的核心新特性。</p>
<h2 id="一、语法简化：减少冗余，提升编码效率"><a href="#一、语法简化：减少冗余，提升编码效率" class="headerlink" title="一、语法简化：减少冗余，提升编码效率"></a>一、语法简化：减少冗余，提升编码效率</h2><p>C++11通过多种语法优化，解决了传统C++中“代码冗余”“表达繁琐”的问题，让开发者更聚焦于逻辑实现而非语法细节。</p>
<h3 id="1-自动类型推导（auto）"><a href="#1-自动类型推导（auto）" class="headerlink" title="1. 自动类型推导（auto）"></a>1. 自动类型推导（auto）</h3><p><strong>核心作用</strong>：让编译器根据变量的初始化值自动推导类型，避免手动书写冗长的类型名（尤其适合模板、STL迭代器等场景）。<br><strong>注意事项</strong>：<code>auto</code>不能单独用于函数返回值、函数参数，也不能推导数组类型。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传统写法：需显式声明int</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// C++11：auto推导为int</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">20</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景1：STL迭代器（传统写法冗长）</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; score_map = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">88</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 传统迭代器声明：std::map&lt;std::string, int&gt;::iterator it</span></span><br><span class="line">    <span class="keyword">auto</span> it = score_map.<span class="built_in">begin</span>(); </span><br><span class="line">    <span class="keyword">while</span> (it != score_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 嵌套类型也可推导：it-&gt;first是string，it-&gt;second是int</span></span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2：复杂表达式类型</span></span><br><span class="line">    <span class="keyword">auto</span> result = (<span class="number">10</span> + <span class="number">20</span>) * <span class="number">3.14</span>; <span class="comment">// 推导为double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出94.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-范围for循环（Range-based-for-Loop）"><a href="#2-范围for循环（Range-based-for-Loop）" class="headerlink" title="2. 范围for循环（Range-based for Loop）"></a>2. 范围for循环（Range-based for Loop）</h3><p><strong>核心作用</strong>：遍历数组、STL容器（如vector、list、map）时，无需手动管理迭代器或索引，语法更简洁。<br><strong>语法格式</strong>：<code>for (auto [&amp;]var : 容器/数组) &#123; ... &#125;</code>，其中<code>&amp;</code>表示引用（避免拷贝，支持修改元素）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : arr) &#123; <span class="comment">// auto推导为int</span></span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历STL容器（并修改元素）</span></span><br><span class="line">    std::vector&lt;std::string&gt; fruits = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified fruits: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; fruit : fruits) &#123; <span class="comment">// 引用传递，可修改元素</span></span><br><span class="line">        fruit += <span class="string">&quot;_new&quot;</span>; <span class="comment">// 给每个元素追加&quot;_new&quot;</span></span><br><span class="line">        std::cout &lt;&lt; fruit &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出apple_new banana_new cherry_new</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-列表初始化（Uniform-Initialization）"><a href="#3-列表初始化（Uniform-Initialization）" class="headerlink" title="3. 列表初始化（Uniform Initialization）"></a>3. 列表初始化（Uniform Initialization）</h3><p><strong>核心作用</strong>：用统一的<code>&#123;&#125;</code>语法初始化变量、数组、类对象，支持“聚合初始化”和“非聚合初始化”，同时避免传统初始化的“窄化转换”（如<code>int a = 3.14</code>的隐式截断）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 基本类型初始化</span></span><br><span class="line">    <span class="type">int</span> x&#123;<span class="number">10</span>&#125;; <span class="comment">// 等价于int x = 10</span></span><br><span class="line">    <span class="comment">// int y&#123;3.14&#125;; // 编译报错：窄化转换（double→int），传统int y=3.14不会报错但有风险</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 数组初始化</span></span><br><span class="line">    <span class="type">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 无需指定数组长度，编译器自动推导</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. STL容器初始化（无需先push_back）</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 直接初始化3个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 输出3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 类对象初始化</span></span><br><span class="line">    Person p&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;; <span class="comment">// 无需写括号，直接用&#123;&#125;传参</span></span><br><span class="line">    p.<span class="built_in">show</span>(); <span class="comment">// 输出Alice, 25岁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二、类型增强：更灵活的类型定义与处理"><a href="#二、类型增强：更灵活的类型定义与处理" class="headerlink" title="二、类型增强：更灵活的类型定义与处理"></a>二、类型增强：更灵活的类型定义与处理</h2><p>C++11新增了多种类型相关特性，解决了传统C++中“类型别名繁琐”“空指针歧义”“枚举类型不安全”等问题。</p>
<h3 id="1-类型别名（using）"><a href="#1-类型别名（using）" class="headerlink" title="1. 类型别名（using）"></a>1. 类型别名（using）</h3><p><strong>核心作用</strong>：替代传统的<code>typedef</code>，支持模板类型别名（<code>typedef</code>无法实现），语法更直观。<br><strong>语法格式</strong>：<code>using 别名 = 原类型;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 基本类型别名（与typedef等价）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MyInt;       <span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">using</span> MyIntNew = <span class="type">int</span>;    <span class="comment">// C++11写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模板类型别名（typedef无法实现）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;; <span class="comment">// 定义模板别名Vec，代替std::vector</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInt a = <span class="number">10</span>;</span><br><span class="line">    MyIntNew b = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl; <span class="comment">// 输出30</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用模板别名Vec</span></span><br><span class="line">    Vec&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 等价于std::vector&lt;int&gt;</span></span><br><span class="line">    Vec&lt;std::string&gt; str_vec&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;; <span class="comment">// 等价于std::vector&lt;std::string&gt;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Str vec size: &quot;</span> &lt;&lt; str_vec.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 输出3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-空指针常量（nullptr）"><a href="#2-空指针常量（nullptr）" class="headerlink" title="2. 空指针常量（nullptr）"></a>2. 空指针常量（nullptr）</h3><p><strong>核心作用</strong>：替代传统的<code>NULL</code>（<code>NULL</code>本质是<code>#define NULL 0</code>，属于<code>int</code>类型），明确表示“空指针”，避免函数重载时的歧义。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调用int版本: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调用char*版本: &quot;</span> &lt;&lt; (p ? p : <span class="string">&quot;null&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传统NULL的问题：NULL是0（int类型），会匹配int版本的func</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 输出“调用int版本: 0”，不符合“传空指针”的预期</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C++11 nullptr：类型是nullptr_t，会匹配指针版本的func</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出“调用char*版本: null”，符合预期</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-强类型枚举（enum-class）"><a href="#3-强类型枚举（enum-class）" class="headerlink" title="3. 强类型枚举（enum class）"></a>3. 强类型枚举（enum class）</h3><p><strong>核心作用</strong>：解决传统枚举（<code>enum</code>）的“作用域污染”（枚举值全局可见）和“隐式类型转换”（枚举值可直接转为<code>int</code>）问题，安全性更高。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统枚举的问题：作用域污染</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="comment">// enum Fruit &#123; APPLE, RED &#125;; // 编译报错：RED已在Color中定义（全局可见）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 强类型枚举：作用域限制在enum class内部</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ColorNew</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">FruitNew</span> &#123; APPLE, BANANA, RED &#125;; <span class="comment">// 允许RED，因为作用域独立</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传统枚举：隐式转换为int</span></span><br><span class="line">    Color c = RED;</span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl; <span class="comment">// 输出0（RED的枚举值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 强类型枚举：必须显式指定作用域，且不能隐式转为int</span></span><br><span class="line">    ColorNew c_new = ColorNew::RED; <span class="comment">// 必须写ColorNew::</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; c_new &lt;&lt; std::endl; // 编译报错：无法隐式转换为int</span></span><br><span class="line">    <span class="comment">// 需显式转换：</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c_new) &lt;&lt; std::endl; <span class="comment">// 输出0</span></span><br><span class="line">    </span><br><span class="line">    FruitNew f_new = FruitNew::RED; <span class="comment">// 正确，与ColorNew::RED无冲突</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(f_new) &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三、内存管理：智能指针，告别内存泄漏"><a href="#三、内存管理：智能指针，告别内存泄漏" class="headerlink" title="三、内存管理：智能指针，告别内存泄漏"></a>三、内存管理：智能指针，告别内存泄漏</h2><p>传统C++依赖手动<code>new/delete</code>管理动态内存，容易出现“内存泄漏”（忘记<code>delete</code>）、“野指针”（<code>delete</code>后未置空）、“重复释放”等问题。C++11引入<strong>智能指针</strong>（<code>std::shared_ptr</code>、<code>std::unique_ptr</code>、<code>std::weak_ptr</code>），通过“RAII（资源获取即初始化）”机制自动管理内存，大幅提升安全性。</p>
<h3 id="1-独占智能指针（std-unique-ptr）"><a href="#1-独占智能指针（std-unique-ptr）" class="headerlink" title="1. 独占智能指针（std::unique_ptr）"></a>1. 独占智能指针（std::unique_ptr）</h3><p><strong>核心特性</strong>：“独占所有权”——同一时间只能有一个<code>unique_ptr</code>指向动态内存，拷贝构造和赋值被禁用（避免多个指针管理同一块内存），适用于“单一所有者”场景。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// 智能指针头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> id) : <span class="built_in">id_</span>(id) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建unique_ptr（自动管理内存，无需手动delete）</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">1</span>))</span></span>;</span><br><span class="line">    ptr1-&gt;<span class="built_in">show</span>(); <span class="comment">// 调用成员函数，输出“ID: 1”</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 所有权转移（通过std::move，原ptr1变为空）</span></span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">    <span class="comment">// ptr1-&gt;show(); // 运行报错：ptr1已为空（所有权已转移）</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出“ID: 1”</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 离开作用域时，ptr2自动析构，释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// MyClass 1 构造</span></span><br><span class="line"><span class="comment">// ID: 1</span></span><br><span class="line"><span class="comment">// ID: 1</span></span><br><span class="line"><span class="comment">// MyClass 1 析构（自动调用，无内存泄漏）</span></span><br></pre></td></tr></table></figure>


<h3 id="2-共享智能指针（std-shared-ptr）"><a href="#2-共享智能指针（std-shared-ptr）" class="headerlink" title="2. 共享智能指针（std::shared_ptr）"></a>2. 共享智能指针（std::shared_ptr）</h3><p><strong>核心特性</strong>：“共享所有权”——多个<code>shared_ptr</code>可指向同一块内存，内部通过“引用计数”跟踪所有者数量，当引用计数为0时自动释放内存，适用于“多所有者”场景。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建shared_ptr（引用计数初始化为1）</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">2</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数1: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 拷贝ptr1，引用计数变为2</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数2: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数3: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. ptr1销毁（离开作用域或重置），引用计数变为1</span></span><br><span class="line">    ptr<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">// 手动重置ptr1（变为空）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用计数4: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. ptr2离开作用域，引用计数变为0，自动析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// MyClass 2 构造</span></span><br><span class="line"><span class="comment">// 引用计数1: 1</span></span><br><span class="line"><span class="comment">// 引用计数2: 2</span></span><br><span class="line"><span class="comment">// 引用计数3: 2</span></span><br><span class="line"><span class="comment">// 引用计数4: 1</span></span><br><span class="line"><span class="comment">// MyClass 2 析构（引用计数为0时释放）</span></span><br></pre></td></tr></table></figure>


<h3 id="3-弱智能指针（std-weak-ptr）"><a href="#3-弱智能指针（std-weak-ptr）" class="headerlink" title="3. 弱智能指针（std::weak_ptr）"></a>3. 弱智能指针（std::weak_ptr）</h3><p><strong>核心特性</strong>：“弱引用”——配合<code>shared_ptr</code>使用，不增加引用计数，用于解决<code>shared_ptr</code>的“循环引用”问题（如A指向B，B指向A，导致引用计数无法为0，内存泄漏）。</p>
<p><strong>示例（解决循环引用）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用weak_ptr指向B，不增加引用计数</span></span><br><span class="line">    std::weak_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A 析构&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用shared_ptr指向A</span></span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B 析构&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建A和B的shared_ptr</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立关联：A指向B，B指向A</span></span><br><span class="line">    a-&gt;b_ptr = b; <span class="comment">// weak_ptr赋值，b的引用计数仍为1</span></span><br><span class="line">    b-&gt;a_ptr = a; <span class="comment">// shared_ptr赋值，a的引用计数变为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 离开作用域时，a和b的引用计数分别减为1和1（无循环引用问题）</span></span><br><span class="line">    <span class="comment">// 最终引用计数为0，A和B均会析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// A 析构</span></span><br><span class="line"><span class="comment">// B 析构（无内存泄漏）</span></span><br></pre></td></tr></table></figure>


<h2 id="四、并发编程：原生支持多线程"><a href="#四、并发编程：原生支持多线程" class="headerlink" title="四、并发编程：原生支持多线程"></a>四、并发编程：原生支持多线程</h2><p>传统C++依赖操作系统API（如POSIX线程、Windows线程）实现多线程，代码可移植性差。C++11首次将<strong>线程库</strong>（<code>std::thread</code>）、<strong>互斥锁</strong>（<code>std::mutex</code>）、<strong>条件变量</strong>（<code>std::condition_variable</code>）等纳入标准库，提供跨平台的并发编程支持。</p>
<h3 id="1-线程创建（std-thread）"><a href="#1-线程创建（std-thread）" class="headerlink" title="1. 线程创建（std::thread）"></a>1. 线程创建（std::thread）</h3><p><strong>核心作用</strong>：通过<code>std::thread</code>类直接创建线程，传入函数（或函数对象、Lambda表达式）作为线程入口，析构前需调用<code>join()</code>（等待线程结束）或<code>detach()</code>（线程独立运行）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span> <span class="comment">// 用于sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数（线程入口）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_numbers</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= count; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;线程&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 休眠100ms，模拟耗时操作</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程开始&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建2个线程，分别执行print_numbers</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(print_numbers, <span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 线程1：打印1-3</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(print_numbers, <span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 线程2：打印1-3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待线程结束（必须调用join()，否则主线程析构时会崩溃）</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出（线程1和线程2交替执行，顺序可能不同）：</span></span><br><span class="line"><span class="comment">// 主线程开始</span></span><br><span class="line"><span class="comment">// 线程1: 1</span></span><br><span class="line"><span class="comment">// 线程2: 1</span></span><br><span class="line"><span class="comment">// 线程1: 2</span></span><br><span class="line"><span class="comment">// 线程2: 2</span></span><br><span class="line"><span class="comment">// 线程1: 3</span></span><br><span class="line"><span class="comment">// 线程2: 3</span></span><br><span class="line"><span class="comment">// 主线程结束</span></span><br></pre></td></tr></table></figure>


<h3 id="2-互斥锁（std-mutex）"><a href="#2-互斥锁（std-mutex）" class="headerlink" title="2. 互斥锁（std::mutex）"></a>2. 互斥锁（std::mutex）</h3><p><strong>核心作用</strong>：解决多线程“数据竞争”问题（多个线程同时读写共享数据，导致结果不确定），通过<code>lock()</code>&#x2F;<code>unlock()</code>手动加解锁，或用<code>std::lock_guard</code>自动管理锁（RAII机制，避免忘记解锁）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 全局互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_count = <span class="number">0</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数：累加共享数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> times)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; ++i) &#123;</span><br><span class="line">        <span class="comment">// 方式1：手动加解锁（需确保unlock()被调用，避免死锁）</span></span><br><span class="line">        <span class="comment">// mtx.lock();</span></span><br><span class="line">        <span class="comment">// shared_count++;</span></span><br><span class="line">        <span class="comment">// mtx.unlock();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式2：lock_guard自动加解锁（推荐，RAII机制）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        shared_count++; <span class="comment">// 临界区：仅一个线程可执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">5</span>; <span class="comment">// 5个线程</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> increment_times = <span class="number">1000</span>; <span class="comment">// 每个线程累加1000次</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(increment, increment_times);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预期结果：5 * 1000 = 5000（无数据竞争）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;共享数据最终值: &quot;</span> &lt;&lt; shared_count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：共享数据最终值: 5000（若不加锁，结果会小于5000）</span></span><br></pre></td></tr></table></figure>


<h2 id="五、通用编程：Lambda表达式与右值引用"><a href="#五、通用编程：Lambda表达式与右值引用" class="headerlink" title="五、通用编程：Lambda表达式与右值引用"></a>五、通用编程：Lambda表达式与右值引用</h2><p>C++11通过<strong>Lambda表达式</strong>简化了“匿名函数”的定义，通过<strong>右值引用</strong>解决了“临时对象拷贝开销”问题，为STL算法、并发编程等场景提供了更高效的支持。</p>
<h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h3><p><strong>核心作用</strong>：定义“匿名函数”，无需单独声明函数，尤其适合作为STL算法（如<code>sort</code>、<code>for_each</code>）的参数，减少代码冗余。<br><strong>语法格式</strong>：<code>[捕获列表](参数列表) mutable -&gt; 返回值类型 &#123; 函数体 &#125;</code>  </p>
<ul>
<li>捕获列表：控制Lambda能否访问外部变量（如<code>[]</code>无捕获、<code>[=]</code>值捕获、<code>[&amp;]</code>引用捕获）；</li>
<li>返回值类型：可省略（编译器自动推导，若有多个<code>return</code>需显式指定）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 用于sort、for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景1：作为sort的比较函数（按降序排序）</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), </span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125; <span class="comment">// Lambda表达式：无捕获，参数a/b，返回bool</span></span><br><span class="line">    );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;降序排序后: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出9 5 4 3 1 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2：作为for_each的操作函数（捕获外部变量sum，累加元素）</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;sum](<span class="type">int</span> num) &#123; sum += num; &#125; <span class="comment">// 引用捕获sum，修改外部变量</span></span><br><span class="line">    );</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数组总和: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出23</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：值捕获外部变量（并修改，需加mutable）</span></span><br><span class="line">    <span class="type">int</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> add_base = [base](<span class="type">int</span> num) <span class="keyword">mutable</span> &#123; </span><br><span class="line">        base++; <span class="comment">// 若不加mutable，值捕获的变量不可修改</span></span><br><span class="line">        <span class="keyword">return</span> num + base; </span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 + (10+1) = &quot;</span> &lt;&lt; <span class="built_in">add_base</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">// 输出21</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部base不变: &quot;</span> &lt;&lt; base &lt;&lt; std::endl; <span class="comment">// 输出10（值捕获不影响外部）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-右值引用（Rvalue-Reference）与移动语义"><a href="#2-右值引用（Rvalue-Reference）与移动语义" class="headerlink" title="2. 右值引用（Rvalue Reference）与移动语义"></a>2. 右值引用（Rvalue Reference）与移动语义</h3><p><strong>核心作用</strong>：区分“左值”（有名称、可取地址的变量，如<code>int a = 10</code>中的<code>a</code>）和“右值”（无名称、临时存在的对象，如<code>10</code>、<code>a+b</code>、函数返回的临时对象），通过右值引用（<code>&amp;&amp;</code>）“移动”临时对象的资源，避免不必要的拷贝，提升性能。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义字符串类（模拟移动语义）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(str);</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数（左值引用参数，深拷贝）</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        length = other.length;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数（C++11新增，右值引用参数，浅拷贝+资源转移）</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// 直接“偷”other的资源，无需重新分配内存</span></span><br><span class="line">        data = other.data;</span><br><span class="line">        length = other.length;</span><br><span class="line">        <span class="comment">// 将other的资源置空，避免析构时重复释放</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动构造: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;析构: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 场景1：左值拷贝（调用拷贝构造，深拷贝，开销大）</span></span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; <span class="comment">// 构造: Hello</span></span><br><span class="line">    MyString s2 = s1;     <span class="comment">// 拷贝构造: Hello（深拷贝）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2：右值移动（调用移动构造，浅拷贝，开销小）</span></span><br><span class="line">    MyString s3 = <span class="built_in">MyString</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 构造: World → 移动构造: World（无深拷贝）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：STL容器的移动（vector::push_back支持右值引用）</span></span><br><span class="line">    std::vector&lt;MyString&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">&quot;Test&quot;</span>)); <span class="comment">// 构造: Test → 移动构造: Test（无深拷贝）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果（关键看“移动构造”避免了深拷贝）：</span></span><br><span class="line"><span class="comment">// 构造: Hello</span></span><br><span class="line"><span class="comment">// 拷贝构造: Hello</span></span><br><span class="line"><span class="comment">// 构造: World</span></span><br><span class="line"><span class="comment">// 移动构造: World</span></span><br><span class="line"><span class="comment">// 构造: Test</span></span><br><span class="line"><span class="comment">// 移动构造: Test</span></span><br><span class="line"><span class="comment">// 析构: Test</span></span><br><span class="line"><span class="comment">// 析构: World</span></span><br><span class="line"><span class="comment">// 析构: Hello</span></span><br><span class="line"><span class="comment">// 析构: Hello</span></span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++11的新特性并非孤立存在，而是相互配合解决实际开发中的痛点：  </p>
<ul>
<li><strong>语法简化</strong>（<code>auto</code>、范围for）降低编码成本；  </li>
<li><strong>类型增强</strong>（<code>enum class</code>、<code>nullptr</code>）提升代码安全性；  </li>
<li><strong>智能指针</strong>（<code>unique_ptr</code>、<code>shared_ptr</code>）彻底解决内存泄漏；  </li>
<li><strong>并发编程</strong>（<code>std::thread</code>、<code>mutex</code>）提供跨平台多线程支持；  </li>
<li><strong>Lambda与右值引用</strong>为通用编程和性能优化提供利器。</li>
</ul>
<p>掌握这些核心特性，不仅能写出更简洁、高效、安全的C++代码，也是理解后续C++14、C++17、C++20新特性的基础。建议在实际项目中逐步应用（如先用<code>auto</code>和智能指针替代传统写法），通过实践加深理解。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的命名以及引用</title>
    <url>/2025/10/20/C_C++/C++%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>本文讲解 <strong>驼峰命名法</strong>、<strong>左值引用</strong> 和 <strong>右值引用</strong>，这些都是 C++（以及许多其他编程语言）中的重要概念。</p>
<hr>
<h2 id="一、驼峰命名法（Camel-Case）"><a href="#一、驼峰命名法（Camel-Case）" class="headerlink" title="一、驼峰命名法（Camel Case）"></a>一、驼峰命名法（Camel Case）</h2><h3 id="✅-定义："><a href="#✅-定义：" class="headerlink" title="✅ 定义："></a>✅ 定义：</h3><p>驼峰命名法是一种变量、函数或类名的命名风格，特点是<strong>单词首字母大写（除第一个单词外）</strong>，整体连在一起，形似驼峰，故得名。</p>
<h3 id="📌-两种常见形式："><a href="#📌-两种常见形式：" class="headerlink" title="📌 两种常见形式："></a>📌 两种常见形式：</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>小驼峰（lower camelCase）</strong></td>
<td>第一个单词小写，后续单词首字母大写</td>
<td><code>findContentChildren</code>、<code>userName</code></td>
<td><strong>常用于函数名、变量名</strong>（C++&#x2F;Java&#x2F;JavaScript 等）</td>
</tr>
<tr>
<td><strong>大驼峰（Upper CamelCase &#x2F; PascalCase）</strong></td>
<td>所有单词首字母都大写</td>
<td><code>MyClass</code>、<code>HttpRequest</code></td>
<td><strong>常用于类名、结构体名</strong></td>
</tr>
</tbody></table>
<h3 id="💡-为什么叫“驼峰”？"><a href="#💡-为什么叫“驼峰”？" class="headerlink" title="💡 为什么叫“驼峰”？"></a>💡 为什么叫“驼峰”？</h3><p>因为大写字母像“驼峰”一样凸起：<br><code>findContentChildren</code> → <code>find</code>（低） + <code>Content</code>（高） + <code>Children</code>（高）</p>
<h3 id="✅-C-中的惯例："><a href="#✅-C-中的惯例：" class="headerlink" title="✅ C++ 中的惯例："></a>✅ C++ 中的惯例：</h3><ul>
<li>函数名、变量名：<strong>小驼峰</strong>（如 <code>maxValue</code>, <code>getUserInput</code>）</li>
<li>类名、结构体名：<strong>大驼峰</strong>（如 <code>StudentRecord</code>, <code>BinaryTree</code>）</li>
</ul>
<blockquote>
<p>📝 注意：C++ 标准库（如 STL）多用<strong>下划线命名法</strong>（如 <code>push_back</code>, <code>vector_size</code>），但用户代码常用驼峰。</p>
</blockquote>
<hr>
<h2 id="二、左值引用（Lvalue-Reference）"><a href="#二、左值引用（Lvalue-Reference）" class="headerlink" title="二、左值引用（Lvalue Reference）"></a>二、左值引用（Lvalue Reference）</h2><h3 id="✅-语法："><a href="#✅-语法：" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type &amp;ref = variable;</span><br></pre></td></tr></table></figure>

<h3 id="🔍-什么是“左值”（Lvalue）？"><a href="#🔍-什么是“左值”（Lvalue）？" class="headerlink" title="🔍 什么是“左值”（Lvalue）？"></a>🔍 什么是“左值”（Lvalue）？</h3><ul>
<li><strong>左值</strong>：有<strong>内存地址</strong>、可以出现在赋值表达式<strong>左边</strong>的值。</li>
<li>通常是<strong>具名变量</strong>（有名字、可取地址）。</li>
</ul>
<h3 id="✅-左值引用的特点："><a href="#✅-左值引用的特点：" class="headerlink" title="✅ 左值引用的特点："></a>✅ 左值引用的特点：</h3><ul>
<li>是<strong>已有对象的别名</strong>。</li>
<li>必须在定义时初始化。</li>
<li>修改引用 &#x3D; 修改原对象。</li>
</ul>
<h3 id="📌-示例："><a href="#📌-示例：" class="headerlink" title="📌 示例："></a>📌 示例：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;   <span class="comment">// ref 是 a 的引用（别名）</span></span><br><span class="line">ref = <span class="number">20</span>;       <span class="comment">// 等价于 a = 20;</span></span><br><span class="line">cout &lt;&lt; a;      <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<h3 id="🧠-关键点："><a href="#🧠-关键点：" class="headerlink" title="🧠 关键点："></a>🧠 关键点：</h3><ul>
<li>左值引用绑定到<strong>左值</strong>（如变量、数组元素等）。</li>
<li>不能直接绑定到临时对象（右值），除非是 <code>const</code> 引用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r1 = <span class="number">42</span>;        <span class="comment">// ❌ 错误！42 是右值（临时值）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">// ✅ 正确！const 左值引用可以绑定右值</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、右值引用（Rvalue-Reference）——-C-11-新特性"><a href="#三、右值引用（Rvalue-Reference）——-C-11-新特性" class="headerlink" title="三、右值引用（Rvalue Reference）—— C++11 新特性"></a>三、右值引用（Rvalue Reference）—— C++11 新特性</h2><h3 id="✅-语法：-1"><a href="#✅-语法：-1" class="headerlink" title="✅ 语法："></a>✅ 语法：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type &amp;&amp;ref = temporary_value;</span><br></pre></td></tr></table></figure>

<h3 id="🔍-什么是“右值”（Rvalue）？"><a href="#🔍-什么是“右值”（Rvalue）？" class="headerlink" title="🔍 什么是“右值”（Rvalue）？"></a>🔍 什么是“右值”（Rvalue）？</h3><ul>
<li><strong>右值</strong>：<strong>临时对象</strong>或<strong>字面量</strong>，没有持久内存地址，通常出现在表达式<strong>右边</strong>。</li>
<li>例如：<code>42</code>、<code>func()</code> 返回的临时对象、<code>a + b</code> 的结果。</li>
</ul>
<h3 id="✅-右值引用的作用："><a href="#✅-右值引用的作用：" class="headerlink" title="✅ 右值引用的作用："></a>✅ 右值引用的作用：</h3><ol>
<li><strong>实现移动语义（Move Semantics）</strong>：避免不必要的深拷贝，提升性能。</li>
<li><strong>实现完美转发（Perfect Forwarding）</strong>。</li>
</ol>
<h3 id="📌-示例：-1"><a href="#📌-示例：-1" class="headerlink" title="📌 示例："></a>📌 示例：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">getTempString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string &amp;&amp;r1 = <span class="built_in">getTempString</span>(); <span class="comment">// 绑定到临时 string 对象</span></span><br><span class="line">string &amp;&amp;r2 = s1 + <span class="string">&quot;!!!&quot;</span>;      <span class="comment">// 绑定到临时结果</span></span><br></pre></td></tr></table></figure>

<h3 id="🚀-移动语义示例（核心用途）："><a href="#🚀-移动语义示例（核心用途）：" class="headerlink" title="🚀 移动语义示例（核心用途）："></a>🚀 移动语义示例（核心用途）：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">createLargeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000000</span>, <span class="number">1</span>); <span class="comment">// 返回一个大 vector（临时对象）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">createLargeVector</span>(); <span class="comment">// C++11 起：自动“移动”而非“拷贝”</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有右值引用，这里会<strong>深拷贝</strong>整个 vector（很慢）。</li>
<li>有了右值引用，编译器调用<strong>移动构造函数</strong>，直接“偷走”资源，效率极高。</li>
</ul>
<h3 id="⚠️-注意："><a href="#⚠️-注意：" class="headerlink" title="⚠️ 注意："></a>⚠️ 注意：</h3><ul>
<li>右值引用只能绑定到<strong>右值</strong>（临时对象、即将销毁的对象）。</li>
<li>不能绑定到普通变量（左值）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = a;   <span class="comment">// ❌ 错误！a 是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = std::<span class="built_in">move</span>(a); <span class="comment">// ✅ 正确！std::move 将 a “伪装”成右值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="四、对比总结"><a href="#四、对比总结" class="headerlink" title="四、对比总结"></a>四、对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>左值引用 (<code>T&amp;</code>)</th>
<th>右值引用 (<code>T&amp;&amp;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>左值（具名变量）</td>
<td>右值（临时对象）</td>
</tr>
<tr>
<td>是否可修改原对象</td>
<td>是</td>
<td>是（但对象即将销毁）</td>
</tr>
<tr>
<td>典型用途</td>
<td>避免拷贝传参、返回引用</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>示例</td>
<td><code>int &amp;r = x;</code></td>
<td><code>int &amp;&amp;r = 42;</code> 或 <code>std::move(x)</code></td>
</tr>
<tr>
<td>C++ 版本</td>
<td>C++98</td>
<td>C++11 起</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、实际应用建议"><a href="#五、实际应用建议" class="headerlink" title="五、实际应用建议"></a>五、实际应用建议</h2><ul>
<li><strong>函数参数传递大对象</strong> → 用 <code>const T&amp;</code>（避免拷贝，只读）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>需要转移资源</strong>（如实现移动构造函数）→ 用 <code>T&amp;&amp;</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(MyClass &amp;&amp;other) <span class="keyword">noexcept</span> &#123; <span class="comment">/* 移动资源 */</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>通用引用（模板中）</strong> → <code>T&amp;&amp;</code> 可能是左值或右值（依赖类型推导）</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>驼峰命名</tag>
        <tag>左值引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础入门：从零开始掌握C++语言基石</title>
    <url>/2025/09/18/C_C++/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><h2 id="C-初识"><a href="#C-初识" class="headerlink" title="C++初识"></a>C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项<br>给C++文件起个名称，然后点击添加即可。</p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码<br><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，&#x3D;&#x3D;对该行代码说明&#x3D;&#x3D;</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，&#x3D;&#x3D;对该段代码做整体说明&#x3D;&#x3D;<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存<br><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据<br>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul>
<li>&#x3D;&#x3D;通常在文件上方定义&#x3D;&#x3D;，表示一个常量</li>
</ul>
</li>
<li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul>
<li>&#x3D;&#x3D;通常在变量定义前加关键字const&#x3D;&#x3D;，修饰该变量为常量，不可修改<br><strong>示例：</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>**作用：**关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong><br>C++关键字如下：<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
<tr>
<td><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
</li>
</ul>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是&#x3D;&#x3D;整数类型&#x3D;&#x3D;的数据<br>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>**作用：**利用sizeof关键字可以&#x3D;&#x3D;统计数据类型所占内存大小&#x3D;&#x3D;<br><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>整型结论</strong>：&#x3D;&#x3D;short &lt; int &lt;&#x3D; long &lt;&#x3D; long long&#x3D;&#x3D;</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于&#x3D;&#x3D;表示小数&#x3D;&#x3D;<br>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double<br>两者的<strong>区别</strong>在于表示的有效数字范围不同。<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>**作用：**字符型变量用于显示单个字符<br><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号<br>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元<br>示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>&#x2F;</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>&#96;</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
<tr>
<td>ASCII 码大致由以下<strong>两部分组</strong>成：</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>**作用：**用于表示一些&#x3D;&#x3D;不能显示出来的ASCII字符&#x3D;&#x3D;<br>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
<tr>
<td>示例：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符<br><strong>两种风格</strong></p>
<ol>
<li><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code><br>示例：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
</li>
<li><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code><br>示例：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件&#x3D;&#x3D;#include&lt;string&gt;&#x3D;&#x3D;</p>
</blockquote>
</li>
</ol>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p>**作用：**布尔数据类型代表真或假的值<br>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）<br><strong>bool类型占&#x3D;&#x3D;1个字节&#x3D;&#x3D;大小</strong><br>示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong><br>**关键字：**cin<br><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code><br>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p>**作用：**用于执行代码的运算<br>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算<br>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>10 &#x2F; 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a&#x3D;2; b&#x3D;++a;</td>
<td>a&#x3D;3; b&#x3D;3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a&#x3D;2; b&#x3D;a++;</td>
<td>a&#x3D;3; b&#x3D;2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a&#x3D;2; b&#x3D;–a;</td>
<td>a&#x3D;1; b&#x3D;1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a&#x3D;2; b&#x3D;a–;</td>
<td>a&#x3D;1; b&#x3D;2;</td>
</tr>
<tr>
<td><strong>示例1：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在除法运算中，除数不能为0<br><strong>示例2：</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：只有整型变量可以进行取模运算<br><strong>示例3：</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p>**作用：**用于将表达式的值赋给变量<br>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;2; b&#x3D;3;</td>
<td>a&#x3D;2; b&#x3D;3;</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加等于</td>
<td>a&#x3D;0; a+&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减等于</td>
<td>a&#x3D;5; a-&#x3D;3;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘等于</td>
<td>a&#x3D;2; a*&#x3D;2;</td>
<td>a&#x3D;4;</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除等于</td>
<td>a&#x3D;4; a&#x2F;&#x3D;2;</td>
<td>a&#x3D;2;</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>模等于</td>
<td>a&#x3D;3; a%2;</td>
<td>a&#x3D;1;</td>
</tr>
<tr>
<td><strong>示例：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p>**作用：**用于表达式的比较，并返回一个真值或假值<br>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>相等于</td>
<td>4 &#x3D;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>4 !&#x3D; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>4 &lt;&#x3D; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>4 &gt;&#x3D; 1</td>
<td>1</td>
</tr>
<tr>
<td>示例：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， &#x3D;&#x3D;“真”用数字“1”来表示， “假”用数字“0”来表示。&#x3D;&#x3D; </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p>**作用：**用于根据表达式的值返回真值或假值<br>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
<tr>
<td>**示例1：**逻辑非</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 真变假，假变真<br>**示例2：**逻辑与</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：逻辑&#x3D;&#x3D;与&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同真为真，其余为假&#x3D;&#x3D;<br>**示例3：**逻辑或</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑&#x3D;&#x3D;或&#x3D;&#x3D;运算符总结： &#x3D;&#x3D;同假为假，其余为真&#x3D;&#x3D;</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：&#x3D;&#x3D;顺序结构、选择结构、循环结构&#x3D;&#x3D;</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p>**作用：**执行满足条件的语句<br>if语句的三种形式</p>
<ul>
<li>单行格式if语句</li>
<li>多行格式if语句</li>
<li>多条件的if语句</li>
</ul>
<ol>
<li>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code><br>示例：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
</li>
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code><br>示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code><br>示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断<br>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断<br><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code><br><strong>解释：</strong><br>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；<br>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p>**作用：**执行多条件分支语句<br><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型<br>注意2：case里如果没有break，那么程序会一直向下执行<br>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p>**作用：**满足循环条件，执行循环语句<br><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code><br><strong>解释：</strong>&#x3D;&#x3D;只要循环条件的结果为真，就执行循环语句&#x3D;&#x3D;<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句<br><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code><br>**注意：**与while的区别在于&#x3D;&#x3D;do…while会先执行一次循环语句&#x3D;&#x3D;，再判断循环条件<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句<br><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔<br>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题<br>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出&#x3D;&#x3D;选择结构&#x3D;&#x3D;或者&#x3D;&#x3D;循环结构&#x3D;&#x3D;<br>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句<br><strong>示例1：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>**作用：**在&#x3D;&#x3D;循环语句&#x3D;&#x3D;中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p>**作用：**可以无条件跳转语句<br><strong>语法：</strong> <code>goto 标记;</code><br>**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">	FLAG:</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素<br>**特点1：**数组中的每个&#x3D;&#x3D;数据元素都是相同的数据类型&#x3D;&#x3D;<br>**特点2：**数组是由&#x3D;&#x3D;连续的内存&#x3D;&#x3D;位置组成的</p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code><br>示例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名<br>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数组名是常量，不可以赋值<br>总结1：直接打印数组名，可以查看数组所占内存的首地址<br>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较<br><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code><blockquote>
<p>建议：以上4种定义方式，利用&#x3D;&#x3D;第二种更加直观，提高代码的可读性&#x3D;&#x3D;<br>示例：</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址<br>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong><br>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
<tr>
<td><strong>参考答案：</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>**作用：**将一段经常使用的代码封装起来，减少重复代码<br>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：<br>1、返回值类型<br>2、函数名<br>3、参数表列<br>4、函数体语句<br>5、return 表达式<br><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line">       函数体语句</span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<br>**示例：**定义一个加法函数，实现两个数相加</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p>**功能：**使用定义好的函数<br><strong>语法：</strong><code> 函数名（参数）</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，&#x3D;&#x3D;如果形参发生，并不会影响实参&#x3D;&#x3D;<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong><br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p>**作用：**让代码结构更加清晰<br>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址<br>总结2：利用指针可以记录地址<br>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
</li>
</ul>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间<br>**用途：**初始化指针变量<br>**注意：**空指针指向的内存是不可以访问的<br><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>：指针变量指向非法的内存空间<br><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p>**作用：**利用指针访问数组中元素<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p>**作用：**利用指针作函数参数，可以修改实参的值<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p>**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序<br>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户&#x3D;&#x3D;自定义的数据类型&#x3D;&#x3D;，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code><br>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line">	stu<span class="number">1.</span>name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu<span class="number">1.</span>age = <span class="number">18</span>;</span><br><span class="line">	stu<span class="number">1.</span>score = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">1.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">1.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">1.</span>score &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">2.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">2.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">2.</span>score &lt;&lt; endl;</span><br><span class="line">	stu<span class="number">3.</span>name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu<span class="number">3.</span>age = <span class="number">18</span>;</span><br><span class="line">	stu<span class="number">3.</span>score = <span class="number">80</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu<span class="number">3.</span>name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu<span class="number">3.</span>age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu<span class="number">3.</span>score &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略<br>总结2：创建结构体变量时，关键字struct可以省略<br>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p>**作用：**将自定义的结构体放入到数组中方便维护<br><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p>**作用：**通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体<br>**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t<span class="number">1.</span>id = <span class="number">10000</span>;</span><br><span class="line">	t<span class="number">1.</span>name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t<span class="number">1.</span>age = <span class="number">40</span>;</span><br><span class="line">	t<span class="number">1.</span>stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t<span class="number">1.</span>stu.age = <span class="number">18</span>;</span><br><span class="line">	t<span class="number">1.</span>stu.score = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t<span class="number">1.</span>id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t<span class="number">1.</span>name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t<span class="number">1.</span>stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t<span class="number">1.</span>stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t<span class="number">1.</span>stu.score &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p>**作用：**将结构体作为参数向函数中传递<br>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p>**作用：**用const来防止误操作<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong><br>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下<br>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员<br>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值<br>最终打印出老师数据以及老师所带的学生数据。<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong><br>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。<br>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。<br>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++基础入门</tag>
      </tags>
  </entry>
  <entry>
    <title>C++提高编程：泛型编程与STL深度解析</title>
    <url>/2025/09/18/C_C++/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul>
<li>本阶段主要针对C++&#x3D;&#x3D;泛型编程&#x3D;&#x3D;和&#x3D;&#x3D;STL&#x3D;&#x3D;技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong><br>例如生活中的模板<br>一寸照片模板：<br>PPT模板：<br>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li>C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板</li>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。<br><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>template  —  声明创建模板<br>typename  — 表面其后面的符号是一种数据类型，可以用class代替<br>T    —   通用的数据类型，名称可以替换，通常为大写字母<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试<br>示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的<br><strong>例如：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了<br>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行<br>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p<span class="number">1.</span>m_Name  == p<span class="number">2.</span>m_Name &amp;&amp; p<span class="number">1.</span>m_Age == p<span class="number">2.</span>m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。<br><strong>语法：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong><br>template  —  声明创建模板<br>typename  — 表面其后面的符号是一种数据类型，可以用class代替<br>T    —   通用的数据类型，名称可以替换，通常为大写字母<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P<span class="number">1.</span><span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式<br>一共有三种传入方式：</li>
</ul>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递<br><strong>示例：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式<br>问题：</li>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到<br>解决：</li>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制<br><strong>示例：</strong><br>person.hpp中代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现<br>全局函数类内实现 - 直接在类内声明友元即可<br>全局函数类外实现 - 需要提前让编译器知道全局函数的存在<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量<br><strong>示例：</strong><br>myArray.hpp中代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array<span class="number">1.</span><span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array<span class="number">1.</span><span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array<span class="number">2.</span><span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array<span class="number">2.</span><span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array<span class="number">2.</span><span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li>长久以来，软件界一直希望建立一种可重复利用的东西</li>
<li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li>
<li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：<strong>置物之所也<br>STL</strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来<br>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等<br>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:<br>​	<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​	<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系<br><strong>算法：<strong>问题之解法也<br>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)<br>算法分为:<strong>质变算法</strong>和</strong>非质变算法</strong>。<br>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等<br>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等<br>**迭代器：**容器和算法之间粘合剂<br>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。<br>每个容器都有自己专属的迭代器<br>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针<br>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
<tr>
<td>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力<br>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code><br>算法：     <code>for_each</code><br>迭代器： <code>vector&lt;int&gt;::iterator</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v<span class="number">3.</span><span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v<span class="number">4.</span><span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类<br><strong>string和char * 区别：</strong></li>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char<em>型的容器。<br><strong>特点：</strong><br>string 类内部封装了很多成员方法<br>例如：查找find，拷贝copy，删除delete 替换replace，插入insert<br>string管理char</em>所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li>
</ul>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>          				&#x2F;&#x2F;创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            &#x2F;&#x2F;使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           &#x2F;&#x2F;使用n个字符c初始化<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值<br>赋值的函数原型：</li>
<li><code>string&amp; operator=(const char* s);</code>             &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          &#x2F;&#x2F;字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              &#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  &#x2F;&#x2F;用n个字符c赋给当前字符串<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	string str4;</span><br><span class="line">	str<span class="number">4.</span><span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	string str5;</span><br><span class="line">	str<span class="number">5.</span><span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	string str6;</span><br><span class="line">	str<span class="number">6.</span><span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">	string str7;</span><br><span class="line">	str<span class="number">7.</span><span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>​	string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串<br><strong>函数原型：</strong></li>
<li><code>string&amp; operator+=(const char* str);</code>                   &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li><code>string&amp; append(const char *s); </code>                               &#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line">	str1 += str2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str<span class="number">3.</span><span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串<br><strong>函数原型：</strong></li>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       &#x2F;&#x2F;查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      &#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      &#x2F;&#x2F;查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 &#x2F;&#x2F;替换从pos开始的n个字符为字符串s<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = str<span class="number">1.f</span>ind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	pos = str<span class="number">1.</span><span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str<span class="number">1.</span><span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较<br><strong>比较方式：</strong></li>
<li>字符串比较是按字符的ASCII码进行对比<br>&#x3D; 返回   0<br>&gt; 返回   1<br>&lt; 返回  -1<br><strong>函数原型：</strong></li>
<li><code>int compare(const string &amp;s) const; </code>  &#x2F;&#x2F;与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      &#x2F;&#x2F;与字符串s比较<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line">	<span class="type">int</span> ret = s<span class="number">1.</span><span class="built_in">compare</span>(s2);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     &#x2F;&#x2F;通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    &#x2F;&#x2F;通过at方法获取字符<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作<br><strong>函数原型：</strong></li>
<li><code>string&amp; insert(int pos, const char* s);  </code>                &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        &#x2F;&#x2F;插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                &#x2F;&#x2F;在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    &#x2F;&#x2F;删除从Pos开始的n个字符<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串<br><strong>函数原型：</strong></li>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong><br><strong>vector与普通数组区别：</strong></li>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong><br><strong>动态扩展：</strong></li>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器<br><strong>函数原型：</strong></li>
<li><code>vector&lt;T&gt; v; </code>               		     &#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         &#x2F;&#x2F;拷贝构造函数。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值<br><strong>函数原型：</strong></li>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>&#x2F;&#x2F;重载等号操作符</li>
<li><code>assign(beg, end);</code>       &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        &#x2F;&#x2F;将n个elem拷贝赋值给本身。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v<span class="number">3.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作<br><strong>函数原型：</strong></li>
<li><code>empty(); </code>                            &#x2F;&#x2F;判断容器是否为空</li>
<li><code>capacity();</code>                      &#x2F;&#x2F;容器的容量</li>
<li><code>size();</code>                              &#x2F;&#x2F;返回容器中元素的个数</li>
<li><code>resize(int num);</code>             &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<br>​                          &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>resize(int num, elem);</code>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<br>​                              &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作<br><strong>函数原型：</strong></li>
<li><code>push_back(ele);</code>                                         &#x2F;&#x2F;尾部插入元素ele</li>
<li><code>pop_back();</code>                                                &#x2F;&#x2F;删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     &#x2F;&#x2F;删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        &#x2F;&#x2F;删除容器中所有元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear</li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作<br><strong>函数原型：</strong></li>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>       &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v<span class="number">1.</span><span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换<br><strong>函数原型：</strong></li>
<li><code>swap(vec);</code>  &#x2F;&#x2F; 将vec与本身的元素互换<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数<br><strong>函数原型：</strong></li>
<li><code>reserve(int len);</code>&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作<br><strong>deque与vector区别：</strong></li>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关<br>deque内部工作原理:<br>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据<br>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</li>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造<br><strong>函数原型：</strong></li>
<li><code>deque&lt;T&gt;</code> deqT;                      &#x2F;&#x2F;默认构造形式</li>
<li><code>deque(beg, end);</code>                  &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   &#x2F;&#x2F;拷贝构造函数<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d<span class="number">1.</span>begin(),d<span class="number">1.</span>end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值<br><strong>函数原型：</strong></li>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>         &#x2F;&#x2F;重载等号操作符</li>
<li><code>assign(beg, end);</code>                                           &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                             &#x2F;&#x2F;将n个elem拷贝赋值给本身。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">	d<span class="number">3.</span><span class="built_in">assign</span>(d<span class="number">1.</span><span class="built_in">begin</span>(), d<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">	d<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作<br><strong>函数原型：</strong></li>
<li><code>deque.empty();</code>                       &#x2F;&#x2F;判断容器是否为空</li>
<li><code>deque.size();</code>                         &#x2F;&#x2F;返回容器中元素的个数</li>
<li><code>deque.resize(num);</code>                &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。<br>​                                         &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>deque.resize(num, elem);</code>     &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。<br>​                                                     &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据<br><strong>函数原型：</strong><br>两端插入操作：</li>
</ul>
<ul>
<li><code>push_back(elem);</code>          &#x2F;&#x2F;在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        &#x2F;&#x2F;在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   &#x2F;&#x2F;删除容器最后一个数据</li>
<li><code>pop_front();</code>                 &#x2F;&#x2F;删除容器第一个数据<br>指定位置操作：</li>
</ul>
<ul>
<li><code>insert(pos,elem);</code>         &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li><code>insert(pos,n,elem);</code>     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li><code>insert(pos,beg,end);</code>    &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li><code>clear();</code>                           &#x2F;&#x2F;清空容器的所有数据</li>
<li><code>erase(beg,end);</code>             &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li><code>erase(pos);</code>                    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d<span class="number">2.</span><span class="built_in">begin</span>(), d<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>operator[]; </code>      &#x2F;&#x2F;返回索引idx所指的数据</li>
<li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li>
<li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序<br><strong>算法：</strong></li>
<li><code>sort(iterator beg, iterator end)</code>  &#x2F;&#x2F;对beg和end区间内元素进行排序<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分<br><strong>示例代码：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line">		<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：<strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口<br>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为<br>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code><br>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code><br>生活中的栈：</p>
<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口<br>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            &#x2F;&#x2F;拷贝构造函数<br>赋值操作：</li>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           &#x2F;&#x2F;重载等号操作符<br>数据存取：</li>
<li><code>push(elem);</code>      &#x2F;&#x2F;向栈顶添加元素</li>
<li><code>pop();</code>                &#x2F;&#x2F;从栈顶移除第一个元素</li>
<li><code>top(); </code>                &#x2F;&#x2F;返回栈顶元素<br>大小操作：</li>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口<br>队列容器允许从一端新增元素，从另一端移除元素<br>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为<br>队列中进数据称为 — <strong>入队</strong>    <code>push</code><br>队列中出数据称为 — <strong>出队</strong>    <code>pop</code><br>生活中的队列：</p>
<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口<br>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            &#x2F;&#x2F;拷贝构造函数<br>赋值操作：</li>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           &#x2F;&#x2F;重载等号操作符<br>数据存取：</li>
<li><code>push(elem);</code>                             &#x2F;&#x2F;往队尾添加元素</li>
<li><code>pop();</code>                                      &#x2F;&#x2F;从队头移除第一个元素</li>
<li><code>back();</code>                                    &#x2F;&#x2F;返回最后一个元素</li>
<li><code>front(); </code>                                  &#x2F;&#x2F;返回第一个元素<br>大小操作：</li>
<li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li>
<li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：<strong>将数据进行链式存储<br><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<br>链表的组成：链表由一系列</strong>结点</strong>组成<br>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong><br>STL中的链表是一个双向循环链表<br>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong><br>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素<br>list的缺点：</li>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大<br>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。<br>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</li>
</ul>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器<br><strong>函数原型：</strong></li>
<li><code>list&lt;T&gt; lst;</code>                               &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            &#x2F;&#x2F;拷贝构造函数。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L<span class="number">1.</span><span class="built_in">begin</span>(),L<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器<br><strong>函数原型：</strong></li>
<li><code>assign(beg, end);</code>            &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         &#x2F;&#x2F;重载等号操作符</li>
<li><code>swap(lst);</code>                         &#x2F;&#x2F;将lst与本身的元素互换。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L<span class="number">3.</span><span class="built_in">assign</span>(L<span class="number">2.</span><span class="built_in">begin</span>(), L<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L<span class="number">4.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L<span class="number">2.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">swap</span>(L2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作<br><strong>函数原型：</strong></li>
<li><code>size(); </code>                             &#x2F;&#x2F;返回容器中元素的个数</li>
<li><code>empty(); </code>                           &#x2F;&#x2F;判断容器是否为空</li>
<li><code>resize(num);</code>                   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。<br>​                        &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li><code>resize(num, elem); </code>       &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<br>                                           &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。<br>                                                   <strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="keyword">if</span> (L<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除<br><strong>函数原型：</strong></li>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取<br><strong>函数原型：</strong></li>
<li><code>front();</code>        &#x2F;&#x2F;返回第一个元素。</li>
<li><code>back();</code>         &#x2F;&#x2F;返回最后一个元素。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.f</span>ront() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序<br><strong>函数原型：</strong></li>
<li><code>reverse();</code>   &#x2F;&#x2F;反转链表</li>
<li><code>sort();</code>        &#x2F;&#x2F;链表排序<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高<br>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序<br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p<span class="number">1.</span>m_Age == p<span class="number">2.</span>m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p<span class="number">1.</span>m_Height  &gt; p<span class="number">2.</span>m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p<span class="number">1.</span>m_Age &lt; p<span class="number">2.</span>m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set&#x2F; multiset 容器"></a>3.8 set&#x2F; multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序<br><strong>本质：</strong></li>
<li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。<br><strong>set和multiset区别</strong>：</li>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值<br>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        &#x2F;&#x2F;默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       &#x2F;&#x2F;拷贝构造函数<br>赋值：</li>
<li><code>set&amp; operator=(const set &amp;st);</code>    &#x2F;&#x2F;重载等号操作符<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器<br><strong>函数原型：</strong></li>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="keyword">if</span> (s<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据<br><strong>函数原型：</strong></li>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            &#x2F;&#x2F;删除容器中值为elem的元素。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.</span><span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据<br><strong>函数原型：</strong></li>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s<span class="number">1.f</span>ind(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">if</span> (pos != s<span class="number">1.</span><span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s<span class="number">1.</span><span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别<br><strong>区别：</strong></li>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据<br><strong>两种创建方式：</strong></li>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code><br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p<span class="number">2.f</span>irst &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则<br>主要技术点：</li>
<li>利用仿函数，可以改变排序规则<br><strong>示例一</strong>   set存放内置数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s<span class="number">1.</span><span class="built_in">begin</span>(); it != s<span class="number">1.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s<span class="number">2.</span><span class="built_in">begin</span>(); it != s<span class="number">2.</span><span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：利用仿函数可以指定set容器的排序规则<br><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p<span class="number">1.</span>m_Age &gt; p<span class="number">2.</span>m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map&#x2F; multimap容器"></a>3.9 map&#x2F; multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序<br><strong>本质：</strong></li>
<li>map&#x2F;multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。<br><strong>优点：</strong></li>
<li>可以根据key值快速找到value值<br>map和multimap<strong>区别</strong>：</li>
</ul>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作<br><strong>函数原型：</strong><br><strong>构造：</strong></li>
<li><code>map&lt;T1, T2&gt; mp;</code>                     &#x2F;&#x2F;map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             &#x2F;&#x2F;拷贝构造函数<br><strong>赋值：</strong></li>
<li><code>map&amp; operator=(const map &amp;mp);</code>    &#x2F;&#x2F;重载等号操作符<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器<br>函数原型：</li>
</ul>
<ul>
<li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li>
<li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li>
<li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m<span class="number">2.</span><span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据<br><strong>函数原型：</strong></li>
<li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li>
<li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li>
<li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            &#x2F;&#x2F;删除容器中值为key的元素。<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据<br><strong>函数原型：</strong></li>
<li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则<br><strong>主要技术点:</strong></li>
<li>利用仿函数，可以改变排序规则<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息<br><strong>案例代码：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong><br><strong>本质：</strong><br>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</li>
</ul>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递<br><strong>示例:</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象<br><strong>分类:</strong></li>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数<br><strong>用法：</strong></li>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算<br><strong>仿函数原型：</strong></li>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                &#x2F;&#x2F;加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              &#x2F;&#x2F;减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    &#x2F;&#x2F;乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         &#x2F;&#x2F;除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         &#x2F;&#x2F;取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           &#x2F;&#x2F;取反仿函数<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比<br><strong>仿函数原型：</strong></li>
</ul>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    &#x2F;&#x2F;等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            &#x2F;&#x2F;不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      &#x2F;&#x2F;大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          &#x2F;&#x2F;大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           &#x2F;&#x2F;小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               &#x2F;&#x2F;小于等于<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              &#x2F;&#x2F;逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                &#x2F;&#x2F;逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              &#x2F;&#x2F;逻辑非<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v<span class="number">2.</span><span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v<span class="number">2.</span><span class="built_in">begin</span>(); it != v<span class="number">2.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法<br><strong>算法简介：</strong></li>
<li><code>for_each</code>     &#x2F;&#x2F;遍历容器</li>
<li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器<br><strong>函数原型：</strong></li>
<li><code>for_each(iterator beg, iterator end, _func);  </code><br>&#x2F;&#x2F; 遍历算法 遍历容器元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _func 函数或者函数对象<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中<br><strong>函数原型：</strong></li>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code><br>&#x2F;&#x2F;beg1 源容器开始迭代器<br>&#x2F;&#x2F;end1 源容器结束迭代器<br>&#x2F;&#x2F;beg2 目标容器开始迭代器<br>&#x2F;&#x2F;_func 函数或者函数对象<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法<br><strong>算法简介：</strong></li>
<li><code>find</code>                     &#x2F;&#x2F;查找元素</li>
<li><code>find_if</code>               &#x2F;&#x2F;按条件查找元素</li>
<li><code>adjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li>
<li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li>
<li><code>count</code>                   &#x2F;&#x2F;统计元素个数</li>
<li><code>count_if</code>             &#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>find(iterator beg, iterator end, value);  </code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 查找的元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>find_if(iterator beg, iterator end, _Pred);  </code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>adjacent_find(iterator beg, iterator end);  </code><br>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>bool binary_search(iterator beg, iterator end, value);  </code><br>&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false<br>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong><br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 查找的元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>count(iterator beg, iterator end, value);  </code><br>&#x2F;&#x2F; 统计元素出现次数<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 统计的元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>count_if(iterator beg, iterator end, _Pred);  </code><br>&#x2F;&#x2F; 按条件统计元素出现次数<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _Pred 谓词<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法<br><strong>算法简介：</strong></li>
<li><code>sort</code>             &#x2F;&#x2F;对容器内元素进行排序</li>
<li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       &#x2F;&#x2F; 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>sort(iterator beg, iterator end, _Pred);  </code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F;  beg    开始迭代器<br>&#x2F;&#x2F;  end    结束迭代器<br>&#x2F;&#x2F; _Pred  谓词<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>random_shuffle(iterator beg, iterator end);  </code><br>&#x2F;&#x2F; 指定范围内的元素随机调整次序<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code><br>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中<br>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong><br>&#x2F;&#x2F; beg1   容器1开始迭代器<br>&#x2F;&#x2F; end1   容器1结束迭代器<br>&#x2F;&#x2F; beg2   容器2开始迭代器<br>&#x2F;&#x2F; end2   容器2结束迭代器<br>&#x2F;&#x2F; dest    目标容器开始迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>reverse(iterator beg, iterator end);  </code><br>&#x2F;&#x2F; 反转指定范围的元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法<br><strong>算法简介：</strong></li>
<li><code>copy</code>                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     &#x2F;&#x2F; 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>copy(iterator beg, iterator end, iterator dest);  </code><br>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置<br>&#x2F;&#x2F; beg  开始迭代器<br>&#x2F;&#x2F; end  结束迭代器<br>&#x2F;&#x2F; dest 目标起始迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>());</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code><br>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; oldvalue 旧元素<br>&#x2F;&#x2F; newvalue 新元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code><br>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; _pred 谓词<br>&#x2F;&#x2F; newvalue 替换的新元素<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>swap(container c1, container c2);  </code><br>&#x2F;&#x2F; 互换两个容器的元素<br>&#x2F;&#x2F; c1容器1<br>&#x2F;&#x2F; c2容器2<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法<br><strong>注意：</strong></li>
</ul>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code><br><strong>算法简介：</strong></li>
</ul>
<ul>
<li><code>accumulate</code>      &#x2F;&#x2F; 计算容器元素累计总和</li>
<li><code>fill</code>                 &#x2F;&#x2F; 向容器中添加元素</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>accumulate(iterator beg, iterator end, value);  </code><br>&#x2F;&#x2F; 计算容器元素累计总和<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 起始值<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>fill(iterator beg, iterator end, value);  </code><br>&#x2F;&#x2F; 向容器中填充元素<br>&#x2F;&#x2F; beg 开始迭代器<br>&#x2F;&#x2F; end 结束迭代器<br>&#x2F;&#x2F; value 填充的值<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法<br><strong>算法简介：</strong></li>
<li><code>set_intersection</code>          &#x2F;&#x2F; 求两个容器的交集</li>
<li><code>set_union</code>                       &#x2F;&#x2F; 求两个容器的并集</li>
<li><code>set_difference </code>              &#x2F;&#x2F; 求两个容器的差集</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code><br>&#x2F;&#x2F; 求两个集合的交集<br>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v<span class="number">1.</span><span class="built_in">size</span>(), v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code><br>&#x2F;&#x2F; 求两个集合的并集<br>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集<br><strong>函数原型：</strong></li>
</ul>
<ul>
<li><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code><br>&#x2F;&#x2F; 求两个集合的差集<br>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong><br>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器<br><strong>示例：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v<span class="number">1.</span><span class="built_in">size</span>() , v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++提高编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程：面向对象技术详解与精髓剖析</title>
    <url>/2025/09/18/C_C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​	在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​	<strong>代码区：</strong></p>
<p>​		存放 CPU 执行的机器指令</p>
<p>​		代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​		代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​	<strong>全局区：</strong></p>
<p>​		全局变量和静态变量存放在此.</p>
<p>​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​		&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​	<strong>栈区：</strong></p>
<p>​		由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	<strong>堆区：</strong></p>
<p>​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​		在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​	C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p>
<p>​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p>
<p>​	语法：<code> new 数据类型</code></p>
<p>​	利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p>**作用：**函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>**优点：**可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p>**作用：**常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p>
<p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​	人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​	车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​	具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​	在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p>**示例1：**设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c<span class="number">1.</span>m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c<span class="number">1.</span>m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c<span class="number">2.</span>m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p>
<p>**优点2：**对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="number">1.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">1.</span>m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">2.</span>m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p>**示例1 ：**静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">2.</span>m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="number">2.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**示例2：**静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.f</span>unc();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">	temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p<span class="number">1.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p<span class="number">2.</span>m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p<span class="number">3.</span>m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系。</p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s<span class="number">1.</span>m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​	3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中的位域（Bit-fields）</title>
    <url>/2025/08/01/C_C++/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9F/</url>
    <content><![CDATA[<p>在 C 语言编程中，当面对内存资源受限的场景（如嵌入式系统、底层驱动开发），如何高效利用内存空间成为关键问题。位域（Bit-fields）作为一种特殊的数据结构，允许开发者按位分配内存，精确控制数据所占的二进制位数，从而显著节省内存。本文将从基础到进阶，全面解析 C 语言位域的特性与应用。</p>
<h3 id="一、位域的基本概念"><a href="#一、位域的基本概念" class="headerlink" title="一、位域的基本概念"></a>一、位域的基本概念</h3><p>位域是一种通过结构体定义的特殊成员，它指定了成员变量所占用的二进制位数。通常情况下，C 语言的基本数据类型（如int、char）占用固定的字节数（如int占 4 字节），但在位域中，我们可以为成员分配更少的位数（如 2 位、3 位），仅保留存储所需数据的最小空间。</p>
<p>例如，一个表示颜色的变量可能只需要 3 位（红、绿、蓝各 1 位），一个表示星期的变量只需 3 位（可表示 0-7，足够覆盖周一到周日）。使用位域存储这类数据，能避免内存浪费。</p>
<h3 id="二、位域的定义与声明"><a href="#二、位域的定义与声明" class="headerlink" title="二、位域的定义与声明"></a>二、位域的定义与声明</h3><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><p>位域通过结构体定义，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct 结构体名 &#123;</span><br><span class="line">    数据类型 成员名 : 位数;</span><br><span class="line">    [数据类型 成员名 : 位数;]</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>数据类型</strong>：通常为unsigned int（无符号整数）或int，部分编译器支持char、short等类型。</p>
</li>
<li><p><strong>位数</strong>：表示该成员占用的二进制位数，必须是非负整数，且不能超过对应数据类型的总位数（如unsigned int为 32 位系统下最大 32 位）。</p>
</li>
</ul>
<h4 id="2-示例：定义位域结构体"><a href="#2-示例：定义位域结构体" class="headerlink" title="2. 示例：定义位域结构体"></a>2. 示例：定义位域结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个存储日期的位域结构体</span><br><span class="line">struct Date &#123;</span><br><span class="line">    unsigned int day : 5;    // 日（1-31，需5位：2^5=32）</span><br><span class="line">    unsigned int month : 4;  // 月（1-12，需4位：2^4=16）</span><br><span class="line">    unsigned int year : 12;  // 年（假设范围0-4095，需12位：2^12=4096）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述结构体中，day、month、year分别占用 5 位、4 位、12 位，总位数为 21 位，仅需 3 字节（24 位）即可存储，而若使用普通int成员（各 4 字节），则需 12 字节，内存占用减少 75%。</p>
<h4 id="3-无名位域与填充位"><a href="#3-无名位域与填充位" class="headerlink" title="3. 无名位域与填充位"></a>3. 无名位域与填充位</h4><ul>
<li><p><strong>无名位域</strong>：可用于预留空位，格式为数据类型 : 位数;（无成员名）。</p>
</li>
<li><p><strong>填充位</strong>：当位域成员总位数不足一个数据类型的字节数时，编译器可能自动填充空位，也可手动指定0长度的无名位域强制对齐（如unsigned int : 0;）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Flags &#123;</span><br><span class="line">    unsigned int flag1 : 1;</span><br><span class="line">    unsigned int : 2;       // 无名位域，预留2位</span><br><span class="line">    unsigned int flag2 : 1;</span><br><span class="line">    unsigned int : 0;       // 强制对齐到下一个存储单元</span><br><span class="line">    unsigned int flag3 : 1; // 从新的存储单元开始</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、位域的内存分配规则"><a href="#三、位域的内存分配规则" class="headerlink" title="三、位域的内存分配规则"></a>三、位域的内存分配规则</h3><p>位域的内存分配由编译器决定，但遵循以下通用规则：</p>
<ol>
<li><strong>同类型成员合并</strong>：同一类型的位域成员优先打包到同一个存储单元（如unsigned int的位域成员会共用 4 字节空间），若总位数超过存储单元大小，则剩余部分存入下一个单元。</li>
</ol>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Bits &#123;</span><br><span class="line">    unsigned int a : 16;  // 占用前16位</span><br><span class="line">    unsigned int b : 16;  // 与a共用4字节（16+16=32）</span><br><span class="line">    unsigned int c : 8;   // 存入下一个4字节单元</span><br><span class="line">&#125;;</span><br><span class="line">// 总大小为8字节（4+4）</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>不同类型成员分离</strong>：不同数据类型的位域成员通常分配到不同的存储单元（具体取决于编译器，如 GCC 允许不同类型合并，而 MSVC 可能分离）。</p>
</li>
<li><p><strong>对齐方式</strong>：位域的起始地址按其数据类型的对齐要求对齐（如int位域按 4 字节对齐），填充位会被计入结构体总大小。</p>
</li>
</ol>
<p>通过sizeof可验证位域结构体的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Date &#123;</span><br><span class="line">    unsigned int day : 5;</span><br><span class="line">    unsigned int month : 4;</span><br><span class="line">    unsigned int year : 12;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Date结构体大小：%zu字节\n&quot;, sizeof(struct Date));  // 输出：4字节（因21位需向上对齐到4字节）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、位域的使用方法"><a href="#四、位域的使用方法" class="headerlink" title="四、位域的使用方法"></a>四、位域的使用方法</h3><h4 id="1-赋值与访问"><a href="#1-赋值与访问" class="headerlink" title="1. 赋值与访问"></a>1. 赋值与访问</h4><p>位域成员的赋值和访问与普通结构体成员类似，但需注意<strong>不能超过其位数限制</strong>，否则会发生溢出（高位被截断）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Date &#123;</span><br><span class="line">    unsigned int day : 5;    // 最大存储31（0b11111）</span><br><span class="line">    unsigned int month : 4;  // 最大存储15（0b1111）</span><br><span class="line">    unsigned int year : 12;  // 最大存储4095</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Date d;</span><br><span class="line">    d.day = 31;    // 合法：31 ≤ 31</span><br><span class="line">    d.month = 12;  // 合法：12 ≤ 15</span><br><span class="line">    d.year = 2025; // 合法：2025 ≤ 4095</span><br><span class="line">    </span><br><span class="line">    printf(&quot;日期：%d-%d-%d\n&quot;, d.year, d.month, d.day);  // 输出：2025-12-31</span><br><span class="line">    </span><br><span class="line">    d.day = 32;    // 溢出：32的二进制为100000，截断后为0（仅保留低5位）</span><br><span class="line">    printf(&quot;溢出后day：%d\n&quot;, d.day);  // 输出：0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-位域与指针"><a href="#2-位域与指针" class="headerlink" title="2. 位域与指针"></a>2. 位域与指针</h4><p>位域成员<strong>不能直接取地址</strong>（&amp;d.day为非法操作），因为其地址可能不是字节对齐的，不符合指针的地址要求。若需通过指针操作，需先获取结构体的地址，再通过成员访问符操作。</p>
<h3 id="五、位域的应用场景"><a href="#五、位域的应用场景" class="headerlink" title="五、位域的应用场景"></a>五、位域的应用场景</h3><h4 id="1-硬件编程与嵌入式系统"><a href="#1-硬件编程与嵌入式系统" class="headerlink" title="1. 硬件编程与嵌入式系统"></a>1. 硬件编程与嵌入式系统</h4><p>在嵌入式开发中，寄存器操作常需精确控制特定位（如控制寄存器的某几位表示使能、中断等状态）。位域可直接映射硬件寄存器的位结构，使代码更直观。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 映射一个8位控制寄存器</span><br><span class="line">struct ControlReg &#123;</span><br><span class="line">    unsigned int enable : 1;    // 第0位：使能</span><br><span class="line">    unsigned int mode : 2;      // 第1-2位：模式（0-3）</span><br><span class="line">    unsigned int reserved : 5;  // 第3-7位：保留</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-数据压缩与存储优化"><a href="#2-数据压缩与存储优化" class="headerlink" title="2. 数据压缩与存储优化"></a>2. 数据压缩与存储优化</h4><p>当需要存储大量小范围数据（如状态标志、枚举值）时，位域能大幅减少内存占用。例如，存储 100 万个Date结构体，使用位域（4 字节）比普通int成员（12 字节）节省 800 万字节（约 7.6MB）。</p>
<h4 id="3-协议解析"><a href="#3-协议解析" class="headerlink" title="3. 协议解析"></a>3. 协议解析</h4><p>网络协议或文件格式中，数据常按位定义（如 IP 头部的版本号占 4 位、服务类型占 8 位）。位域可直接解析这类按位划分的数据，简化代码逻辑。</p>
<h3 id="六、使用位域的注意事项"><a href="#六、使用位域的注意事项" class="headerlink" title="六、使用位域的注意事项"></a>六、使用位域的注意事项</h3><ol>
<li><p><strong>可移植性问题</strong>：位域的内存分配方式（如成员是否跨存储单元、填充位数量）因编译器而异，不同平台可能存在差异，需谨慎使用于跨平台代码。</p>
</li>
<li><p><strong>位数限制</strong>：位域的位数不能为 0（除非是无名填充位），且不能超过其数据类型的总位数（如char位域最大 8 位）。</p>
</li>
<li><p><strong>符号问题</strong>：若使用signed int定义位域，其最高位为符号位，可能导致非预期结果（如 3 位signed int的范围为 - 4~3），建议优先使用unsigned int。</p>
</li>
<li><p><strong>性能权衡</strong>：位域的读写需要额外的位运算操作，可能比普通变量稍慢，在内存充足但对性能敏感的场景中需权衡使用。</p>
</li>
</ol>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>位域是 C 语言中一种高效的内存优化工具，通过精确控制数据的二进制位数，在嵌入式开发、硬件交互、数据压缩等场景中发挥着重要作用。它的核心价值在于<strong>用最小的内存存储必要数据</strong>，但同时也需注意其可移植性限制和性能开销。</p>
<p>掌握位域的使用，不仅能提升代码的内存效率，更能深入理解计算机底层的位操作逻辑。在实际开发中，应根据具体场景合理选择：当内存紧张且数据范围明确时，位域是理想选择；而当追求跨平台兼容性或极致性能时，普通数据类型可能更合适。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
        <tag>位域</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>argc和argv参数解析</title>
    <url>/2025/07/22/C_C++/argc%E5%92%8Cargv%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="argc和argv参数解析"><a href="#argc和argv参数解析" class="headerlink" title="argc和argv参数解析"></a>argc和argv参数解析</h1><p><code>argc</code> 和 <code>argv</code> 是 C&#x2F;C++ 语言中 <code>main</code> 函数的两个特殊参数，它们用于接收和处理<strong>命令行参数</strong>。</p>
<p>在操作系统命令行（如终端、命令提示符）中运行一个程序时，可以在程序名后面附加一些额外的信息，这些信息就是命令行参数。<code>argc</code> 和 <code>argv</code> 就是用来让程序获取这些信息的。</p>
<h3 id="1-定义与含义"><a href="#1-定义与含义" class="headerlink" title="1. 定义与含义"></a>1. 定义与含义</h3><p>在 C&#x2F;C++ 中，<code>main</code> 函数的标准形式之一是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line"><span class="comment">// 或者等价形式</span></span><br><span class="line"><span class="comment">// int main(int argc, char **argv)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>argc</code> (Argument Count)</strong>:</p>
<ul>
<li><strong>含义</strong>：这是一个整数（<code>int</code>），表示<strong>命令行参数的总个数</strong>。</li>
<li><strong>包含内容</strong>：它<strong>包含程序本身的名称</strong>。也就是说，即使你没有输入任何额外参数，<code>argc</code> 的值至少为 1（因为程序名本身算一个参数）。</li>
<li><strong>作用</strong>：告诉程序一共有多少个参数被传递进来，防止访问 <code>argv</code> 数组时越界。</li>
</ul>
</li>
<li><p><strong><code>argv</code> (Argument Vector)</strong>:</p>
<ul>
<li><strong>含义</strong>：这是一个指向字符串数组的指针（<code>char *argv[]</code> 或 <code>char **argv</code>）。数组中的每个元素都是一个指向字符串的指针。</li>
<li><strong>内容</strong>：这个数组包含了所有的命令行参数，每个参数作为一个字符串存储。</li>
<li><strong>索引</strong>：<ul>
<li><code>argv[0]</code>：指向<strong>程序本身的名称</strong>（或调用程序时使用的路径&#x2F;命令）。</li>
<li><code>argv[1]</code>：指向<strong>第一个</strong>用户提供的命令行参数。</li>
<li><code>argv[2]</code>：指向<strong>第二个</strong>用户提供的命令行参数。</li>
<li>…</li>
<li><code>argv[argc - 1]</code>：指向<strong>最后一个</strong>命令行参数。</li>
<li><code>argv[argc]</code>：<strong>必须是 <code>NULL</code> 指针</strong>，作为数组结束的标志。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2. 用途"></a>2. 用途</h3><p><code>argc</code> 和 <code>argv</code> 的主要用途是让程序能够根据用户在运行时提供的不同参数，执行不同的操作或配置。这使得程序更加灵活和自动化。常见用途包括：</p>
<ul>
<li><strong>指定输入&#x2F;输出文件</strong>：例如 <code>myprogram input.txt output.txt</code>。</li>
<li><strong>传递配置选项或开关</strong>：例如 <code>myprogram --verbose --debug</code> 或 <code>myprogram -v -d</code>。</li>
<li><strong>提供操作模式或命令</strong>：例如 <code>git commit -m &quot;message&quot;</code> 或 <code>ls -l /home</code>。</li>
<li><strong>传递数据给程序</strong>：例如 <code>calculator 10 + 5</code>。</li>
</ul>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>假设我们有一个名为 <code>echo_args.c</code> 的 C 程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序名: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;参数个数 (argc): %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的参数:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123; <span class="comment">// 从1开始，跳过程序名</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提供额外的命令行参数。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong>：<code>gcc echo_args.c -o echo_args</code></p>
<p><strong>运行示例 1</strong>：不带参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./echo_args</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序名: ./echo_args</span><br><span class="line">参数个数 (argc): 1</span><br><span class="line">没有提供额外的命令行参数。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>argc = 1</code> (只有程序名)</li>
<li><code>argv[0] = &quot;./echo_args&quot;</code></li>
<li><code>argv[1] = NULL</code></li>
</ul>
<p><strong>运行示例 2</strong>：带多个参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./echo_args hello world 123 --option</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序名: ./echo_args</span><br><span class="line">参数个数 (argc): 5</span><br><span class="line">接收到的参数:</span><br><span class="line">  argv[1]: hello</span><br><span class="line">  argv[2]: world</span><br><span class="line">  argv[3]: 123</span><br><span class="line">  argv[4]: --option</span><br></pre></td></tr></table></figure>
<ul>
<li><code>argc = 5</code> (程序名 + 4个参数)</li>
<li><code>argv[0] = &quot;./echo_args&quot;</code></li>
<li><code>argv[1] = &quot;hello&quot;</code></li>
<li><code>argv[2] = &quot;world&quot;</code></li>
<li><code>argv[3] = &quot;123&quot;</code></li>
<li><code>argv[4] = &quot;--option&quot;</code></li>
<li><code>argv[5] = NULL</code></li>
</ul>
<h3 id="4-重要注意事项"><a href="#4-重要注意事项" class="headerlink" title="4. 重要注意事项"></a>4. 重要注意事项</h3><ul>
<li><strong>参数是字符串</strong>：所有命令行参数都以字符串形式传递给程序。如果你需要整数、浮点数等，必须使用 <code>atoi()</code>, <code>atof()</code>, <code>strtol()</code> 等函数进行转换。</li>
<li><strong>空格分隔</strong>：命令行中通常用空格来分隔不同的参数。如果参数本身包含空格，需要用引号（单引号 <code>&#39;</code> 或双引号 <code>&quot;</code>）括起来。</li>
<li><strong><code>argv[0]</code> 的可靠性</strong>：虽然 <code>argv[0]</code> 通常是程序名，但在某些情况下（如通过 <code>exec</code> 系列函数调用），它可能不是原始的可执行文件名，或者可能被修改。不过，对于大多数直接从命令行启动的程序，它是可靠的。</li>
<li><strong>内存管理</strong>：<code>argv</code> 数组及其指向的字符串由运行时系统负责分配和管理，程序通常不需要（也不应该）手动释放它们的内存。</li>
</ul>
<p><strong>总结</strong>：<br><code>argc</code> 告诉你有多少个命令行参数（包括程序名），<code>argv</code> 是一个字符串数组，让你可以访问每个参数的具体内容。它们是实现程序与用户在命令行进行交互、接收运行时配置和输入数据的关键机制。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中的共用体（Union）</title>
    <url>/2025/08/01/C_C++/C%E8%AF%AD%E8%A8%80%E5%85%B1%E5%90%8C%E4%BD%93/</url>
    <content><![CDATA[<p>在 C 语言中，数据结构的灵活运用是提升程序效率和可读性的关键。除了常见的结构体（Struct），共用体（Union）也是一种重要的复合数据类型，它能够让不同类型的数据共享同一块内存空间，在特定场景下能极大地节省内存资源。本文将带你全面认识 C 语言中的共用体，从基础概念到实际应用，逐步揭开它的神秘面纱。</p>
<h3 id="一、共用体的基本概念"><a href="#一、共用体的基本概念" class="headerlink" title="一、共用体的基本概念"></a>一、共用体的基本概念</h3><p>共用体，又称联合体，在 C 语言中用union关键字定义，它允许在同一块内存空间中存储不同的数据类型。与结构体不同的是，结构体的每个成员都有独立的内存空间，而共用体的所有成员<strong>共享同一块内存</strong>，这意味着同一时间只能有一个成员被有效使用。</p>
<p>共用体的大小由其<strong>最大的成员所占的内存空间</strong>决定，因为它需要容纳下最大的那个成员。例如，如果一个共用体包含一个int类型（通常占 4 字节）和一个char类型（通常占 1 字节）的成员，那么这个共用体的大小就是 4 字节。</p>
<h3 id="二、共用体的定义与使用"><a href="#二、共用体的定义与使用" class="headerlink" title="二、共用体的定义与使用"></a>二、共用体的定义与使用</h3><h4 id="1-定义共用体"><a href="#1-定义共用体" class="headerlink" title="1. 定义共用体"></a>1. 定义共用体</h4><p>定义共用体的语法与结构体类似，基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名 &#123;</span><br><span class="line">    数据类型 成员1;</span><br><span class="line">    数据类型 成员2;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，定义一个可以存储整数、浮点数和字符的共用体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Data &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-声明共用体变量"><a href="#2-声明共用体变量" class="headerlink" title="2. 声明共用体变量"></a>2. 声明共用体变量</h4><p>声明共用体变量的方式有多种，可以在定义共用体的同时声明，也可以单独声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义时声明</span><br><span class="line">union Data &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125; data1, data2;</span><br><span class="line"></span><br><span class="line">// 单独声明</span><br><span class="line">union Data data3;</span><br></pre></td></tr></table></figure>

<h4 id="3-访问共用体成员"><a href="#3-访问共用体成员" class="headerlink" title="3. 访问共用体成员"></a>3. 访问共用体成员</h4><p>通过.运算符可以访问共用体的成员，但需要注意的是，每次只能给一个成员赋值，并且赋值后之前成员的值会被覆盖。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union Data &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    union Data data;</span><br><span class="line">    </span><br><span class="line">    data.i = 10;</span><br><span class="line">    printf(&quot;data.i = %d\n&quot;, data.i);  // 输出：data.i = 10</span><br><span class="line">    </span><br><span class="line">    data.f = 3.14f;</span><br><span class="line">    printf(&quot;data.f = %f\n&quot;, data.f);  // 输出：data.f = 3.140000</span><br><span class="line">    printf(&quot;data.i = %d\n&quot;, data.i);  // 输出结果不确定，因为内存已被float覆盖</span><br><span class="line">    </span><br><span class="line">    data.c = &#x27;A&#x27;;</span><br><span class="line">    printf(&quot;data.c = %c\n&quot;, data.c);  // 输出：data.c = A</span><br><span class="line">    printf(&quot;data.f = %f\n&quot;, data.f);  // 输出结果不确定，内存被char覆盖</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，当给共用体的一个成员赋值后，其他成员的值会变得不确定，这是因为它们共享同一块内存。</p>
<h3 id="三、共用体的内存特性"><a href="#三、共用体的内存特性" class="headerlink" title="三、共用体的内存特性"></a>三、共用体的内存特性</h3><p>共用体的核心特性是<strong>内存共享</strong>，这一特性使得它在内存受限的场景下非常有用。我们可以通过sizeof运算符来验证共用体的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union Data &#123;</span><br><span class="line">    int i;          // 4字节</span><br><span class="line">    float f;        // 4字节</span><br><span class="line">    char arr[6];    // 6字节</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;共用体大小：%zu\n&quot;, sizeof(union Data));  // 输出：6</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，共用体Data的最大成员是char arr[6]（占 6 字节），所以整个共用体的大小就是 6 字节，这充分体现了共用体大小由最大成员决定的特点。</p>
<p>此外，共用体的所有成员都从<strong>同一块内存的起始地址</strong>开始存储。我们可以通过打印成员的地址来验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union Data &#123;</span><br><span class="line">    int i;</span><br><span class="line">    float f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    union Data data;</span><br><span class="line">    printf(&quot;&amp;data.i = %p\n&quot;, &amp;data.i);</span><br><span class="line">    printf(&quot;&amp;data.f = %p\n&quot;, &amp;data.f);</span><br><span class="line">    // 输出的两个地址相同</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、共用体的应用场景"><a href="#四、共用体的应用场景" class="headerlink" title="四、共用体的应用场景"></a>四、共用体的应用场景</h3><p>共用体虽然使用场景不如结构体广泛，但在一些特定情况下能发挥重要作用：</p>
<h4 id="1-节省内存空间"><a href="#1-节省内存空间" class="headerlink" title="1. 节省内存空间"></a>1. 节省内存空间</h4><p>当程序中需要处理多种数据类型，但这些数据不会同时使用时，使用共用体可以显著节省内存。例如，在嵌入式系统中，内存资源通常比较紧张，共用体的优势就会凸显出来。</p>
<h4 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2. 数据类型转换"></a>2. 数据类型转换</h4><p>通过共用体可以实现不同数据类型之间的转换，尤其是在不使用强制类型转换的情况下。例如，将一个浮点数的二进制表示转换为整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union FloatInt &#123;</span><br><span class="line">    float f;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    union FloatInt fi;</span><br><span class="line">    fi.f = 3.14f;</span><br><span class="line">    printf(&quot;浮点数3.14的二进制表示对应的整数：%d\n&quot;, fi.i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式利用了共用体成员共享内存的特性，直接读取浮点数的二进制存储作为整数。</p>
<h4 id="3-处理多种类型的数据结构"><a href="#3-处理多种类型的数据结构" class="headerlink" title="3. 处理多种类型的数据结构"></a>3. 处理多种类型的数据结构</h4><p>在一些需要处理多种类型数据的场景中，共用体可以与结构体结合使用。例如，在网络协议中，不同的数据包可能有不同的格式，这时可以用结构体包含一个标识字段和一个共用体，共用体中存放不同格式的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Packet &#123;</span><br><span class="line">    int type;  // 数据包类型</span><br><span class="line">    union &#123;</span><br><span class="line">        int int_data;</span><br><span class="line">        float float_data;</span><br><span class="line">        char str_data[20];</span><br><span class="line">    &#125; data;    // 根据type存储不同类型的数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="五、使用共用体的注意事项"><a href="#五、使用共用体的注意事项" class="headerlink" title="五、使用共用体的注意事项"></a>五、使用共用体的注意事项</h3><ol>
<li><p><strong>成员互斥性</strong>：共用体的成员不能同时使用，给一个成员赋值后，其他成员的值会失效，使用时需特别注意。</p>
</li>
<li><p><strong>类型对齐</strong>：共用体的大小不仅取决于最大成员的大小，还可能受到系统内存对齐的影响，不同编译器的处理方式可能略有差异。</p>
</li>
<li><p><strong>初始化</strong>：共用体只能初始化其中的一个成员，且必须是第一个成员。例如：union Data data &#x3D; {10}; 表示初始化i成员为 10。</p>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>共用体作为 C 语言中一种特殊的复合数据类型，通过内存共享的特性为程序设计提供了更多灵活性。它在节省内存、数据类型转换和处理多类型数据结构等场景中有着独特的优势。但同时，我们也要注意其成员互斥的特性，避免因错误使用而导致程序出现异常。</p>
<p>深入理解并合理运用共用体，能让我们在 C 语言编程中更高效地管理内存，编写出更简洁、更优化的代码。希望本文能帮助你对 C 语言共用体有一个清晰而全面的认识，在实际开发中灵活运用这一有用的工具。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
        <tag>共用体</tag>
        <tag>Union</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中 const 与 static 的作用及区别详解</title>
    <url>/2025/07/29/C_C++/const%E5%92%8Cstatic/</url>
    <content><![CDATA[<p>在 C&#x2F;C++ 编程中，const和static是两个常用且重要的关键字，它们各自承担着独特的功能，却又容易被混淆。本文将从作用、使用场景和核心区别三个维度，全面解析这两个关键字，帮助开发者在实际编程中正确运用。</p>
<h3 id="一、const-关键字：定义常量与只读特性"><a href="#一、const-关键字：定义常量与只读特性" class="headerlink" title="一、const 关键字：定义常量与只读特性"></a>一、const 关键字：定义常量与只读特性</h3><p>const（constant 的缩写）的核心作用是<strong>定义不可修改的实体</strong>，即常量或只读对象，其本质是为变量或函数加上 “只读” 属性，防止意外修改，提高代码的安全性和可读性。</p>
<h4 id="1-const-的主要作用"><a href="#1-const-的主要作用" class="headerlink" title="1. const 的主要作用"></a>1. const 的主要作用</h4><ul>
<li><strong>定义常量</strong>：声明变量为常量，初始化后不可修改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int MAX_SIZE = 100; // 常量，不可修改</span><br><span class="line">MAX_SIZE = 200; // 编译错误：常量不可赋值</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰指针</strong>：有三种形式，分别限制指针本身、指针指向的内容，或两者都限制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int* p1; // 指向常量的指针（内容不可改，指针可改）</span><br><span class="line">int* const p2; // 常量指针（指针不可改，内容可改）</span><br><span class="line">const int* const p3; // 指向常量的常量指针（两者都不可改）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰函数参数</strong>：防止函数内部修改参数值，尤其适用于传递大型对象（避免拷贝且保证安全）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void printStr(const string&amp; str) &#123;</span><br><span class="line">    str = &quot;new&quot;; // 编译错误：参数为const引用，不可修改</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰函数返回值</strong>：限制返回值不可被修改（常用于返回指针或引用时）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int* getArray() &#123;</span><br><span class="line">    static int arr[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">// 调用时</span><br><span class="line">const int* ptr = getArray();</span><br><span class="line">*ptr = 10; // 编译错误：返回值为const指针</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰类成员</strong>：在类中，const成员变量必须在初始化列表中初始化；const成员函数不能修改类的成员变量（mutable 修饰的除外）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    const int value; // const成员变量</span><br><span class="line">public:</span><br><span class="line">    MyClass(int v) : value(v) &#123;&#125; // 必须在初始化列表初始化</span><br><span class="line">    int getValue() const &#123; // const成员函数</span><br><span class="line">        // value = 10; // 编译错误：const函数不可修改成员变量</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-const-的核心特性"><a href="#2-const-的核心特性" class="headerlink" title="2. const 的核心特性"></a>2. const 的核心特性</h4><ul>
<li><p><strong>不可修改性</strong>：被const修饰的实体，其值或状态在初始化后不可修改。</p>
</li>
<li><p><strong>编译期检查</strong>：const的约束在编译阶段生效，试图修改会导致编译错误。</p>
</li>
<li><p><strong>提高代码可读性</strong>：明确告诉开发者 “这个实体不应该被修改”。</p>
</li>
</ul>
<h3 id="二、static-关键字：控制存储周期与作用域"><a href="#二、static-关键字：控制存储周期与作用域" class="headerlink" title="二、static 关键字：控制存储周期与作用域"></a>二、static 关键字：控制存储周期与作用域</h3><p>static的核心作用是<strong>控制变量或函数的存储周期、作用域和链接属性</strong>，其行为在不同场景（全局、局部、类中）有所差异，但都与 “静态” 特性相关。</p>
<h4 id="1-static-的主要作用"><a href="#1-static-的主要作用" class="headerlink" title="1. static 的主要作用"></a>1. static 的主要作用</h4><ul>
<li><strong>修饰全局变量</strong>：限制全局变量的作用域为当前文件（内部链接），避免不同文件中同名变量的冲突。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// file1.cpp</span><br><span class="line">static int globalVar = 10; // 仅在file1.cpp中可见</span><br><span class="line"></span><br><span class="line">// file2.cpp</span><br><span class="line">int globalVar = 20; // 合法，与file1.cpp中的变量不冲突</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰局部变量</strong>：改变局部变量的存储周期为整个程序运行期间（静态存储），但作用域仍为当前函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void count() &#123;</span><br><span class="line">    static int cnt = 0; // 仅初始化一次，程序结束时释放</span><br><span class="line">    cnt++;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    count(); // 输出1</span><br><span class="line">    count(); // 输出2</span><br><span class="line">    count(); // 输出3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰函数</strong>：限制函数的作用域为当前文件（内部链接），避免与其他文件的同名函数冲突。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// file1.cpp</span><br><span class="line">static void func() &#123; ... &#125; // 仅在file1.cpp中可见</span><br><span class="line"></span><br><span class="line">// file2.cpp</span><br><span class="line">void func() &#123; ... &#125; // 合法，与file1.cpp中的函数不冲突</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰类成员</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">private:</span><br><span class="line">    static int total; // 静态成员变量</span><br><span class="line">public:</span><br><span class="line">    static void add() &#123; total++; &#125; // 静态成员函数</span><br><span class="line">    static int getTotal() &#123; return total; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Counter::total = 0; // 类外初始化</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Counter::add();</span><br><span class="line">    Counter::add();</span><br><span class="line">    cout &lt;&lt; Counter::getTotal() &lt;&lt; endl; // 输出2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><strong>静态成员变量</strong>：属于类本身，而非类的实例，所有对象共享同一变量，需在类外初始化。</li>
</ul>
</li>
<li><ul>
<li><strong>静态成员函数</strong>：属于类本身，不含this指针，只能访问静态成员变量和静态成员函数。</li>
</ul>
</li>
</ul>
<h4 id="2-static-的核心特性"><a href="#2-static-的核心特性" class="headerlink" title="2. static 的核心特性"></a>2. static 的核心特性</h4><ul>
<li><p><strong>存储周期</strong>：静态变量在程序启动时分配内存，程序结束时释放（全局生命周期）。</p>
</li>
<li><p><strong>作用域控制</strong>：限制全局变量 &#x2F; 函数的作用域为当前文件，局部静态变量作用域仍为函数内。</p>
</li>
<li><p><strong>类共享性</strong>：类的静态成员被所有实例共享，无需创建对象即可访问。</p>
</li>
</ul>
<h3 id="三、const-与-static-的核心区别"><a href="#三、const-与-static-的核心区别" class="headerlink" title="三、const 与 static 的核心区别"></a>三、const 与 static 的核心区别</h3><table>
<thead>
<tr>
<th>维度</th>
<th>const</th>
<th>static</th>
</tr>
</thead>
<tbody><tr>
<td>核心功能</td>
<td>定义不可修改的实体（只读特性）</td>
<td>控制存储周期、作用域和链接属性</td>
</tr>
<tr>
<td>内存管理</td>
<td>变量存储位置取决于场景（栈、全局区等）</td>
<td>变量存储在静态存储区（全局生命周期）</td>
</tr>
<tr>
<td>类中使用</td>
<td>const 成员属于对象，每个对象有独立副本</td>
<td>static 成员属于类，所有对象共享一个副本</td>
</tr>
<tr>
<td>初始化要求</td>
<td>必须在定义时或构造函数初始化列表中初始化</td>
<td>静态成员变量需在类外单独初始化</td>
</tr>
<tr>
<td>修饰函数</td>
<td>限制函数不能修改成员变量（类中）</td>
<td>函数属于类，不依赖对象实例</td>
</tr>
<tr>
<td>编译期检查</td>
<td>主要检查 “是否被修改”</td>
<td>主要检查 “作用域和链接属性”</td>
</tr>
</tbody></table>
<p><strong>典型误用示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误：const和static在类中修饰成员变量的初始化方式不同</span><br><span class="line">class Test &#123;</span><br><span class="line">    const static int a; // 合法：静态常量，可在类内声明，类外初始化</span><br><span class="line">    static const int b = 10; // 合法：C++11后允许类内初始化静态常量</span><br><span class="line">    const int c = 20; // 错误：非静态const成员不能在类内直接初始化（需在初始化列表）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>const和static是 C&#x2F;C++ 中功能截然不同的关键字：</p>
<ul>
<li><p>const的核心是 <strong>“只读”</strong>，用于保护数据不被意外修改，强调数据的不可变性，在编译期生效。</p>
</li>
<li><p>static的核心是 <strong>“静态管理”</strong>，用于控制变量 &#x2F; 函数的存储周期和作用域，强调资源的共享性和生命周期，在运行期体现效果。</p>
</li>
</ul>
<p>在实际编程中，两者可以结合使用（如static const修饰类的静态常量），但需明确各自的职责：const保证数据安全，static优化资源管理。理解它们的区别，能帮助我们写出更健壮、更高效的代码。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>memset和memcpy函数</title>
    <url>/2025/11/04/C_C++/memset%E5%92%8Cmemcpy%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><code>memset</code> 和 <code>memcpy</code> 是 C 语言标准库 <code>&lt;string.h&gt;</code> 中两个非常常用的内存操作函数，它们都用于直接操作内存，但用途和行为有明显区别。下面分别详细讲解：</p>
<hr>
<h2 id="一、memset-函数"><a href="#一、memset-函数" class="headerlink" title="一、memset 函数"></a>一、<code>memset</code> 函数</h2><h3 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h3><p>将内存区域 <code>s</code> 的前 <code>n</code> 个字节<strong>全部设置为值 <code>c</code></strong>（注意：<code>c</code> 被转换为 <code>unsigned char</code>）。</p>
<h3 id="3-参数说明"><a href="#3-参数说明" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h3><ul>
<li><code>s</code>：指向要操作的内存块的指针（通常是一个数组或结构体的地址）。</li>
<li><code>c</code>：要填充的值（以 <code>int</code> 形式传入，但只取低 8 位，即一个字节）。</li>
<li><code>n</code>：要填充的字节数。</li>
</ul>
<h3 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><p>返回 <code>s</code> 的原始指针（即传入的第一个参数）。</p>
<h3 id="5-典型用途"><a href="#5-典型用途" class="headerlink" title="5. 典型用途"></a>5. 典型用途</h3><ul>
<li>初始化数组（尤其是清零）。</li>
<li>初始化结构体。</li>
<li>快速将一段内存置为特定值（如 0 或 -1）。</li>
</ul>
<h3 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 将 buf 全部置为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, buf[i]); <span class="comment">// 输出 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：<code>memset</code> 是按<strong>字节</strong>填充的，因此<strong>不能用于将 int 数组初始化为任意非 0 值</strong>（例如 <code>memset(arr, 1, sizeof(arr))</code> 不会把每个 int 设为 1，而是每个字节设为 1，结果是 0x01010101）。</p>
</blockquote>
<hr>
<h2 id="二、memcpy-函数"><a href="#二、memcpy-函数" class="headerlink" title="二、memcpy 函数"></a>二、<code>memcpy</code> 函数</h2><h3 id="1-函数原型-1"><a href="#1-函数原型-1" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-功能-1"><a href="#2-功能-1" class="headerlink" title="2. 功能"></a>2. 功能</h3><p>从源内存区域 <code>src</code> <strong>复制 <code>n</code> 个字节</strong>到目标内存区域 <code>dest</code>。</p>
<h3 id="3-参数说明-1"><a href="#3-参数说明-1" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h3><ul>
<li><code>dest</code>：目标内存地址（必须足够大以容纳 <code>n</code> 字节）。</li>
<li><code>src</code>：源内存地址。</li>
<li><code>n</code>：要复制的字节数。</li>
</ul>
<h3 id="4-返回值-1"><a href="#4-返回值-1" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><p>返回 <code>dest</code> 指针。</p>
<h3 id="5-典型用途-1"><a href="#5-典型用途-1" class="headerlink" title="5. 典型用途"></a>5. 典型用途</h3><ul>
<li>复制数组。</li>
<li>复制结构体。</li>
<li>内存块整体拷贝。</li>
</ul>
<h3 id="6-示例-1"><a href="#6-示例-1" class="headerlink" title="6. 示例"></a>6. 示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> src[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dest[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span>(src)); <span class="comment">// 复制整个数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dest[i]); <span class="comment">// 输出 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：</p>
<ul>
<li><code>memcpy</code> <strong>不检查内存重叠</strong>。如果 <code>src</code> 和 <code>dest</code> 有重叠区域，结果是未定义的。</li>
<li>如果存在内存重叠，应使用 <code>memmove</code>（它能正确处理重叠）。</li>
</ul>
</blockquote>
<hr>
<h2 id="三、对比总结"><a href="#三、对比总结" class="headerlink" title="三、对比总结"></a>三、对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>memset</code></th>
<th><code>memcpy</code></th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>填充内存（设为同一字节值）</td>
<td>复制内存（从 src 到 dest）</td>
</tr>
<tr>
<td>参数数量</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>是否处理重叠</td>
<td>不适用（单内存块操作）</td>
<td><strong>不处理重叠</strong>（用 <code>memmove</code>）</td>
</tr>
<tr>
<td>常见用途</td>
<td>初始化（如清零）</td>
<td>数据拷贝</td>
</tr>
<tr>
<td>安全性</td>
<td>安全（只要指针有效）</td>
<td>若内存重叠则不安全</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、使用建议"><a href="#四、使用建议" class="headerlink" title="四、使用建议"></a>四、使用建议</h2><ul>
<li>初始化数组或结构体为 0：用 <code>memset(ptr, 0, size)</code>。</li>
<li>拷贝数据：用 <code>memcpy</code>（确保无重叠）或 <code>memmove</code>（可能有重叠）。</li>
<li>不要用 <code>memset</code> 初始化非字节对齐的非零值（如 <code>int</code> 数组设为 5）。</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>memset</tag>
        <tag>memcpy</tag>
      </tags>
  </entry>
  <entry>
    <title>extern关键字</title>
    <url>/2025/12/30/C_C++/extern%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p><code>extern</code> 是 C 和 C++ 语言中的一个关键字，用于声明变量或函数具有**外部链接（external linkage）**属性，即该变量或函数的定义在其他文件（或当前文件的其他位置）中。它的主要作用是告诉编译器：“这个符号（变量或函数）是在别处定义的，请不要在此分配存储空间，只需引用它即可。”</p>
<hr>
<h2 id="一、基本用途"><a href="#一、基本用途" class="headerlink" title="一、基本用途"></a>一、基本用途</h2><h3 id="1-声明外部变量"><a href="#1-声明外部变量" class="headerlink" title="1. 声明外部变量"></a>1. 声明外部变量</h3><p>当你在一个源文件中定义了一个全局变量，并希望在另一个源文件中使用它时，就需要用 <code>extern</code> 来声明。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>file1.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">42</span>;  <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>

<p><strong>file2.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var;  <span class="comment">// 声明：global_var 在别处定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, global_var);  <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>extern</code> 只是声明，不是定义。不能用 <code>extern</code> 初始化变量（除非在 C++ 中有特殊规则，见下文）。</p>
</blockquote>
<hr>
<h3 id="2-声明外部函数（通常可省略）"><a href="#2-声明外部函数（通常可省略）" class="headerlink" title="2. 声明外部函数（通常可省略）"></a>2. 声明外部函数（通常可省略）</h3><p>函数默认具有外部链接，所以一般不需要显式加 <code>extern</code>，但可以加上以增强可读性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数（通常写在头文件中）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、在-C-中的扩展用法"><a href="#二、在-C-中的扩展用法" class="headerlink" title="二、在 C++ 中的扩展用法"></a>二、在 C++ 中的扩展用法</h2><h3 id="1-extern-C-——-兼容-C-语言链接"><a href="#1-extern-C-——-兼容-C-语言链接" class="headerlink" title="1. extern &quot;C&quot; —— 兼容 C 语言链接"></a>1. <code>extern &quot;C&quot;</code> —— 兼容 C 语言链接</h3><p>C++ 支持函数重载，因此编译器会对函数名进行 <strong>名称修饰（name mangling）</strong>。而 C 语言不会。为了在 C++ 中调用 C 编写的函数（如标准库函数），需要用 <code>extern &quot;C&quot;</code> 告诉编译器按 C 的方式链接。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_c_library.h&quot;</span>  <span class="comment">// 包含 C 头文件</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者单独声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">c_function</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样，<code>c_function</code> 就不会被 C++ 编译器进行名称修饰，能正确链接到 C 编译的目标文件。</p>
<hr>
<h3 id="2-extern-与-const-变量（C-特有）"><a href="#2-extern-与-const-变量（C-特有）" class="headerlink" title="2. extern 与 const 变量（C++ 特有）"></a>2. <code>extern</code> 与 const 变量（C++ 特有）</h3><p>在 C++ 中，<code>const</code> 全局变量默认具有<strong>内部链接</strong>（即只在本文件可见）。如果想让它在多个文件间共享，必须显式加上 <code>extern</code>。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p><strong>constants.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;  <span class="comment">// 定义 + 外部链接</span></span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX_SIZE;  <span class="comment">// 声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; MAX_SIZE &lt;&lt; std::endl;  <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有 <code>extern</code>，每个文件包含 <code>const int MAX_SIZE = 100;</code> 都会创建自己的副本，无法共享。</p>
</blockquote>
<hr>
<h2 id="三、常见误区"><a href="#三、常见误区" class="headerlink" title="三、常见误区"></a>三、常见误区</h2><table>
<thead>
<tr>
<th>误区</th>
<th>正确理解</th>
</tr>
</thead>
<tbody><tr>
<td><code>extern</code> 会分配内存</td>
<td>❌ <code>extern</code> 只是声明，不分配存储空间</td>
</tr>
<tr>
<td>所有全局变量都要加 <code>extern</code></td>
<td>❌ 只有在其他文件中使用时才需要在使用文件中加 <code>extern</code> 声明</td>
</tr>
<tr>
<td><code>extern</code> 可以初始化变量</td>
<td>❌ 一般不行（C 中绝对不行；C++ 中作为定义时可以，但此时它就不再是“纯声明”了）</td>
</tr>
</tbody></table>
<blockquote>
<p>在 C++ 中，<code>extern int x = 5;</code> 实际上是<strong>定义</strong>，不是声明。这种写法等价于 <code>int x = 5;</code>，但强调其具有外部链接。</p>
</blockquote>
<hr>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li><code>extern</code> 用于<strong>声明</strong>变量或函数在别处定义。</li>
<li>主要用于跨文件共享全局变量。</li>
<li>函数通常不需要 <code>extern</code>（默认外部链接）。</li>
<li>C++ 中用 <code>extern &quot;C&quot;</code> 实现 C 兼容链接。</li>
<li>C++ 中 <code>const</code> 全局变量需 <code>extern</code> 才能跨文件共享。</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>extern</tag>
      </tags>
  </entry>
  <entry>
    <title>cstring详解</title>
    <url>/2025/07/28/C_C++/cstring%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="cstring详解"><a href="#cstring详解" class="headerlink" title="cstring详解"></a>cstring详解</h1><p>#include <cstring> 是在 C++ 程序中引入头文件 <cstring> 的语句。这个头文件提供了用于处理 C 风格字符串（即以空字符 ‘\0’ 结尾的字符数组）的函数。</p>
<p>具体来说，<cstring> 定义了一些常用的字符串操作函数，如：</p>
<h2 id="（1）strcpy-复制字符串"><a href="#（1）strcpy-复制字符串" class="headerlink" title="（1）strcpy: 复制字符串"></a>（1）strcpy: 复制字符串</h2><p>strcpy 是 cstring 中用于复制 C 风格字符串的函数，它将源字符串的内容复制到目标字符串中，包括末尾的空字符 (‘\0’)。使用 strcpy 时需要确保目标数组有足够的空间来存放源字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* strcpy(char* destination, const char* source);</span><br></pre></td></tr></table></figure>

<p>destination：目标字符数组，存放复制后的字符串。<br>source：源字符数组，被复制的字符串。<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建源字符串</span><br><span class="line">    const char source[] = &quot;Hello, World!&quot;;</span><br><span class="line">    </span><br><span class="line">    // 创建目标数组，确保大小足够容纳源字符串</span><br><span class="line">    char destination[20];</span><br><span class="line">    </span><br><span class="line">    // 使用 strcpy 复制字符串</span><br><span class="line">    std::strcpy(destination, source);</span><br><span class="line">    </span><br><span class="line">    // 输出结果</span><br><span class="line">    std::cout &lt;&lt; &quot;Source: &quot; &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Destination: &quot; &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Source: Hello, World!</span><br><span class="line">Destination: Hello, World!</span><br></pre></td></tr></table></figure>

<p>注意：<br>destination 数组必须足够大，以容纳 source 字符串及其末尾的空字符 (‘\0’)。<br>如果 destination 的空间不足，strcpy 不会进行检查，可能导致缓冲区溢出等问题。因此，程序员要手动确保内存安全。</p>
<h2 id="（2）strncpy-复制指定长度的字符串"><a href="#（2）strncpy-复制指定长度的字符串" class="headerlink" title="（2）strncpy: 复制指定长度的字符串"></a>（2）strncpy: 复制指定长度的字符串</h2><p>strncpy 是 cstring 中的一个函数，用于从源字符串复制指定长度的字符到目标字符串。与 strcpy 不同的是，strncpy 只会复制指定长度的字符，且如果源字符串的长度小于指定长度，则会在目标字符串中填充空字符 (‘\0’) 以确保长度一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* strncpy(char* destination, const char* source, size_t num);</span><br></pre></td></tr></table></figure>


<p>destination：目标字符数组，存放复制后的字符串。<br>source：源字符数组，被复制的字符串。<br>num：要复制的字符数。<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建源字符串</span><br><span class="line">    const char source[] = &quot;Hello, World!&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 创建目标数组，确保大小足够</span><br><span class="line">    char destination[20];</span><br><span class="line">    </span><br><span class="line">    // 使用 strncpy 复制指定长度的字符串</span><br><span class="line">    std::strncpy(destination, source, 5);</span><br><span class="line">    </span><br><span class="line">    // 手动添加空字符，以确保目标字符串正确结束</span><br><span class="line">    destination[5] = &#x27;\0&#x27;;</span><br><span class="line">    </span><br><span class="line">    // 输出结果</span><br><span class="line">    std::cout &lt;&lt; &quot;Source: &quot; &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Destination: &quot; &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Source: Hello, World!</span><br><span class="line">Destination: Hello</span><br></pre></td></tr></table></figure>

<p>说明：<br>strncpy(destination, source, 5) 只复制源字符串的前 5 个字符 Hello 到目标数组。<br>手动添加 destination[5] &#x3D; ‘\0’; 是为了确保目标字符串以空字符结尾，否则在输出时可能会导致意外行为。<br>如果 source 字符串的长度小于 num，则 strncpy 会在目标数组中补充空字符 (\0) 直到复制了 num 个字符。<br>注意：<br>strncpy 不会自动添加结尾的空字符 (‘\0’)，因此需要手动添加。<br>如果源字符串的长度小于指定的字符数，目标字符串会用空字符填充。</p>
<h2 id="（3）strcmp-比较两个字符串"><a href="#（3）strcmp-比较两个字符串" class="headerlink" title="（3）strcmp: 比较两个字符串"></a>（3）strcmp: 比较两个字符串</h2><p>strcmp 是 cstring 中的一个函数，用于按字典序比较两个 C 风格字符串。它比较的是字符串的 ASCII 值，并返回一个整数，表示两个字符串的相对顺序。</p>
<p>str1 和 str2：要比较的两个字符串。<br>返回值：<br>0：str1 和 str2 相等。<br>正值：str1 大于 str2。<br>负值：str1 小于 str2。<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义两个字符串</span><br><span class="line">    const char str1[] = &quot;apple&quot;;</span><br><span class="line">    const char str2[] = &quot;banana&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 使用 strcmp 比较两个字符串</span><br><span class="line">    int result = std::strcmp(str1, str2);</span><br><span class="line">    </span><br><span class="line">    // 输出比较结果</span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;str1 and str2 are equal.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else if (result &gt; 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;str1 is greater than str2.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;str1 is less than str2.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str1 is less than str2.</span><br></pre></td></tr></table></figure>

<p>说明：<br>在这个例子中，strcmp(“apple”, “banana”) 返回一个负值，因为在字典序（基于 ASCII 值）中，a（ASCII 值为 97）比 b（ASCII 值为 98）小，因此 apple 小于 banana。<br>strcmp 的返回值详解：<br>如果 strcmp 返回 0，表示两个字符串相等。<br>如果返回正值，表示 str1 在字典序中比 str2 大。<br>如果返回负值，表示 str1 在字典序中比 str2 小。<br>举几个简单例子：<br>strcmp(“apple”, “apple”) &#x3D;&#x3D; 0：两个字符串相等。<br>strcmp(“apple”, “banana”) &lt; 0：apple 小于 banana。<br>strcmp(“banana”, “apple”) &gt; 0：banana 大于 apple。</p>
<h2 id="（4）strlen-获取字符串的长度"><a href="#（4）strlen-获取字符串的长度" class="headerlink" title="（4）strlen: 获取字符串的长度"></a>（4）strlen: 获取字符串的长度</h2><p>strlen 是 cstring 中的一个函数，用于计算 C 风格字符串的长度（不包括结尾的空字符 ‘\0’）。它返回的是字符串中字符的个数。</p>
<p>size_t strlen(const char* str);</p>
<p>str：要计算长度的字符串。<br>返回值：字符串的长度（不包括终止的空字符 ‘\0’）。<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义一个字符串</span><br><span class="line">    const char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 使用 strlen 计算字符串长度</span><br><span class="line">    size_t length = std::strlen(str);</span><br><span class="line">    </span><br><span class="line">    // 输出字符串长度</span><br><span class="line">    std::cout &lt;&lt; &quot;The length of the string \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; is &quot; &lt;&lt; length &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The length of the string &quot;Hello, World!&quot; is 13.</span><br></pre></td></tr></table></figure>

<p>说明：<br>在这个例子中，strlen(“Hello, World!”) 返回 13，因为 “Hello, World!” 中有 13 个字符（不包括字符串末尾的空字符 ‘\0’）。<br>strlen 函数遍历字符串直到遇到终止空字符 ‘\0’，然后返回遍历的字符数。<br>重要注意事项：<br>strlen 计算的长度不包括字符串的结束符 ‘\0’。<br>如果传递给 strlen 的字符串没有以 ‘\0’ 结尾（即不是合法的 C 风格字符串），它可能导致未定义行为，因为 strlen 函数会继续读取内存，直到找到 ‘\0’。因此，确保传递的字符串是正确终止的非常重要。</p>
<h2 id="（5）strcat-拼接字符串"><a href="#（5）strcat-拼接字符串" class="headerlink" title="（5）strcat: 拼接字符串"></a>（5）strcat: 拼接字符串</h2><p>strcat 是 cstring 中的一个函数，用于将一个 C 风格字符串追加到另一个 C 风格字符串的末尾。它会将源字符串的内容附加到目标字符串的末尾，包括结尾的空字符 ‘\0’。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* strcat(char* destination, const char* source);</span><br></pre></td></tr></table></figure>

<p>destination：目标字符数组，原有内容会被保留，源字符串会被追加到其末尾。<br>source：要追加的源字符串。<br>返回值：返回目标字符串 destination 的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义目标字符串数组和源字符串</span><br><span class="line">    char destination[50] = &quot;Hello, &quot;;</span><br><span class="line">    const char source[] = &quot;World!&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 使用 strcat 拼接字符串</span><br><span class="line">    std::strcat(destination, source);</span><br><span class="line">    </span><br><span class="line">    // 输出结果</span><br><span class="line">    std::cout &lt;&lt; &quot;Resulting string: &quot; &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resulting string: Hello, World!</span><br></pre></td></tr></table></figure>


<p>在这个例子中，strcat(destination, source) 将 “World!” 追加到 “Hello, “ 的末尾。<br>destination 字符数组在使用 strcat 之前已经分配了足够的空间来容纳拼接后的结果（这里是 50 个字符）。strcat 依赖于目标数组有足够的空间来存储拼接后的字符串，否则可能会导致缓冲区溢出。<br>注意事项：<br>确保 destination 数组有足够的空间来存放原有内容加上追加的源字符串，以及结尾的空字符 ‘\0’。<br>strcat 不会自动检查目标数组的大小，所以在使用 strcat 时必须手动确保目标数组足够大。否则，可能会导致内存溢出、数据损坏或其他未定义行为。</p>
<h2 id="（6）strchr-查找字符在字符串中的第一次出现位置"><a href="#（6）strchr-查找字符在字符串中的第一次出现位置" class="headerlink" title="（6）strchr: 查找字符在字符串中的第一次出现位置"></a>（6）strchr: 查找字符在字符串中的第一次出现位置</h2><p>strchr 是 cstring 中的一个函数，用于在 C 风格字符串中查找指定字符第一次出现的位置。它返回一个指向找到的字符位置的指针。如果字符未找到，则返回 nullptr。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* strchr(const char* str, int character);</span><br></pre></td></tr></table></figure>

<p>str：要搜索的字符串。<br>character：要查找的字符，作为 int 类型传递，通常是 char 类型的值。<br>返回值：返回一个指向找到的字符位置的指针；如果字符未找到，则返回 nullptr。<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 定义一个字符串</span><br><span class="line">    const char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 查找字符 &#x27;W&#x27; 在字符串中的第一次出现位置</span><br><span class="line">    char* position = std::strchr(str, &#x27;W&#x27;);</span><br><span class="line">    </span><br><span class="line">    // 输出结果</span><br><span class="line">    if (position != nullptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Character &#x27;W&#x27; found at position: &quot; &lt;&lt; (position - str) &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;Sub-string starting from &#x27;W&#x27;: &quot; &lt;&lt; position &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Character &#x27;W&#x27; not found.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Character &#x27;W&#x27; found at position: 7</span><br><span class="line">Sub-string starting from &#x27;W&#x27;: World!</span><br></pre></td></tr></table></figure>

<p>说明：<br>std::strchr(str, ‘W’) 查找字符 ‘W’ 在字符串 “Hello, World!” 中的位置。函数返回一个指向字符 ‘W’ 的位置的指针。<br>(position - str) 计算字符 ‘W’ 在字符串中的位置，结果是 7（索引从 0 开始）。<br>position 指向 “World!”，即从字符 ‘W’ 开始的子字符串。<br>注意事项：<br>strchr 查找的是第一个匹配的字符，如果要查找所有匹配的字符，需要在找到匹配项后继续搜索。<br>传递的字符 character 作为 int 类型，但通常以 char 类型的值传递，strchr 内部会处理这个值。<br>通过 #include <cstring>，你可以使用这些函数来处理 C 风格字符串。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cstring</tag>
      </tags>
  </entry>
  <entry>
    <title>For循环中的i++与++i：区别、性能与最佳实践</title>
    <url>/2025/09/01/C_C++/i++%E5%92%8C++i/</url>
    <content><![CDATA[<p>在编写循环语句时，<code>for (int i = 0; i &lt; n; i++)</code>几乎是程序员最熟悉的代码模板之一。但很少有人深究：这里的<code>i++</code>换成<code>++i</code>会有什么不同？哪种写法更优？表面上看，两者都是让变量<code>i</code>自增1，但它们的执行逻辑、返回值和潜在性能存在细微却重要的差异。本文将从基础原理到实际应用，全面解析For循环中<code>i++</code>与<code>++i</code>的区别，并通过实例说明哪种写法更值得推荐。</p>
<span id="more"></span>

<h3 id="一、基础原理：i-与-i的本质区别"><a href="#一、基础原理：i-与-i的本质区别" class="headerlink" title="一、基础原理：i++与++i的本质区别"></a>一、基础原理：i++与++i的本质区别</h3><p><code>i++</code>（后缀自增）和<code>++i</code>（前缀自增）是C、C++、Java、JavaScript等语言中常见的自增运算符，它们的核心区别体现在<strong>执行顺序</strong>和<strong>返回值</strong>上：</p>
<h4 id="1-后缀自增（i-）"><a href="#1-后缀自增（i-）" class="headerlink" title="1. 后缀自增（i++）"></a>1. 后缀自增（i++）</h4><ul>
<li><strong>执行逻辑</strong>：先返回变量当前的值，再将变量加1。</li>
<li><strong>过程分解</strong>：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i++的等效伪代码</span></span><br><span class="line">temp = i;   <span class="comment">// 保存当前值</span></span><br><span class="line">i = i + <span class="number">1</span>;  <span class="comment">// 变量自增</span></span><br><span class="line"><span class="keyword">return</span> temp; <span class="comment">// 返回原始值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-前缀自增（-i）"><a href="#2-前缀自增（-i）" class="headerlink" title="2. 前缀自增（++i）"></a>2. 前缀自增（++i）</h4><ul>
<li><strong>执行逻辑</strong>：先将变量加1，再返回自增后的值。</li>
<li><strong>过程分解</strong>：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++i的等效伪代码</span></span><br><span class="line">i = i + <span class="number">1</span>;  <span class="comment">// 变量自增</span></span><br><span class="line"><span class="keyword">return</span> i;   <span class="comment">// 返回新值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="直观示例"><a href="#直观示例" class="headerlink" title="直观示例"></a>直观示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> a = i++;  <span class="comment">// a = 3（返回原始值），i变为4</span></span><br><span class="line"><span class="type">int</span> b = ++i;  <span class="comment">// i先变为5，b = 5（返回新值）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：a=3, b=5, i=5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d, i=%d\n&quot;</span>, a, b, i);</span><br></pre></td></tr></table></figure>

<p>这个例子清晰展示了两者的核心差异：<code>i++</code>返回自增前的值，<code>++i</code>返回自增后的值。</p>
<h3 id="二、For循环中的表现：差异被“屏蔽”的场景"><a href="#二、For循环中的表现：差异被“屏蔽”的场景" class="headerlink" title="二、For循环中的表现：差异被“屏蔽”的场景"></a>二、For循环中的表现：差异被“屏蔽”的场景</h3><p>在For循环的经典结构<code>for (init; condition; increment)</code>中，自增运算符的位置位于<strong>循环后操作</strong>（increment）部分，其返回值通常会被忽略。这导致很多人认为<code>i++</code>和<code>++i</code>在这里可以随意替换，但事实并非完全如此。</p>
<h4 id="1-循环执行流程对比"><a href="#1-循环执行流程对比" class="headerlink" title="1. 循环执行流程对比"></a>1. 循环执行流程对比</h4><p>以<code>for (int i = 0; i &lt; 3; i++)</code>和<code>for (int i = 0; i &lt; 3; ++i)</code>为例，两者的循环步骤如下：</p>
<table>
<thead>
<tr>
<th>循环阶段</th>
<th>i++版本</th>
<th>++i版本</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>i &#x3D; 0</td>
<td>i &#x3D; 0</td>
</tr>
<tr>
<td>第1次循环</td>
<td>执行循环体（i&#x3D;0）→ i变为1（返回值0被忽略）</td>
<td>执行循环体（i&#x3D;0）→ i变为1（返回值1被忽略）</td>
</tr>
<tr>
<td>第2次循环</td>
<td>执行循环体（i&#x3D;1）→ i变为2（返回值1被忽略）</td>
<td>执行循环体（i&#x3D;1）→ i变为2（返回值2被忽略）</td>
</tr>
<tr>
<td>第3次循环</td>
<td>执行循环体（i&#x3D;2）→ i变为3（返回值2被忽略）</td>
<td>执行循环体（i&#x3D;2）→ i变为3（返回值3被忽略）</td>
</tr>
<tr>
<td>终止</td>
<td>i&#x3D;3不满足条件，循环结束</td>
<td>i&#x3D;3不满足条件，循环结束</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：在For循环中，无论使用<code>i++</code>还是<code>++i</code>，循环体执行时<code>i</code>的值完全相同，循环次数和最终结果也完全一致。</p>
<h4 id="2-反汇编视角：编译器的优化"><a href="#2-反汇编视角：编译器的优化" class="headerlink" title="2. 反汇编视角：编译器的优化"></a>2. 反汇编视角：编译器的优化</h4><p>通过GCC生成的汇编代码可以更深入地看到差异。对于以下两段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码1：i++版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 空循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2：++i版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 空循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开启优化（<code>-O2</code>）的情况下，两者生成的汇编代码完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl    $0, %eax        ; i = 0</span><br><span class="line">.L2:</span><br><span class="line">cmpl    $10, %eax       ; 比较i与10</span><br><span class="line">jge     .L4             ; 若i &gt;= 10，跳转到结束</span><br><span class="line">addl    $1, %eax        ; i += 1（自增操作）</span><br><span class="line">jmp     .L2             ; 跳回循环开始</span><br><span class="line">.L4:</span><br></pre></td></tr></table></figure>

<p>可见，现代编译器会忽略循环后操作中自增运算符的返回值差异，生成完全相同的机器码。这意味着在<strong>循环条件和循环体与自增返回值无关</strong>的情况下，两者的执行效率没有区别。</p>
<h3 id="三、性能对比：是否存在效率差异？"><a href="#三、性能对比：是否存在效率差异？" class="headerlink" title="三、性能对比：是否存在效率差异？"></a>三、性能对比：是否存在效率差异？</h3><p>长期以来，存在一种观点认为<code>++i</code>比<code>i++</code>更高效，因为<code>i++</code>需要保存原始值的临时变量。这种说法在某些场景下成立，但在For循环中需要具体分析。</p>
<h4 id="1-基础类型（int、long等）"><a href="#1-基础类型（int、long等）" class="headerlink" title="1. 基础类型（int、long等）"></a>1. 基础类型（int、long等）</h4><p>对于<code>int</code>等基础类型，现代编译器（如GCC、Clang）会对<code>i++</code>进行优化，消除临时变量的开销。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器会将i++优化为与++i等价的代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际测试中（1亿次循环，空循环体），<code>i++</code>和<code>++i</code>的执行时间误差在1%以内，可认为无性能差异。</p>
<h4 id="2-复杂类型（迭代器、自定义对象）"><a href="#2-复杂类型（迭代器、自定义对象）" class="headerlink" title="2. 复杂类型（迭代器、自定义对象）"></a>2. 复杂类型（迭代器、自定义对象）</h4><p>对于C++的迭代器（如<code>std::vector&lt;int&gt;::iterator</code>）或重载了<code>++</code>运算符的自定义对象，情况则不同。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义计数器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀自增</span></span><br><span class="line">    Counter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回引用，无拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后缀自增</span></span><br><span class="line">    Counter <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Counter temp = *<span class="keyword">this</span>; <span class="comment">// 产生临时对象（拷贝开销）</span></span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">return</span> temp; <span class="comment">// 返回临时对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">int</span> n) &#123; <span class="keyword">return</span> value &lt; n; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环测试</span></span><br><span class="line"><span class="keyword">for</span> (Counter <span class="built_in">c</span>(<span class="number">0</span>); c &lt; <span class="number">10000000</span>; c++) &#123; <span class="comment">/* 空循环 */</span> &#125;  <span class="comment">// 后缀自增，有拷贝</span></span><br><span class="line"><span class="keyword">for</span> (Counter <span class="built_in">c</span>(<span class="number">0</span>); c &lt; <span class="number">10000000</span>; ++c) &#123; <span class="comment">/* 空循环 */</span> &#125;  <span class="comment">// 前缀自增，无拷贝</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>c++</code>会触发临时对象的创建和销毁（拷贝构造函数和析构函数调用），而<code>++c</code>直接返回引用，性能差异可达<strong>30%以上</strong>（视对象复杂度而定）。</p>
<p><strong>结论</strong>：</p>
<ul>
<li>基础类型：For循环中<code>i++</code>和<code>++i</code>性能几乎无差异（编译器优化的结果）</li>
<li>复杂类型：<code>++i</code>通常更高效（避免临时对象的拷贝开销）</li>
</ul>
<h3 id="四、可读性与最佳实践"><a href="#四、可读性与最佳实践" class="headerlink" title="四、可读性与最佳实践"></a>四、可读性与最佳实践</h3><p>除了性能，代码的可读性和一致性也是重要考量因素。</p>
<h4 id="1-可读性对比"><a href="#1-可读性对比" class="headerlink" title="1. 可读性对比"></a>1. 可读性对比</h4><ul>
<li><code>i++</code>：在For循环中是更传统、更广泛使用的写法，大多数程序员对此更熟悉，看到代码时无需额外思考。</li>
<li><code>++i</code>：虽然逻辑上更直接（先自增再使用），但在循环中因返回值被忽略，其“先自增”的特性体现不明显，可能让新手产生困惑。</li>
</ul>
<h4 id="2-最佳实践建议"><a href="#2-最佳实践建议" class="headerlink" title="2. 最佳实践建议"></a>2. 最佳实践建议</h4><ul>
<li><p><strong>基础类型（int等）</strong>：</p>
<ul>
<li>若团队已有统一规范，遵循规范即可</li>
<li>若无规范，推荐使用<code>i++</code>（符合大多数人的阅读习惯）</li>
<li>避免过度纠结于微乎其微的性能差异（现代编译器已优化）</li>
</ul>
</li>
<li><p><strong>复杂类型（迭代器、自定义对象）</strong>：</p>
<ul>
<li>强制使用<code>++i</code>，以避免不必要的性能损耗</li>
<li>例如C++标准库的迭代器循环：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 使用*it访问元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特殊场景</strong>：当自增操作的返回值被使用时，必须根据逻辑选择：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1：需要先使用原始值再自增</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    sum += arr[i++];  <span class="comment">// 先取arr[i]，再i++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：需要先自增再使用新值</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    sum += arr[++i];  <span class="comment">// 先i++，再取arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="五、常见误区澄清"><a href="#五、常见误区澄清" class="headerlink" title="五、常见误区澄清"></a>五、常见误区澄清</h3><ol>
<li><strong>“++i一定比i++高效”</strong>：错误。对于基础类型，编译器优化后两者效率相同；只有在复杂类型中<code>++i</code>才更有优势。</li>
<li><strong>“For循环中使用++i可以提高性能”</strong>：部分正确。仅当循环变量是复杂类型时才有意义，对于<code>int</code>等类型属于过度优化。</li>
<li><strong>“i++和++i在循环中行为不同”</strong>：错误。如前文分析，循环体执行时<code>i</code>的值完全相同，循环次数也一致。</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p><code>i++</code>与<code>++i</code>的核心区别在于返回值（原始值 vs 新值），这一差异在For循环的循环后操作中被弱化——因为返回值未被使用。</p>
<ul>
<li><strong>性能层面</strong>：基础类型无实质差异；复杂类型（如迭代器）<code>++i</code>更优。</li>
<li><strong>可读性层面</strong>：<code>i++</code>更符合传统习惯，认知成本更低。</li>
<li><strong>最佳实践</strong>：基础类型可任选（推荐<code>i++</code>），复杂类型强制使用<code>++i</code>。</li>
</ul>
<p>理解这一区别的价值不仅在于写出更高效的代码，更在于培养对细节的敏感度——编程中许多性能优化和bug预防，都源于对运算符、语法规则等基础概念的深入理解。在实际开发中，应根据变量类型和团队规范选择合适的写法，在可读性和性能之间找到平衡。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>For循环</tag>
        <tag>自增运算符</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内存四区深度解析</title>
    <url>/2025/07/22/C_C++/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/</url>
    <content><![CDATA[<p>C++ 程序运行时，内存被划分为四个逻辑区域 —— 代码区、全局区（全局变量与静态变量区）、栈区（局部变量区）和堆区（静态存储区），每个区域承担不同的功能，遵循不同的管理规则。理解内存四区的特性是掌握 C++ 内存管理的基础，也是排查内存泄漏、野指针等问题的关键。本文将从底层机制到实战案例，全面解析内存四区的运作原理。</p>
<h3 id="一、内存四区的基本划分与特性"><a href="#一、内存四区的基本划分与特性" class="headerlink" title="一、内存四区的基本划分与特性"></a>一、内存四区的基本划分与特性</h3><p>C++ 程序加载到内存后，操作系统会将其划分为四个逻辑区域，各区域的存储内容、生命周期和管理方式截然不同：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>存储内容</th>
<th>生命周期</th>
<th>管理方式</th>
<th>典型大小</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码区</strong></td>
<td>二进制指令、常量字符串（部分）</td>
<td>程序启动至退出</td>
<td>操作系统自动管理</td>
<td>随代码量增长</td>
</tr>
<tr>
<td><strong>全局区</strong></td>
<td>全局变量、静态变量、常量（全局）</td>
<td>程序启动至退出</td>
<td>操作系统自动管理</td>
<td>通常几 MB 至数十 MB</td>
</tr>
<tr>
<td><strong>栈区</strong></td>
<td>局部变量、函数参数、返回地址</td>
<td>函数调用至返回</td>
<td>编译器自动分配 &#x2F; 释放</td>
<td>通常 8MB（可配置）</td>
</tr>
<tr>
<td><strong>堆区</strong></td>
<td>动态分配的内存（new&#x2F;malloc）</td>
<td>手动分配至手动释放</td>
<td>程序员通过 delete&#x2F;free 管理</td>
<td>理论上可达系统内存上限</td>
</tr>
</tbody></table>
<h3 id="二、代码区（Code-Area）"><a href="#二、代码区（Code-Area）" class="headerlink" title="二、代码区（Code Area）"></a>二、代码区（Code Area）</h3><p>代码区是程序运行的基础，存储 CPU 可执行的二进制指令（机器码）及部分常量数据，具有以下特性：</p>
<h4 id="1-只读属性"><a href="#1-只读属性" class="headerlink" title="1. 只读属性"></a>1. 只读属性</h4><p>为防止程序意外修改指令，代码区通常被标记为 “只读”（read-only）。若试图通过指针修改代码区内容，会触发内存访问错误（如 Linux 下的 Segmentation Fault）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char* str = &quot;hello&quot;;  // &quot;hello&quot;存储在代码区（只读）</span><br><span class="line">    char* ptr = const_cast&lt;char*&gt;(str);</span><br><span class="line">    *ptr = &#x27;H&#x27;;  // 错误：修改只读内存，触发段错误</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2. 共享性"></a>2. 共享性</h4><p>多个运行实例（进程）可共享同一份代码区数据，例如同时运行两个记事本程序，它们的代码区是共享的，仅数据区独立，节省内存开销。</p>
<h4 id="3-常量字符串存储"><a href="#3-常量字符串存储" class="headerlink" title="3. 常量字符串存储"></a>3. 常量字符串存储</h4><p>C 风格字符串常量（如”hello”）通常存储在代码区的常量段（.rodata），而 C++ 的std::string对象的内容在 C++11 后可能存储在堆区或栈区（短字符串优化）。</p>
<h3 id="三、全局区（Global-Area）"><a href="#三、全局区（Global-Area）" class="headerlink" title="三、全局区（Global Area）"></a>三、全局区（Global Area）</h3><p>全局区（又称静态存储区）存储具有全局生命周期的变量和常量，在程序编译阶段即完成分配，可细分为以下子区域：</p>
<h4 id="1-全局变量与静态变量区"><a href="#1-全局变量与静态变量区" class="headerlink" title="1. 全局变量与静态变量区"></a>1. 全局变量与静态变量区</h4><ul>
<li><p><strong>全局变量</strong>：定义在函数外的变量（如int global_var &#x3D; 10;），未初始化的全局变量默认值为 0，存储在.bss 段；已初始化的存储在.data 段。</p>
</li>
<li><p><strong>静态变量</strong>：包括static修饰的全局变量（static int static_global;）和局部静态变量（void func() { static int stat; }），无论定义位置，均存储在全局区。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局变量：存储在全局区.data段（已初始化）</span><br><span class="line">int global_init = 20;</span><br><span class="line"></span><br><span class="line">// 全局变量：存储在全局区.bss段（未初始化，默认0）</span><br><span class="line">int global_uninit;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    // 静态局部变量：存储在全局区，生命周期与程序一致</span><br><span class="line">    static int static_local = 30;</span><br><span class="line">    static_local++;</span><br><span class="line">    cout &lt;&lt; static_local &lt;&lt; endl;  // 每次调用自增</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    func();  // 31（首次初始化）</span><br><span class="line">    func();  // 32（全局区变量未被释放）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-全局常量区"><a href="#2-全局常量区" class="headerlink" title="2. 全局常量区"></a>2. 全局常量区</h4><p>全局常量包括const修饰的全局变量和extern const变量，存储在全局区的只读段，其值在编译期确定且不可修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int GLOBAL_CONST = 100;  // 全局常量，存储在全局区只读段</span><br><span class="line">void func() &#123;</span><br><span class="line">    const int LOCAL_CONST = 200;  // 局部常量，存储在栈区（C++17后可能优化）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：局部常量（如LOCAL_CONST）存储在栈区，其 “只读” 属性由编译器在编译期检查保障，可通过指针强制修改（不推荐），而全局常量的只读性由内存属性保障，无法修改。</p>
<h3 id="四、栈区（Stack-Area）"><a href="#四、栈区（Stack-Area）" class="headerlink" title="四、栈区（Stack Area）"></a>四、栈区（Stack Area）</h3><p>栈区是函数调用的临时数据存储区，遵循 “先进后出”（FILO）原则，由编译器自动管理，效率极高（通常仅需几条汇编指令完成分配）。</p>
<h4 id="1-栈帧结构"><a href="#1-栈帧结构" class="headerlink" title="1. 栈帧结构"></a>1. 栈帧结构</h4><p>每次函数调用时，编译器会在栈区创建一个 “栈帧”（Stack Frame），包含：</p>
<ul>
<li><p>函数参数；</p>
</li>
<li><p>返回地址（函数执行完毕后跳转的位置）；</p>
</li>
<li><p>局部变量；</p>
</li>
<li><p>栈底指针（ebp&#x2F;rbp）和栈顶指针（esp&#x2F;rsp）维护的栈帧边界。</p>
</li>
</ul>
<p>函数返回时，栈帧被自动销毁，局部变量随之释放，这也是局部变量生命周期仅限于函数调用的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int* func() &#123;</span><br><span class="line">    int a = 10;  // a存储在栈区，函数返回后释放</span><br><span class="line">    return &amp;a;   // 警告：返回栈区地址（野指针）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int* p = func();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;  // 未定义行为：可能输出10（脏数据）或崩溃</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，a在func()返回后被释放，p成为 “野指针”，访问其指向的内存会导致不可预测的结果。</p>
<h4 id="2-栈的大小限制与栈溢出"><a href="#2-栈的大小限制与栈溢出" class="headerlink" title="2. 栈的大小限制与栈溢出"></a>2. 栈的大小限制与栈溢出</h4><p>栈区大小通常由操作系统预先分配（Linux 默认 8MB，Windows 默认 1MB），若函数递归过深或局部变量过大，会导致 “栈溢出”（Stack Overflow）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 递归过深导致栈溢出</span><br><span class="line">void recursion() &#123;</span><br><span class="line">    char big_array[1024 * 1024];  // 1MB局部数组，快速耗尽栈空间</span><br><span class="line">    recursion();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    recursion();  // 栈溢出，程序崩溃</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决栈溢出的方法：</p>
<ul>
<li><p>减少局部变量大小，改用堆区动态分配；</p>
</li>
<li><p>调整栈大小（如 Linux 下通过ulimit -s命令）；</p>
</li>
<li><p>避免过深递归，改用迭代实现。</p>
</li>
</ul>
<h3 id="五、堆区（Heap-Area）"><a href="#五、堆区（Heap-Area）" class="headerlink" title="五、堆区（Heap Area）"></a>五、堆区（Heap Area）</h3><p>堆区是程序中最灵活的内存区域，由程序员手动管理，用于存储动态大小的数据（如链表节点、动态数组），具有以下特性：</p>
<h4 id="1-动态分配与释放"><a href="#1-动态分配与释放" class="headerlink" title="1. 动态分配与释放"></a>1. 动态分配与释放</h4><p>C++ 中通过new&#x2F;delete操作堆区内存，C 语言使用malloc&#x2F;free，两者需配对使用，否则会导致内存泄漏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正确用法：new与delete配对</span><br><span class="line">int* ptr = new int(10);  // 堆区分配int，初始化10</span><br><span class="line">delete ptr;              // 释放堆区内存</span><br><span class="line">ptr = nullptr;           // 避免野指针</span><br><span class="line"></span><br><span class="line">// 错误用法：内存泄漏</span><br><span class="line">void leak() &#123;</span><br><span class="line">    int* p = new int[100];  // 分配数组</span><br><span class="line">    // 未调用delete[]，函数返回后p被销毁，堆区内存无法释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：new[]分配的数组需用delete[]释放，否则会导致部分内存泄漏（仅释放首元素）。</p>
<h4 id="2-碎片化问题"><a href="#2-碎片化问题" class="headerlink" title="2. 碎片化问题"></a>2. 碎片化问题</h4><p>频繁分配和释放不同大小的堆内存会导致 “内存碎片”—— 堆区存在大量无法利用的小空闲块。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导致碎片的操作</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    int* p = new int;    // 分配4字节</span><br><span class="line">    delete p;</span><br><span class="line">    char* q = new char[100];  // 分配100字节</span><br><span class="line">    delete[] q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存碎片会导致 “虽然总空闲内存足够，但无法分配连续大内存块” 的问题，可通过内存池（Memory Pool）技术缓解。</p>
<h4 id="3-堆与栈的性能对比"><a href="#3-堆与栈的性能对比" class="headerlink" title="3. 堆与栈的性能对比"></a>3. 堆与栈的性能对比</h4><p>堆区分配 &#x2F; 释放的开销远大于栈区：</p>
<ul>
<li><p>栈区操作仅需移动栈指针（如sub rsp, 0x10），耗时约 1~2 个 CPU 周期；</p>
</li>
<li><p>堆区操作需遍历空闲链表（new&#x2F;malloc）或标记回收（delete&#x2F;free），耗时通常为栈区的 100 倍以上。</p>
</li>
</ul>
<p>因此，小内存、短生命周期的变量优先使用栈区，大内存、长生命周期的变量使用堆区。</p>
<h3 id="六、四区交互：变量传递与内存流转"><a href="#六、四区交互：变量传递与内存流转" class="headerlink" title="六、四区交互：变量传递与内存流转"></a>六、四区交互：变量传递与内存流转</h3><p>程序运行时，四区并非孤立存在，而是通过指针 &#x2F; 引用相互交互，以下为典型场景：</p>
<h4 id="1-栈区变量地址传递到堆区"><a href="#1-栈区变量地址传递到堆区" class="headerlink" title="1. 栈区变量地址传递到堆区"></a>1. 栈区变量地址传递到堆区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 堆区分配字符串，接收栈区的const char*</span><br><span class="line">char* copy_str(const char* src) &#123;  // src是栈区指针（指向代码区或栈区）</span><br><span class="line">    int len = strlen(src);</span><br><span class="line">    char* dest = new char[len + 1];  // 堆区分配</span><br><span class="line">    strcpy(dest, src);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char stack_str[] = &quot;stack&quot;;  // 存储在栈区（可修改）</span><br><span class="line">    char* heap_str = copy_str(stack_str);</span><br><span class="line">    cout &lt;&lt; heap_str;  // 输出：stack</span><br><span class="line">    delete[] heap_str;  // 释放堆区内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-堆区数据返回给栈区"><a href="#2-堆区数据返回给栈区" class="headerlink" title="2. 堆区数据返回给栈区"></a>2. 堆区数据返回给栈区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 堆区创建对象，返回指针给栈区</span><br><span class="line">class Object &#123;</span><br><span class="line">public:</span><br><span class="line">    int data;</span><br><span class="line">    Object(int d) : data(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object* create_obj(int d) &#123;</span><br><span class="line">    return new Object(d);  // 堆区分配对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Object* obj = create_obj(100);  // 栈区指针指向堆区对象</span><br><span class="line">    cout &lt;&lt; obj-&gt;data;  // 100</span><br><span class="line">    delete obj;  // 必须手动释放</span><br><span class="line">    obj = nullptr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、实战：内存四区相关问题排查"><a href="#七、实战：内存四区相关问题排查" class="headerlink" title="七、实战：内存四区相关问题排查"></a>七、实战：内存四区相关问题排查</h3><p>理解内存四区是解决常见内存问题的基础，以下为三个典型案例：</p>
<h4 id="1-野指针（栈区释放后访问）"><a href="#1-野指针（栈区释放后访问）" class="headerlink" title="1. 野指针（栈区释放后访问）"></a>1. 野指针（栈区释放后访问）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* get_ptr() &#123;</span><br><span class="line">    int x = 10;  // 栈区变量</span><br><span class="line">    return &amp;x;   // 返回栈区地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int* p = get_ptr();  // p为野指针（x已释放）</span><br><span class="line">    *p = 20;  // 未定义行为：可能修改其他栈数据，导致程序崩溃</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong>：避免返回局部变量地址，如需返回动态数据，使用堆区分配并由调用者释放。</p>
<h4 id="2-内存泄漏（堆区未释放）"><a href="#2-内存泄漏（堆区未释放）" class="headerlink" title="2. 内存泄漏（堆区未释放）"></a>2. 内存泄漏（堆区未释放）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">    int* p = new int[1000];  // 堆区分配</span><br><span class="line">    // 未调用delete[]，函数返回后p被销毁，内存无法释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        func();  // 持续泄漏内存，最终可能导致程序崩溃</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong>：使用智能指针（std::unique_ptr&#x2F;shared_ptr）自动管理堆区内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">void func() &#123;</span><br><span class="line">    auto p = std::make_unique&lt;int[]&gt;(1000);  // 智能指针自动释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-常量修改错误（代码区只读）"><a href="#3-常量修改错误（代码区只读）" class="headerlink" title="3. 常量修改错误（代码区只读）"></a>3. 常量修改错误（代码区只读）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* str = &quot;hello&quot;;  // &quot;hello&quot;在代码区（只读）</span><br><span class="line">str[0] = &#x27;H&#x27;;  // 段错误</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong>：若需修改字符串，使用栈区数组或堆区分配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char str[] = &quot;hello&quot;;  // 栈区拷贝，可修改</span><br><span class="line">str[0] = &#x27;H&#x27;;  // 正确：str变为&quot;Hello&quot;</span><br></pre></td></tr></table></figure>

<h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>内存四区是 C++ 程序运行的基础框架，其核心差异在于<strong>生命周期</strong>和<strong>管理方式</strong>：</p>
<ul>
<li><p>代码区和全局区由操作系统管理，生命周期与程序一致；</p>
</li>
<li><p>栈区由编译器自动管理，生命周期与函数调用绑定；</p>
</li>
<li><p>堆区由程序员手动管理，灵活性最高但风险也最大。</p>
</li>
</ul>
<p>掌握内存四区的特性，不仅能写出更高效的代码，更能快速定位内存泄漏、野指针等疑难问题。在实际开发中，应根据数据的生命周期和大小选择合适的存储区域，并善用智能指针等工具减少手动管理负担。</p>
<p>你在内存四区使用中遇到过哪些问题？欢迎在评论区分享你的排查经验～</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++lambda表达式</title>
    <url>/2025/10/23/C_C++/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>C++ 的 <strong>lambda 表达式</strong>（Lambda Expression）是 C++11 引入的一项重要特性，用于定义<strong>匿名函数对象</strong>（也称为闭包）。它提供了一种简洁、内联的方式来编写函数，特别适用于 STL 算法、回调函数、并行编程等场景。</p>
<hr>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>[capture]</code>：<strong>捕获列表</strong>，用于指定 lambda 如何访问其所在作用域中的变量。</li>
<li><code>(parameters)</code>：<strong>参数列表</strong>，和普通函数一样（C++14 起支持泛型参数，即 <code>auto</code>）。</li>
<li><code>-&gt; return_type</code>：<strong>返回类型</strong>（可选），如果省略，编译器会自动推导（C++14 起推导能力更强）。</li>
<li><code>&#123; body &#125;</code>：<strong>函数体</strong>。</li>
</ul>
<blockquote>
<p>最简形式：<code>[]() &#123;&#125;</code> —— 一个不捕获、无参数、无返回值的 lambda。</p>
</blockquote>
<hr>
<h2 id="二、捕获列表（Capture-Clause）"><a href="#二、捕获列表（Capture-Clause）" class="headerlink" title="二、捕获列表（Capture Clause）"></a>二、捕获列表（Capture Clause）</h2><p>捕获列表决定了 lambda 如何“看到”外部作用域的变量。</p>
<h3 id="1-按值捕获（copy）"><a href="#1-按值捕获（copy）" class="headerlink" title="1. 按值捕获（copy）"></a>1. 按值捕获（copy）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x]() &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;; <span class="comment">// x 被复制进 lambda</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(); <span class="comment">// 输出 11（使用的是副本）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-按引用捕获（reference）"><a href="#2-按引用捕获（reference）" class="headerlink" title="2. 按引用捕获（reference）"></a>2. 按引用捕获（reference）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;x]() &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(); <span class="comment">// 输出 21（引用外部 x）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-混合捕获"><a href="#3-混合捕获" class="headerlink" title="3. 混合捕获"></a>3. 混合捕获</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a, &amp;b]() &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-默认捕获模式"><a href="#4-默认捕获模式" class="headerlink" title="4. 默认捕获模式"></a>4. 默认捕获模式</h3><ul>
<li><code>[=]</code>：默认按值捕获所有用到的外部变量。</li>
<li><code>[&amp;]</code>：默认按引用捕获所有用到的外部变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]() &#123; <span class="keyword">return</span> x + y; &#125;;     <span class="comment">// 等价于 [x, y]</span></span><br><span class="line"><span class="keyword">auto</span> g = [&amp;]() &#123; x++; y++; &#125;;         <span class="comment">// 等价于 [&amp;x, &amp;y]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：默认捕获后仍可显式指定个别变量的捕获方式，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[&amp;, x]   <span class="comment">// 默认引用捕获，但 x 按值</span></span><br><span class="line">[=, &amp;y]  <span class="comment">// 默认值捕获，但 y 按引用</span></span><br></pre></td></tr></table></figure></blockquote>
<h3 id="5-捕获-this（成员函数中）"><a href="#5-捕获-this（成员函数中）" class="headerlink" title="5. 捕获 this（成员函数中）"></a>5. 捕获 <code>this</code>（成员函数中）</h3><p>在类的成员函数中，可以捕获 <code>this</code> 指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> val; &#125;; <span class="comment">// 捕获 this，可访问成员</span></span><br><span class="line">        <span class="comment">// C++17 起也支持 [*this] 捕获 this 的副本（值语义）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、参数与返回类型"><a href="#三、参数与返回类型" class="headerlink" title="三、参数与返回类型"></a>三、参数与返回类型</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>和普通函数一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>

<p>C++14 起支持泛型 lambda（使用 <code>auto</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// 可接受任意类型</span></span><br></pre></td></tr></table></figure>

<p>这实际上等价于一个模板函数对象。</p>
<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>通常可省略，由编译器推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;; <span class="comment">// 返回 int</span></span><br></pre></td></tr></table></figure>

<p>但若函数体较复杂（如含 <code>if-else</code> 分支返回不同类型），或需明确指定，可用 <code>-&gt;</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> x) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、lambda-的类型与存储"><a href="#四、lambda-的类型与存储" class="headerlink" title="四、lambda 的类型与存储"></a>四、lambda 的类型与存储</h2><p>每个 lambda 表达式都会生成一个<strong>唯一的匿名类类型</strong>（闭包类型），该类型重载了 <code>operator()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="comment">// f 的类型是某个编译器生成的、不可命名的类类型</span></span><br></pre></td></tr></table></figure>

<p>因此，不能直接用 <code>decltype(f)</code> 声明另一个 lambda（除非是同一表达式），但可以用：</p>
<ul>
<li><code>std::function&lt;R(Args...)&gt;</code> 存储（有运行时开销）</li>
<li>模板参数自动推导（无开销）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、常见用途"><a href="#五、常见用途" class="headerlink" title="五、常见用途"></a>五、常见用途</h2><h3 id="1-STL-算法"><a href="#1-STL-算法" class="headerlink" title="1. STL 算法"></a>1. STL 算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义排序"><a href="#2-自定义排序" class="headerlink" title="2. 自定义排序"></a>2. 自定义排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-线程与异步"><a href="#3-线程与异步" class="headerlink" title="3. 线程与异步"></a>3. 线程与异步</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<h3 id="4-回调函数"><a href="#4-回调函数" class="headerlink" title="4. 回调函数"></a>4. 回调函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_callback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_callback</span>([]() &#123; std::cout &lt;&lt; <span class="string">&quot;Callback called!\n&quot;</span>; &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、注意事项与陷阱"><a href="#六、注意事项与陷阱" class="headerlink" title="六、注意事项与陷阱"></a>六、注意事项与陷阱</h2><h3 id="1-悬空引用（Dangling-Reference）"><a href="#1-悬空引用（Dangling-Reference）" class="headerlink" title="1. 悬空引用（Dangling Reference）"></a>1. 悬空引用（Dangling Reference）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">bad_lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> [&amp;x]() &#123; <span class="keyword">return</span> x; &#125;; <span class="comment">// 错误！x 在函数返回后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应使用 <code>[=]</code> 或 <code>[x]</code> 按值捕获。</p>
<h3 id="2-mutable-关键字"><a href="#2-mutable-关键字" class="headerlink" title="2. mutable 关键字"></a>2. mutable 关键字</h3><p>lambda 默认是 <code>const</code> 的，不能修改按值捕获的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x++; <span class="comment">// 允许修改副本</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：<code>mutable</code> 只影响副本，不影响外部变量。</p>
<h3 id="3-性能考虑"><a href="#3-性能考虑" class="headerlink" title="3. 性能考虑"></a>3. 性能考虑</h3><ul>
<li>按值捕获大对象可能有拷贝开销（可考虑移动捕获，C++14 起支持初始化捕获）</li>
<li><code>std::function</code> 有类型擦除开销，优先使用模板或直接传递 lambda</li>
</ul>
<h3 id="4-初始化捕获（C-14）"><a href="#4-初始化捕获（C-14）" class="headerlink" title="4. 初始化捕获（C++14）"></a>4. 初始化捕获（C++14）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> f = [p = std::<span class="built_in">move</span>(p)]() &#123;  <span class="comment">// 移动捕获</span></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>匿名函数</td>
<td>无需命名，内联定义</td>
</tr>
<tr>
<td>闭包</td>
<td>可捕获外部变量</td>
</tr>
<tr>
<td>类型</td>
<td>每个 lambda 有唯一匿名类型</td>
</tr>
<tr>
<td>用途</td>
<td>STL、回调、线程、简化代码</td>
</tr>
<tr>
<td>安全</td>
<td>注意引用生命周期、mutable、移动语义</td>
</tr>
</tbody></table>
<hr>
<p>Lambda 表达式极大提升了 C++ 的表达能力和编程效率，是现代 C++ 编程不可或缺的工具。掌握其捕获机制和使用场景，能写出更简洁、高效、安全的代码。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 中的 static 关键字</title>
    <url>/2025/07/22/C_C++/static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>在 C 和 C++ 中，static 关键字堪称 “多面手”，其用法横跨变量、函数和类成员，且在不同场景下表现出截然不同的特性。对于初学者而言，static 的多样功能常常令人困惑 —— 时而延长变量生命周期，时而限制作用域，时而又成为类的共享成员。本文将系统梳理 static 的所有用法，结合代码示例解析其底层原理，助你彻底掌握这一基础而重要的关键字。</p>
<h3 id="一、C-语言中的-static-关键字"><a href="#一、C-语言中的-static-关键字" class="headerlink" title="一、C 语言中的 static 关键字"></a>一、C 语言中的 static 关键字</h3><p>在 C 语言中，static 的核心作用可概括为 “控制可见性” 和 “延长生命周期”，具体体现在修饰局部变量、全局变量和函数三种场景。</p>
<h4 id="1-修饰局部变量：延长生命周期，限制作用域"><a href="#1-修饰局部变量：延长生命周期，限制作用域" class="headerlink" title="1. 修饰局部变量：延长生命周期，限制作用域"></a>1. 修饰局部变量：延长生命周期，限制作用域</h4><p>普通局部变量存储在栈区，其生命周期仅限于函数调用期间，每次函数执行时重新初始化；而被 static 修饰的局部变量（静态局部变量）存储在数据段（.data 或.bss），生命周期与程序一致，且仅在第一次进入函数时初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void count() &#123;</span><br><span class="line">    int normal = 0;         // 普通局部变量，每次调用重置为0</span><br><span class="line">    static int stat = 0;    // 静态局部变量，仅初始化一次</span><br><span class="line">    normal++;</span><br><span class="line">    stat++;</span><br><span class="line">    printf(&quot;normal: %d, static: %d\n&quot;, normal, stat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    count();  // normal: 1, static: 1</span><br><span class="line">    count();  // normal: 1, static: 2</span><br><span class="line">    count();  // normal: 1, static: 3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：静态局部变量的初始化表达式必须是编译期常量（如0、3.14），不能使用变量或函数返回值初始化（C++ 中允许部分动态初始化）。</p>
<h4 id="2-修饰全局变量：限制作用域为当前文件"><a href="#2-修饰全局变量：限制作用域为当前文件" class="headerlink" title="2. 修饰全局变量：限制作用域为当前文件"></a>2. 修饰全局变量：限制作用域为当前文件</h4><p>全局变量默认具有外部链接性（external linkage），可通过extern关键字在其他文件中访问；而 static 修饰的全局变量（静态全局变量）仅具有内部链接性（internal linkage），作用域被限制在当前编译单元（.c 文件），避免不同文件中同名全局变量的冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// file1.c</span><br><span class="line">static int file_var = 10;  // 静态全局变量，仅file1.c可见</span><br><span class="line"></span><br><span class="line">// file2.c</span><br><span class="line">extern int file_var;       // 错误：无法访问file1.c的static全局变量</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;%d&quot;, file_var); // 编译报错：undefined reference to `file_var`</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-修饰函数：限制作用域为当前文件"><a href="#3-修饰函数：限制作用域为当前文件" class="headerlink" title="3. 修饰函数：限制作用域为当前文件"></a>3. 修饰函数：限制作用域为当前文件</h4><p>与静态全局变量类似，static 修饰的函数（静态函数）仅在当前文件中可见，防止与其他文件中的同名函数冲突，常用于实现 “文件内部的辅助函数”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// math.c</span><br><span class="line">static int add(int a, int b) &#123;  // 静态函数，仅math.c可用</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int public_calc(int x) &#123;</span><br><span class="line">    return add(x, x);  // 内部调用有效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.c</span><br><span class="line">extern int add(int a, int b);   // 错误：无法访问math.c的static函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    add(1, 2);        // 编译报错：undefined reference to `add`</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、C-中-static-的扩展用法"><a href="#二、C-中-static-的扩展用法" class="headerlink" title="二、C++ 中 static 的扩展用法"></a>二、C++ 中 static 的扩展用法</h3><p>C++ 继承了 C 中 static 的所有用法，并新增了 “类静态成员” 和 “静态成员函数” 的特性，用于实现类级别的共享数据和操作。</p>
<h4 id="1-类静态成员变量"><a href="#1-类静态成员变量" class="headerlink" title="1. 类静态成员变量"></a>1. 类静态成员变量</h4><p>静态成员变量属于整个类而非某个对象，所有对象共享同一内存空间，需在类外单独初始化（通常在.cpp 文件中）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">private:</span><br><span class="line">    static int total_count;  // 声明静态成员变量：总学生数</span><br><span class="line">    string name;</span><br><span class="line">public:</span><br><span class="line">    Student(string n) : name(n) &#123;</span><br><span class="line">        total_count++;  // 每创建一个对象，总数+1</span><br><span class="line">    &#125;</span><br><span class="line">    static int getTotal() &#123;  // 静态成员函数访问静态变量</span><br><span class="line">        return total_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 静态成员变量必须在类外初始化，不加static关键字</span><br><span class="line">int Student::total_count = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Student s1(&quot;Alice&quot;);</span><br><span class="line">    Student s2(&quot;Bob&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;总人数：&quot; &lt;&lt; Student::getTotal() &lt;&lt; endl;  // 输出：2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特性</strong>：</p>
<ul>
<li><p>静态成员变量可被声明为public、private或protected，遵循类的访问控制规则；</p>
</li>
<li><p>可通过 “类名：：变量名”（如Student::total_count）或 “对象。变量名” 访问，但推荐前者更清晰。</p>
</li>
</ul>
<h4 id="2-类静态成员函数"><a href="#2-类静态成员函数" class="headerlink" title="2. 类静态成员函数"></a>2. 类静态成员函数</h4><p>静态成员函数属于类本身，不依赖于对象实例，因此：</p>
<ul>
<li><p>不能访问非静态成员变量 &#x2F; 函数（无this指针）；</p>
</li>
<li><p>可直接通过 “类名：：函数名” 调用，无需创建对象；</p>
</li>
<li><p>不能被声明为virtual（虚函数依赖this指针实现多态）。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Utility &#123;</span><br><span class="line">public:</span><br><span class="line">    static int max(int a, int b) &#123;  // 静态成员函数：工具类常用</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 无需创建Utility对象，直接调用静态函数</span><br><span class="line">    cout &lt;&lt; Utility::max(3, 5) &lt;&lt; endl;  // 输出：5</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-静态成员在模板类中的特殊处理"><a href="#3-静态成员在模板类中的特殊处理" class="headerlink" title="3. 静态成员在模板类中的特殊处理"></a>3. 静态成员在模板类中的特殊处理</h4><p>模板类的静态成员变量在不同模板实例化中是独立的，即Template<int>和Template<double>的静态成员属于不同类型，各自拥有独立内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Template &#123;</span><br><span class="line">public:</span><br><span class="line">    static int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 模板静态成员的初始化</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int Template&lt;T&gt;::count = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Template&lt;int&gt;::count++;</span><br><span class="line">    Template&lt;double&gt;::count++;</span><br><span class="line">    cout &lt;&lt; Template&lt;int&gt;::count;    // 输出：1</span><br><span class="line">    cout &lt;&lt; Template&lt;double&gt;::count; // 输出：1（与int实例独立）</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、C-和-C-中-static-的共性与差异"><a href="#三、C-和-C-中-static-的共性与差异" class="headerlink" title="三、C 和 C++ 中 static 的共性与差异"></a>三、C 和 C++ 中 static 的共性与差异</h3><table>
<thead>
<tr>
<th>用法场景</th>
<th>C 语言</th>
<th>C++ 语言</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量</td>
<td>延长生命周期，编译期常量初始化</td>
<td>同 C，允许部分动态初始化（如static int a &#x3D; func();）</td>
</tr>
<tr>
<td>全局变量</td>
<td>限制作用域为当前文件</td>
<td>同 C</td>
</tr>
<tr>
<td>函数</td>
<td>限制作用域为当前文件</td>
<td>同 C</td>
</tr>
<tr>
<td>类成员</td>
<td>不支持（无类概念）</td>
<td>支持静态成员变量和函数，实现类级共享</td>
</tr>
<tr>
<td>链接性</td>
<td>控制外部 &#x2F; 内部链接性</td>
<td>同 C，新增类内静态成员的类内链接性</td>
</tr>
</tbody></table>
<h3 id="四、static-关键字的常见使用场景与最佳实践"><a href="#四、static-关键字的常见使用场景与最佳实践" class="headerlink" title="四、static 关键字的常见使用场景与最佳实践"></a>四、static 关键字的常见使用场景与最佳实践</h3><ol>
<li><strong>单例模式</strong>：通过静态成员变量存储唯一实例，确保全局只有一个对象。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private:</span><br><span class="line">    static Singleton* instance;  // 静态指针存储实例</span><br><span class="line">    Singleton() &#123;&#125;  // 私有构造函数，防止外部创建</span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance() &#123;</span><br><span class="line">        if (instance == nullptr) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = nullptr;  // 初始化</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>工具类</strong>：将无状态的工具函数（如数学计算、字符串处理）声明为静态成员函数，避免创建无用对象。</p>
</li>
<li><p><strong>计数器</strong>：用静态成员变量统计类的实例数量（如学生总数、连接数）。</p>
</li>
<li><p><strong>避免头文件重复定义</strong>：在头文件中定义 static 函数或变量时，每个包含该头文件的.cpp 文件会生成独立副本，避免链接冲突（但可能增加代码体积，谨慎使用）。</p>
</li>
</ol>
<h3 id="五、注意事项与常见误区"><a href="#五、注意事项与常见误区" class="headerlink" title="五、注意事项与常见误区"></a>五、注意事项与常见误区</h3><ul>
<li><p><strong>内存泄漏风险</strong>：静态局部变量和全局静态变量在程序退出时才销毁，若指向动态分配内存（如static int* p &#x3D; new int;），需确保程序退出前释放，否则会导致内存泄漏。</p>
</li>
<li><p><strong>线程安全问题</strong>：多线程环境下，静态变量的初始化和修改可能存在竞争条件，需通过互斥锁保护（C++11 后静态局部变量初始化是线程安全的）。</p>
</li>
<li><p><strong>命名空间替代</strong>：C++ 中，可通过命名空间（namespace）替代部分 static 全局变量 &#x2F; 函数的功能，使代码结构更清晰（如namespace MyUtils { int func(); }）。</p>
</li>
</ul>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>static 关键字在 C 和 C++ 中虽用法多样，但核心逻辑始终围绕 “作用域控制” 和 “生命周期管理”：在 C 中主要用于限制变量 &#x2F; 函数的可见性和延长局部变量生命周期；在 C++ 中进一步扩展到类，实现类级别的数据共享和操作。掌握 static 的关键在于理解 “链接性”（external&#x2F;internal）和 “存储期”（static&#x2F;auto）的概念，结合具体场景选择合适的用法，既能避免命名冲突，又能提升代码的封装性和效率。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>如何防止头文件被重复引用</title>
    <url>/2025/11/13/C_C++/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>防止头文件被重复引用（也叫<strong>重复包含</strong>）是 C&#x2F;C++ 编程中的一个基础但关键的问题。如果不处理，会导致<strong>重复定义错误（redefinition error）</strong>，因为同一个结构体、函数声明或宏可能被多次引入。</p>
<p>C&#x2F;C++ 提供了两种主流方法来解决这个问题：</p>
<hr>
<h2 id="✅-方法一：头文件防护（Header-Guards）-——-标准、可移植"><a href="#✅-方法一：头文件防护（Header-Guards）-——-标准、可移植" class="headerlink" title="✅ 方法一：头文件防护（Header Guards） —— 标准、可移植"></a>✅ 方法一：<strong>头文件防护（Header Guards）</strong> —— 标准、可移植</h2><p>这是 ANSI C&#x2F;C++ 标准支持的方式，适用于所有编译器。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>利用 <code>#ifndef</code> &#x2F; <code>#define</code> &#x2F; <code>#endif</code> 保证头文件内容<strong>只被编译一次</strong>。</p>
<h3 id="示例：myheader-h"><a href="#示例：myheader-h" class="headerlink" title="示例：myheader.h"></a>示例：<code>myheader.h</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H      <span class="comment">// 如果 MYHEADER_H 没有被定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H      <span class="comment">// 就定义它，并继续编译下面的内容</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的实际内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYHEADER_H</span></span></span><br></pre></td></tr></table></figure>

<h3 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h3><ul>
<li>第一次包含 <code>myheader.h</code> 时，<code>MYHEADER_H</code> 未定义 → 进入 <code>#ifndef</code> 块，定义宏并处理内容。</li>
<li>第二次再包含时，<code>MYHEADER_H</code> 已定义 → 跳过整个 <code>#ifndef ... #endif</code> 块 → 内容不会重复处理。</li>
</ul>
<h3 id="命名规范建议："><a href="#命名规范建议：" class="headerlink" title="命名规范建议："></a>命名规范建议：</h3><p>宏名通常用 <strong>全大写 + 文件名 + <code>_H</code> 或 <code>_INCLUDED</code></strong>，避免冲突：</p>
<ul>
<li><code>MYUTILS_H</code></li>
<li><code>VECTOR_INCLUDED</code></li>
<li><code>PROJECT_CONFIG_H</code></li>
</ul>
<blockquote>
<p>⚠️ 注意：宏名必须<strong>全局唯一</strong>！如果两个头文件用了相同的防护宏名，会导致其中一个被意外跳过。</p>
</blockquote>
<hr>
<h2 id="✅-方法二：-pragma-once-——-简洁、现代（非标准但广泛支持）"><a href="#✅-方法二：-pragma-once-——-简洁、现代（非标准但广泛支持）" class="headerlink" title="✅ 方法二：#pragma once —— 简洁、现代（非标准但广泛支持）"></a>✅ 方法二：<code>#pragma once</code> —— 简洁、现代（非标准但广泛支持）</h2><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_var;</span><br></pre></td></tr></table></figure>

<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>代码简洁，无需手动命名宏。</li>
<li>不会因宏名冲突出错。</li>
<li>编译器通常能更高效地处理（基于文件路径判断）。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>不是 C&#x2F;C++ 国际标准的一部分</strong>（属于编译器扩展）。</li>
<li>极少数老旧或特殊平台的编译器可能不支持（如某些嵌入式工具链）。</li>
</ul>
<h3 id="支持情况（主流编译器都支持）："><a href="#支持情况（主流编译器都支持）：" class="headerlink" title="支持情况（主流编译器都支持）："></a>支持情况（主流编译器都支持）：</h3><table>
<thead>
<tr>
<th>编译器</th>
<th>支持 <code>#pragma once</code></th>
</tr>
</thead>
<tbody><tr>
<td>GCC</td>
<td>✅ 是（从很早版本起）</td>
</tr>
<tr>
<td>Clang</td>
<td>✅ 是</td>
</tr>
<tr>
<td>MSVC (Visual Studio)</td>
<td>✅ 是</td>
</tr>
<tr>
<td>Intel ICC</td>
<td>✅ 是</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>结论</strong>：在绝大多数现代项目中，<code>#pragma once</code> 是安全且推荐的选择。</p>
</blockquote>
<hr>
<h2 id="🔁-两种方式对比"><a href="#🔁-两种方式对比" class="headerlink" title="🔁 两种方式对比"></a>🔁 两种方式对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Header Guards (<code>#ifndef</code>)</th>
<th><code>#pragma once</code></th>
</tr>
</thead>
<tbody><tr>
<td>标准兼容性</td>
<td>✅ 完全符合 ANSI C&#x2F;C++</td>
<td>❌ 非标准（但广泛支持）</td>
</tr>
<tr>
<td>可移植性</td>
<td>✅ 极高</td>
<td>⚠️ 绝大多数平台支持</td>
</tr>
<tr>
<td>代码简洁性</td>
<td>❌ 需要三行+唯一宏名</td>
<td>✅ 一行搞定</td>
</tr>
<tr>
<td>宏名冲突风险</td>
<td>⚠️ 有（需小心命名）</td>
<td>✅ 无</td>
</tr>
<tr>
<td>编译速度</td>
<td>⚠️ 稍慢（需处理宏）</td>
<td>✅ 通常更快</td>
</tr>
<tr>
<td>符号链接&#x2F;硬链接问题</td>
<td>✅ 无问题</td>
<td>⚠️ 极少数情况下可能误判（罕见）</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 注：在符号链接（symbolic link）或网络文件系统等复杂场景下，极个别编译器可能误判 <code>#pragma once</code>，但实际开发中几乎遇不到。</p>
</blockquote>
<hr>
<h2 id="🛡️-最佳实践建议"><a href="#🛡️-最佳实践建议" class="headerlink" title="🛡️ 最佳实践建议"></a>🛡️ 最佳实践建议</h2><h3 id="对于新项目（尤其是-C-）："><a href="#对于新项目（尤其是-C-）：" class="headerlink" title="对于新项目（尤其是 C++）："></a>对于新项目（尤其是 C++）：</h3><p>✅ <strong>优先使用 <code>#pragma once</code></strong>，简洁安全。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// your code here</span></span><br></pre></td></tr></table></figure>

<h3 id="对于需要极致可移植性的项目（如嵌入式、跨古老平台）："><a href="#对于需要极致可移植性的项目（如嵌入式、跨古老平台）：" class="headerlink" title="对于需要极致可移植性的项目（如嵌入式、跨古老平台）："></a>对于需要极致可移植性的项目（如嵌入式、跨古老平台）：</h3><p>✅ 使用 <strong>Header Guards</strong>，并遵循命名规范：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYPROJECT_UTILS_MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYPROJECT_UTILS_MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// content</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYPROJECT_UTILS_MATH_H</span></span></span><br></pre></td></tr></table></figure>

<h3 id="不要混用！"><a href="#不要混用！" class="headerlink" title="不要混用！"></a>不要混用！</h3><p>虽然可以同时写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但这<strong>没必要</strong>，反而增加冗余。选一种即可。</p>
<hr>
<h2 id="❌-错误示例：没有防护的头文件"><a href="#❌-错误示例：没有防护的头文件" class="headerlink" title="❌ 错误示例：没有防护的头文件"></a>❌ 错误示例：没有防护的头文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad_header.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若在多个 <code>.c</code> 文件中包含，或在一个 <code>.c</code> 中被间接多次包含，就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: redefinition of &#x27;struct Point&#x27;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>目标</th>
<th>推荐做法</th>
</tr>
</thead>
<tbody><tr>
<td>快速、现代开发</td>
<td><code>#pragma once</code></td>
</tr>
<tr>
<td>最大可移植性（如 POSIX 标准库）</td>
<td>Header Guards</td>
</tr>
<tr>
<td>避免重复定义错误</td>
<td><strong>必须使用其中一种！</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>🎯 <strong>记住：每一个 <code>.h</code> 头文件都应该有防重复包含机制！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>定文件防护</tag>
      </tags>
  </entry>
  <entry>
    <title>指针与引用的异同：深入理解 C++ 中的两种间接访问方式</title>
    <url>/2025/08/09/C_C++/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>在 C++ 编程中，指针（Pointer）和引用（Reference）是实现间接访问变量的两种核心机制，它们在函数参数传递、数据结构设计等场景中被广泛使用。尽管两者都能实现对其他变量的间接操作，但在语法规则、内存特性和使用限制上存在显著差异。本文将从基础定义到实际应用，全面对比指针与引用的异同，帮助你在开发中做出正确选择。</p>
<h3 id="一、基础定义与语法形式"><a href="#一、基础定义与语法形式" class="headerlink" title="一、基础定义与语法形式"></a>一、基础定义与语法形式</h3><p>理解指针和引用的本质，首先需要明确它们的定义和基本语法：</p>
<h4 id="1-指针（Pointer）"><a href="#1-指针（Pointer）" class="headerlink" title="1. 指针（Pointer）"></a>1. 指针（Pointer）</h4><p>指针是一个<strong>变量</strong>，它存储的是另一个变量的内存地址。通过指针可以间接访问该地址对应的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int* ptr = &amp;a;  // 指针ptr存储变量a的地址（&amp;是取地址符）</span><br><span class="line">*ptr = 20;      // 通过解引用运算符*访问指针指向的变量，此时a的值变为20</span><br></pre></td></tr></table></figure>

<ul>
<li><p>声明语法：数据类型* 指针名（*表示该变量是指针）</p>
</li>
<li><p>访问目标变量：使用解引用运算符*（如*ptr）</p>
</li>
<li><p>获取变量地址：使用取地址运算符&amp;（如&amp;a）</p>
</li>
</ul>
<h4 id="2-引用（Reference）"><a href="#2-引用（Reference）" class="headerlink" title="2. 引用（Reference）"></a>2. 引用（Reference）</h4><p>引用是一个<strong>变量的别名</strong>，它与被引用的变量共享同一块内存空间，对引用的操作等价于对原变量的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int b = 20;</span><br><span class="line">int&amp; ref = b;  // ref是变量b的引用（别名）</span><br><span class="line">ref = 30;      // 对引用的修改会直接影响原变量，此时b的值变为30</span><br></pre></td></tr></table></figure>

<ul>
<li><p>声明语法：数据类型&amp; 引用名（&amp;表示该变量是引用）</p>
</li>
<li><p>引用必须在声明时初始化，且一旦初始化后不能再指向其他变量</p>
</li>
<li><p>访问目标变量：直接使用引用名（如ref等价于b）</p>
</li>
</ul>
<h3 id="二、核心相同点"><a href="#二、核心相同点" class="headerlink" title="二、核心相同点"></a>二、核心相同点</h3><p>指针和引用作为间接访问工具，存在以下共同特性：</p>
<ol>
<li><strong>间接访问变量</strong>：两者都能通过自身操作来访问或修改另一个变量的值，避免直接传递大型对象时的内存开销。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void increment(int* p) &#123; *p += 1; &#125;  // 指针版本</span><br><span class="line">void increment(int&amp; r) &#123; r += 1; &#125;   // 引用版本</span><br><span class="line"></span><br><span class="line">int x = 5;</span><br><span class="line">increment(&amp;x);  // 传递x的地址</span><br><span class="line">increment(x);   // 传递x的引用（语法上与传值相同）</span><br><span class="line">// 两种方式都能使x的值变为6</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>用于函数参数传递</strong>：都可用于实现 “传址调用”，让函数能够修改实参的值，而不是操作副本。</p>
</li>
<li><p><strong>支持链式操作</strong>：都可以用于构建复杂的数据结构（如链表、树），通过指针或引用链接节点。</p>
</li>
</ol>
<h3 id="三、关键不同点"><a href="#三、关键不同点" class="headerlink" title="三、关键不同点"></a>三、关键不同点</h3><p>指针和引用的差异体现在语法规则、内存特性和使用限制等多个方面，这些差异直接影响它们的适用场景：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>变量（存储地址）</td>
<td>别名（非独立变量）</td>
</tr>
<tr>
<td>初始化</td>
<td>可以不初始化（但不推荐，此时为野指针）</td>
<td>必须在声明时初始化，且必须指向一个已存在的变量</td>
</tr>
<tr>
<td>指向变更</td>
<td>可以重新指向其他变量</td>
<td>一旦初始化，不能再指向其他变量</td>
</tr>
<tr>
<td>空值</td>
<td>可以为nullptr（表示不指向任何变量）</td>
<td>不能为 null，必须始终指向一个有效变量</td>
</tr>
<tr>
<td>解引用</td>
<td>需要使用*运算符</td>
<td>无需解引用，直接使用引用名</td>
</tr>
<tr>
<td>内存占用</td>
<td>占用内存（通常与机器字长相同，如 64 位系统占 8 字节）</td>
<td>不占用额外内存（编译器可能优化为指针实现，但语法上无内存开销）</td>
</tr>
<tr>
<td>多级形式</td>
<td>支持多级指针（如int**表示指向指针的指针）</td>
<td>不支持多级引用（int&amp;&amp;在 C++11 中是右值引用，并非二级引用）</td>
</tr>
<tr>
<td>算术运算</td>
<td>支持指针算术（如ptr++移动到下一个元素）</td>
<td>不支持算术运算（编译报错）</td>
</tr>
</tbody></table>
<h4 id="1-初始化与指向变更"><a href="#1-初始化与指向变更" class="headerlink" title="1. 初始化与指向变更"></a>1. 初始化与指向变更</h4><ul>
<li>指针的灵活性：可以随时改变指向的目标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int c = 100, d = 200;</span><br><span class="line">int* p = &amp;c;</span><br><span class="line">p = &amp;d;  // 指针p可以重新指向d，合法</span><br></pre></td></tr></table></figure>

<ul>
<li>引用的不可变性：一旦绑定变量，无法更改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int e = 100, f = 200;</span><br><span class="line">int&amp; r = e;</span><br><span class="line">// r = f;  // 这是将f的值赋给e，而非改变引用指向，r仍绑定e</span><br><span class="line">// int&amp; r = f;  // 编译错误：引用已初始化，不能重新定义</span><br></pre></td></tr></table></figure>

<h4 id="2-空值与有效性"><a href="#2-空值与有效性" class="headerlink" title="2. 空值与有效性"></a>2. 空值与有效性</h4><ul>
<li>指针可以为nullptr，常用于表示 “无指向” 状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p = nullptr;  // 空指针，不指向任何变量</span><br><span class="line">if (p != nullptr) &#123;  // 需判断指针是否有效，避免解引用空指针（程序崩溃）</span><br><span class="line">    *p = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用必须始终指向有效变量，不存在 “空引用”</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// int&amp; r = nullptr;  // 编译错误：引用不能绑定空值</span><br><span class="line">int g;</span><br><span class="line">int&amp; r = g;  // 合法：g是已声明的变量（即使未初始化，但其内存地址有效）</span><br></pre></td></tr></table></figure>

<h4 id="3-内存占用与访问方式"><a href="#3-内存占用与访问方式" class="headerlink" title="3. 内存占用与访问方式"></a>3. 内存占用与访问方式</h4><ul>
<li>指针本身是变量，占用内存空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int h = 5;</span><br><span class="line">int* p = &amp;h;</span><br><span class="line">cout &lt;&lt; sizeof(p);  // 输出8（64位系统）或4（32位系统）</span><br></pre></td></tr></table></figure>

<ul>
<li>引用不占用额外内存，访问时无需解引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 5;</span><br><span class="line">int&amp; r = i;</span><br><span class="line">cout &lt;&lt; sizeof(r);  // 输出4（与int类型大小相同，实际是i的大小）</span><br></pre></td></tr></table></figure>

<h3 id="四、使用场景对比"><a href="#四、使用场景对比" class="headerlink" title="四、使用场景对比"></a>四、使用场景对比</h3><p>根据两者的特性差异，它们的适用场景也有所不同：</p>
<h4 id="1-优先使用指针的场景"><a href="#1-优先使用指针的场景" class="headerlink" title="1. 优先使用指针的场景"></a>1. 优先使用指针的场景</h4><ul>
<li><p><strong>需要动态改变指向</strong>：如链表节点的遍历（指针不断指向 next 节点）</p>
</li>
<li><p><strong>表示 “无对象” 状态</strong>：如函数返回nullptr表示操作失败</p>
</li>
<li><p><strong>多级间接访问</strong>：如二维数组访问（int**）或指针数组</p>
</li>
<li><p><strong>C 语言兼容</strong>：在混合 C&#x2F;C++ 编程时，需使用指针（C 语言无引用）</p>
</li>
</ul>
<p>示例：链表节点定义（必须使用指针）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    Node* next;  // 指针指向后续节点，可动态改变</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-优先使用引用的场景"><a href="#2-优先使用引用的场景" class="headerlink" title="2. 优先使用引用的场景"></a>2. 优先使用引用的场景</h4><ul>
<li><strong>函数参数传递</strong>：避免指针的解引用操作，语法更简洁，且保证参数有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引用版本：语法清晰，无需检查有效性</span><br><span class="line">void print(const string&amp; s) &#123;  // const引用避免意外修改，同时支持临时对象</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指针版本：需显式传递地址，且需判断非空</span><br><span class="line">void print(const string* s) &#123;</span><br><span class="line">    if (s != nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; *s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数返回值</strong>：返回函数内部静态变量或类成员的别名（避免返回局部变量的引用，会导致未定义行为）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">public:</span><br><span class="line">    int&amp; getValue() &#123; return value; &#125;  // 返回成员变量的引用，可直接修改</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运算符重载</strong>：如++、+&#x3D;等运算符，使用引用可实现连续操作（如a &#x3D; b &#x3D; c）</li>
</ul>
<h3 id="五、常见误区与注意事项"><a href="#五、常见误区与注意事项" class="headerlink" title="五、常见误区与注意事项"></a>五、常见误区与注意事项</h3><ol>
<li><p><strong>引用不是指针的语法糖</strong>：尽管编译器可能通过指针实现引用，但两者的语义不同（引用无内存开销、不可为空等），不能混为一谈。</p>
</li>
<li><p><strong>避免返回局部变量的引用</strong>：局部变量在函数结束后被销毁，其引用会指向无效内存，导致未定义行为。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp; badRef() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    return x;  // 错误：返回局部变量的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>指针需注意空值检查</strong>：解引用空指针或野指针会导致程序崩溃，使用前必须确保指针有效。</p>
</li>
<li><p><strong>const 修饰的差异</strong>：</p>
</li>
</ol>
<ul>
<li><ul>
<li>const int* p：指针指向的变量不可修改，但指针可重新指向</li>
</ul>
</li>
<li><ul>
<li>int* const p：指针本身不可修改，但指向的变量可修改</li>
</ul>
</li>
<li><ul>
<li>const int&amp; r：引用的变量不可修改（常引用），常用于函数参数避免拷贝</li>
</ul>
</li>
</ul>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>指针和引用是 C++ 中实现间接访问的两种重要机制，它们既有共性（如间接操作变量），又有显著差异：</p>
<ul>
<li><p><strong>指针</strong>是存储地址的变量，支持动态指向、空值和算术运算，灵活性高但需手动管理有效性，适合需要动态调整指向或表示 “无对象” 的场景。</p>
</li>
<li><p><strong>引用</strong>是变量的别名，必须初始化且不可变更指向，语法简洁且无额外内存开销，适合作为函数参数或返回值，确保操作的安全性和可读性。</p>
</li>
</ul>
<p>理解两者的异同是编写高效、安全 C++ 代码的基础。在实际开发中，应根据具体场景选择合适的工具：追求灵活性和动态性时用指针，追求简洁性和安全性时用引用。同时，需严格遵循两者的使用规范，避免因误用导致内存错误或逻辑漏洞。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言变量所占字节数</title>
    <url>/2025/07/29/C_C++/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="C语言变量所占字节数："><a href="#C语言变量所占字节数：" class="headerlink" title="C语言变量所占字节数："></a>C语言变量所占字节数：</h2><p>变量的基本类型包括：字符型、整型、长整型、浮点型。<br>每个变量在每个编译器所占的字节数不同，《the C Programming language》是这样说的：</p>
<p>Each compiler is free to choose appropriate sizes for its own hardware, subject only to the restriction that ints are at least 16bits,longs are at least 32bits, and short is no longer than int, which is no longer than long .</p>
<p>也就意味着编译器可以根据自身的硬件选择合适的大小，约束条件是：short和int至少为16位；并且short的长度不得大于int ; int的长度不得大于long.</p>
<p>总结即为：<br>1、sizeof(short int) &lt;&#x3D; sizeof(int)<br>2、sizeof(int) &lt;&#x3D; sizeof(long int)<br>3、short int至少应为16位（2字节）<br>4、long int至少应为32位。<br>unsigned 为无符号。<br>注意：指针类型存储的是**所指向变量的地址，32位的编译器需要32bit（即4个字节）,64位的机器需要需要64bit（即8个字节）.<br>当下主流的编译器是32位和64位。下面列举32位和64位编译器各个类型变量所占的字节数：<br>char存储大小1字节，值范围-128<del>127；<br>unsigned char存储大小1字节，值范围0</del>255；<br>short存储大小2字节，值范围-32768<del>32767；<br>unsigned short存储大小2字节，值范围0</del>65535；</p>
<table>
<thead>
<tr>
<th>C类型所占字节数</th>
<th>32位编译器（X86）</th>
<th>64位编译器</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short int</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>char*</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>long int</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>long long int</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<p>sizeof(type)可以得到对象或类型的存储字节大小。<br>例子：32位的编译器下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sizeof(int) = 4 ；</span><br><span class="line">sizeof(char) = 1 ;</span><br><span class="line">sizeof(*char)= 4 ; </span><br><span class="line">sizeof(long int ) = 4 ;</span><br><span class="line"></span><br><span class="line">Void main</span><br><span class="line">&#123;</span><br><span class="line">   double i;</span><br><span class="line">   int  j;</span><br><span class="line">   char n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数的sizeof&#x3D; 16 ;对齐原则，double是8个字节，int是4个字节，char是一个字节，补3个对齐；所以一共16个字节。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>字节数</tag>
      </tags>
  </entry>
  <entry>
    <title>空指针和野指针</title>
    <url>/2025/11/13/C_C++/%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>空指针（Null Pointer）</strong> 和 <strong>野指针（Wild Pointer &#x2F; Dangling Pointer）</strong> 是 C&#x2F;C++ 中非常常见且容易引发程序崩溃或未定义行为的两类指针问题。下面我们将从定义、成因、危害、示例、检测和防范等方面进行详细讲解。</p>
<hr>
<h2 id="一、空指针（Null-Pointer）"><a href="#一、空指针（Null-Pointer）" class="headerlink" title="一、空指针（Null Pointer）"></a>一、空指针（Null Pointer）</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>空指针</strong>是一个<strong>明确不指向任何有效内存地址</strong>的指针，其值为 <code>NULL</code>（C）或 <code>nullptr</code>（C++11 起）。</p>
<ul>
<li>在 C 中：<code>NULL</code> 通常被定义为 <code>(void*)0</code> 或 <code>0</code></li>
<li>在 C++ 中：推荐使用 <code>nullptr</code>（类型安全）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;      <span class="comment">// C 风格</span></span><br><span class="line"><span class="type">int</span> *q = nullptr;   <span class="comment">// C++11 风格（更安全）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h3><ul>
<li>空指针是<strong>合法的指针值</strong>。</li>
<li>解引用空指针（如 <code>*p</code>）会导致<strong>未定义行为（Undefined Behavior）</strong>，通常表现为程序崩溃（如段错误 Segmentation Fault）。</li>
<li>可用于表示“无对象”、“初始化未完成”、“函数返回失败”等语义。</li>
</ul>
<h3 id="3-示例：安全使用空指针"><a href="#3-示例：安全使用空指针" class="headerlink" title="3. 示例：安全使用空指针"></a>3. 示例：安全使用空指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *p = <span class="number">10</span>;  <span class="comment">// 不会执行，安全</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pointer is null!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-常见用途"><a href="#4-常见用途" class="headerlink" title="4. 常见用途"></a>4. 常见用途</h3><ul>
<li><p>函数返回失败时返回 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NULL</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;not_exist.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;File open failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化指针变量（避免成为野指针）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 明确表示“尚未指向任何东西”</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="✅-正确做法："><a href="#✅-正确做法：" class="headerlink" title="✅ 正确做法："></a>✅ 正确做法：</h3><blockquote>
<p><strong>所有指针在声明后若未立即赋值，应初始化为 <code>NULL</code>&#x2F;<code>nullptr</code>。</strong></p>
</blockquote>
<hr>
<h2 id="二、野指针（Wild-Pointer-Dangling-Pointer）"><a href="#二、野指针（Wild-Pointer-Dangling-Pointer）" class="headerlink" title="二、野指针（Wild Pointer &#x2F; Dangling Pointer）"></a>二、野指针（Wild Pointer &#x2F; Dangling Pointer）</h2><p>“野指针”其实包含两类常见情况：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>未初始化指针（Wild Pointer）</strong></td>
<td>声明后未赋值，值是随机垃圾地址</td>
</tr>
<tr>
<td>2</td>
<td><strong>悬空指针（Dangling Pointer）</strong></td>
<td>曾指向有效内存，但该内存已被释放</td>
</tr>
</tbody></table>
<p>我们分别讲解。</p>
<hr>
<h3 id="▶-类型-1：未初始化的野指针（Wild-Pointer）"><a href="#▶-类型-1：未初始化的野指针（Wild-Pointer）" class="headerlink" title="▶ 类型 1：未初始化的野指针（Wild Pointer）"></a>▶ 类型 1：未初始化的野指针（Wild Pointer）</h3><h4 id="成因："><a href="#成因：" class="headerlink" title="成因："></a>成因：</h4><p>指针变量声明后<strong>没有初始化</strong>，其值是栈上残留的随机值（垃圾地址）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;  <span class="comment">// 危险！p 的值是未知的（比如 0x12345678）</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 尝试写入随机地址 → 极可能崩溃或破坏内存</span></span><br></pre></td></tr></table></figure>

<h4 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h4><ul>
<li>写入非法内存 → 段错误（Segmentation Fault）</li>
<li>写入合法但不属于你的内存 → 数据被悄悄破坏（更难调试！）</li>
</ul>
<h4 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h4><p>✅ <strong>始终初始化指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">// 安全</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="▶-类型-2：悬空指针（Dangling-Pointer）"><a href="#▶-类型-2：悬空指针（Dangling-Pointer）" class="headerlink" title="▶ 类型 2：悬空指针（Dangling Pointer）"></a>▶ 类型 2：悬空指针（Dangling Pointer）</h3><h4 id="成因：-1"><a href="#成因：-1" class="headerlink" title="成因："></a>成因：</h4><p>指针曾指向一块有效内存（如堆内存），但该内存<strong>已被释放（free&#x2F;delete）</strong>，而指针<strong>未置空</strong>，仍保留旧地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">free</span>(p);        <span class="comment">// 内存已释放</span></span><br><span class="line"><span class="comment">// p 仍然指向原来的地址（但现在是无效的！）</span></span><br><span class="line">*p = <span class="number">100</span>;       <span class="comment">// ❌ 危险！写入已释放的内存 → 未定义行为</span></span><br></pre></td></tr></table></figure>

<h4 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a>典型场景：</h4><ol>
<li><p><code>malloc</code>&#x2F;<code>free</code> 或 <code>new</code>&#x2F;<code>delete</code> 后未置空</p>
</li>
<li><p>返回局部变量的地址（函数返回后栈帧销毁）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getPtr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;  <span class="comment">// ❌ 返回局部变量地址 → 悬空指针！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="危害：-1"><a href="#危害：-1" class="headerlink" title="危害："></a>危害：</h4><ul>
<li>表面可能“正常运行”（因为内存尚未被覆盖），但结果不可靠。</li>
<li>后续该内存被分配给其他对象，导致<strong>数据被意外修改</strong>。</li>
<li>多线程环境下极易引发难以复现的 bug。</li>
</ul>
<h4 id="防范：-1"><a href="#防范：-1" class="headerlink" title="防范："></a>防范：</h4><p>✅ <strong>释放内存后立即将指针置为 <code>NULL</code></strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;  <span class="comment">// 关键一步！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续即使误用，也能通过 if (p) 检查</span></span><br></pre></td></tr></table></figure>

<p>✅ <strong>不要返回局部变量的地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确做法：返回值 or 动态分配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;          <span class="comment">// 返回值</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getPtr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> p;  <span class="comment">// 调用者负责 free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、空指针-vs-野指针-对比表"><a href="#三、空指针-vs-野指针-对比表" class="headerlink" title="三、空指针 vs 野指针 对比表"></a>三、空指针 vs 野指针 对比表</h2><table>
<thead>
<tr>
<th>特性</th>
<th>空指针（Null Pointer）</th>
<th>野指针（Wild&#x2F;Dangling Pointer）</th>
</tr>
</thead>
<tbody><tr>
<td>是否有明确值</td>
<td>✅ 有（<code>NULL</code>&#x2F;<code>nullptr</code>）</td>
<td>❌ 无（随机值 或 已失效地址）</td>
</tr>
<tr>
<td>是否合法</td>
<td>✅ 合法（可比较、可判断）</td>
<td>❌ 非法（使用即危险）</td>
</tr>
<tr>
<td>解引用后果</td>
<td>通常立即崩溃（易发现）</td>
<td>可能延迟崩溃或静默破坏（难调试）</td>
</tr>
<tr>
<td>初始化建议</td>
<td>声明时赋 <code>NULL</code></td>
<td>声明时赋 <code>NULL</code>；释放后置 <code>NULL</code></td>
</tr>
<tr>
<td>检测难度</td>
<td>容易（加 if 判断即可）</td>
<td>困难（需工具辅助）</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、如何检测和调试？"><a href="#四、如何检测和调试？" class="headerlink" title="四、如何检测和调试？"></a>四、如何检测和调试？</h2><h3 id="1-静态分析工具"><a href="#1-静态分析工具" class="headerlink" title="1. 静态分析工具"></a>1. 静态分析工具</h3><ul>
<li><code>clang-static-analyzer</code></li>
<li><code>PC-lint</code>, <code>Coverity</code></li>
</ul>
<h3 id="2-动态检测工具"><a href="#2-动态检测工具" class="headerlink" title="2. 动态检测工具"></a>2. 动态检测工具</h3><ul>
<li><p><strong>Valgrind</strong>（Linux&#x2F;macOS）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck ./your_program</span><br></pre></td></tr></table></figure>

<p>能检测：使用未初始化内存、访问已释放内存、内存泄漏等。</p>
</li>
<li><p><strong>AddressSanitizer (ASan)</strong>（GCC&#x2F;Clang）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -g program.c -o program</span><br><span class="line">./program</span><br></pre></td></tr></table></figure>

<p>能实时捕获野指针访问、缓冲区溢出等。</p>
</li>
</ul>
<h3 id="3-编码习惯"><a href="#3-编码习惯" class="headerlink" title="3. 编码习惯"></a>3. 编码习惯</h3><ul>
<li>所有指针初始化为 <code>NULL</code></li>
<li><code>free</code>&#x2F;<code>delete</code> 后立即置 <code>NULL</code></li>
<li>使用前检查是否为 <code>NULL</code></li>
<li>避免返回局部变量地址</li>
<li>尽量使用智能指针（C++）：<code>std::unique_ptr</code>, <code>std::shared_ptr</code></li>
</ul>
<hr>
<h2 id="五、C-中的现代解决方案（推荐）"><a href="#五、C-中的现代解决方案（推荐）" class="headerlink" title="五、C++ 中的现代解决方案（推荐）"></a>五、C++ 中的现代解决方案（推荐）</h2><p>在 C++ 中，应尽量避免裸指针，改用<strong>RAII</strong> 和 <strong>智能指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 自动管理内存，无需手动 delete</span></span><br><span class="line"><span class="comment">// 作用域结束自动释放，不会产生悬空指针</span></span><br></pre></td></tr></table></figure>

<p>智能指针从根本上减少了野指针和内存泄漏的风险。</p>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><table>
<thead>
<tr>
<th>问题</th>
<th>根本原因</th>
<th>防范措施</th>
</tr>
</thead>
<tbody><tr>
<td><strong>空指针</strong></td>
<td>未检查就解引用</td>
<td>使用前 <code>if (ptr != nullptr)</code></td>
</tr>
<tr>
<td><strong>未初始化野指针</strong></td>
<td>声明后未赋值</td>
<td>声明时初始化为 <code>nullptr</code></td>
</tr>
<tr>
<td><strong>悬空指针</strong></td>
<td>释放后未置空 &#x2F; 返回局部地址</td>
<td><code>free/delete</code> 后置 <code>nullptr</code>；不返回栈变量地址</td>
</tr>
</tbody></table>
<blockquote>
<p>🛑 <strong>黄金法则</strong>：<br><strong>“指针要么指向有效对象，要么是空（null）。”</strong><br>除此之外的状态都是危险的！</p>
</blockquote>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言入门：从寄存器到指令，手把手教你写汇编</title>
    <url>/2025/09/01/C_C++/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>提到汇编语言，很多人会觉得 “晦涩难懂”“离日常开发太远”。但实际上，汇编是连接高级语言（C&#x2F;C++&#x2F;Java）与硬件的桥梁 —— 理解汇编，能帮你看清程序的底层执行逻辑，排查性能瓶颈，甚至逆向分析代码。本文以最常用的 x86-64 架构（Linux 系统）为背景，从最基础的 “寄存器” 讲起，通过一个个可运行的实例，带你逐步掌握汇编语言的核心知识。</p>
<h3 id="一、前置知识：汇编语言的-“世界观”"><a href="#一、前置知识：汇编语言的-“世界观”" class="headerlink" title="一、前置知识：汇编语言的 “世界观”"></a>一、前置知识：汇编语言的 “世界观”</h3><p>在学具体指令前，先搞懂汇编的核心概念，避免后续 confusion：</p>
<h4 id="1-什么是汇编语言？"><a href="#1-什么是汇编语言？" class="headerlink" title="1. 什么是汇编语言？"></a>1. 什么是汇编语言？</h4><p>汇编语言是<strong>机器指令的符号化表示</strong>—— 每一条汇编指令对应一条 CPU 可直接执行的机器码（二进制）。例如，add rax, rbx 对应二进制 0x48 0x01 0xd8，作用是 “将 rbx 寄存器的值加到 rax 寄存器”。</p>
<h4 id="2-为什么学-x86-64？"><a href="#2-为什么学-x86-64？" class="headerlink" title="2. 为什么学 x86-64？"></a>2. 为什么学 x86-64？</h4><p>x86-64 是目前 PC、服务器最主流的架构（32 位 x86 的扩展），支持 64 位地址空间，指令集丰富，资料齐全，适合入门。本文所有实例均基于 <strong>Linux 系统的 x86-64 汇编</strong>（AT&amp;T 语法或 Intel 语法，本文以更直观的 Intel 语法为主）。</p>
<h4 id="3-工具准备"><a href="#3-工具准备" class="headerlink" title="3. 工具准备"></a>3. 工具准备</h4><p>需要 3 个工具：</p>
<ul>
<li><p><strong>nasm</strong>：汇编器，将汇编代码（.asm）编译为目标文件（.o）</p>
</li>
<li><p><strong>ld</strong>：链接器，将目标文件链接为可执行文件</p>
</li>
<li><p><strong>gdb</strong>：调试器，查看汇编代码执行过程</p>
</li>
</ul>
<p>安装命令（Linux）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install nasm binutils gdb</span><br></pre></td></tr></table></figure>

<h3 id="二、核心基础：x86-64-的寄存器"><a href="#二、核心基础：x86-64-的寄存器" class="headerlink" title="二、核心基础：x86-64 的寄存器"></a>二、核心基础：x86-64 的寄存器</h3><p>寄存器是 CPU 内部的高速存储单元（比内存快 100 倍以上），汇编语言的操作几乎都围绕寄存器展开。x86-64 有 16 个通用寄存器，每个 64 位，常用的如下：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>用途（Linux 约定）</th>
<th>32 位别名</th>
<th>16 位别名</th>
<th>8 位别名（高 &#x2F; 低）</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>累加器（返回值）</td>
<td>eax</td>
<td>ax</td>
<td>ah（高 8 位）&#x2F;al（低 8 位）</td>
</tr>
<tr>
<td>rbx</td>
<td>基址寄存器（通用）</td>
<td>ebx</td>
<td>bx</td>
<td>bh&#x2F;bl</td>
</tr>
<tr>
<td>rcx</td>
<td>计数器（循环 &#x2F; 函数参数）</td>
<td>ecx</td>
<td>cx</td>
<td>ch&#x2F;cl</td>
</tr>
<tr>
<td>rdx</td>
<td>数据寄存器（函数参数）</td>
<td>edx</td>
<td>dx</td>
<td>dh&#x2F;dl</td>
</tr>
<tr>
<td>rsi</td>
<td>源索引（字符串 &#x2F; 数组）</td>
<td>esi</td>
<td>si</td>
<td>sil</td>
</tr>
<tr>
<td>rdi</td>
<td>目的索引（字符串 &#x2F; 数组）</td>
<td>edi</td>
<td>di</td>
<td>dil</td>
</tr>
<tr>
<td>rbp</td>
<td>栈基址指针（栈帧）</td>
<td>ebp</td>
<td>bp</td>
<td>bpl</td>
</tr>
<tr>
<td>rsp</td>
<td>栈指针（栈顶）</td>
<td>esp</td>
<td>sp</td>
<td>spl</td>
</tr>
<tr>
<td>r8-r15</td>
<td>通用寄存器（64 位新增）</td>
<td>r8d-r15d</td>
<td>r8w-r15w</td>
<td>r8b-r15b</td>
</tr>
</tbody></table>
<p><strong>关键规则</strong>：</p>
<ul>
<li><p>64 位寄存器名以r开头（如 rax），32 位以e开头（如 eax），16 位以x结尾（如 ax），8 位以b结尾（如 al）。</p>
</li>
<li><p>操作 32 位寄存器会自动将 64 位寄存器的高 32 位清零（如修改 eax，rax 的高 32 位变为 0）。</p>
</li>
</ul>
<h3 id="三、第一个汇编程序：Hello-World"><a href="#三、第一个汇编程序：Hello-World" class="headerlink" title="三、第一个汇编程序：Hello World"></a>三、第一个汇编程序：Hello World</h3><p>和所有语言一样，从 “Hello World” 开始，感受汇编的执行流程。</p>
<h4 id="实例-1：打印字符串（系统调用方式）"><a href="#实例-1：打印字符串（系统调用方式）" class="headerlink" title="实例 1：打印字符串（系统调用方式）"></a>实例 1：打印字符串（系统调用方式）</h4><p>x86-64 Linux 中，程序通过 “系统调用” 与内核交互（如打印、退出），需要用到以下寄存器：</p>
<ul>
<li><p>rax：系统调用号（如 1&#x3D;write，60&#x3D;exit）</p>
</li>
<li><p>rdi：第一个参数（如文件描述符，1 &#x3D; 标准输出）</p>
</li>
<li><p>rsi：第二个参数（如字符串地址）</p>
</li>
<li><p>rdx：第三个参数（如字符串长度）</p>
</li>
<li><p>触发系统调用：syscall指令</p>
</li>
</ul>
<p>汇编代码（hello.asm）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data           ; 数据段：存放常量、已初始化数据</span><br><span class="line">    msg db &#x27;Hello, Assembly!&#x27;, 0xA  ; 字符串，0xA是换行符</span><br><span class="line">    len equ $ - msg      ; 计算字符串长度（$表示当前地址，减去msg地址）</span><br><span class="line"></span><br><span class="line">section .text           ; 代码段：存放指令</span><br><span class="line">    global _start        ; 声明入口点（链接器需要）</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 系统调用1：write(1, msg, len)</span><br><span class="line">    mov rax, 1           ; rax=1（write的系统调用号）</span><br><span class="line">    mov rdi, 1           ; rdi=1（标准输出文件描述符）</span><br><span class="line">    mov rsi, msg         ; rsi=msg（字符串地址）</span><br><span class="line">    mov rdx, len         ; rdx=len（字符串长度）</span><br><span class="line">    syscall              ; 触发系统调用</span><br><span class="line"></span><br><span class="line">    ; 系统调用60：exit(0)</span><br><span class="line">    mov rax, 60          ; rax=60（exit的系统调用号）</span><br><span class="line">    mov rdi, 0           ; rdi=0（退出码，0表示正常）</span><br><span class="line">    syscall              ; 触发系统调用</span><br></pre></td></tr></table></figure>

<h4 id="编译与运行："><a href="#编译与运行：" class="headerlink" title="编译与运行："></a>编译与运行：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 汇编：nasm将.asm编译为.o（-f elf64指定64位ELF格式）</span><br><span class="line">nasm -f elf64 hello.asm -o hello.o</span><br><span class="line"></span><br><span class="line"># 2. 链接：ld将.o链接为可执行文件</span><br><span class="line">ld hello.o -o hello</span><br><span class="line"></span><br><span class="line"># 3. 运行</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, Assembly!</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>：</p>
<ul>
<li><p>section .data：数据段存放字符串msg和长度len，db表示 “定义字节”（每个字符占 1 字节）。</p>
</li>
<li><p>section .text：代码段是程序执行的核心，_start是入口点（类似 C 语言的 main）。</p>
</li>
<li><p>mov指令：“移动” 数据（如mov rax, 1是将 1 赋值给 rax）。</p>
</li>
<li><p>syscall：触发内核执行对应的系统调用（write 打印，exit 退出）。</p>
</li>
</ul>
<h3 id="四、核心指令：数据操作与运算"><a href="#四、核心指令：数据操作与运算" class="headerlink" title="四、核心指令：数据操作与运算"></a>四、核心指令：数据操作与运算</h3><p>汇编的核心是 “指令”，掌握以下常用指令，就能完成大部分基础逻辑。</p>
<h4 id="1-数据移动指令：mov"><a href="#1-数据移动指令：mov" class="headerlink" title="1. 数据移动指令：mov"></a>1. 数据移动指令：mov</h4><p>mov 目标, 源：将源操作数的值赋给目标操作数（支持寄存器→寄存器、内存→寄存器、立即数→寄存器）。</p>
<p><strong>实例 2：mov 指令的用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, 100         ; 立即数→寄存器（rax=100）</span><br><span class="line">    mov rbx, rax         ; 寄存器→寄存器（rbx=rax=100）</span><br><span class="line">    mov rcx, [var]       ; 内存→寄存器（需先定义var，见下文）</span><br><span class="line">    mov [var2], rbx      ; 寄存器→内存（将rbx的值存到var2地址）</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    var dq 200           ; dq：定义8字节（64位）数据，var=200</span><br><span class="line">    var2 dq 0            ; var2初始值0</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：内存操作需要用[]包裹地址（如[var]表示 “var 地址处的值”），dq表示 “定义 64 位数据”（对应 x86-64 的 qword）。</p>
<h4 id="2-算术运算指令：add-sub-mul-div"><a href="#2-算术运算指令：add-sub-mul-div" class="headerlink" title="2. 算术运算指令：add&#x2F;sub&#x2F;mul&#x2F;div"></a>2. 算术运算指令：add&#x2F;sub&#x2F;mul&#x2F;div</h4><ul>
<li><p>add 目标, 源：目标 &#x3D; 目标 + 源</p>
</li>
<li><p>sub 目标, 源：目标 &#x3D; 目标 - 源</p>
</li>
<li><p>mul 源：无符号乘法（rax &#x3D; rax * 源，64 位结果存 rax+rdx）</p>
</li>
<li><p>div 源：无符号除法（rax &#x2F; 源，商存 rax，余数存 rdx）</p>
</li>
</ul>
<p><strong>实例 3：计算 10+20-5，结果存入内存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    result dq 0          ; 存放结果的变量</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, 10          ; rax=10</span><br><span class="line">    add rax, 20          ; rax=10+20=30</span><br><span class="line">    sub rax, 5           ; rax=30-5=25</span><br><span class="line">    mov [result], rax    ; 将25存入result</span><br><span class="line"></span><br><span class="line">    ; 退出</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p><strong>验证结果</strong>：用 gdb 调试查看result的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./a.out</span><br><span class="line">(gdb) break _start+20  # 在退出前打断点</span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) x/q &amp;result       # 查看result的64位值（q=quadword）</span><br><span class="line">0x601008 &lt;result&gt;:     25  # 结果正确</span><br></pre></td></tr></table></figure>

<h4 id="3-比较与分支指令：cmp-jmp-jxx"><a href="#3-比较与分支指令：cmp-jmp-jxx" class="headerlink" title="3. 比较与分支指令：cmp&#x2F;jmp&#x2F;jxx"></a>3. 比较与分支指令：cmp&#x2F;jmp&#x2F;jxx</h4><p>汇编没有if-else，但可以通过 “比较 + 条件跳转” 实现分支逻辑：</p>
<ul>
<li><p>cmp a, b：计算 a - b（不修改 a 和 b，只影响标志寄存器）</p>
</li>
<li><p>jmp 标签：无条件跳转到标签处</p>
</li>
<li><p>jxx 标签：条件跳转（xx 是条件，如 je &#x3D; 等于、jne &#x3D; 不等于、jg &#x3D; 大于）</p>
</li>
</ul>
<p>标志寄存器（rflags）是隐藏的寄存器，cmp指令会修改它的位（如零标志位 ZF：a&#x3D;&#x3D;b 时 ZF&#x3D;1，否则 ZF&#x3D;0），jxx指令根据这些位决定是否跳转。</p>
<p><strong>实例 4：判断两个数是否相等（if-else 逻辑）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    num1 dq 30</span><br><span class="line">    num2 dq 30</span><br><span class="line">    msg_eq db &#x27;Equal&#x27;, 0xA</span><br><span class="line">    len_eq equ $ - msg_eq</span><br><span class="line">    msg_ne db &#x27;Not Equal&#x27;, 0xA</span><br><span class="line">    len_ne equ $ - msg_ne</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 比较num1和num2</span><br><span class="line">    mov rax, [num1]</span><br><span class="line">    mov rbx, [num2]</span><br><span class="line">    cmp rax, rbx         ; rax - rbx，设置标志位</span><br><span class="line">    je equal             ; 如果相等（ZF=1），跳转到equal标签</span><br><span class="line"></span><br><span class="line">    ; 不相等的逻辑：打印Not Equal</span><br><span class="line">not_equal:</span><br><span class="line">    mov rax, 1</span><br><span class="line">    mov rdi, 1</span><br><span class="line">    mov rsi, msg_ne</span><br><span class="line">    mov rdx, len_ne</span><br><span class="line">    syscall</span><br><span class="line">    jmp exit             ; 跳转到exit，避免执行equal的代码</span><br><span class="line"></span><br><span class="line">    ; 相等的逻辑：打印Equal</span><br><span class="line">equal:</span><br><span class="line">    mov rax, 1</span><br><span class="line">    mov rdi, 1</span><br><span class="line">    mov rsi, msg_eq</span><br><span class="line">    mov rdx, len_eq</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    ; 退出</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>运行结果：因num1&#x3D;num2&#x3D;30，输出Equal；若修改num2&#x3D;40，则输出Not Equal。</p>
<h4 id="4-循环指令：loop"><a href="#4-循环指令：loop" class="headerlink" title="4. 循环指令：loop"></a>4. 循环指令：loop</h4><p>loop 标签：实现循环，依赖rcx寄存器（每次循环rcx–，直到rcx&#x3D;0退出循环）。</p>
<p><strong>实例 5：循环打印 5 次 “Loop”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Loop&#x27;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rcx, 5           ; rcx=5（循环次数）</span><br><span class="line"></span><br><span class="line">loop_label:</span><br><span class="line">    ; 打印msg</span><br><span class="line">    mov rax, 1</span><br><span class="line">    mov rdi, 1</span><br><span class="line">    mov rsi, msg</span><br><span class="line">    mov rdx, len</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    loop loop_label      ; rcx--，若rcx≠0则跳回loop_label</span><br><span class="line"></span><br><span class="line">    ; 退出</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>运行结果：连续打印 5 次 “Loop”，每次换行。</p>
<h3 id="五、内存操作：栈与全局变量"><a href="#五、内存操作：栈与全局变量" class="headerlink" title="五、内存操作：栈与全局变量"></a>五、内存操作：栈与全局变量</h3><p>除了寄存器，汇编还需要操作内存 —— 全局变量（.data 段）和栈（临时存储）是两种常用方式。</p>
<h4 id="1-全局变量（-data-bss-段）"><a href="#1-全局变量（-data-bss-段）" class="headerlink" title="1. 全局变量（.data&#x2F;.bss 段）"></a>1. 全局变量（.data&#x2F;.bss 段）</h4><ul>
<li><p>.data：存放已初始化的全局变量（如var dq 100）</p>
</li>
<li><p>.bss：存放未初始化的全局变量（仅占地址，不占文件空间，初始值 0）</p>
</li>
</ul>
<p><strong>实例 6：使用.bss 段存储临时结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .bss</span><br><span class="line">    temp resq 1          ; resq 1：预留1个64位（8字节）空间，初始值0</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    num dq 50</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, [num]</span><br><span class="line">    add rax, 30          ; rax=50+30=80</span><br><span class="line">    mov [temp], rax      ; 将80存入temp（.bss段）</span><br><span class="line"></span><br><span class="line">    ; 退出</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<h4 id="2-栈操作：push-pop"><a href="#2-栈操作：push-pop" class="headerlink" title="2. 栈操作：push&#x2F;pop"></a>2. 栈操作：push&#x2F;pop</h4><p>栈是 “先进后出” 的内存区域，由rsp寄存器指向栈顶（栈向下生长，rsp减小表示栈扩容，增大表示栈收缩）：</p>
<ul>
<li><p>push 数据：将数据压入栈（rsp -&#x3D; 8，再存数据到 rsp 地址）</p>
</li>
<li><p>pop 目标：将栈顶数据弹出到目标（取 rsp 地址的数据，再 rsp +&#x3D; 8）</p>
</li>
</ul>
<p><strong>实例 7：用栈保存寄存器值（函数调用前常用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, 100</span><br><span class="line">    mov rbx, 200</span><br><span class="line"></span><br><span class="line">    ; 保存rax和rbx到栈</span><br><span class="line">    push rax</span><br><span class="line">    push rbx</span><br><span class="line"></span><br><span class="line">    ; 修改rax和rbx</span><br><span class="line">    mov rax, 0</span><br><span class="line">    mov rbx, 0</span><br><span class="line"></span><br><span class="line">    ; 从栈恢复rax和rbx（注意顺序：先push的后pop）</span><br><span class="line">    pop rbx              ; rbx恢复为200</span><br><span class="line">    pop rax              ; rax恢复为100</span><br><span class="line"></span><br><span class="line">    ; 退出</span><br><span class="line">    mov rax, 60</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p><strong>为什么用栈？</strong>：当需要临时修改寄存器（如函数调用），又不想丢失原有值时，用栈保存是标准做法。</p>
<h3 id="六、汇编与-C-的关联：反汇编看本质"><a href="#六、汇编与-C-的关联：反汇编看本质" class="headerlink" title="六、汇编与 C 的关联：反汇编看本质"></a>六、汇编与 C 的关联：反汇编看本质</h3><p>学汇编的重要目的是理解高级语言的底层执行逻辑。通过gcc将 C 代码反汇编，能直观看到汇编与 C 的对应关系。</p>
<p><strong>实例 8：C 代码反汇编</strong></p>
<p>写一个简单的 C 程序（add.c）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译为汇编代码（-S选项生成.s文件）</span><br><span class="line">gcc -S -masm=intel add.c -o add.s</span><br><span class="line"></span><br><span class="line"># 查看汇编代码</span><br><span class="line">cat add.s</span><br></pre></td></tr></table></figure>

<p>关键汇编代码（精简）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    push rbp              ; 保存旧栈基址</span><br><span class="line">    mov rbp, rsp          ; 设置新栈基址（栈帧初始化）</span><br><span class="line">    sub rsp, 16           ; 栈扩容16字节（存放a、b、c）</span><br><span class="line"></span><br><span class="line">    mov DWORD PTR [rbp-4], 10  ; a=10（rbp-4是a的地址）</span><br><span class="line">    mov DWORD PTR [rbp-8], 20  ; b=20（rbp-8是b的地址）</span><br><span class="line">    mov eax&lt;/doubaocanvas&gt;</span><br><span class="line"></span><br><span class="line">	mov eax, DWORD PTR [rbp-4]  ; eax = a（将 a 的值加载到 eax）</span><br><span class="line"></span><br><span class="line">	add eax, DWORD PTR [rbp-8]  ; eax = a + b（累加后存入 eax）</span><br><span class="line"></span><br><span class="line">	mov DWORD PTR [rbp-12], eax ; c = eax（将结果存入 c 的地址）</span><br><span class="line"></span><br><span class="line">	mov eax, 0                  ; main 函数返回值 0（存入 eax）</span><br><span class="line"></span><br><span class="line">	leave                       ; 等价于 mov rsp, rbp + pop rbp（销毁栈帧）</span><br><span class="line"></span><br><span class="line">	ret                         ; 返回到调用者（如操作系统）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>代码解析</strong>：</p>
<ul>
<li>栈帧初始化：<code>push rbp</code> + <code>mov rbp, rsp</code> 是函数入口的标准操作，用于创建独立的栈帧（每个函数有自己的栈空间），<code>sub rsp, 16</code> 为局部变量 <code>a</code>、<code>b</code>、<code>c</code> 分配16字节栈空间（实际仅用12字节，编译器会按对齐规则分配）。</li>
<li>局部变量存储：<code>[rbp-4]</code> 是 <code>a</code> 的地址、<code>[rbp-8]</code> 是 <code>b</code> 的地址、<code>[rbp-12]</code> 是 <code>c</code> 的地址，均基于栈基址 <code>rbp</code> 偏移，确保地址唯一。</li>
<li>返回值传递：C语言函数的返回值默认通过 <code>eax</code>（32位）或 <code>rax</code>（64位）寄存器传递，因此 <code>main</code> 函数将返回值0存入 <code>eax</code>。</li>
<li>栈帧销毁：<code>leave</code> 指令恢复栈指针和栈基址，<code>ret</code> 指令从栈中取出返回地址，跳回调用者，完成函数退出。</li>
</ul>
<h3 id="七、进阶实例：汇编实现函数调用"><a href="#七、进阶实例：汇编实现函数调用" class="headerlink" title="七、进阶实例：汇编实现函数调用"></a>七、进阶实例：汇编实现函数调用</h3><p>在高级语言中，函数调用是核心逻辑，汇编通过“栈传参+<code>call</code>&#x2F;<code>ret</code> 指令”实现函数调用，遵循特定的调用约定（x86-64 Linux 遵循 System V AMD64 ABI 约定）。</p>
<h4 id="调用约定核心规则（64位）："><a href="#调用约定核心规则（64位）：" class="headerlink" title="调用约定核心规则（64位）："></a>调用约定核心规则（64位）：</h4><ol>
<li>前6个参数依次通过 <code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code> 寄存器传递，超过6个的参数通过栈传递。</li>
<li>函数返回值通过 <code>rax</code> 寄存器传递。</li>
<li>调用者需为被调用者预留“影子空间”（128字节栈空间，用于被调用者临时存储寄存器），但简单函数可省略。</li>
</ol>
<h4 id="实例9：汇编实现函数调用（计算两数之和）"><a href="#实例9：汇编实现函数调用（计算两数之和）" class="headerlink" title="实例9：汇编实现函数调用（计算两数之和）"></a>实例9：汇编实现函数调用（计算两数之和）</h4><p>编写一个 <code>add_num</code> 函数，接收两个参数并返回和，在 <code>_start</code> 中调用该函数。</p>
<p>汇编代码（func_call.asm）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">; 函数：add_num(a, b)，返回a + b</span><br><span class="line">; 参数：a -&gt; rdi，b -&gt; rsi</span><br><span class="line">; 返回值：a + b -&gt; rax</span><br><span class="line">add_num:</span><br><span class="line">    mov rax, rdi        ; rax = a</span><br><span class="line">    add rax, rsi        ; rax = a + b</span><br><span class="line">    ret                 ; 返回，rax中的值即为返回值</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 准备参数：调用add_num(15, 25)</span><br><span class="line">    mov rdi, 15         ; 第一个参数a=15</span><br><span class="line">    mov rsi, 25         ; 第二个参数b=25</span><br><span class="line">    call add_num        ; 调用函数，返回值存入rax（此时rax=40）</span><br><span class="line"></span><br><span class="line">    ; 退出程序（返回值存入rdi，作为退出码）</span><br><span class="line">    mov rdi, rax        ; 退出码=40（验证函数返回值）</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<h4 id="编译运行与验证："><a href="#编译运行与验证：" class="headerlink" title="编译运行与验证："></a>编译运行与验证：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm -f elf64 func_call.asm -o func_call.o</span><br><span class="line">ld func_call.o -o func_call</span><br><span class="line">./func_call</span><br><span class="line">echo $?  # 查看程序退出码（应输出40，即函数返回值）</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>：</p>
<ul>
<li><p>函数定义：add_num 函数接收 rdi（a）和 rsi（b）传递的参数，计算和后存入 rax，通过 ret 指令返回。</p>
</li>
<li><p>函数调用：call add_num 指令会先将下一条指令的地址（返回地址）压入栈，再跳转到 add_num 函数入口；函数执行完 ret 指令时，会从栈中取出返回地址，跳回 _start 继续执行。</p>
</li>
<li><p>返回值验证：通过将 rax（函数返回值）存入 rdi 作为程序退出码，用 echo $? 查看退出码，验证函数调用结果是否正确。</p>
</li>
</ul>
<h4 id="实例-10：汇编调用-C-函数（混合编程）"><a href="#实例-10：汇编调用-C-函数（混合编程）" class="headerlink" title="实例 10：汇编调用 C 函数（混合编程）"></a>实例 10：汇编调用 C 函数（混合编程）</h4><p>汇编不仅能自己写函数，还能调用 C 语言编写的函数，实现 “汇编 + C” 混合编程，降低复杂逻辑的编写难度。</p>
<p>步骤 1：编写 C 函数（add_c.c）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// C函数：接收两个整数，返回和</span><br><span class="line">int add_c(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤 2：编写汇编代码（call_c.asm），调用 add_c 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern add_c  ; 声明外部C函数（告诉汇编器该函数在其他文件中定义）</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 准备参数：调用add_c(30, 40)（参数通过rdi、rsi传递）</span><br><span class="line">    mov rdi, 30         ; 第一个参数a=30</span><br><span class="line">    mov rsi, 40         ; 第二个参数b=40</span><br><span class="line">    call add_c          ; 调用C函数，返回值存入rax（此时rax=70）</span><br><span class="line"></span><br><span class="line">    ; 退出程序，退出码=70</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    mov rax, 60</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>步骤 3：编译链接（需将 C 文件和汇编文件一起链接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 编译C文件为目标文件（-c表示只编译不链接）</span><br><span class="line">gcc -c -fPIC add_c.c -o add_c.o</span><br><span class="line"></span><br><span class="line"># 2. 编译汇编文件为目标文件</span><br><span class="line">nasm -f elf64 call_c.asm -o call_c.o</span><br><span class="line"></span><br><span class="line"># 3. 链接两个目标文件（需指定C标准库，否则会报错）</span><br><span class="line">gcc call_c.o add_c.o -o call_c -nostdlib -lc -lgcc</span><br><span class="line"></span><br><span class="line"># 4. 运行并验证</span><br><span class="line">./call_c</span><br><span class="line">echo $?  # 输出70，验证C函数调用成功</span><br></pre></td></tr></table></figure>

<p><strong>关键说明</strong>：</p>
<ul>
<li><p>extern add_c：汇编中声明外部函数，表明 add_c 由其他文件（如 C 文件）定义，避免汇编器报错。</p>
</li>
<li><p>链接选项：-nostdlib 表示不链接默认的标准库启动文件，-lc 链接 C 标准库（add_c 函数依赖），-lgcc 链接 GCC 支持库，确保函数调用正常。</p>
</li>
<li><p>混合编程优势：复杂逻辑（如字符串处理、数学计算）用 C 编写更高效，简单的底层操作（如系统调用、寄存器控制）用汇编实现，兼顾开发效率和底层控制能力。</p>
</li>
</ul>
<h3 id="八、汇编调试：用-GDB-查看执行过程"><a href="#八、汇编调试：用-GDB-查看执行过程" class="headerlink" title="八、汇编调试：用 GDB 查看执行过程"></a>八、汇编调试：用 GDB 查看执行过程</h3><p>汇编代码的执行逻辑较抽象，通过 GDB 调试能直观看到寄存器、内存、指令的变化，是理解汇编的重要手段。</p>
<h4 id="实例-11：用-GDB-调试-Hello-World-程序"><a href="#实例-11：用-GDB-调试-Hello-World-程序" class="headerlink" title="实例 11：用 GDB 调试 Hello World 程序"></a>实例 11：用 GDB 调试 Hello World 程序</h4><p>以实例 1 的 hello.asm 为例，演示 GDB 调试步骤：</p>
<ol>
<li><strong>编译时保留调试信息</strong>：汇编时添加 -g 选项，生成包含调试信息的目标文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm -f elf64 -g hello.asm -o hello.o</span><br><span class="line">ld hello.o -o hello</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>启动 GDB 调试</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./hello</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>常用 GDB 调试命令</strong></li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>b 标签</td>
<td>在指定标签处设置断点</td>
<td>b _start（在_start处断点）</td>
</tr>
<tr>
<td>run</td>
<td>启动程序</td>
<td>run</td>
</tr>
<tr>
<td>nexti</td>
<td>执行一条汇编指令（单步执行）</td>
<td>nexti（简写ni）</td>
</tr>
<tr>
<td>info registers</td>
<td>查看所有寄存器的值</td>
<td>info registers（简写i r）</td>
</tr>
<tr>
<td>x&#x2F;格式 地址</td>
<td>查看内存内容</td>
<td>x&#x2F;s msg（查看msg地址的字符串）</td>
</tr>
<tr>
<td>continue</td>
<td>继续执行到下一个断点</td>
<td>continue（简写c）</td>
</tr>
<tr>
<td>quit</td>
<td>退出 GDB</td>
<td>quit（简写q）</td>
</tr>
</tbody></table>
<ol>
<li><strong>调试流程示例</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b _start        # 在程序入口设置断点</span><br><span class="line">(gdb) run             # 启动程序，停在_start断点</span><br><span class="line">(gdb) ni              # 执行第一条指令mov rax, 1</span><br><span class="line">(gdb) i r rax         # 查看rax寄存器，应显示rax=0x1</span><br><span class="line">(gdb) ni              # 执行mov rdi, 1</span><br><span class="line">(gdb) i r rdi         # 查看rdi寄存器，应显示rdi=0x1</span><br><span class="line">(gdb) x/s msg         # 查看msg地址的字符串，显示&quot;Hello, Assembly!\n&quot;</span><br><span class="line">(gdb) c               # 继续执行，直到程序退出</span><br><span class="line">(gdb) q               # 退出GDB</span><br></pre></td></tr></table></figure>

<p>通过调试，能清晰看到每条指令执行后寄存器的变化（如 rax 从 0 变为 1、rdi 从 0 变为 1），以及内存中字符串的实际存储，帮助理解汇编代码的执行逻辑。</p>
<h3 id="九、学习汇编的常见误区与建议"><a href="#九、学习汇编的常见误区与建议" class="headerlink" title="九、学习汇编的常见误区与建议"></a>九、学习汇编的常见误区与建议</h3><h4 id="1-常见误区"><a href="#1-常见误区" class="headerlink" title="1. 常见误区"></a>1. 常见误区</h4><ul>
<li><p><strong>“汇编只能操作寄存器，不能用变量”</strong>：错误。汇编可通过全局变量（.data&#x2F;.bss段）和局部变量（栈空间）存储数据，只是需要手动管理地址。</p>
</li>
<li><p><strong>“学汇编必须背所有指令”</strong>：错误。入门阶段只需掌握常用指令（mov&#x2F;add&#x2F;sub&#x2F;cmp&#x2F;jmp&#x2F;call&#x2F;ret），复杂指令可在需要时查阅文档（如 Intel 官方指令集手册）。</p>
</li>
<li><p><strong>“汇编效率一定比 C 高”</strong>：错误。现代编译器（如 GCC、Clang）的优化能力极强，简单逻辑的汇编代码效率往往不如编译器优化后的 C 代码；只有对性能敏感的核心逻辑（如加密、算法），手动编写汇编才可能提升效率。</p>
</li>
</ul>
<h4 id="2-学习建议"><a href="#2-学习建议" class="headerlink" title="2. 学习建议"></a>2. 学习建议</h4><ul>
<li><p><strong>从简单实例入手</strong>：先实现 Hello World、算术计算、循环等基础功能，再逐步尝试函数调用、混合编程，避免一开始接触复杂逻辑。</p>
</li>
<li><p><strong>结合反汇编学习</strong>：将 C 代码反汇编，对比 C 与汇编的对应关系，理解高级语言的底层实现，如循环对应loop指令、if-else对应cmp+jxx指令。</p>
</li>
<li><p><strong>多动手调试</strong>：通过 GDB 查看寄存器和内存变化，验证自己对指令执行逻辑的理解是否正确，调试是掌握汇编的关键。</p>
</li>
<li><p><strong>查阅官方文档</strong>：遇到不熟悉的指令或调用约定，参考 Intel 64 and IA-32 Architectures Software Developer’s Manual（Intel 官方指令集手册）或 System V AMD64 ABI（调用约定文档），确保知识的准确性。</p>
</li>
</ul>
<h3 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h3><p>汇编语言虽然是底层语言，但并非 “高深莫测”—— 它的核心是 “寄存器操作 + 指令执行 + 内存管理”，通过本文的 11 个实例，你已掌握 x86-64 汇编的基础：</p>
<ol>
<li><p><strong>寄存器</strong>：了解 16 个通用寄存器的用途，掌握 64 位 &#x2F; 32 位 &#x2F; 16 位 &#x2F; 8 位寄存器的别名与使用规则。</p>
</li>
<li><p><strong>核心指令</strong>：熟练使用mov（数据移动）、add&#x2F;sub（算术运算）、cmp&#x2F;jxx（分支）、loop（循环）、call&#x2F;ret（函数调用）等指令。</p>
</li>
<li><p><strong>内存操作</strong>：学会用.data&#x2F;.bss段存储全局变量，用栈存储局部变量，理解栈帧的创建与销毁。</p>
</li>
<li><p><strong>混合编程</strong>：掌握汇编调用 C 函数的方法，实现 “汇编 + C” 协同开发，兼顾底层控制与开发效率。</p>
</li>
</ol>
<p>学习汇编的价值，不仅在于能编写底层代码，更在于理解程序的执行本质 —— 当你能看懂 C 代码对应的汇编逻辑，就能更清晰地排查性能瓶颈（如冗余指令）、理解内存布局（如栈溢出原理），甚至为后续学习逆向工程、操作系统内核打下基础。</p>
<p>后续可进一步学习高级主题，如浮点数操作、SIMD 指令（向量计算）、系统调用深入解析等，逐步提升汇编能力。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理器与预处理指令</title>
    <url>/2025/11/13/C_C++/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>结合例子（<code>#define a 1 + 5</code>）来<strong>详细讲解 C&#x2F;C++ 中的预处理指令（preprocessor directives）</strong>，尤其是 <code>#define</code> 的工作原理、常见用法和陷阱。</p>
<hr>
<h2 id="一、什么是预处理器？"><a href="#一、什么是预处理器？" class="headerlink" title="一、什么是预处理器？"></a>一、什么是预处理器？</h2><p>在 C&#x2F;C++ 编译过程中，<strong>预处理器（Preprocessor）</strong> 是编译的第一步。它在真正的编译开始前对源代码进行文本级别的处理。所有以 <code>#</code> 开头的行都是预处理指令，例如：</p>
<ul>
<li><code>#define</code></li>
<li><code>#include</code></li>
<li><code>#ifdef</code> &#x2F; <code>#ifndef</code> &#x2F; <code>#endif</code></li>
<li><code>#pragma</code></li>
<li><code>#error</code></li>
</ul>
<p>这些指令<strong>不会被编译器直接执行</strong>，而是在编译前由预处理器处理。</p>
<hr>
<h2 id="二、-define-宏定义详解"><a href="#二、-define-宏定义详解" class="headerlink" title="二、#define 宏定义详解"></a>二、<code>#define</code> 宏定义详解</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 替换文本</span></span><br></pre></td></tr></table></figure>

<p>作用：在预处理阶段，将代码中所有出现的 <strong>标识符</strong> 替换成 <strong>替换文本</strong>（纯文本替换，不计算、不检查类型）。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：宏不是变量，也不是函数！它只是“复制粘贴”式的文本替换。</p>
</blockquote>
<hr>
<h3 id="2-回到你的例子：-define-a-1-5"><a href="#2-回到你的例子：-define-a-1-5" class="headerlink" title="2. 回到你的例子：#define a 1 + 5"></a>2. 回到你的例子：<code>#define a 1 + 5</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 1 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = a * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 输出什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="预处理后的代码："><a href="#预处理后的代码：" class="headerlink" title="预处理后的代码："></a>预处理后的代码：</h4><p>预处理器会把 <code>a</code> 替换为 <code>1 + 5</code>，所以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span> + <span class="number">5</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>由于运算符优先级：<code>*</code> 高于 <code>+</code>，等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span> + (<span class="number">5</span> * <span class="number">2</span>); <span class="comment">// = 1 + 10 = 11</span></span><br></pre></td></tr></table></figure>

<p>✅ 所以输出是 <strong>11</strong>，而不是很多人直觉认为的 <code>(1+5)*2 = 12</code>。</p>
<hr>
<h3 id="3-为什么这是个陷阱？如何避免？"><a href="#3-为什么这是个陷阱？如何避免？" class="headerlink" title="3. 为什么这是个陷阱？如何避免？"></a>3. 为什么这是个陷阱？如何避免？</h3><p>问题根源：<strong>宏替换是纯文本，不考虑数学逻辑或优先级</strong>。</p>
<h4 id="正确写法：加括号！"><a href="#正确写法：加括号！" class="headerlink" title="正确写法：加括号！"></a>正确写法：加括号！</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a (1 + 5)</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>a * 2</code> 就变成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">5</span>) * <span class="number">2</span>  <span class="comment">// = 6 * 2 = 12</span></span><br></pre></td></tr></table></figure>

<p>更进一步，如果宏中有参数，每个参数和整个表达式都要加括号：</p>
<p>❌ 危险写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SQUARE(<span class="number">2</span> + <span class="number">3</span>) → <span class="number">2</span> + <span class="number">3</span> * <span class="number">2</span> + <span class="number">3</span> = <span class="number">2</span> + <span class="number">6</span> + <span class="number">3</span> = <span class="number">11</span> ❌（期望是 <span class="number">25</span>）</span><br></pre></td></tr></table></figure>

<p>✅ 安全写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>

<p>这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SQUARE(<span class="number">2</span> + <span class="number">3</span>) → ((<span class="number">2</span> + <span class="number">3</span>) * (<span class="number">2</span> + <span class="number">3</span>)) = (<span class="number">5</span> * <span class="number">5</span>) = <span class="number">25</span> ✅</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、-define-的其他常见用途"><a href="#三、-define-的其他常见用途" class="headerlink" title="三、#define 的其他常见用途"></a>三、<code>#define</code> 的其他常见用途</h2><h3 id="1-定义常量（现代-C-更推荐-const-或-constexpr）"><a href="#1-定义常量（现代-C-更推荐-const-或-constexpr）" class="headerlink" title="1. 定义常量（现代 C++ 更推荐 const 或 constexpr）"></a>1. 定义常量（现代 C++ 更推荐 <code>const</code> 或 <code>constexpr</code>）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="2-条件编译开关"><a href="#2-条件编译开关" class="headerlink" title="2. 条件编译开关"></a>2. 条件编译开关</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode enabled\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-多行宏（用反斜杠-连接）"><a href="#3-多行宏（用反斜杠-连接）" class="headerlink" title="3. 多行宏（用反斜杠 \ 连接）"></a>3. 多行宏（用反斜杠 <code>\</code> 连接）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SUM(a, b) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        int sum = (a) + (b); \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;Sum = %d\n&quot;</span>, sum); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>do...while(0)</code> 是为了在任何上下文中都能安全使用分号。</p>
</blockquote>
<hr>
<h2 id="四、预处理的几个关键特点"><a href="#四、预处理的几个关键特点" class="headerlink" title="四、预处理的几个关键特点"></a>四、预处理的几个关键特点</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>文本替换</strong></td>
<td>不进行语法或类型检查，只是字符串替换</td>
</tr>
<tr>
<td><strong>无作用域</strong></td>
<td>宏从定义处到文件结束（或 <code>#undef</code>）都有效</td>
</tr>
<tr>
<td><strong>可取消定义</strong></td>
<td>用 <code>#undef a</code> 可取消宏定义</td>
</tr>
<tr>
<td><strong>不能调试</strong></td>
<td>宏在编译前就被替换了，调试器看不到原始宏名</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、现代替代方案（C-推荐）"><a href="#五、现代替代方案（C-推荐）" class="headerlink" title="五、现代替代方案（C++ 推荐）"></a>五、现代替代方案（C++ 推荐）</h2><p>虽然 <code>#define</code> 仍有用武之地（如条件编译），但在定义常量或简单函数时，<strong>更推荐使用语言特性</strong>：</p>
<ul>
<li>常量：<code>const int a = 6;</code> 或 <code>constexpr int a = 6;</code></li>
<li>函数：用内联函数 <code>inline int square(int x) &#123; return x * x; &#125;</code></li>
</ul>
<p>这些方式有类型安全、作用域控制、可调试等优势。</p>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul>
<li><code>#define a 1 + 5</code> 是<strong>文本替换</strong>，不是赋值。</li>
<li><code>a * 2</code> 被替换为 <code>1 + 5 * 2</code>，结果是 <strong>11</strong>（因优先级）。</li>
<li><strong>务必给宏加括号</strong>：<code>#define a (1 + 5)</code></li>
<li>宏强大但危险，使用时要格外小心优先级和副作用。</li>
<li>在现代 C&#x2F;C++ 中，尽量用 <code>const</code>、<code>constexpr</code>、<code>inline</code> 替代简单宏。</li>
</ul>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>预处理指令</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的队列 queue 详解</title>
    <url>/2025/07/28/C_C++/%E9%98%9F%E5%88%97%EF%BC%88queue%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>队列是一种常见的数据结构，遵循 “先进先出”（FIFO）原则。在 C++ 的 STL（标准模板库）中，queue 容器为我们提供了实现队列功能的便捷方式。本文将详细介绍 C++ 中 queue 的特性、常用操作及使用示例。</p>
<h3 id="一、queue-的基本概念"><a href="#一、queue-的基本概念" class="headerlink" title="一、queue 的基本概念"></a>一、queue 的基本概念</h3><p>queue 是 C++ STL 中的一个容器适配器，它基于其他容器（默认是 deque）实现，提供了队列的基本操作。其核心特点是元素的插入在队尾进行，元素的删除和访问在队头进行，严格遵循先进先出的规则。</p>
<h3 id="二、queue-的头文件与定义"><a href="#二、queue-的头文件与定义" class="headerlink" title="二、queue 的头文件与定义"></a>二、queue 的头文件与定义</h3><p>要使用 queue，需要包含头文件<queue>，定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q; // 定义一个存储int类型元素的队列</span><br><span class="line">queue&lt;string&gt; strQueue; // 定义一个存储string类型元素的队列</span><br></pre></td></tr></table></figure>

<h3 id="三、queue-的常用成员函数"><a href="#三、queue-的常用成员函数" class="headerlink" title="三、queue 的常用成员函数"></a>三、queue 的常用成员函数</h3><ol>
<li><strong>入队操作</strong>：push()</li>
</ol>
<ul>
<li><ul>
<li>功能：在队列的队尾插入一个元素。</li>
</ul>
</li>
<li><ul>
<li>示例：q.push(10);</li>
</ul>
</li>
</ul>
<ol>
<li><strong>出队操作</strong>：pop()</li>
</ol>
<ul>
<li><ul>
<li>功能：删除队列的队头元素，无返回值。</li>
</ul>
</li>
<li><ul>
<li>注意：使用前需判断队列是否为空，否则可能导致未定义行为。</li>
</ul>
</li>
<li><ul>
<li>示例：if (!q.empty()) q.pop();</li>
</ul>
</li>
</ul>
<ol>
<li><strong>访问队头元素</strong>：front()</li>
</ol>
<ul>
<li><ul>
<li>功能：返回队头元素的引用。</li>
</ul>
</li>
<li><ul>
<li>示例：int frontVal &#x3D; q.front();</li>
</ul>
</li>
</ul>
<ol>
<li><strong>访问队尾元素</strong>：back()</li>
</ol>
<ul>
<li><ul>
<li>功能：返回队尾元素的引用。</li>
</ul>
</li>
<li><ul>
<li>示例：int backVal &#x3D; q.back();</li>
</ul>
</li>
</ul>
<ol>
<li><strong>判断队列是否为空</strong>：empty()</li>
</ol>
<ul>
<li><ul>
<li>功能：若队列为空，返回 true；否则返回 false。</li>
</ul>
</li>
<li><ul>
<li>示例：if (q.empty()) cout &lt;&lt; “队列为空” &lt;&lt; endl;</li>
</ul>
</li>
</ul>
<ol>
<li><strong>获取队列元素个数</strong>：size()</li>
</ol>
<ul>
<li><ul>
<li>功能：返回队列中元素的数量。</li>
</ul>
</li>
<li><ul>
<li>示例：cout &lt;&lt; “队列元素个数：” &lt;&lt; q.size() &lt;&lt; endl;</li>
</ul>
</li>
</ul>
<h3 id="四、queue-的使用示例"><a href="#四、queue-的使用示例" class="headerlink" title="四、queue 的使用示例"></a>四、queue 的使用示例</h3><p>下面通过一个简单的示例来演示 queue 的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">    // 入队</span><br><span class="line">    q.push(10);</span><br><span class="line">    q.push(20);</span><br><span class="line">    q.push(30);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;队列元素个数：&quot; &lt;&lt; q.size() &lt;&lt; endl; // 输出：3</span><br><span class="line">    cout &lt;&lt; &quot;队头元素：&quot; &lt;&lt; q.front() &lt;&lt; endl; // 输出：10</span><br><span class="line">    cout &lt;&lt; &quot;队尾元素：&quot; &lt;&lt; q.back() &lt;&lt; endl; // 输出：30</span><br><span class="line"></span><br><span class="line">    // 出队</span><br><span class="line">    q.pop();</span><br><span class="line">    cout &lt;&lt; &quot;出队后队头元素：&quot; &lt;&lt; q.front() &lt;&lt; endl; // 输出：20</span><br><span class="line"></span><br><span class="line">    // 清空队列</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (q.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;队列已清空&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、queue-的注意事项"><a href="#五、queue-的注意事项" class="headerlink" title="五、queue 的注意事项"></a>五、queue 的注意事项</h3><ol>
<li><p>queue 没有迭代器，无法直接遍历队列中的所有元素，只能通过不断出队的方式访问。</p>
</li>
<li><p>使用front()和pop()函数前，务必先用empty()判断队列是否为空，避免操作空队列导致错误。</p>
</li>
<li><p>queue 的底层容器默认是 deque，也可以指定为 list，但不能是 vector，因为 vector 不支持高效的头删操作。</p>
</li>
</ol>
<p>通过本文的介绍，相信大家对 C++ 中的 queue 有了一定的了解。在实际编程中，queue 常用于广度优先搜索（BFS）、任务调度等场景，合理使用能提高编程效率。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的智能指针</title>
    <url>/2025/10/27/C_C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针（Smart Pointer）是 C++ 中用于自动管理动态分配内存的工具，它们封装了原始指针，并在其生命周期结束时自动释放所管理的资源，从而避免内存泄漏、悬空指针等问题。C++11 引入了标准库中的三种主要智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。下面将逐一详细讲解其原理、特点及用法示例。</p>
<hr>
<h2 id="一、std-unique-ptr：独占式智能指针"><a href="#一、std-unique-ptr：独占式智能指针" class="headerlink" title="一、std::unique_ptr：独占式智能指针"></a>一、<code>std::unique_ptr</code>：独占式智能指针</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>独占所有权</strong>：一个对象只能被一个 <code>unique_ptr</code> 拥有。</li>
<li><strong>不可复制</strong>（copy），但<strong>可移动</strong>（move）。</li>
<li>轻量级，无额外开销（除指针本身外）。</li>
<li>析构时自动调用 <code>delete</code>（或自定义删除器）。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed with &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权（不能复制）</span></span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="built_in">move</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr is now null\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr2 离开作用域时自动析构 MyClass 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass constructed with 42</span><br><span class="line">Value: 42</span><br><span class="line">ptr is now null</span><br><span class="line">Value: 42</span><br><span class="line">MyClass destructed</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、std-shared-ptr：共享式智能指针"><a href="#二、std-shared-ptr：共享式智能指针" class="headerlink" title="二、std::shared_ptr：共享式智能指针"></a>二、<code>std::shared_ptr</code>：共享式智能指针</h2><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可指向同一对象。</li>
<li>使用<strong>引用计数</strong>机制：当最后一个 <code>shared_ptr</code> 被销毁时，对象才被释放。</li>
<li>可复制、可赋值。</li>
<li>有轻微性能开销（引用计数的原子操作）。</li>
</ul>
<h3 id="基本用法示例：-1"><a href="#基本用法示例：-1" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">100</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; sp2 = sp1; <span class="comment">// 引用计数变为2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2</span></span><br><span class="line">    &#125; <span class="comment">// sp2 离开作用域，引用计数减为1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sp1 离开作用域，引用计数为0，对象被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass constructed with 100</span><br><span class="line">Use count: 2</span><br><span class="line">Use count: 1</span><br><span class="line">MyClass destructed</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、std-weak-ptr：弱引用智能指针（解决循环引用）"><a href="#三、std-weak-ptr：弱引用智能指针（解决循环引用）" class="headerlink" title="三、std::weak_ptr：弱引用智能指针（解决循环引用）"></a>三、<code>std::weak_ptr</code>：弱引用智能指针（解决循环引用）</h2><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>不增加引用计数</strong>，仅观察 <code>shared_ptr</code> 管理的对象。</li>
<li>不能直接访问对象，必须通过 <code>lock()</code> 转换为 <code>shared_ptr</code>。</li>
<li>主要用于打破 <code>shared_ptr</code> 之间的<strong>循环引用</strong>。</li>
</ul>
<h3 id="示例：循环引用问题与-weak-ptr-解决方案"><a href="#示例：循环引用问题与-weak-ptr-解决方案" class="headerlink" title="示例：循环引用问题与 weak_ptr 解决方案"></a>示例：循环引用问题与 <code>weak_ptr</code> 解决方案</h3><h4 id="❌-问题：循环引用导致内存泄漏"><a href="#❌-问题：循环引用导致内存泄漏" class="headerlink" title="❌ 问题：循环引用导致内存泄漏"></a>❌ 问题：循环引用导致内存泄漏</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; prev; <span class="comment">// 双向链表</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;prev = n1; <span class="comment">// 此时 n1 和 n2 的引用计数均为2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域后，引用计数仍为1，无法释放！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 内存泄漏！</span></span><br></pre></td></tr></table></figure>

<h4 id="✅-解决：将其中一个指针改为-weak-ptr"><a href="#✅-解决：将其中一个指针改为-weak-ptr" class="headerlink" title="✅ 解决：将其中一个指针改为 weak_ptr"></a>✅ 解决：将其中一个指针改为 <code>weak_ptr</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev; <span class="comment">// 使用 weak_ptr 打破循环</span></span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Node destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">auto</span> n2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    n1-&gt;next = n2;</span><br><span class="line">    n2-&gt;prev = n1; <span class="comment">// weak_ptr 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域后，n1 和 n2 的 shared_ptr 引用计数为1 → 析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-weak-ptr-访问对象："><a href="#使用-weak-ptr-访问对象：" class="headerlink" title="使用 weak_ptr 访问对象："></a>使用 <code>weak_ptr</code> 访问对象：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;MyClass&gt; wp = sp1;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> sp = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    sp-&gt;<span class="built_in">print</span>(); <span class="comment">// 安全访问</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object already destroyed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、何时使用哪种智能指针？"><a href="#四、何时使用哪种智能指针？" class="headerlink" title="四、何时使用哪种智能指针？"></a>四、何时使用哪种智能指针？</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐智能指针</th>
</tr>
</thead>
<tbody><tr>
<td>独占资源，不需要共享</td>
<td><code>std::unique_ptr</code></td>
</tr>
<tr>
<td>多个所有者共享资源</td>
<td><code>std::shared_ptr</code></td>
</tr>
<tr>
<td>需要观察资源但不拥有（如缓存、观察者）</td>
<td><code>std::weak_ptr</code></td>
</tr>
<tr>
<td>避免循环引用</td>
<td><code>std::weak_ptr</code> + <code>std::shared_ptr</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h2><ol>
<li><p><strong>优先使用 <code>std::make_unique</code> 和 <code>std::make_shared</code></strong><br>它们更安全（异常安全）、更高效（<code>make_shared</code> 可能减少一次内存分配）。</p>
</li>
<li><p><strong>避免混合使用原始指针和智能指针</strong><br>不要将同一个原始指针交给多个智能指针管理。</p>
</li>
<li><p><strong>不要对同一对象创建多个独立的 <code>shared_ptr</code></strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass* raw = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">p1</span><span class="params">(raw)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">p2</span><span class="params">(raw)</span></span>; <span class="comment">// 危险！双重释放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>慎用 <code>get()</code></strong><br><code>get()</code> 返回原始指针，但不转移所有权，容易误用。</p>
</li>
</ol>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>智能指针是现代 C++ 内存管理的核心工具：</p>
<ul>
<li><code>unique_ptr</code>：高效、独占，适合大多数场景。</li>
<li><code>shared_ptr</code>：灵活共享，但注意性能和循环引用。</li>
<li><code>weak_ptr</code>：辅助 <code>shared_ptr</code>，解决循环引用问题。</li>
</ul>
<p>合理使用智能指针，可以显著提升代码的安全性、可维护性和健壮性。</p>
]]></content>
      <categories>
        <category>C_C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/2025/11/13/Hot100/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p>
<p>题目：<br>给你一个链表，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么最后剩余的节点保持原有顺序。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 500]</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
<li><code>1 &lt;= k &lt;= 链表长度</code></li>
</ul>
<p>这是力扣（LeetCode）第 25 题，标记为 <strong>Hard</strong>。</p>
<p>这道题被誉为 <strong>“链表题的面霸”</strong>。</p>
<p>如果你在面试中遇到这道题，说明面试官对你的期望很高。它不再是单一技巧的考察，而是要求你将 <strong>“遍历计数”</strong>、<strong>“断链重连”</strong> 和 <strong>“局部反转”</strong> 这三套组合拳打得行云流水。</p>
<p>只要你能把这道题逻辑理顺，链表这个板块你就彻底通关了。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：K 个一组翻转链表 (Reverse Nodes in k-Group)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个链表的头节点 <code>head</code>，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<ul>
<li>如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</li>
</ul>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>空间复杂度</strong>：$O(1)$（意味着不能用递归，必须用迭代）。</li>
<li>不能只改变节点的值，必须修改节点指针。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>head = [1, 2, 3, 4, 5]</code>, <code>k = 2</code></p>
<p>输出：<code>[2, 1, 4, 3, 5]</code> (1,2反转; 3,4反转; 5不够一组，不动)</p>
<p>输入：<code>head = [1, 2, 3, 4, 5]</code>, <code>k = 3</code></p>
<p>输出：<code>[3, 2, 1, 4, 5]</code> (1,2,3反转; 4,5不够一组，不动)</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-宏观策略：切断-反转-拼接"><a href="#2-1-宏观策略：切断-反转-拼接" class="headerlink" title="2.1 宏观策略：切断 -&gt; 反转 -&gt; 拼接"></a>2.1 宏观策略：切断 -&gt; 反转 -&gt; 拼接</h4><p>这道题的核心难点在于 <strong>“维护连接点”</strong>。</p>
<p>当我们把中间某一段 <code>[start, end]</code> 翻转后，它需要和<strong>前面</strong>的链表接上，也需要和<strong>后面</strong>的链表接上。</p>
<p>我们需要定义四个关键指针来定位每一组：</p>
<ol>
<li><strong><code>pre</code></strong>：这一组的前驱节点（上一组的尾巴）。</li>
<li><strong><code>start</code></strong>：这一组原本的头（翻转后变成尾）。</li>
<li><strong><code>end</code></strong>：这一组原本的尾（翻转后变成头）。</li>
<li><strong><code>next</code></strong>：这一组的后继节点（下一组的头）。</li>
</ol>
<h4 id="2-2-详细步骤-The-Algorithm"><a href="#2-2-详细步骤-The-Algorithm" class="headerlink" title="2.2 详细步骤 (The Algorithm)"></a>2.2 详细步骤 (The Algorithm)</h4><ol>
<li><strong>初始化</strong>：创建一个 <code>dummy</code> 节点指向 <code>head</code>。<code>pre</code> 和 <code>end</code> 一开始都指向 <code>dummy</code>。</li>
<li><strong>寻找分组</strong>：<ul>
<li>让 <code>end</code> 向后走 <code>k</code> 步。</li>
<li>如果在走这 <code>k</code> 步的过程中遇到了 <code>NULL</code>，说明剩余节点不足 <code>k</code> 个，直接结束（不需要反转）。</li>
</ul>
</li>
<li><strong>记录断点</strong>：<ul>
<li>记录 <code>start = pre-&gt;next</code>。</li>
<li>记录 <code>next = end-&gt;next</code>。</li>
<li><strong>关键一步</strong>：把 <code>end-&gt;next = nullptr</code>。为什么要这么做？为了让我们的反转函数知道哪里是终点（把它当成一个独立的短链表来反转）。</li>
</ul>
</li>
<li><strong>局部反转</strong>：<ul>
<li>调用我们熟悉的 <code>reverse(start)</code> 函数。</li>
</ul>
</li>
<li><strong>重新连接</strong>：<ul>
<li><code>pre-&gt;next</code> 指向翻转后的新头（也就是原来的 <code>end</code>）。</li>
<li><code>start-&gt;next</code> 指向刚才保存的 <code>next</code>（这一组的新尾巴连接下一组的头）。</li>
</ul>
</li>
<li><strong>重置指针</strong>：<ul>
<li><code>pre</code> 移动到 <code>start</code>（因为 <code>start</code> 变成了这一组的尾巴，也就是下一组的前驱）。</li>
<li><code>end</code> 重置为 <code>pre</code>，准备开始下一轮寻找。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>为了代码清晰，我们将“反转链表”提取为一个独立的子函数。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 辅函数：标准的翻转链表</span><br><span class="line">    // 输入链表头，返回翻转后的链表头</span><br><span class="line">    ListNode* reverse(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            ListNode* nextNode = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode* dummy = new ListNode(0);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        // pre 指向待翻转区域的前一个节点</span><br><span class="line">        ListNode* pre = dummy;</span><br><span class="line">        // end 指向待翻转区域的最后一个节点</span><br><span class="line">        ListNode* end = dummy;</span><br><span class="line"></span><br><span class="line">        while (end-&gt;next != nullptr) &#123;</span><br><span class="line">            // 1. 让 end 往前走 k 步，确认这一组是否有 k 个节点</span><br><span class="line">            for (int i = 0; i &lt; k &amp;&amp; end != nullptr; ++i) &#123;</span><br><span class="line">                end = end-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果 end 为空，说明剩下的不足 k 个，不翻转，直接退出</span><br><span class="line">            if (end == nullptr) break;</span><br><span class="line"></span><br><span class="line">            // 2. 记录关键节点</span><br><span class="line">            ListNode* start = pre-&gt;next; // 这一组的开头</span><br><span class="line">            ListNode* nextGroup = end-&gt;next; // 下一组的开头</span><br><span class="line"></span><br><span class="line">            // 3. 断开链表，形成独立的子链表</span><br><span class="line">            end-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">            // 4. 翻转这个子链表</span><br><span class="line">            // pre-&gt;next 指向翻转后的新头（原来的 end）</span><br><span class="line">            pre-&gt;next = reverse(start);</span><br><span class="line"></span><br><span class="line">            // 5. 重新接上后续链表</span><br><span class="line">            // start 变成了现在的尾巴，让它指向下一组的开头</span><br><span class="line">            start-&gt;next = nextGroup;</span><br><span class="line"></span><br><span class="line">            // 6. 重置指针，准备下一轮</span><br><span class="line">            // pre 移动到当前组的尾巴 (start)，也就是下一组的前驱</span><br><span class="line">            pre = start;</span><br><span class="line">            // end 重置为 pre，重新开始计数</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们看起来有很多指针跑来跑去，但本质上：<ul>
<li>每个节点会被 <code>end</code> 指针访问一次（计数）。</li>
<li>每个节点会被 <code>reverse</code> 函数访问一次（翻转）。</li>
</ul>
</li>
<li>总操作次数是 $2N$，也就是线性的 $O(N)$。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只用到了常数个指针变量 (<code>dummy</code>, <code>pre</code>, <code>end</code>, <code>start</code>, <code>nextGroup</code>)。</li>
<li>符合题目要求的原地算法。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要断开链表 (<code>end-&gt;next = nullptr</code>)？</strong><ul>
<li><strong>A:</strong> 这为了复用标准的 <code>reverse</code> 函数。</li>
<li>标准的 <code>reverse</code> 函数是“直到遇到 nullptr 停止”。如果我们不断开，<code>reverse</code> 会一直反转到链表真正的末尾，把后面不需要翻转的组也给翻了。</li>
<li>当然，你也可以重写一个 <code>reverse(start, end)</code> 函数，但这会增加代码的复杂度和出错率。<strong>“断开-反转-重连”</strong> 是最稳健的策略。</li>
</ul>
</li>
<li><strong>Q: 为什么循环里要重置 <code>end = pre</code>？</strong><ul>
<li><strong>A:</strong> 因为翻转后，原来的 <code>end</code> 已经跑到这一组的前面去了，而 <code>pre</code> (也就是 <code>start</code>) 才是这一组的最后。</li>
<li>下一轮我们要从这个新的尾巴开始往后数 k 个，所以 <code>end</code> 必须回到起跑线（<code>pre</code> 的位置）。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU 缓存</title>
    <url>/2025/11/13/Hot100/LRU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p>
<p>题目：<br>设计并实现一个 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存。</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果不存在，则插入该组「关键字-值」。当缓存达到其容量时，它应该在写入新数据之前删除最久未使用的数据值。</li>
</ul>
<p><strong>示例：</strong><br>输入：<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出：<br>[null, null, null, 1, null, -1, null, -1, 3, 4]<br>解释：<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1); &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2); &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1); &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3); &#x2F;&#x2F; 返回 3<br>lRUCache.get(4); &#x2F;&#x2F; 返回 4</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10⁴</code></li>
<li><code>0 &lt;= value &lt;= 10⁵</code></li>
<li>最多调用 <code>get</code> 和 <code>put</code> 方法 <code>2 * 10⁵</code> 次</li>
</ul>
<p>这道题是力扣（LeetCode）第 146 题，难度 <strong>Medium</strong>（但其实是各大厂面试中的 Hard 级常客，字节跳动甚至有一段时间是“必考题”）。</p>
<p>它的难点不在于算法有多深奥，而在于它要求你在 <strong>$O(1)$</strong> 的时间内完成数据的 <strong>查询 (Get)</strong> 和 <strong>写入 (Put)</strong>，并且在容量满时自动淘汰 <strong>最近最少使用</strong> 的数据。</p>
<p>单一的数据结构（数组、链表、哈希表）都无法同时满足这些要求。你需要把 <strong>哈希表</strong> 和 <strong>双向链表</strong> 结合起来，设计一个复合数据结构。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：LRU 缓存 (LRU Cache)</p>
<p><strong>题目大意</strong>：</p>
<p>设计一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存约束</a> 的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code>: 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存。</li>
<li><code>int get(int key)</code>: 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li>
<li><code>void put(int key, int value)</code>:<ul>
<li>如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code>。</li>
<li>如果不存在，则向缓存中插入该组 <code>key-value</code>。</li>
<li>如果插入操作导致关键字数量超过 <code>capacity</code>，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
</li>
<li><strong>进阶要求</strong>：<code>get</code> 和 <code>put</code> 必须以 <strong>$O(1)$</strong> 平均时间复杂度运行。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>容量 &#x3D; 2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put(1, 1)` -&gt; `[1]</span><br></pre></td></tr></table></figure>

<p><code>put(2, 2)</code> -&gt; <code>[1, 2]</code> (2 是最新的)</p>
<p><code>get(1)</code>    -&gt; 返回 1。<code>[2, 1]</code> (1 刚被用过，变成最新的，2 变老了)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put(3, 3)` -&gt; 容量满，淘汰最老的 2。`[1, 3]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么单一结构不行？"><a href="#2-1-为什么单一结构不行？" class="headerlink" title="2.1 为什么单一结构不行？"></a>2.1 为什么单一结构不行？</h4><ul>
<li><strong>只用哈希表</strong>：查询快 $O(1)$，但不知道谁最老（没顺序）。</li>
<li><strong>只用链表</strong>：能维持顺序（新的放头，老的在尾），但查询慢 $O(N)$。</li>
</ul>
<h4 id="2-2-核心设计：哈希链表-Hash-Linked-List"><a href="#2-2-核心设计：哈希链表-Hash-Linked-List" class="headerlink" title="2.2 核心设计：哈希链表 (Hash Linked List)"></a>2.2 核心设计：哈希链表 (Hash Linked List)</h4><p>我们需要把它们结合起来：</p>
<ol>
<li><strong>双向链表 (Doubly Linked List)</strong>：用来维护数据的<strong>时间顺序</strong>。<ul>
<li>规定：<strong>链表头部</strong>存最近使用的，<strong>链表尾部</strong>存最久未使用的。</li>
<li>当数据被访问（Get）或更新（Put）时，把它移到链表头部。</li>
<li>当容量满时，直接删除链表尾部的节点。</li>
<li><em>为什么是双向？</em> 因为我们需要在 $O(1)$ 时间内删除任意一个节点，单向链表删除需要遍历找前驱，是 $O(N)$。</li>
</ul>
</li>
<li><strong>哈希表 (Hash Map)</strong>：用来实现 $O(1)$ 的<strong>查询</strong>。<ul>
<li>Key: 题目给的 <code>key</code>。</li>
<li>Value: 指向链表中对应 <strong>节点 (Node)</strong> 的指针。</li>
<li>这样我们就能直接通过 Key 找到链表里的节点，不需要遍历链表。</li>
</ul>
</li>
</ol>
<p>[LRU Cache Hash Map + Doubly Linked List Diagram]</p>
<ul>
<li><strong>HashMap</strong>: <code>&#123;1: NodeA, 2: NodeB&#125;</code></li>
<li><strong>LinkedList</strong>: <code>Head &lt;-&gt; NodeA(1,1) &lt;-&gt; NodeB(2,2) &lt;-&gt; Tail</code></li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这道题代码量较大，建议手写一个简单的 <code>Node</code> 结构体，并封装 <code>removeNode</code> 和 <code>addToHead</code> 两个核心函数，这样逻辑会非常清晰。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义双向链表的节点</span><br><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    // 构造函数</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    // 哈希表：Key -&gt; 链表节点指针</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    // 虚拟头尾节点，方便操作，避免处理空链表的边界情况</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity) : capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 初始化虚拟头尾节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 【核心操作 1】 get</span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果存在，先通过哈希表定位到节点</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        // 因为被访问了，所以要移动到头部（最近使用）</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 【核心操作 2】 put</span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新节点</span><br><span class="line">            DLinkedNode* newNode = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = newNode;</span><br><span class="line">            // 添加到链表头部</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            </span><br><span class="line">            // 如果容量超了，淘汰尾部</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 找到最久未使用的节点（尾部的前一个）</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 从哈希表中移除</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 释放内存</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果 key 存在，更新 value</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            // 移动到头部</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // === 辅函数：双向链表的基本操作 ===</span><br><span class="line"></span><br><span class="line">    // 将节点添加到头部（虚拟头节点之后）</span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除任意一个节点</span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移动节点到头部 = 先删除 + 再添加到头部</span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除尾部节点（淘汰最久未使用的）</span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* res = tail-&gt;prev; // 真正的最后一个节点</span><br><span class="line">        removeNode(res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-1"><a href="#时间复杂度：-O-1" class="headerlink" title="时间复杂度：$O(1)$"></a><strong>时间复杂度：$O(1)$</strong></h4><ul>
<li><code>get</code>: 哈希查找是 $O(1)$，链表移动节点是 $O(1)$。</li>
<li><code>put</code>: 哈希插入&#x2F;删除是 $O(1)$，链表插入&#x2F;删除节点是 $O(1)$。</li>
<li>完美符合题目要求。</li>
</ul>
<h4 id="空间复杂度：-O-capacity"><a href="#空间复杂度：-O-capacity" class="headerlink" title="空间复杂度：$O(capacity)$"></a><strong>空间复杂度：$O(capacity)$</strong></h4><ul>
<li>我们需要存储最多 <code>capacity</code> 个节点，哈希表和链表都需要这么多空间。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 <code>Node</code> 里既要存 <code>value</code> 也要存 <code>key</code>？只存 <code>value</code> 不行吗？</strong><ul>
<li><strong>A:</strong> 这是一个非常关键的细节！</li>
<li>当缓存满时，我们删除了链表尾部的节点 <code>node</code>。</li>
<li>此时，我们也必须从哈希表 <code>cache</code> 中把对应的记录删掉。</li>
<li>可是哈希表的 API 是 <code>cache.erase(key)</code>。如果我们手里的 <code>node</code> 只有 <code>value</code>，我们怎么知道它的 <code>key</code> 是多少？</li>
<li>所以节点里必须存 <code>key</code>，主要是为了<strong>反向查找</strong>哈希表并删除。</li>
</ul>
</li>
<li><strong>Q: 为什么可以用 <code>std::list</code> 吗？</strong><ul>
<li><strong>A:</strong> 可以。C++ 的 <code>std::list</code> 就是双向链表。</li>
<li>用 <code>std::list</code> 代码会短很多，但是面试官通常希望看你手写双向链表的操作（考察基本功）。</li>
<li>另外，<code>std::list</code> 的迭代器操作稍微复杂一点，手写 <code>Node</code> 结构反而逻辑更直观。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>15三数之和</title>
    <url>/2025/11/13/Hot100/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p>
<p>题目：<br>给你一个整数数组 <code>nums</code>，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足：</p>
<ul>
<li><code>i != j</code>、<code>i != k</code>、<code>j != k</code></li>
<li><code>nums[i] + nums[j] + nums[k] == 0</code></li>
</ul>
<p>请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10⁵ &lt;= nums[i] &lt;= 10⁵</code></li>
</ul>
<p>这就是我刚才提到的“数组算法守门员”——<strong>三数之和 (3Sum)</strong>。</p>
<p>如果说“两数之和”是幼儿园，“移动零”是小学，“盛最多水的容器”是中学，那么这道“三数之和”就是<strong>大学入学考试</strong>。</p>
<p>它之所以难，不是因为算法复杂，而是因为它对**边界情况（Corner Cases）<strong>和</strong>去重（De-duplication）**的处理要求非常高。很多初学者写出的代码要么超时，要么输出了一堆重复的结果。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：三数之和 (3Sum)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code>，判断是否存在三个元素 $a, b, c$ ，使得 $a + b + c &#x3D; 0$。请你找出所有满足条件且<strong>不重复</strong>的三元组。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>不重复</strong>：结果集里不能包含相同的组合。例如 <code>[-1, 0, 1]</code> 和 <code>[0, 1, -1]</code> 被视为同一个结果，只能保留一份。</li>
<li>时间复杂度：暴力法是 $O(n^3)$，这里我们需要优化到 <strong>$O(n^2)$</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [-1, 0, 1, 2, -1, -4]</code></p>
<p>输出：<code>[[-1, -1, 2], [-1, 0, 1]]</code></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-降维打击：化繁为简"><a href="#2-1-降维打击：化繁为简" class="headerlink" title="2.1 降维打击：化繁为简"></a>2.1 降维打击：化繁为简</h4><p>我们要找 $a + b + c &#x3D; 0$。</p>
<p>如果我们<strong>固定</strong>其中一个数（假设是 $a$），那么问题就变成了：</p>
<blockquote>
<p>在剩下的数中，找到两个数 $b$ 和 $c$，使得 $b + c &#x3D; -a$。</p>
</blockquote>
<p>是不是很眼熟？没错！这就变成了一个 <strong>“两数之和”</strong> 的问题。</p>
<p>既然我们需要遍历每一个数作为 $a$，如果对于每个 $a$ 都跑一遍 $O(n)$ 的两数之和算法，总复杂度就是 $O(n^2)$。这符合预期。</p>
<h4 id="2-2-为什么必须先排序？"><a href="#2-2-为什么必须先排序？" class="headerlink" title="2.2 为什么必须先排序？"></a>2.2 为什么必须先排序？</h4><p>对于“两数之和”，我们用的是哈希表。但在“三数之和”里，<strong>哈希表很难处理“不重复”这个要求</strong>。</p>
<p>（比如 <code>[-1, -1, 2]</code>，哈希表很难判断这次的 <code>-1</code> 和上次的 <code>-1</code> 组成的结果是不是重复的）。</p>
<p><strong>排序的威力</strong>：</p>
<ol>
<li><strong>去重容易</strong>：相同的数字排在了一起。如果我们刚才处理了 <code>nums[i]</code>，发现 <code>nums[i+1]</code> 和它一样，那直接跳过 <code>nums[i+1]</code> 就行了，因为它能找到的组合，<code>nums[i]</code> 肯定都已经找过了。</li>
<li><strong>双指针更高效</strong>：有序数组找两数之和，不需要哈希表，直接用<strong>左右指针</strong>（类似“盛最多水的容器”的逻辑）夹逼即可。</li>
</ol>
<h4 id="2-3-算法流程-双指针法"><a href="#2-3-算法流程-双指针法" class="headerlink" title="2.3 算法流程 (双指针法)"></a>2.3 算法流程 (双指针法)</h4><ol>
<li><strong>排序</strong>：将数组从小到大排序。</li>
<li><strong>遍历</strong>：用指针 <code>i</code> 遍历数组，<code>nums[i]</code> 就是我们固定的第一个数 $a$。</li>
<li><strong>双指针</strong>：令 <code>left = i + 1</code>，<code>right = n - 1</code>。<ul>
<li>计算 <code>sum = nums[i] + nums[left] + nums[right]</code>。</li>
<li>如果 <code>sum == 0</code>：<strong>找到啦！</strong> 记录答案。然后 <code>left</code> 右移，<code>right</code> 左移（继续找这组 $a$ 下的其他可能）。</li>
<li>如果 <code>sum &lt; 0</code>：太小了，<code>left</code> 右移（让数变大）。</li>
<li>如果 <code>sum &gt; 0</code>：太大了，<code>right</code> 左移（让数变小）。</li>
</ul>
</li>
<li><strong>去重（最核心的细节）</strong>：<ul>
<li><strong>针对 <code>i</code> 的去重</strong>：如果 <code>nums[i] == nums[i-1]</code>，说明这个基准数刚才用过了，直接 <code>continue</code>。</li>
<li><strong>针对 <code>left</code> 和 <code>right</code> 的去重</strong>：找到一组答案后，如果 <code>nums[left]</code> 和下一位一样，继续右移；<code>right</code> 同理。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        </span><br><span class="line">        // 特判：如果不到3个数，根本凑不出，直接返回</span><br><span class="line">        if (n &lt; 3) return result;</span><br><span class="line"></span><br><span class="line">        // 1. 排序：这是使用双指针的前提，也是去重的基础</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        // 2. 遍历第一个数 nums[i]</span><br><span class="line">        for (int i = 0; i &lt; n - 2; ++i) &#123; // i 只需要走到倒数第3个位置</span><br><span class="line">            </span><br><span class="line">            // 【剪枝优化】</span><br><span class="line">            // 如果当前的数已经大于 0，因为数组是有序的，</span><br><span class="line">            // 后面的数肯定也都大于 0，加起来不可能等于 0，直接结束。</span><br><span class="line">            if (nums[i] &gt; 0) break;</span><br><span class="line"></span><br><span class="line">            // 【i 的去重】</span><br><span class="line">            // 如果当前数和前一个数相同，说明已经处理过这个数作为第一个数的情况了，跳过</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</span><br><span class="line"></span><br><span class="line">            // 3. 双指针寻找另外两个数</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = n - 1;</span><br><span class="line"></span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                if (sum == 0) &#123;</span><br><span class="line">                    // 找到一组解，加入结果集</span><br><span class="line">                    result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    // 【left 和 right 的去重】</span><br><span class="line">                    // 找到了解之后，我们需要移动指针寻找下一组可能的解。</span><br><span class="line">                    // 在移动之前，必须跳过所有重复的元素，否则会产生重复结果。</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line"></span><br><span class="line">                    // 跳过重复值后，双指针同时收缩</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; </span><br><span class="line">                else if (sum &lt; 0) &#123;</span><br><span class="line">                    // 和太小，让 left 变大</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; </span><br><span class="line">                else &#123; // sum &gt; 0</span><br><span class="line">                    // 和太大，让 right 变小</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n-2"><a href="#时间复杂度：-O-n-2" class="headerlink" title="时间复杂度：$O(n^2)$"></a><strong>时间复杂度：$O(n^2)$</strong></h4><ul>
<li><strong>排序</strong>：$O(n \log n)$。</li>
<li><strong>双层循环</strong>：<ul>
<li>外层循环遍历 <code>i</code>，次数为 $n$。</li>
<li>内层 <code>while</code> 循环双指针从两端向中间走，复杂度是 $O(n)$。</li>
<li>嵌套起来是 $n \times n &#x3D; O(n^2)$。</li>
</ul>
</li>
<li>总复杂度是 $O(n^2) + O(n \log n)$，舍去低阶项，最终为 <strong>$O(n^2)$</strong>。这是该题目前已知的最优解法。</li>
</ul>
<h4 id="空间复杂度：-O-1-不考虑输出占用的空间"><a href="#空间复杂度：-O-1-不考虑输出占用的空间" class="headerlink" title="空间复杂度：$O(1)$ (不考虑输出占用的空间)"></a><strong>空间复杂度：$O(1)$</strong> (不考虑输出占用的空间)</h4><ul>
<li>除了存储结果的 <code>result</code> 数组外，我们只使用了常数个变量 (<code>i</code>, <code>left</code>, <code>right</code>, <code>sum</code>)。</li>
<li><em>注：C++ 标准库的 <code>sort</code> 实现（通常是 Introsort）可能会用到 $O(\log n)$ 的栈空间。</em></li>
</ul>
<hr>
<h3 id="5-初学者避坑指南-Debug-常见错误"><a href="#5-初学者避坑指南-Debug-常见错误" class="headerlink" title="5. 初学者避坑指南 (Debug 常见错误)"></a>5. 初学者避坑指南 (Debug 常见错误)</h3><ol>
<li><strong>忘记排序</strong>：不排序，双指针逻辑完全失效，去重也无法完成。</li>
<li><strong><code>i</code> 的去重写错了位置</strong>：<ul>
<li>错误写法：<code>if (nums[i] == nums[i+1]) continue;</code></li>
<li><strong>后果</strong>：会漏掉结果。比如 <code>[-1, -1, 2]</code>，如果跳过了第一个 <code>-1</code>，这组解就找不到了。</li>
<li><strong>正确写法</strong>：<code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1])</code>。意思是“我<strong>只要第一个</strong>出现的 <code>-1</code>，后面重复出现的 <code>-1</code> 我都不要”。</li>
</ul>
</li>
<li><strong>找到答案后忘记去重并移动指针</strong>：<ul>
<li>很多同学写了 <code>result.push_back(...)</code> 后直接写 <code>left++</code>。</li>
<li>如果有 <code>[-2, 0, 0, 2, 2]</code>，找到 <code>[-2, 0, 2]</code> 后，如果不跳过中间的重复 <code>0</code>，下一次循环还会再找到一次 <code>[-2, 0, 2]</code>，导致结果重复。</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2025/11/13/Hot100/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<p>题目：<br>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; []<br>输出：[]</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; [1]<br>输出：[1]</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 100]</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是链表操作中的**“微操大师”**训练。</p>
<p>它不再像“反转链表”那样大刀阔斧地改变整条链的方向，而是要求你精细地、两两一组地进行局部反转。这道题极其考验你对<strong>指针顺序</strong>的把控能力，稍有不慎就会断链（Memory Leak）或成环。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：两两交换链表中的节点 (Swap Nodes in Pairs)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。</p>
<ul>
<li><strong>要求</strong>：你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</li>
<li><strong>空间复杂度</strong>：$O(1)$（这意味着尽量不要用递归，而是用迭代）。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>1 -&gt; 2 -&gt; 3 -&gt; 4</code></p>
<p>输出：<code>2 -&gt; 1 -&gt; 4 -&gt; 3</code></p>
<p>输入：<code>1 -&gt; 2 -&gt; 3</code></p>
<p>输出：<code>2 -&gt; 1 -&gt; 3</code> （最后剩一个 3，不用换）</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么容易晕？"><a href="#2-1-为什么容易晕？" class="headerlink" title="2.1 为什么容易晕？"></a>2.1 为什么容易晕？</h4><p>假设我们要交换 <code>1</code> 和 <code>2</code>。</p>
<ul>
<li>仅仅把 <code>1-&gt;next</code> 改成 <code>3</code>，把 <code>2-&gt;next</code> 改成 <code>1</code> 是不够的。</li>
<li><strong>关键在于</strong>：谁指向 <code>1</code>？（前面的节点必须指向新的头 <code>2</code>）。</li>
<li>如果 <code>1</code> 是头节点，头指针要变；如果 <code>1</code> 在中间，前驱节点的 <code>next</code> 要变。</li>
</ul>
<h4 id="2-2-核心神器：虚拟头节点-Dummy-Head"><a href="#2-2-核心神器：虚拟头节点-Dummy-Head" class="headerlink" title="2.2 核心神器：虚拟头节点 (Dummy Head)"></a>2.2 核心神器：虚拟头节点 (Dummy Head)</h4><p>为了避免处理“头节点变了”这种特殊情况，我们依然祭出 <strong>Dummy Node</strong>。</p>
<p>让 <code>dummy</code> 指向 <code>1</code>。这样 <code>1</code> 和 <code>2</code> 就变成了“普通的中间节点”，逻辑完全统一。</p>
<h4 id="2-3-操作步骤-三步走"><a href="#2-3-操作步骤-三步走" class="headerlink" title="2.3 操作步骤 (三步走)"></a>2.3 操作步骤 (三步走)</h4><p>设我们要交换 <code>node1</code> 和 <code>node2</code>，它们的前驱是 <code>prev</code>。</p>
<p>初始状态：<code>prev -&gt; node1 -&gt; node2 -&gt; nextNode</code></p>
<p>我们需要把线重新接成：<code>prev -&gt; node2 -&gt; node1 -&gt; nextNode</code></p>
<p><strong>步骤详解</strong>：</p>
<ol>
<li><strong>控制前驱</strong>：<code>prev-&gt;next = node2</code> （让前驱指向 2）</li>
<li><strong>回马枪</strong>：<code>node2-&gt;next = node1</code> （让 2 指回 1）</li>
<li><strong>接续后续</strong>：<code>node1-&gt;next = nextNode</code> （让 1 指向后面的 3）</li>
</ol>
<p>做完这三步后，原来的 <code>node1</code> 变成了这组的尾巴。</p>
<p><strong>下一步准备</strong>：将 <code>prev</code> 指针移动到 <code>node1</code>，准备处理下一组。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这里提供 <strong>迭代法 (Iterative)</strong> 的实现，因为这才是真正的 $O(1)$ 空间复杂度。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        // 1. 创建虚拟头节点</span><br><span class="line">        // 它的 next 指向 head，这样无论 head 怎么换，result 始终是 dummy-&gt;next</span><br><span class="line">        ListNode* dummy = new ListNode(-1);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        // prev 指针：永远指向【待交换的两个节点】的前一个节点</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line"></span><br><span class="line">        // 2. 循环条件：必须后面至少还有两个节点，才能交换</span><br><span class="line">        // prev-&gt;next 是第一个节点 (node1)</span><br><span class="line">        // prev-&gt;next-&gt;next 是第二个节点 (node2)</span><br><span class="line">        while (prev-&gt;next != nullptr &amp;&amp; prev-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            // 定义临时指针，方便操作</span><br><span class="line">            ListNode* node1 = prev-&gt;next;</span><br><span class="line">            ListNode* node2 = prev-&gt;next-&gt;next;</span><br><span class="line">            ListNode* nextNode = node2-&gt;next; // 暂存下一轮的开头 (比如 3)</span><br><span class="line"></span><br><span class="line">            // === 核心交换逻辑 (三步走) ===</span><br><span class="line">            </span><br><span class="line">            // Step 1: 前驱指向第二个节点</span><br><span class="line">            prev-&gt;next = node2;</span><br><span class="line">            </span><br><span class="line">            // Step 2: 第二个节点指向第一个节点</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            </span><br><span class="line">            // Step 3: 第一个节点指向后续节点</span><br><span class="line">            node1-&gt;next = nextNode;</span><br><span class="line"></span><br><span class="line">            // === 准备下一轮 ===</span><br><span class="line">            // 此时顺序变成了 prev -&gt; 2 -&gt; 1 -&gt; 3</span><br><span class="line">            // 下一轮我们要处理 3 和 4，所以 prev 应该站在 1 的位置</span><br><span class="line">            prev = node1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取结果</span><br><span class="line">        ListNode* result = dummy-&gt;next;</span><br><span class="line">        delete dummy; // 释放 dummy 内存</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们遍历了链表一次，每次处理两个节点。</li>
<li>总操作次数是 $N&#x2F;2$ 次交换，线性复杂度。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只用了 <code>dummy</code>, <code>prev</code>, <code>node1</code>, <code>node2</code> 等几个指针变量，没有使用递归栈或额外数组。</li>
</ul>
<hr>
<h3 id="5-进阶对比：递归写法-Recursive"><a href="#5-进阶对比：递归写法-Recursive" class="headerlink" title="5. 进阶对比：递归写法 (Recursive)"></a>5. 进阶对比：递归写法 (Recursive)</h3><p>虽然题目推荐 $O(1)$ 空间，但递归写法非常简洁，逻辑也很优美，适合在面试中展示思维。</p>
<p><strong>递归逻辑</strong>：</p>
<blockquote>
<p>“我只负责交换前两个节点，剩下的链表交给递归函数去处理，处理完把新的头节点还给我，我接在屁股后面。”</p>
</blockquote>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 递归版本（代码极短）</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        // 终止条件：没有节点或只有一个节点，无法交换，直接返回</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 定义 node1 和 node2</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        ListNode* node2 = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 递归处理后续部分 (比如 3-&gt;4-&gt;...)</span><br><span class="line">        // 递归函数会返回交换好的后续链表的头 (比如 4)</span><br><span class="line">        ListNode* newHeadOfRest = swapPairs(node2-&gt;next);</span><br><span class="line"></span><br><span class="line">        // 当前层交换</span><br><span class="line">        node2-&gt;next = node1;      // 2 指向 1</span><br><span class="line">        node1-&gt;next = newHeadOfRest; // 1 指向后面换好的部分</span><br><span class="line"></span><br><span class="line">        // 返回当前层的头 (也就是 2)</span><br><span class="line">        return node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>注意：递归版本的空间复杂度是 $O(N)$，因为递归调用栈的深度是 $N&#x2F;2$。</em></p>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 交换顺序有讲究吗？</strong><ul>
<li><strong>A:</strong> 有！必须先保存 <code>nextNode</code>（或者 <code>node2</code>）。如果你上来就写 <code>node1-&gt;next = node2-&gt;next</code>，那么 <code>node2</code> 本身的地址可能就找不到了（如果没提前存 <code>node2</code>），或者链表断开后无法访问后续节点。<strong>保存现场</strong>是链表操作的第一准则。</li>
</ul>
</li>
<li><strong>Q: 循环条件 <code>prev-&gt;next &amp;&amp; prev-&gt;next-&gt;next</code> 顺序能反吗？</strong><ul>
<li><strong>A:</strong> 不能。必须先判断 <code>prev-&gt;next</code> (第一个节点) 存在，才能去访问 <code>prev-&gt;next-&gt;next</code> (第二个节点)。如果第一个都不存在，访问第二个会直接报空指针异常 (Segmentation Fault)。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1两数之和</title>
    <url>/2025/11/13/Hot100/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<p>题目：<br>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个整数</strong>，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10⁴</code></li>
<li><code>-10⁹ &lt;= nums[i] &lt;= 10⁹</code></li>
<li><code>-10⁹ &lt;= target &lt;= 10⁹</code></li>
<li>只会存在一个有效答案</li>
</ul>
<p>作为力扣（LeetCode）Hot 100 系列的第一题，“两数之和”（Two Sum）是无数程序员算法之路的起点。它虽然看似简单，但蕴含了算法设计中非常核心的思想——<strong>空间换时间</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：两数之和 (Two Sum)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>。请你在该数组中找出 <strong>和</strong> 为目标值 <code>target</code> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p><strong>约束条件</strong>：</p>
<ul>
<li>你可以假设每种输入只会对应一个答案。</li>
<li>但是，数组中同一个元素在答案里不能重复出现（即不能使用下标 <code>i</code> 两次来凑出 <code>target</code>）。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code></p>
<p>输出：<code>[0, 1]</code> （因为 <code>nums[0] + nums[1] == 9</code>）</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力解法不够好？"><a href="#2-1-为什么暴力解法不够好？" class="headerlink" title="2.1 为什么暴力解法不够好？"></a>2.1 为什么暴力解法不够好？</h4><p>最直观的想法是<strong>双重循环</strong>：</p>
<ol>
<li>我先拿第 1 个数，去和后面剩下的数一个个加，看等不等于 <code>target</code>。</li>
<li>如果不成，我再拿第 2 个数，和后面的加……</li>
<li>以此类推。</li>
</ol>
<p><strong>问题在于</strong>：这种做法的时间复杂度是 $O(n^2)$。如果数组有一万个数字，运算次数就是亿级别的，这在算法竞赛或面试中通常会被判定为“超时”或“不够高效”。</p>
<h4 id="2-2-优化的关键：哈希表-Hash-Map"><a href="#2-2-优化的关键：哈希表-Hash-Map" class="headerlink" title="2.2 优化的关键：哈希表 (Hash Map)"></a>2.2 优化的关键：哈希表 (Hash Map)</h4><p>我们需要思考：在遍历数组时，当我们拿到一个数字 <code>x</code>（比如 <code>nums[i]</code>），我们要找的是什么？</p>
<p>我们要找的是是否存在另一个数字 <code>y</code>，使得 <code>x + y = target</code>。</p>
<p>换句话说，我们要找 <strong><code>y = target - x</code></strong> 是否已经在数组里出现过。</p>
<p><strong>核心观察</strong>：</p>
<p>如果我们有一个“记事本”，在遍历数组时，把<strong>遍历过的数字</strong>和它的<strong>下标</strong>记下来。那么，当我们遇到一个新的数字 <code>x</code> 时，只需要立刻问“记事本”：</p>
<blockquote>
<p>“嘿，你那里有没有一个叫 <code>target - x</code> 的数字？”</p>
</blockquote>
<ul>
<li><strong>如果有</strong>：太好了！现在的下标是 <code>i</code>，“记事本”里的下标是 <code>j</code>，答案就是 <code>[j, i]</code>。</li>
<li><strong>如果没有</strong>：把当前的数字 <code>x</code> 和下标 <code>i</code> 记入“记事本”，继续往后找。</li>
</ul>
<p><strong>为什么选择哈希表（unordered_map）？</strong></p>
<ul>
<li>数组查找一个数需要 $O(n)$ 的时间。</li>
<li><strong>哈希表查找一个数只需要 $O(1)$ 的平均时间</strong>。</li>
<li>通过引入哈希表，我们将查找的时间从线性压缩到了常数级别，这就是经典的<strong>空间换时间</strong>策略。</li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt; // 包含所有标准库，方便刷题</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // 创建哈希表</span><br><span class="line">        // Key（键）: 存储数字本身 (nums[i])</span><br><span class="line">        // Value（值）: 存储该数字对应的下标 (i)</span><br><span class="line">        unordered_map&lt;int, int&gt; visited;</span><br><span class="line"></span><br><span class="line">        // 遍历数组</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            // 当前数字是 nums[i]</span><br><span class="line">            // 我们需要的另一半数字是 need</span><br><span class="line">            int need = target - nums[i];</span><br><span class="line"></span><br><span class="line">            // 1. 查询哈希表：之前是否出现过 need 这个数字？</span><br><span class="line">            // visited.count() 在 C++ 中用于检查键是否存在，时间复杂度平均 O(1)</span><br><span class="line">            if (visited.count(need)) &#123;</span><br><span class="line">                // 如果存在，说明找到了！</span><br><span class="line">                // visited[need] 是之前存进去的下标</span><br><span class="line">                // i 是当前的下标</span><br><span class="line">                return &#123;visited[need], i&#125;; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2. 如果没找到，将当前数字和下标存入哈希表</span><br><span class="line">            // 为后续的数字提供匹配机会</span><br><span class="line">            visited[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 题目保证一定有解，所以这里实际上不会执行，</span><br><span class="line">        // 但为了代码完整性返回一个空数组</span><br><span class="line">        return &#123;&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><p>为了确保这份代码能够通过并通过得漂亮，我们进行严格的复杂度体检：</p>
<h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们只遍历了数组一次，循环次数是 $n$。</li>
<li>在循环内部，哈希表的查找（<code>count</code>）和插入操作平均时间复杂度都是 $O(1)$。</li>
<li>总耗时：$n \times O(1) &#x3D; O(n)$。这比暴力解法的 $O(n^2)$ 快得多。</li>
</ul>
<h4 id="空间复杂度：-O-n"><a href="#空间复杂度：-O-n" class="headerlink" title="空间复杂度：$O(n)$"></a><strong>空间复杂度：$O(n)$</strong></h4><ul>
<li>我们需要一个哈希表来存储信息。</li>
<li>在最坏的情况下（比如目标对在数组的最后两个位置），我们需要把前 $n-1$ 个元素都存入哈希表。</li>
<li>所以空间消耗取决于数组的长度，为 $O(n)$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要用 <code>unordered_map</code> 而不是 <code>map</code>？</strong><ul>
<li><strong>A:</strong> 在 C++ 中，<code>map</code> 底层是红黑树（平衡二叉树），查找复杂度是 $O(\log n)$；而 <code>unordered_map</code> 底层是哈希表，查找平均复杂度是 $O(1)$。对于这道题，我们只关心“有没有”，不关心顺序，所以 <code>unordered_map</code> 更快。</li>
</ul>
</li>
<li><strong>Q: 如果数组里有重复的数字怎么办？比如 <code>[3, 3]</code>, target&#x3D;6？</strong><ul>
<li><strong>A:</strong> 算法依然有效。<ol>
<li>遇到第一个 <code>3</code>：哈希表里没找到 <code>3</code> (即 6-3)，把 <code>&#123;3: 0&#125;</code> 存进去。</li>
<li>遇到第二个 <code>3</code>：计算 <code>need = 6 - 3 = 3</code>。去哈希表找，发现 <code>3</code> 存在（下标 0）。</li>
<li>返回 <code>[0, 1]</code>。完美解决。</li>
</ol>
</li>
</ul>
</li>
<li><strong>Q: 为什么要先查询再插入？</strong><ul>
<li><strong>A:</strong> 这是一个很棒的细节！题目要求“数组中同一个元素不能使用两遍”。如果我们先插入当前元素，再查询 <code>target - nums[i]</code>，如果是 <code>target = 6</code> 且 <code>nums[i] = 3</code>，可能会误把自己刚刚存进去的 3 当作答案。<strong>“先查后存”能完美避开自己匹配自己的情况。</strong></li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2025/11/13/Hot100/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p>
<p>题目：<br>给你两个 <strong>非空</strong> 的链表，表示两个非负整数。数字以<strong>逆序</strong>存储在链表中，每一位数字对应一个节点。</p>
<p>请你将这两个数相加，并返回一个新的链表来表示它们的和。</p>
<p><strong>示例 1：</strong><br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807。</p>
<p><strong>示例 2：</strong><br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p>
<p><strong>示例 3：</strong><br>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[1, 100]</code></li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>它保证两个输入数字不包含前导零</li>
</ul>
<p>这道题是力扣（LeetCode）第 2 题 <strong>“两数相加” (Add Two Numbers)</strong>。</p>
<p>它虽然是链表题，但本质上是在模拟我们小学数学课上学的 <strong>“竖式加法”</strong>。</p>
<p>这道题非常适合练习 <strong>链表遍历</strong> 和 <strong>进位逻辑</strong> 的处理。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：两数相加 (Add Two Numbers)</p>
<p><strong>题目大意</strong>：</p>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>逆序存储</strong>：个位在链表头，十位在第二个… 这其实是<strong>天大的好事</strong>！这意味着我们遍历链表的方向，刚好和我们做加法的方向（从低位到高位）是一致的。</li>
<li><strong>进位</strong>：相加如果超过 10，需要向后一个节点进位。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>l1 = [2, 4, 3]</code>, <code>l2 = [5, 6, 4]</code></p>
<p>含义：$342 + 465 &#x3D; 807$</p>
<p>输出：<code>[7, 0, 8]</code> (代表 807)</p>
<p>解释：</p>
<ul>
<li>个位：$2 + 5 &#x3D; 7$</li>
<li>十位：$4 + 6 &#x3D; 10$ (留 0，进 1)</li>
<li>百位：$3 + 4 + 1(\text{进位}) &#x3D; 8$</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-模拟竖式加法"><a href="#2-1-模拟竖式加法" class="headerlink" title="2.1 模拟竖式加法"></a>2.1 模拟竖式加法</h4><p>我们需要同时遍历两个链表 <code>l1</code> 和 <code>l2</code>。</p>
<p>对于每一个位置，我们计算：</p>
<p>$$\text{sum} &#x3D; \text{val1} + \text{val2} + \text{carry}$$</p>
<p>其中 <code>carry</code> 是上一轮运算留下来的进位（初始为 0）。</p>
<ul>
<li><strong>当前位的值</strong>：<code>sum % 10</code> （我们要创建一个新节点存这个值）。</li>
<li><strong>新的进位</strong>：<code>sum / 10</code> （留给下一轮使用）。</li>
</ul>
<h4 id="2-2-痛点解决：长短不一怎么办？"><a href="#2-2-痛点解决：长短不一怎么办？" class="headerlink" title="2.2 痛点解决：长短不一怎么办？"></a>2.2 痛点解决：长短不一怎么办？</h4><p>两个链表长度可能不一样，比如 <code>99</code> + <code>1</code>。</p>
<ul>
<li>当一个链表走完（变 <code>NULL</code>）而另一个还没走完时，我们不能停。</li>
<li><strong>技巧</strong>：如果某个链表已经走到头了，我们就当它那个位置的数字是 <strong>0</strong>。</li>
</ul>
<h4 id="2-3-容易被遗忘的边界：最后的进位"><a href="#2-3-容易被遗忘的边界：最后的进位" class="headerlink" title="2.3 容易被遗忘的边界：最后的进位"></a>2.3 容易被遗忘的边界：最后的进位</h4><p>如果算到最后，<code>l1</code> 完了，<code>l2</code> 也完了，但是 <code>carry</code> 还是 1 怎么办？</p>
<p>比如 <code>5 + 5</code>。</p>
<ul>
<li>第一轮：$5+5&#x3D;10$，存 0，<code>carry=1</code>。</li>
<li>链表结束了？不行！</li>
<li>我们需要<strong>再补一个节点</strong>存最后的 <code>1</code>。结果是 <code>[0, 1]</code>。</li>
</ul>
<p><strong>通用循环条件</strong>：</p>
<p>只要 <code>l1</code> 没走完 <strong>或者</strong> <code>l2</code> 没走完 <strong>或者</strong> <code>carry</code> 不为 0，循环就得继续！</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        // 1. 创建虚拟头节点 (Dummy Head)</span><br><span class="line">        // 它可以让我们省去处理“头节点为空”的特殊判断，最后返回 dummy-&gt;next 即可</span><br><span class="line">        ListNode* dummy = new ListNode(0);</span><br><span class="line">        ListNode* curr = dummy; // curr 指针用来构建新链表</span><br><span class="line"></span><br><span class="line">        int carry = 0; // 记录进位</span><br><span class="line"></span><br><span class="line">        // 2. 核心循环</span><br><span class="line">        // 只要还有没处理完的节点，或者还有进位，就继续</span><br><span class="line">        while (l1 != nullptr || l2 != nullptr || carry != 0) &#123;</span><br><span class="line">            </span><br><span class="line">            // 获取当前位的值，如果链表已空则视为 0</span><br><span class="line">            int x = (l1 != nullptr) ? l1-&gt;val : 0;</span><br><span class="line">            int y = (l2 != nullptr) ? l2-&gt;val : 0;</span><br><span class="line"></span><br><span class="line">            // 计算当前位的总和</span><br><span class="line">            int sum = x + y + carry;</span><br><span class="line"></span><br><span class="line">            // 更新进位 (比如 sum=15, carry=1)</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            </span><br><span class="line">            // 创建新节点存储个位数 (sum=15, val=5)</span><br><span class="line">            curr-&gt;next = new ListNode(sum % 10);</span><br><span class="line">            </span><br><span class="line">            // 指针移动</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            </span><br><span class="line">            if (l1 != nullptr) l1 = l1-&gt;next;</span><br><span class="line">            if (l2 != nullptr) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回结果（跳过 dummy 节点）</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-max-M-N"><a href="#时间复杂度：-O-max-M-N" class="headerlink" title="时间复杂度：$O(\max(M, N))$"></a><strong>时间复杂度：$O(\max(M, N))$</strong></h4><ul>
<li>$M$ 和 $N$ 分别是两个链表的长度。</li>
<li>我们要遍历较长的那个链表一遍。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>如果不计算存储结果所用的空间（返回值所需的链表），我们只用了常数个变量。</li>
<li>如果计算结果链表，空间是 $O(\max(M, N))$，因为结果链表的长度最多比长链表多 1 位。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么不用把链表转成 <code>int</code> 或者 <code>long long</code> 加完再转回去？</strong><ul>
<li><strong>A:</strong> 这是一个陷阱！链表的长度可能非常长（比如 100 个节点），这代表一个 100 位的整数。任何 <code>long long</code> 都存不下这么大的数（溢出）。所以必须一位一位地加。</li>
</ul>
</li>
<li><strong>Q: 如果题目给的是“正序”存储（高位在头）怎么办？</strong><ul>
<li><strong>A:</strong> 那难度就升级了（这是力扣 445 题）。</li>
<li>方法一：先把两个链表<strong>反转</strong>，然后用这一题的代码，算完再反转回去。</li>
<li>方法二：利用<strong>栈 (Stack)</strong>。把两个链表压入栈，利用栈“后进先出”的特性，从个位开始弹出来相加。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>230. 二叉搜索树中第 K 小的元素</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></p>
<p>题目：<br>给定一个二叉搜索树的根节点 <code>root</code> 和一个整数 <code>k</code>，请你返回树中第 <code>k</code> 小的值。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>输出：1</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>输出：3</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 10⁴]</code></li>
<li><code>0 &lt;= k &lt;= 树中节点总数</code></li>
<li><code>1 &lt;= Node.val &lt;= 10⁴</code></li>
</ul>
<p>这道题是 <strong>二叉搜索树 (BST)</strong> 性质的教科书级应用。</p>
<p>它是力扣（LeetCode）第 230 题。</p>
<p>这道题不需要你发明什么新算法，它只需要你记住一句话：</p>
<blockquote>
<p><strong>二叉搜索树的中序遍历 (In-order Traversal) 结果是一个有序数组。</strong></p>
</blockquote>
<p>只要掌握了这句话，这道题瞬间就变成了：“在一个有序数组中找第 K 个元素”。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉搜索树中第 K 小的元素 (Kth Smallest Element in a BST)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉搜索树的根节点 <code>root</code> 和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小的元素（从 1 开始计数）。</p>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>

<p>输入：<code>root = [3, 1, 4, null, 2]</code>, <code>k = 1</code></p>
<p>输出：<code>1</code></p>
<p>输入：同上，<code>k = 3</code></p>
<p>输出：<code>3</code> (顺序是 1, 2, 3, 4，第 3 个是 3)</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-笨办法：存下来再找"><a href="#2-1-笨办法：存下来再找" class="headerlink" title="2.1 笨办法：存下来再找"></a>2.1 笨办法：存下来再找</h4><p>如果我们对这棵树进行一次完整的 <strong>中序遍历</strong>，并将结果存入一个数组 <code>vector&lt;int&gt;</code>。</p>
<ul>
<li>树：<code>[5, 3, 6, 2, 4]</code></li>
<li>中序遍历后：<code>[2, 3, 4, 5, 6]</code></li>
<li>第 <code>k</code> 小就是 <code>arr[k-1]</code>。</li>
</ul>
<p><strong>缺点</strong>：你需要遍历整棵树，并且需要 $O(N)$ 的额外空间来存数组。如果树有 1 亿个节点，内存就爆了。</p>
<h4 id="2-2-聪明办法：边走边数-Early-Stop"><a href="#2-2-聪明办法：边走边数-Early-Stop" class="headerlink" title="2.2 聪明办法：边走边数 (Early Stop)"></a>2.2 聪明办法：边走边数 (Early Stop)</h4><p>我们不需要把所有数字都存下来。</p>
<p>既然中序遍历是按顺序访问的（第一个访问的一定是最小的，第二个访问的是第二小的…），我们只需要 <strong>搞一个计数器</strong>。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>开始中序遍历（左 -&gt; 根 -&gt; 右）。</li>
<li>每访问一个节点，<strong>计数器 <code>k</code> 减 1</strong>（或者 <code>count</code> 加 1）。</li>
<li>当 <code>k</code> 减到 <strong>0</strong> 时，说明当前访问的这个节点就是我们要找的第 <code>K</code> 小元素。</li>
<li><strong>立刻停下来</strong>，直接返回结果，后面的节点（右边的大数）都不用看了。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-迭代法-推荐"><a href="#3-C-代码实现-迭代法-推荐" class="headerlink" title="3. C++ 代码实现 (迭代法 - 推荐)"></a>3. C++ 代码实现 (迭代法 - 推荐)</h3><p>为了能够“立刻停下来”，使用 <strong>迭代法（栈模拟）</strong> 是控制力最强、最容易理解的方式。这就用到了我们之前学的 <strong>“二叉树中序遍历”</strong> 的模板。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        // 使用栈模拟递归</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        // 标准的中序遍历模板</span><br><span class="line">        while (curr != nullptr || !stk.empty()) &#123;</span><br><span class="line">            </span><br><span class="line">            // 1. 一路向左，把沿途节点压入栈</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                stk.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2. 弹出栈顶节点（当前最左/最小）</span><br><span class="line">            curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            // === 核心逻辑开始 ===</span><br><span class="line">            k--; // 找到了第 1 小、第 2 小...</span><br><span class="line">            if (k == 0) &#123;</span><br><span class="line">                return curr-&gt;val; // 这就是第 k 小</span><br><span class="line">            &#125;</span><br><span class="line">            // === 核心逻辑结束 ===</span><br><span class="line"></span><br><span class="line">            // 3. 转向右子树</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1; // 题目保证 k 有效，这行理论上不会执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-H-k"><a href="#时间复杂度：-O-H-k" class="headerlink" title="时间复杂度：$O(H + k)$"></a><strong>时间复杂度：$O(H + k)$</strong></h4><ul>
<li>$H$ 是树的高度。我们需要先钻到最左下的节点（耗时 $O(H)$）。</li>
<li>然后我们只需要遍历 $k$ 个节点就可以停下来了。</li>
<li>不需要遍历整棵树 $O(N)$。</li>
</ul>
<h4 id="空间复杂度：-O-H"><a href="#空间复杂度：-O-H" class="headerlink" title="空间复杂度：$O(H)$"></a><strong>空间复杂度：$O(H)$</strong></h4><ul>
<li>栈的大小取决于树的高度。</li>
</ul>
<hr>
<h3 id="5-进阶面试题-Follow-up"><a href="#5-进阶面试题-Follow-up" class="headerlink" title="5. 进阶面试题 (Follow-up)"></a>5. 进阶面试题 (Follow-up)</h3><p><strong>面试官常问：</strong></p>
<blockquote>
<p>“如果这个 BST 会被频繁地修改（插入&#x2F;删除操作），并且我们需要频繁地查找第 K 小的值，你会怎么优化？”</p>
</blockquote>
<p><strong>现有解法的问题</strong>：</p>
<p>每次查找都要重新遍历一遍，时间复杂度是 $O(k)$。如果 $k$ 很大（接近 $N$），就很慢。</p>
<p><strong>优化解法：记录子树大小 (Subtree Size)</strong></p>
<p>我们可以在定义 <code>TreeNode</code> 时多加一个字段 <code>size</code>，记录 <strong>以该节点为根的子树中节点的总数</strong>。</p>
<p><strong>查找逻辑（类似二分查找）</strong>：</p>
<p>假设当前站在 <code>root</code> 节点：</p>
<ol>
<li>左子树的大小为 <code>left_size</code>。</li>
<li>如果 <code>k == left_size + 1</code>：恭喜，<code>root</code> 就是第 <code>k</code> 小。</li>
<li>如果 <code>k &lt;= left_size</code>：说明目标在左边，去左子树找第 <code>k</code> 小。</li>
<li>如果 <code>k &gt; left_size + 1</code>：说明目标在右边，去右子树找第 <code>k - (left_size + 1)</code> 小。</li>
</ol>
<p><strong>复杂度变化</strong>：</p>
<ul>
<li><strong>查找</strong>：优化为 $O(H)$（也就是 $O(\log N)$），不用遍历了，直接走路径。</li>
<li><strong>插入&#x2F;删除</strong>：虽然需要更新路径上节点的 <code>size</code>，但复杂度依然保持 $O(H)$。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 用递归能写吗？</strong><ul>
<li><strong>A:</strong> 可以。需要用一个全局变量（或者引用传参）来记录 <code>count</code>。但递归不好“直接中断”（除非抛异常或者设置全局 flag），大部分人写递归都会不小心遍历完整个树。迭代法在控制“提前退出”上更直观。</li>
</ul>
</li>
<li><strong>Q: 这里的 <code>k</code> 是从 0 开始还是从 1 开始？</strong><ul>
<li><strong>A:</strong> 题目通常规定是从 1 开始。如果是从 0 开始，逻辑里改成 <code>k--</code> 后判断 <code>k == -1</code> 或者初始判断 <code>k == 0</code> 即可。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>94. 二叉树的中序遍历</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<p>题目：<br>给你二叉树的根节点 <code>root</code>，返回其节点值的 <strong>中序遍历</strong>。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; []<br>输出：[]</p>
<p><strong>示例 3：</strong><br>输入：root &#x3D; [1]<br>输出：[1]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[0, 100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是 <strong>二叉树 (Binary Tree)</strong> 系列的开篇之作。</p>
<p>它是力扣（LeetCode）第 94 题。</p>
<p>虽然这道题标为 Easy，但它就像“反转链表”一样，是面试官考察你基本功的试金石。</p>
<p>面试官通常会问：“你能用递归写出来吗？”（这很简单）。</p>
<p>紧接着会问：“<strong>你能不用递归（迭代法）写出来吗？</strong>”（这才是真正的考点）。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的中序遍历 (Binary Tree Inorder Traversal)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历结果。</p>
<p><strong>什么是中序遍历？</strong></p>
<p>按照 <strong>“左 $\rightarrow$ 根 $\rightarrow$ 右”</strong> 的顺序访问节点。</p>
<ol>
<li>优先递归访问 <strong>左子树</strong>。</li>
<li>访问 <strong>根节点</strong>（记录值）。</li>
<li>最后递归访问 <strong>右子树</strong>。</li>
</ol>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输入：<code>root = [1, null, 2, 3]</code></p>
<p>输出：<code>[1, 3, 2]</code></p>
<p>解释：</p>
<ul>
<li>根是 1，先看左边（空）。</li>
<li>记录 <strong>1</strong>。</li>
<li>看右边 2。</li>
<li>2 的左边是 3。</li>
<li>记录 <strong>3</strong>。</li>
<li>记录 <strong>2</strong>。</li>
<li>2 的右边（空）。</li>
<li>结束。</li>
</ul>
<hr>
<h3 id="2-解法一：递归-Recursion-——-秒杀解"><a href="#2-解法一：递归-Recursion-——-秒杀解" class="headerlink" title="2. 解法一：递归 (Recursion) —— 秒杀解"></a>2. 解法一：递归 (Recursion) —— 秒杀解</h3><p>这是最符合人类直觉的写法。二叉树本身的定义就是递归的，所以代码非常短。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 1. 递归遍历左子树 (L)</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        </span><br><span class="line">        // 2. 访问根节点 (Root)</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        // 3. 递归遍历右子树 (R)</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>复杂度</strong>：时间 $O(N)$，空间 $O(N)$（最坏情况链状树的递归栈深度）。</li>
</ul>
<hr>
<h3 id="3-解法二：迭代-Iteration-——-真正的考验"><a href="#3-解法二：迭代-Iteration-——-真正的考验" class="headerlink" title="3. 解法二：迭代 (Iteration) —— 真正的考验"></a>3. 解法二：迭代 (Iteration) —— 真正的考验</h3><p>为什么要学迭代？</p>
<ol>
<li><strong>工程限制</strong>：系统栈（递归栈）的大小是有限的，如果树特别深（比如 10万层），递归会报 <code>Stack Overflow</code> 错误。</li>
<li><strong>面试要求</strong>：考察你是否理解递归的本质 —— <strong>栈 (Stack)</strong>。</li>
</ol>
<p><strong>核心思路</strong>：</p>
<p>我们要人工模拟递归的过程。</p>
<p>递归的本质是：<strong>“一头扎到底，撞了南墙才回头”</strong>。</p>
<p>在“中序遍历”中，我们要先打印左边的。所以：</p>
<ol>
<li><strong>一路向左</strong>：从根节点开始，只要有左子节点，就把它压入栈中，然后移到左孩子。<ul>
<li><em>就像坐过山车，先猛冲到最左下的角落。</em></li>
</ul>
</li>
<li><strong>撞墙回头</strong>：当没有左孩子时（curr 为空），说明我们到了最左边的尽头。</li>
<li><strong>弹出处理</strong>：从栈顶弹出一个节点。<ul>
<li>这个节点就是当前的“最左”（或者说是局部的“根”）。</li>
<li><strong>记录它的值</strong>。</li>
</ul>
</li>
<li><strong>转向右边</strong>：让指针指向刚才弹出节点的 <strong>右孩子</strong>。</li>
<li><strong>重复</strong>：回到步骤 1，继续对右孩子做“一路向左”的操作。</li>
</ol>
<p><strong>图解逻辑</strong>：</p>
<p>假设树是 <code>[1, 2, 3]</code> (2是左，3是右)。</p>
<ol>
<li><code>1</code> 入栈，<code>1</code> 有左 <code>2</code>。</li>
<li><code>2</code> 入栈，<code>2</code> 无左。</li>
<li>弹出 <code>2</code>，<strong>记录 2</strong>。<code>2</code> 无右。</li>
<li>弹出 <code>1</code>，<strong>记录 1</strong>。<code>1</code> 有右 <code>3</code>。</li>
<li><code>3</code> 入栈，<code>3</code> 无左。</li>
<li>弹出 <code>3</code>，<strong>记录 3</strong>。</li>
<li>结束。顺序：2 -&gt; 1 -&gt; 3。</li>
</ol>
<hr>
<h3 id="4-C-代码实现-迭代法"><a href="#4-C-代码实现-迭代法" class="headerlink" title="4. C++ 代码实现 (迭代法)"></a>4. C++ 代码实现 (迭代法)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * TreeNode *left;</span><br><span class="line"> * TreeNode *right;</span><br><span class="line"> * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        // 循环条件：</span><br><span class="line">        // 1. curr != nullptr: 说明还有节点没被遍历到（比如正在往右子树走）</span><br><span class="line">        // 2. !stk.empty(): 说明栈里还有等着回溯的父节点</span><br><span class="line">        while (curr != nullptr || !stk.empty()) &#123;</span><br><span class="line">            </span><br><span class="line">            // 步骤 1: 尽情地往左走，沿途把节点压入栈</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                stk.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 步骤 2: 左边走到头了，弹出栈顶节点</span><br><span class="line">            curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            // 步骤 3: 记录该节点的值 (左 -&gt; 【根】 -&gt; 右)</span><br><span class="line">            res.push_back(curr-&gt;val);</span><br><span class="line"></span><br><span class="line">            // 步骤 4: 转向右子树</span><br><span class="line">            // 如果有右子树，下一轮循环会把右子树的左边界全部压栈</span><br><span class="line">            // 如果无右子树，curr 为 null，下一轮会继续从栈里弹上层节点</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>每个节点只会被压入栈一次，弹出栈一次。</li>
</ul>
<h4 id="空间复杂度：-O-H"><a href="#空间复杂度：-O-H" class="headerlink" title="空间复杂度：$O(H)$"></a><strong>空间复杂度：$O(H)$</strong></h4><ul>
<li>$H$ 是树的高度。</li>
<li>栈中最多同时存储从根节点到最左侧叶子节点的路径。</li>
<li>平均情况 $O(\log N)$，最坏情况（退化成链表）$O(N)$。</li>
</ul>
<hr>
<h3 id="6-知识点延伸：二叉搜索树-BST"><a href="#6-知识点延伸：二叉搜索树-BST" class="headerlink" title="6. 知识点延伸：二叉搜索树 (BST)"></a>6. 知识点延伸：二叉搜索树 (BST)</h3><p>中序遍历在 <strong>二叉搜索树 (Binary Search Tree, BST)</strong> 中有一个极其重要的性质：</p>
<blockquote>
<p><strong>BST 的中序遍历结果是一个严格递增的有序数组。</strong></p>
</blockquote>
<p>很多关于 BST 的题目（比如“验证二叉搜索树”、“二叉搜索树中第 K 小的元素”）本质上都在考中序遍历。</p>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>114. 二叉树展开为链表</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></p>
<p>题目：<br>给你二叉树的根节点 <code>root</code>，展开成一个单链表：</p>
<ul>
<li>单链表中的节点顺序应与二叉树中使用 <strong>前序遍历</strong> 得到的顺序相同。</li>
<li>每个节点的左子指针应指向 <code>null</code>。</li>
<li>每个节点的右子指针应指向下一个节点。</li>
</ul>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; []<br>输出：[]</p>
<p><strong>示例 3：</strong><br>输入：root &#x3D; [0]<br>输出：[0]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[0, 2000]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是 <strong>二叉树 (Binary Tree)</strong> 和 <strong>链表 (Linked List)</strong> 的结合体。</p>
<p>它是力扣（LeetCode）第 114 题 <strong>“二叉树展开为链表 (Flatten Binary Tree to Linked List)”</strong>。</p>
<p>这道题非常经典，因为它要求你 <strong>原地 (In-place)</strong> 修改树的结构。这不仅考察你对递归的理解，还考察你对指针操作（断链、重连）的“微操”能力。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树展开为链表 (Flatten Binary Tree to Linked List)</p>
<p><strong>题目大意</strong>：</p>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ol>
<li>展开后的单链表应该同样使用 <code>TreeNode</code>，其中 <code>right</code> 子指针指向链表中下一个结点，而 <code>left</code> 子指针始终为 <code>null</code>。</li>
<li>展开后的单链表应该与二叉树 <strong>先序遍历 (Pre-order Traversal)</strong> 顺序相同。</li>
</ol>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<p>（注意：看起来像是一个只往右边长的树，实际上就是一个链表）</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么直接先序遍历不行？"><a href="#2-1-为什么直接先序遍历不行？" class="headerlink" title="2.1 为什么直接先序遍历不行？"></a>2.1 为什么直接先序遍历不行？</h4><p>如果我们写一个标准的先序遍历（根-左-右），把节点存在一个数组里，然后重新连接，是可以的。但这样需要 $O(N)$ 的额外空间。题目通常暗示我们要 <strong>原地修改</strong>。</p>
<h4 id="2-2-核心策略：寻找前驱节点-Predecessor"><a href="#2-2-核心策略：寻找前驱节点-Predecessor" class="headerlink" title="2.2 核心策略：寻找前驱节点 (Predecessor)"></a>2.2 核心策略：寻找前驱节点 (Predecessor)</h4><p>让我们观察一下转换的规律：</p>
<p>对于任意节点 <code>root</code>：</p>
<ol>
<li>如果有左子树，那么 <strong>左子树</strong> 应该插入到 <code>root</code> 和 <code>root-&gt;right</code> 之间。</li>
<li>具体怎么插？<ul>
<li><code>root</code> 的 <strong>左子树</strong> 变成新的 <strong>右子树</strong>。</li>
<li><code>root</code> 原来的 <strong>右子树</strong>，应该接到哪里？</li>
<li>应该接到 <strong>左子树最右边的那个节点</strong>（也就是左子树遍历完的最后一个节点）后面。</li>
</ul>
</li>
</ol>
<p><strong>算法步骤（像拉链一样）</strong>：</p>
<ol>
<li>拿到当前节点 <code>curr</code>。</li>
<li>如果 <code>curr</code> 有左孩子 (<code>curr-&gt;left</code>)：<ul>
<li>找到左子树中 <strong>最右边</strong> 的节点，记为 <code>predecessor</code>（因为在先序遍历中，它是 <code>curr-&gt;right</code> 的前一个节点）。</li>
<li>把 <code>curr</code> 的 <strong>右子树</strong> 接在 <code>predecessor-&gt;right</code> 上。</li>
<li>把 <code>curr</code> 的 <strong>左子树</strong> 移到 <code>curr-&gt;right</code> 上。</li>
<li>把 <code>curr-&gt;left</code> 置空。</li>
</ul>
</li>
<li><code>curr</code> 向右移动（处理下一个节点）。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-迭代法-推荐"><a href="#3-C-代码实现-迭代法-推荐" class="headerlink" title="3. C++ 代码实现 (迭代法 - 推荐)"></a>3. C++ 代码实现 (迭代法 - 推荐)</h3><p>这种解法不需要递归栈，空间复杂度是真正的 $O(1)$。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            // 如果有左子树，才需要处理</span><br><span class="line">            if (curr-&gt;left != nullptr) &#123;</span><br><span class="line">                // 1. 找到左子树中最右边的节点 (predecessor)</span><br><span class="line">                TreeNode* next = curr-&gt;left;</span><br><span class="line">                TreeNode* predecessor = next;</span><br><span class="line">                </span><br><span class="line">                while (predecessor-&gt;right != nullptr) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2. 核心“嫁接”操作</span><br><span class="line">                // 将原来的右子树接到 predecessor 的右边</span><br><span class="line">                predecessor-&gt;right = curr-&gt;right;</span><br><span class="line"></span><br><span class="line">                // 3. 将左子树移到右边</span><br><span class="line">                curr-&gt;right = next;</span><br><span class="line">                </span><br><span class="line">                // 4. 左指针置空 (记得这一步！)</span><br><span class="line">                curr-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 继续处理下一个节点 (现在的右边就是刚才移过来的左边)</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-另一种思路：递归法-后序遍历的变种"><a href="#4-另一种思路：递归法-后序遍历的变种" class="headerlink" title="4. 另一种思路：递归法 (后序遍历的变种)"></a>4. 另一种思路：递归法 (后序遍历的变种)</h3><p>如果你觉得指针指来指去太晕，可以尝试 <strong>递归</strong>。</p>
<p>但是，常规的先序遍历（根左右）很难操作，因为你刚处理完根，就把右指针覆盖了，导致右子树丢失。</p>
<p>我们可以用 <strong>变形的后序遍历 (右 -&gt; 左 -&gt; 根)</strong>。</p>
<p>如果我们按照 <code>右 -&gt; 左 -&gt; 根</code> 的顺序遍历，我们总是先处理完后面的节点。</p>
<p>我们维护一个全局变量 <code>prev</code>，指向 <strong>已经展平链表的头</strong>。</p>
<p><strong>操作逻辑</strong>：</p>
<ol>
<li>先递归处理 <code>root-&gt;right</code>。</li>
<li>再递归处理 <code>root-&gt;left</code>。</li>
<li>最后处理 <code>root</code>：<ul>
<li><code>root-&gt;right = prev</code></li>
<li><code>root-&gt;left = nullptr</code></li>
<li><code>prev = root</code></li>
</ul>
</li>
</ol>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode* prev = nullptr;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 先去处理右边，防止右孩子丢失</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        // 再去处理左边</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        // 处理当前节点</span><br><span class="line">        // 当前节点的右边指向“上一次处理完的链表头”</span><br><span class="line">        root-&gt;right = prev;</span><br><span class="line">        root-&gt;left = nullptr;</span><br><span class="line">        </span><br><span class="line">        // 更新 prev 为当前节点</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li><strong>迭代法</strong>：每个节点被访问的次数是常数次（寻找前驱节点虽然是循环，但每条边最多走两次）。</li>
<li><strong>递归法</strong>：每个节点访问一次。</li>
</ul>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a><strong>空间复杂度：</strong></h4><ul>
<li><strong>迭代法</strong>：$O(1)$。这是真正的原地算法。</li>
<li><strong>递归法</strong>：$O(N)$。递归栈的开销（最坏情况树退化为链表）。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要找左子树的“最右”节点？</strong><ul>
<li><strong>A:</strong> 因为我们要保持 <strong>先序遍历</strong> 的顺序。</li>
<li>先序是：<code>根 -&gt; [左子树...] -&gt; [右子树...]</code>。</li>
<li>展开后：<code>根 -&gt; [左子树展开...] -&gt; [右子树展开...]</code>。</li>
<li>显然，<code>右子树</code> 应该接在 <code>左子树</code> 的 <strong>最后一个节点</strong> 后面。</li>
<li>而左子树先序遍历的最后一个节点，正是其结构上 <strong>最右下</strong> 的那个节点。</li>
</ul>
</li>
<li><strong>Q: 为什么 <code>root-&gt;left</code> 必须置空？</strong><ul>
<li><strong>A:</strong> 题目明确要求展开后的结构是 <strong>单链表</strong>，只能用 <code>right</code> 指针。如果不把 <code>left</code> 置空，它就不是链表，且可能会导致后续遍历出现环或错误判断。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>199. 二叉树的右视图</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>
<p>题目：<br>给你一个二叉树的根节点 <code>root</code>，想象自己站在它的右侧，返回你看到的节点值的顺序。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,2,3,null,5,null,4]<br>输出：[1,3,4]</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [1,null,3]<br>输出：[1,3]</p>
<p><strong>示例 3：</strong><br>输入：root &#x3D; []<br>输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[0, 100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是 <strong>BFS (广度优先搜索)</strong> 的一个极其巧妙的变种。</p>
<p>它是力扣（LeetCode）第 199 题。</p>
<p>很多初学者看到“右视图”，第一反应是：“哦，一直往右走 (<code>root-&gt;right-&gt;right...</code>) 不就行了吗？”</p>
<p><strong>错！</strong></p>
<p>因为 <strong>右视图 $\neq$ 右边界</strong>。</p>
<p>如果树的左边很长（像一条长长的左臂），而右边很短，那么当你站在右侧看时，你是能看到左边露出来的部分的。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的右视图 (Binary Tree Right Side View)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉树的根节点 <code>root</code>，想象自己站在它的 <strong>右侧</strong>，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1            &lt;--- 看到了 1</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;--- 看到了 3</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;--- 看到了 4</span><br></pre></td></tr></table></figure>

<p>输出：<code>[1, 3, 4]</code></p>
<p><strong>反例（关键）</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1         &lt;--- 看到了 1</span><br><span class="line">   / \</span><br><span class="line">  2   3       &lt;--- 看到了 3 (挡住了 2)</span><br><span class="line"> /</span><br><span class="line">4             &lt;--- 看到了 4 (因为右边没东西挡它)</span><br></pre></td></tr></table></figure>

<p>输出：<code>[1, 3, 4]</code></p>
<p><em>注意：这里 4 在左子树上，但因为右子树在这一层没节点，所以 4 被看到了。</em></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么是-BFS？"><a href="#2-1-为什么是-BFS？" class="headerlink" title="2.1 为什么是 BFS？"></a>2.1 为什么是 BFS？</h4><p>既然我们要找的是 <strong>“每一层”</strong> 最右边的那个节点，那么最自然的思路就是 <strong>层序遍历 (Level Order Traversal)</strong>。</p>
<p>只要我们能把树一层一层地剥开，对于每一层，我们只需要 <strong>拿走最后一个被遍历到的节点</strong>，它一定就是最右边的那个。</p>
<h4 id="2-2-算法流程-BFS"><a href="#2-2-算法流程-BFS" class="headerlink" title="2.2 算法流程 (BFS)"></a>2.2 算法流程 (BFS)</h4><p>这完全复用了我们之前讲过的 <strong>层序遍历模板</strong>。</p>
<ol>
<li><strong>初始化</strong>：队列 <code>q</code>，放入 <code>root</code>。</li>
<li><strong>大循环</strong>：当队列不空时。</li>
<li><strong>批处理</strong>：<ul>
<li>获取当前层的节点数 <code>size = q.size()</code>。</li>
<li>循环 <code>size</code> 次（遍历当前层的所有节点）。</li>
<li><strong>关键判断</strong>：如果当前节点是这一层的 <strong>最后一个</strong>（即下标 <code>i == size - 1</code>），把它加入结果集。</li>
<li>将左右孩子加入队列。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-BFS-推荐"><a href="#3-C-代码实现-BFS-推荐" class="headerlink" title="3. C++ 代码实现 (BFS - 推荐)"></a>3. C++ 代码实现 (BFS - 推荐)</h3><p>这是最稳健、最不容易出错的写法。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) return res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 1. 锁定当前层的节点数量</span><br><span class="line">            // 这是 BFS 的精髓，把每一层隔开</span><br><span class="line">            int size = q.size();</span><br><span class="line"></span><br><span class="line">            // 2. 遍历当前层</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                // 【核心逻辑】</span><br><span class="line">                // 如果是当前层的最后一个节点，说明它就是右视图看到的那个</span><br><span class="line">                if (i == size - 1) &#123;</span><br><span class="line">                    res.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 继续拓展下一层 (先左后右)</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-进阶思路：DFS-递归法"><a href="#4-进阶思路：DFS-递归法" class="headerlink" title="4. 进阶思路：DFS (递归法)"></a>4. 进阶思路：DFS (递归法)</h3><p>虽然 BFS 很直观，但 DFS 其实写起来更帅，而且能体现你对遍历顺序的掌控。</p>
<p><strong>核心思想</strong>：</p>
<p>我们要找每一层的最右边的节点。如果我们改变 DFS 的遍历顺序，从 <strong>“根 -&gt; 左 -&gt; 右”</strong> 改成 <strong>“根 -&gt; 右 -&gt; 左”</strong> 会发生什么？</p>
<ul>
<li>我们每一次来到一个新的深度（Depth），<strong>第一个</strong> 访问到的节点，一定是这一层 <strong>最右边</strong> 的节点！</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>维护一个 <code>result</code> 数组。</li>
<li>递归函数 <code>dfs(node, depth)</code>。</li>
<li>先访问右孩子，再访问左孩子。</li>
<li><strong>判断</strong>：如果 <code>depth == result.size()</code>，说明我们 <strong>第一次</strong> 来到这个深度。<ul>
<li>既然是先往右走的，第一次到的肯定是最右边的。</li>
<li>记录该节点。</li>
</ul>
</li>
</ol>
<h4 id="C-代码实现-DFS"><a href="#C-代码实现-DFS" class="headerlink" title="C++ 代码实现 (DFS)"></a>C++ 代码实现 (DFS)</h4><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(root, 0, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // depth: 当前节点的深度（从 0 开始）</span><br><span class="line">    void dfs(TreeNode* node, int depth, vector&lt;int&gt;&amp; res) &#123;</span><br><span class="line">        if (node == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 【核心判断】</span><br><span class="line">        // 如果当前深度等于结果数组的大小，说明这一层还没记录过数据</span><br><span class="line">        // 因为我们就先访问的右边，所以这必定是右视图看到的那个</span><br><span class="line">        if (depth == res.size()) &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 注意顺序：先右后左！</span><br><span class="line">        dfs(node-&gt;right, depth + 1, res);</span><br><span class="line">        dfs(node-&gt;left, depth + 1, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>无论是 BFS 还是 DFS，都需要访问所有节点一次。</li>
</ul>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a><strong>空间复杂度：</strong></h4><ul>
<li><strong>BFS</strong>: $O(W)$，取决于树的最大宽度（队列大小）。</li>
<li><strong>DFS</strong>: $O(H)$，取决于树的高度（递归栈深度）。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果题目改成“左视图”怎么做？</strong><ul>
<li><strong>A:</strong><ul>
<li><strong>BFS</strong>: 判断 <code>i == 0</code>（这一层的第一个）时加入结果。</li>
<li><strong>DFS</strong>: 遍历顺序改成 <code>根 -&gt; 左 -&gt; 右</code>，依然判断 <code>depth == res.size()</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 为什么 DFS 方法里的 <code>if</code> 判断是 <code>depth == res.size()</code>？</strong><ul>
<li><strong>A:</strong><ul>
<li>刚开始 <code>depth=0</code>, <code>res</code> 是空 (size&#x3D;0)。相等 $\rightarrow$ 放根节点。</li>
<li>去下一层 <code>depth=1</code>, <code>res</code> 有 1 个元素 (size&#x3D;1)。相等 $\rightarrow$ 放右孩子。</li>
<li>回溯后再去左边，<code>depth=1</code>，但此时 <code>res</code> 已经有 2 个元素了 (size&#x3D;2)。<code>1 != 2</code> $\rightarrow$ 跳过（因为这一层已经有人占座了）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>BFS</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p>题目：<br>给你二叉树的根节点 <code>root</code>，返回其节点值的 <strong>层序遍历</strong>（即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [1]<br>输出：</p>
<p><strong>示例 3：</strong><br>输入：root &#x3D; []<br>输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>这道题是 <strong>BFS (广度优先搜索)</strong> 的最经典模板题。</p>
<p>它不再像 DFS 那样“一条道走到黑”，而是要求你 <strong>一层一层地</strong> 扫描整棵树。</p>
<p>这就好比公司的组织架构图：先把 CEO 打印出来，再把所有 VP 打印出来，最后打印所有的 Director。</p>
<p>掌握了这道题，你就能解决一系列“层序”相关的问题（比如锯齿形遍历、二叉树的右视图、找树的最大宽度）。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的层序遍历 (Binary Tree Level Order Traversal)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。</p>
<p>（即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>输入：<code>root = [3, 9, 20, null, null, 15, 7]</code></p>
<p>输出：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9, 20],</span><br><span class="line">  [15, 7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><em>注意：返回结果是一个二维数组 <code>vector&lt;vector&lt;int&gt;&gt;</code>，每一层是一个独立的子数组。</em></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么-DFS-不好做？"><a href="#2-1-为什么-DFS-不好做？" class="headerlink" title="2.1 为什么 DFS 不好做？"></a>2.1 为什么 DFS 不好做？</h4><p>DFS（前&#x2F;中&#x2F;后序）天生是纵向的。它会先钻到最左下的 <code>15</code>，然后再回头找 <code>7</code>。</p>
<p>如果要用 DFS 做层序，你需要传递一个 <code>level</code> 参数，然后把节点值塞到对应的 <code>res[level]</code> 数组里。虽然也能做，但不够直观。</p>
<h4 id="2-2-核心神器：队列-Queue"><a href="#2-2-核心神器：队列-Queue" class="headerlink" title="2.2 核心神器：队列 (Queue)"></a>2.2 核心神器：队列 (Queue)</h4><p><strong>队列</strong> 的特性是 <strong>先进先出 (FIFO)</strong>。</p>
<p>这就保证了：<strong>只有把上一层的所有节点都处理完（弹出），下一层的节点才会排在队列的前面被处理。</strong></p>
<p><strong>算法流程（关键在于“批处理”）</strong>：</p>
<ol>
<li><strong>初始化</strong>：建一个队列 <code>q</code>，先把根节点 <code>root</code> 扔进去。</li>
<li><strong>大循环</strong>：只要队列不空，就说明还有层没遍历完。</li>
<li><strong>批处理（The Batch Process）</strong>：<ul>
<li><strong>Step A</strong>: 记录当前队列长度 <code>size = q.size()</code>。这个 <code>size</code> 就是 <strong>这一层</strong> 包含的节点数。</li>
<li><strong>Step B</strong>: 循环 <code>size</code> 次（把这一层的所有节点都拿出来）：<ul>
<li>弹出一个节点，记入当前层的数组 <code>currentLevel</code>。</li>
<li><strong>关键点</strong>：如果它有左孩子，把左孩子扔进队列；如果它有右孩子，把右孩子扔进队列。</li>
</ul>
</li>
<li><strong>Step C</strong>: 这一层的循环结束后，把 <code>currentLevel</code> 加入最终结果 <code>res</code>。</li>
</ul>
</li>
<li><strong>结束</strong>：队列空了，返回 <code>res</code>。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-BFS-模板"><a href="#3-C-代码实现-BFS-模板" class="headerlink" title="3. C++ 代码实现 (BFS 模板)"></a>3. C++ 代码实现 (BFS 模板)</h3><p>这是所有 BFS 题目的 <strong>万能模板</strong>，请务必背诵并理解。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if (root == nullptr) return res;</span><br><span class="line"></span><br><span class="line">        // 1. 定义队列，加入根节点</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        // 2. 开始层序遍历</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 【核心关键点】</span><br><span class="line">            // 在遍历每一层之前，先记录这一层的节点数量 size</span><br><span class="line">            // 这个 size 锁定了我们这一轮循环只处理当前层的节点</span><br><span class="line">            // 新加入的子节点（下一层）会排在 size 之后，留给下一轮 while 处理</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            </span><br><span class="line">            // 存储当前层的节点值</span><br><span class="line">            vector&lt;int&gt; currentLevel;</span><br><span class="line"></span><br><span class="line">            // 3. 处理当前层的每一个节点</span><br><span class="line">            for (int i = 0; i &lt; currentLevelSize; ++i) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                // 记录值</span><br><span class="line">                currentLevel.push_back(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                // 将下一层的左右孩子加入队列</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 将这一层的结果加入总结果</span><br><span class="line">            res.push_back(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>每个节点进队列一次，出队列一次。</li>
<li>也就是每个节点都被访问了一次。</li>
</ul>
<h4 id="空间复杂度：-O-W"><a href="#空间复杂度：-O-W" class="headerlink" title="空间复杂度：$O(W)$"></a><strong>空间复杂度：$O(W)$</strong></h4><ul>
<li>$W$ 是树的 <strong>最大宽度</strong>（某一层节点数的最大值）。</li>
<li>队列中最多同时存储一层的节点。对于满二叉树，最后一层大约有 $N&#x2F;2$ 个节点，所以空间也是 $O(N)$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 那个 <code>for (int i = 0; i &lt; currentLevelSize; ++i)</code> 能不能写成 <code>while (!q.empty())</code>？</strong><ul>
<li><strong>A:</strong> <strong>不能！</strong></li>
<li>如果写成 <code>while</code>，你会把刚才这一层新加入的孩子（下一层的节点）也在这一轮里处理掉。</li>
<li>结果就变成了“所有节点混在一起的一个大数组”，而不是“分层的二维数组”。</li>
<li><code>currentLevelSize</code> 就像一个 <strong>闸门</strong>，把当前层和下一层隔开了。</li>
</ul>
</li>
<li><strong>Q: 如果要实现“锯齿形层序遍历”（先从左往右，再从右往左）怎么办？</strong><ul>
<li><strong>A:</strong> 这就是力扣 103 题。</li>
<li>只需要加一个 <code>bool isOrderLeft = true</code> 标志位。</li>
<li>每处理完一层，翻转一下标志位。</li>
<li>如果是 <code>false</code>，就把 <code>currentLevel</code> 数组 <code>reverse</code> 一下再加入 <code>res</code>。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>二叉树</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>104. 二叉树的最大深度</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p>题目：<br>给你一个二叉树的根节点 <code>root</code>，返回其最大深度。</p>
<p>二叉树的<strong>最大深度</strong>是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：3</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [1,null,2]<br>输出：2</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 10⁴]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是二叉树算法中的 <strong>“Hello World”</strong>。</p>
<p>它是力扣（LeetCode）第 104 题。</p>
<p>这道题虽然简单，但它标志着你思维方式的重大转变：从 <strong>“线性思维”</strong>（数组、链表）转向了 <strong>“分治思维”</strong>（树）。</p>
<p>此外，这道题也是引入 <strong>广度优先搜索 (BFS)</strong> 和 <strong>队列 (Queue)</strong> 的最佳时机。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的最大深度 (Maximum Depth of Binary Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例</strong>：</p>
<p>给定二叉树 <code>[3, 9, 20, null, null, 15, 7]</code>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3      &lt;- 层 1</span><br><span class="line"> / \</span><br><span class="line">9  20    &lt;- 层 2</span><br><span class="line">  /  \</span><br><span class="line"> 15   7  &lt;- 层 3</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 <strong>3</strong>。</p>
<hr>
<h3 id="2-核心思路一：递归法-DFS-——-自底向上"><a href="#2-核心思路一：递归法-DFS-——-自底向上" class="headerlink" title="2. 核心思路一：递归法 (DFS) —— 自底向上"></a>2. 核心思路一：递归法 (DFS) —— 自底向上</h3><p>这是最直观的 <strong>“分而治之” (Divide and Conquer)</strong> 策略。</p>
<p><strong>老板思维</strong>：</p>
<p>假设你是根节点 <code>3</code>（老板）。你想知道整个公司（树）有多少层级。</p>
<p>你不必自己去数。你只需要问你的两个副手（左孩子 <code>9</code> 和 右孩子 <code>20</code>）：</p>
<blockquote>
<p>“嘿，你们各自管理的部门最深有多少层？”</p>
</blockquote>
<ul>
<li>左副手汇报：“我这边深度是 1。”</li>
<li>右副手汇报：“我这边深度是 2。”</li>
</ul>
<p><strong>老板的决策</strong>：</p>
<p>我的深度 &#x3D; <code>max(左副手深度, 右副手深度) + 1</code>（加上我自己这一层）。</p>
<p>即：$1 + \max(1, 2) &#x3D; 3$。</p>
<p><strong>终止条件</strong>：</p>
<p>如果问到了空节点（<code>NULL</code>），它会回答：“我是 0 层。”</p>
<h4 id="C-代码实现-递归"><a href="#C-代码实现-递归" class="headerlink" title="C++ 代码实现 (递归)"></a>C++ 代码实现 (递归)</h4><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        // 1. 终止条件：如果是空节点，深度为 0</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 递归询问左右子树的深度</span><br><span class="line">        int leftHeight = maxDepth(root-&gt;left);</span><br><span class="line">        int rightHeight = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        // 3. 汇报结果：取最大值 + 1</span><br><span class="line">        return max(leftHeight, rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>这也是一种 <strong>后序遍历</strong>（左右根），因为我们要先拿到子树的结果，才能计算自己的结果。</em></p>
<hr>
<h3 id="3-核心思路二：迭代法-BFS-——-层序遍历"><a href="#3-核心思路二：迭代法-BFS-——-层序遍历" class="headerlink" title="3. 核心思路二：迭代法 (BFS) —— 层序遍历"></a>3. 核心思路二：迭代法 (BFS) —— 层序遍历</h3><p>在上一个问题（中序遍历）中，我们用 <strong>栈 (Stack)</strong> 模拟了 DFS。</p>
<p>在计算深度（尤其是层数）的问题中，更自然的思路是 <strong>“一层一层地剥”</strong>，就像剥洋葱一样。</p>
<p>这就需要引入一个新的数据结构：<strong>队列 (Queue)</strong>。</p>
<ul>
<li><strong>特性</strong>：先进先出 (FIFO)。</li>
<li><strong>作用</strong>：保证我们按层级顺序处理节点。</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>把根节点扔进队列。</li>
<li>只要队列不空，说明还有下一层：<ul>
<li><strong>记录当前层的节点数</strong> <code>size</code> (这一步非常关键！)。</li>
<li>一口气把这 <code>size</code> 个节点全部拿出来（处理完这一整层）。</li>
<li>在拿的过程中，如果这些节点有孩子，把孩子扔进队列（这就成了下一层）。</li>
<li>这一层处理完后，<code>depth + 1</code>。</li>
</ul>
</li>
<li>循环结束，返回 <code>depth</code>。</li>
</ol>
<h4 id="C-代码实现-BFS"><a href="#C-代码实现-BFS" class="headerlink" title="C++ 代码实现 (BFS)"></a>C++ 代码实现 (BFS)</h4><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line"></span><br><span class="line">        // 引入队列</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 【关键点】</span><br><span class="line">            // 在开始处理这一层之前，先记录这一层的节点数量</span><br><span class="line">            // 为什么要记下来？因为在处理过程中，队列长度会变（会有新孩子加进来）</span><br><span class="line">            // 我们只处理属于“当前层”的那几个</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line"></span><br><span class="line">            // 遍历当前层的所有节点</span><br><span class="line">            for (int i = 0; i &lt; currentLevelSize; ++i) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                // 把下一层的节点加入队列</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 这一层处理完了，深度加 1</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>无论是递归还是 BFS，我们都必须访问每一个节点一次。</li>
</ul>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a><strong>空间复杂度：</strong></h4><ul>
<li><strong>递归 (DFS)</strong>：$O(H)$，其中 $H$ 是树的高度。最坏情况（链状）是 $O(N)$。</li>
<li><strong>迭代 (BFS)</strong>：$O(W)$，其中 $W$ 是树的最大宽度（某一层节点数的最大值）。对于满二叉树，最后一层约有 $N&#x2F;2$ 个节点，所以空间也是 $O(N)$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 BFS 里的 <code>for</code> 循环那么重要？没有它行吗？</strong><ul>
<li><strong>A:</strong> <strong>不行。</strong></li>
<li>如果没有 <code>for</code> 循环，你每弹出一个节点就 <code>depth++</code>，那你算的就不是“层数”，而是“节点总数”了。</li>
<li><code>currentLevelSize</code> 就像一个<strong>快照</strong>，告诉循环：“这一轮只准处理刚才就在里面的这几个老员工，新进来的实习生（子节点）下一轮再处理。”</li>
</ul>
</li>
<li><strong>Q: 什么时候用 DFS，什么时候用 BFS？</strong><ul>
<li><strong>A:</strong><ul>
<li><strong>求深度&#x2F;层数</strong>：BFS 更直观，逻辑对应“层”。</li>
<li><strong>求路径&#x2F;回溯</strong>：DFS 更强（比如“路径总和”）。</li>
<li><strong>面试通用</strong>：递归（DFS）代码短，BFS 逻辑稳。两者都要会。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>124. 二叉树中的最大路径和</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p>
<p>题目：<br>给定一个非空二叉树，找到其最大路径和。</p>
<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,2,3]<br>输出：6<br>解释：路径 [2,1,3] 的和为 6。</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [-10,9,20,null,null,15,7]<br>输出：42<br>解释：路径 [15,20,7] 的和为 42。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 10⁴]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>这道题是二叉树题目中的 <strong>“大魔王” (Hard)</strong>。</p>
<p>它是力扣（LeetCode）第 124 题。</p>
<p>虽然标记为 Hard，但如果你刚才听懂了 <strong>“二叉树的直径”</strong>，那么这道题其实就是它的 <strong>“带权值 + 负数版”</strong>。</p>
<p>这道题考察的核心是：如何在递归过程中，区分 <strong>“能继续往上延伸的路径”</strong> 和 <strong>“必须在这里拐弯的路径”</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树中的最大路径和 (Binary Tree Maximum Path Sum)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个非空二叉树，返回其最大路径和。</p>
<ul>
<li><strong>路径</strong>：被定义为一条从树中任意节点出发，达到任意节点的序列。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</li>
<li><strong>节点值</strong>：可能是 <strong>负数</strong>（这是难点）。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> /  \</span><br><span class="line">9   20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure>

<p>输出：<code>42</code>。</p>
<p>解释：最优路径是 <code>15 -&gt; 20 -&gt; 7</code>，和为 $15 + 20 + 7 &#x3D; 42$。</p>
<p>注意：根节点 <code>-10</code> 和左边的 <code>9</code> 都不在路径里，因为加上它们只会让总和变小。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-两种角色的冲突"><a href="#2-1-两种角色的冲突" class="headerlink" title="2.1 两种角色的冲突"></a>2.1 两种角色的冲突</h4><p>对于任意一个节点（比如 <code>root</code>），它在路径中只有两种角色：</p>
<ol>
<li><strong>作为“联络员” (贡献者)</strong>：<ul>
<li>它作为子路径的一部分，要把自己贡献给父节点。</li>
<li>这意味着它只能选 <strong>左边</strong> 或 <strong>右边</strong> 其中一条路（或者都不选，只剩自己）。</li>
<li><strong>不能分叉</strong>：它不能同时拉着左右两个孩子去见父节点（那样路径就分叉了，不符合定义）。</li>
<li><strong>公式</strong>：<code>return node.val + max(left_gain, right_gain)</code></li>
</ul>
</li>
<li><strong>作为“终结者” (拐点)</strong>：<ul>
<li>它决定以自己为最高点（转折点），连接左右两边，形成一个 <strong>倒 V 字形</strong>（或者叫拱形）。</li>
<li>这条路径不能再往上走了（因为已经拐弯了）。</li>
<li>这代表了一条完整的、潜在的最大路径。我们需要用它来更新 <strong>全局最大值</strong>。</li>
<li><strong>公式</strong>：<code>GlobalMax = max(GlobalMax, node.val + left_gain + right_gain)</code></li>
</ul>
</li>
</ol>
<h4 id="2-2-负数的处理-剪枝"><a href="#2-2-负数的处理-剪枝" class="headerlink" title="2.2 负数的处理 (剪枝)"></a>2.2 负数的处理 (剪枝)</h4><p>如果子树计算出的最大路径和是 <strong>负数</strong>，那还要它干嘛？</p>
<ul>
<li>比如 <code>left_gain = -5</code>。如果不加它，我自己是 <code>10</code>；加了它，变成了 <code>5</code>。</li>
<li><strong>策略</strong>：如果子树贡献是负的，直接当作 <strong>0</strong>（断尾求生，不要那一边了）。</li>
</ul>
<hr>
<h3 id="3-C-代码实现"><a href="#3-C-代码实现" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><p>代码结构和“二叉树的直径”非常像，只是计算公式变了。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 全局变量，记录遍历过程中遇到的最大路径和</span><br><span class="line">    // 初始化为最小值，因为结果可能是负数</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归函数：计算节点的最大贡献值 (Max Gain)</span><br><span class="line">    // 返回值：【必须包含当前节点】，且只能选择【一个方向】（左或右）的最大和</span><br><span class="line">    int maxGain(TreeNode* node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 递归计算左右子树的贡献</span><br><span class="line">        // 【关键点】：如果子树贡献是负数，直接舍弃 (取 0)</span><br><span class="line">        int leftGain = max(maxGain(node-&gt;left), 0);</span><br><span class="line">        int rightGain = max(maxGain(node-&gt;right), 0);</span><br><span class="line"></span><br><span class="line">        // 2. 计算以当前节点为“拐点”的路径和 (倒 V 字形)</span><br><span class="line">        // 这条路径包含了：左边 + 自己 + 右边</span><br><span class="line">        // 用这个值去挑战全局最大值</span><br><span class="line">        int currentPathSum = node-&gt;val + leftGain + rightGain;</span><br><span class="line">        maxSum = max(maxSum, currentPathSum);</span><br><span class="line"></span><br><span class="line">        // 3. 返回给父节点 (向上汇报)</span><br><span class="line">        // 只能选一条路：自己 + max(左, 右)</span><br><span class="line">        return node-&gt;val + max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们利用后序遍历访问了每一个节点一次。</li>
</ul>
<h4 id="空间复杂度：-O-H"><a href="#空间复杂度：-O-H" class="headerlink" title="空间复杂度：$O(H)$"></a><strong>空间复杂度：$O(H)$</strong></h4><ul>
<li>递归栈的深度。</li>
</ul>
<hr>
<h3 id="5-对比总结：直径-vs-最大路径和"><a href="#5-对比总结：直径-vs-最大路径和" class="headerlink" title="5. 对比总结：直径 vs 最大路径和"></a>5. 对比总结：直径 vs 最大路径和</h3><p>这两道题简直是双胞胎，放在一起看能彻底理解递归的精髓。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>二叉树的直径 (Diameter)</strong></th>
<th><strong>二叉树的最大路径和 (Max Path Sum)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注点</strong></td>
<td>边的数量 (或节点数)</td>
<td>节点值的和</td>
</tr>
<tr>
<td><strong>负数处理</strong></td>
<td>无 (长度是非负的)</td>
<td><strong>有</strong> (必须 <code>max(gain, 0)</code> 抛弃负贡献)</td>
</tr>
<tr>
<td><strong>更新全局变量</strong></td>
<td><code>L_height + R_height</code></td>
<td><code>val + L_gain + R_gain</code></td>
</tr>
<tr>
<td><strong>返回给父节点</strong></td>
<td><code>max(L, R) + 1</code> (深度)</td>
<td><code>val + max(L, R)</code> (单侧最大和)</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么递归返回值和更新 <code>maxSum</code> 的公式不一样？</strong><ul>
<li><strong>A:</strong> * <strong>更新 <code>maxSum</code></strong> 是在寻找“拱桥”形状的路径，可以同时包含左右两边（因为不需要再往上走了）。<ul>
<li><strong>递归返回值</strong> 是告诉父节点“我这一支能给你提供多少油水”。如果我同时带上了左右孩子，我就分叉了，父节点就没法把我和他连成一条 <strong>单向</strong> 路径了。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 如果整棵树全是负数怎么办？</strong><ul>
<li><strong>A:</strong><ul>
<li><code>leftGain</code> 和 <code>rightGain</code> 都会被 <code>max(..., 0)</code> 变成 0。</li>
<li><code>currentPathSum</code> 就会等于 <code>node-&gt;val</code>（单个节点）。</li>
<li><code>maxSum</code> 会尝试更新为这些单个负数中的最大值（比如 <code>-10, -5, -20</code> 中选 <code>-2</code>）。</li>
<li>代码依然能正确工作，返回最大的那个负数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
<p>题目：<br>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p>
<p><strong>最近公共祖先</strong>（LCA）定义为：对于有根树 T 的两个节点 p 和 q，它们的 LCA 是位于从根节点到 p 和 q 的路径之间的最低节点。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5，因为节点 5 是节点 4 的祖先。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[2, 10⁵]</code></li>
<li><code>-10⁹ &lt;= Node.val &lt;= 10⁹</code></li>
<li>所有 <code>Node.val</code> 互不相同</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于树中</li>
</ul>
<p>这道题是二叉树递归逻辑的 <strong>“集大成者”</strong>。</p>
<p>它是力扣（LeetCode）第 236 题。</p>
<p>这道题的代码非常短（核心只有 5 行），但逻辑极其精妙。它是检验你是否真正理解 <strong>“后序遍历” (Post-order Traversal)</strong> 和 <strong>“递归返回值”</strong> 的试金石。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的最近公共祖先 (Lowest Common Ancestor of a Binary Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉树，找到该树中两个指定节点 <code>p</code> 和 <code>q</code> 的最近公共祖先 (LCA)。</p>
<p><strong>最近公共祖先的定义</strong>：</p>
<p>对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  5   1</span><br><span class="line"> / \ / \</span><br><span class="line">6  2 0  8</span><br><span class="line">  / \</span><br><span class="line"> 7   4</span><br></pre></td></tr></table></figure>

<ul>
<li>输入：<code>root = 3</code>, <code>p = 5</code>, <code>q = 1</code><ul>
<li>输出：<code>3</code> (3 是 5 和 1 的分叉点)</li>
</ul>
</li>
<li>输入：<code>root = 3</code>, <code>p = 5</code>, <code>q = 4</code><ul>
<li>输出：<code>5</code> (因为 5 是 4 的祖先，且 5 是它自己，所以 LCA 是 5)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么是后序遍历？"><a href="#2-1-为什么是后序遍历？" class="headerlink" title="2.1 为什么是后序遍历？"></a>2.1 为什么是后序遍历？</h4><p>我们需要在树的底部找到 <code>p</code> 和 <code>q</code>，然后把这个信息 <strong>“向上汇报”</strong>。</p>
<p>父节点需要根据子节点汇报上来的信息做决策：</p>
<ul>
<li><p>“我的左边有没有找到 p 或 q？”</p>
</li>
<li><p>“我的右边有没有找到 p 或 q？”</p>
<p>这种 <strong>先子后父</strong> 的逻辑，就是典型的 <strong>后序遍历</strong>。</p>
</li>
</ul>
<h4 id="2-2-递归函数的定义"><a href="#2-2-递归函数的定义" class="headerlink" title="2.2 递归函数的定义"></a>2.2 递归函数的定义</h4><p>函数 <code>lowestCommonAncestor(root, p, q)</code> 的含义是：</p>
<p><strong>“在以 <code>root</code> 为根的子树中，去寻找 <code>p</code> 和 <code>q</code>。”</strong></p>
<p><strong>返回值的含义</strong>（这是最关键的）：</p>
<ol>
<li>如果找到了 LCA，返回 <strong>LCA 节点</strong>。</li>
<li>如果只找到了 <code>p</code>，返回 <code>p</code>。</li>
<li>如果只找到了 <code>q</code>，返回 <code>q</code>。</li>
<li>如果都没找到，返回 <code>NULL</code>。</li>
</ol>
<h4 id="2-3-核心决策逻辑-The-Decision-Logic"><a href="#2-3-核心决策逻辑-The-Decision-Logic" class="headerlink" title="2.3 核心决策逻辑 (The Decision Logic)"></a>2.3 核心决策逻辑 (The Decision Logic)</h4><p>当我们在某个节点 <code>root</code> 汇总左右子树的搜索结果时，有三种情况：</p>
<ol>
<li><strong>左边找到了，右边也找到了</strong>：<ul>
<li>这意味着 <code>p</code> 在左子树，<code>q</code> 在右子树（或者反过来）。</li>
<li><strong>当前节点 <code>root</code> 就是分叉点！</strong> 即 LCA。</li>
<li><strong>Action</strong>: 返回 <code>root</code>。</li>
</ul>
</li>
<li><strong>左边没找到，右边找到了</strong>：<ul>
<li>说明 <code>p</code> 和 <code>q</code> 都在右子树里（或者其中一个是另一个的祖先）。</li>
<li><strong>Action</strong>: 返回右边找到的那个结果。</li>
</ul>
</li>
<li><strong>左边找到了，右边没找到</strong>：<ul>
<li>说明 <code>p</code> 和 <code>q</code> 都在左子树里。</li>
<li><strong>Action</strong>: 返回左边找到的那个结果。</li>
</ul>
</li>
<li><strong>两边都没找到</strong>：<ul>
<li><strong>Action</strong>: 返回 <code>NULL</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这段代码非常精炼，建议逐行背诵并理解。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 1. 递归终止条件 (Base Case)</span><br><span class="line">        // 情况 A: 越过叶子节点了，没找到 -&gt; 返回 NULL</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line">        </span><br><span class="line">        // 情况 B: 找到了 p 或者 q 其中的一个 -&gt; 返回当前节点</span><br><span class="line">        // 注意：这里包含了“p 是 q 的祖先”这种情况。</span><br><span class="line">        // 如果 root 是 p，我们直接返回 p，不需要再往下找了。</span><br><span class="line">        // 因为 q 一定在 p 的下面（或者在别的地方），</span><br><span class="line">        // 无论哪种情况，p 都是我们要向上汇报的信息。</span><br><span class="line">        if (root == p || root == q) return root;</span><br><span class="line"></span><br><span class="line">        // 2. 递归 (Divide)</span><br><span class="line">        // 去左子树找</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        // 去右子树找</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        // 3. 处理汇报结果 (Conquer)</span><br><span class="line">        </span><br><span class="line">        // 情况 C: 左右两边都不为空</span><br><span class="line">        // 说明 p 和 q 分别在当前节点的两侧</span><br><span class="line">        // 当前节点就是 LCA</span><br><span class="line">        if (left != nullptr &amp;&amp; right != nullptr) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 情况 D: 只有一边找到了 (或者都为空)</span><br><span class="line">        // 如果左边有，返回左边；如果右边有，返回右边；都没有，返回 NULL</span><br><span class="line">        // 这是一个简洁的写法：</span><br><span class="line">        if (left != nullptr) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>最坏情况下，我们需要遍历整棵树才能找到 <code>p</code> 和 <code>q</code>。</li>
<li>每个节点只被访问一次。</li>
</ul>
<h4 id="空间复杂度：-O-N"><a href="#空间复杂度：-O-N" class="headerlink" title="空间复杂度：$O(N)$"></a><strong>空间复杂度：$O(N)$</strong></h4><ul>
<li>递归栈的深度。最坏情况（退化成链表）为 $N$，平均情况为 $\log N$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果 <code>p</code> 是 <code>q</code> 的父节点，代码怎么处理？</strong><ul>
<li><strong>A:</strong> 这是一个很好的问题。</li>
<li>当递归遍历到 <code>p</code> 时，触发 <code>if (root == p) return root;</code>。</li>
<li>我们 <strong>直接返回了 <code>p</code></strong>，没有继续去遍历 <code>p</code> 的子树（也就是没去找 <code>q</code>）。</li>
<li>这会导致最终结果返回 <code>p</code>。</li>
<li>这符合 LCA 的定义：如果一个节点是另一个节点的祖先，那么这个节点就是 LCA。代码逻辑天然涵盖了这一点。</li>
</ul>
</li>
<li><strong>Q: 二叉搜索树 (BST) 的 LCA 会更简单吗？</strong><ul>
<li><strong>A:</strong> 会简单很多！</li>
<li>BST 有顺序：<ul>
<li>如果 <code>p</code> 和 <code>q</code> 都比当前节点小 -&gt; 往左走。</li>
<li>如果 <code>p</code> 和 <code>q</code> 都比当前节点大 -&gt; 往右走。</li>
<li>如果一个大一个小 -&gt; 当前节点就是 LCA。</li>
</ul>
</li>
<li>这是力扣 235 题，不需要递归回溯，一次遍历就能搞定。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>543. 二叉树的直径</title>
    <url>/2025/11/13/Hot100/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p>
<p>题目：<br>给定一个二叉树，你需要计算它的 <strong>直径长度</strong>。二叉树的直径是指树中任意两个节点之间最长路径的长度。这条路径可能穿过根节点，也可能不穿过。</p>
<p><strong>注意</strong>：路径的长度是以边的数量来计算的。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,2,3,4,5]<br>输出：3<br>解释：路径 [4,2,1,3] 或 [5,2,1,3] 的长度为 3。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[1, 10⁴]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是二叉树题目中 <strong>“最容易被误解”</strong> 的题目之一。</p>
<p>它是力扣（LeetCode）第 543 题。<br>很多初学者看到“直径”，第一反应是：“哦，就是左子树的最大深度 + 右子树的最大深度嘛！”<br><strong>错！大错特错！</strong></p>
<p>因为 <strong>最长路径不一定经过根节点</strong>。它可以是左子树内部的一个“倒 V”字形，或者右子树内部的一个弯钩。</p>
<p>这道题考察的是你对 <strong>后序遍历 (Post-order Traversal)</strong> 的理解，以及如何在递归过程中使用 <strong>全局变量</strong> 来记录“历史最大值”。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：二叉树的直径 (Diameter of Binary Tree)</p>
<p><strong>题目大意</strong>：<br>给定一棵二叉树，你需要计算它的直径长度。<br>一棵二叉树的直径长度是 <strong>任意两个节点</strong> 路径长度中的 <strong>最大值</strong>。<br>这条路径 <strong>可能穿过也可能不穿过根节点</strong>。<br><em>注意：两个节点之间的路径长度是以它们之间边的数目表示。</em></p>
<p><strong>示例</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>。路径是 <code>[4, 2, 1, 3]</code> 或者 <code>[5, 2, 1, 3]</code>。</p>
<p><strong>反例（不经过根节点的情况）</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     /</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  3   4</span><br><span class="line"> /     \</span><br><span class="line">5       6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，经过根节点 <code>1</code> 的最长路径是 <code>5-3-2-1</code> (长度 3)。<br>但是，<strong>真正的直径</strong> 是在左子树内部的 <code>5-3-2-4-6</code> (长度 4)！</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-转换思维：每个节点都是“转折点”"><a href="#2-1-转换思维：每个节点都是“转折点”" class="headerlink" title="2.1 转换思维：每个节点都是“转折点”"></a>2.1 转换思维：每个节点都是“转折点”</h4><p>虽然我们不知道最长路径在哪里，但每一条路径（倒 V 字形）一定有一个 <strong>最高点</strong>（转折点&#x2F;LCA）。</p>
<p>我们可以遍历树中的 <strong>每一个节点</strong>，假设它是这个“转折点”，计算经过它的最长路径长度。</p>
<p>然后，我们在所有节点计算出的结果中，取一个 <strong>最大值 (Global Max)</strong>。</p>
<h4 id="2-2-递归函数的职责分离"><a href="#2-2-递归函数的职责分离" class="headerlink" title="2.2 递归函数的职责分离"></a>2.2 递归函数的职责分离</h4><p>这里有一个难点：<strong>递归函数到底该返回什么？</strong></p>
<ul>
<li>如果函数返回“直径”，那父节点没法用子节点的“直径”来计算自己的深度。</li>
<li><strong>所以，递归函数必须返回“深度 (Height)”</strong>，这样父节点才能计算它自己的深度。</li>
<li>而“直径”的计算，作为递归过程中的一个 <strong>副作用 (Side Effect)</strong>，存储在一个 <strong>全局变量</strong> 里。</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>定义一个全局变量 <code>maxDiameter = 0</code>。</li>
<li>编写一个函数 <code>height(node)</code>：</li>
</ol>
<ul>
<li><p><strong>Base Case</strong>：如果 <code>node</code> 是空，返回 0。</p>
</li>
<li><p><strong>递归</strong>：</p>
</li>
<li><p><code>L = height(node-&gt;left)</code> （左边有多深？）</p>
</li>
<li><p><code>R = height(node-&gt;right)</code> （右边有多深？）</p>
</li>
<li><p><strong>更新全局最大值</strong>：<code>maxDiameter = max(maxDiameter, L + R)</code>。</p>
</li>
<li><p><em>（这一步就是计算以当前节点为转折点的直径）</em></p>
</li>
<li><p><strong>返回给父节点</strong>：<code>max(L, R) + 1</code>。</p>
</li>
<li><p><em>（告诉爸爸：我这条胳膊最长有多少）</em></p>
</li>
</ul>
<hr>
<h3 id="3-C-代码实现"><a href="#3-C-代码实现" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 全局变量，记录遍历过程中遇到的最大直径</span></span><br><span class="line">    <span class="type">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动递归</span></span><br><span class="line">        <span class="built_in">calculateHeight</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅函数：计算树的高度（深度）</span></span><br><span class="line">    <span class="comment">// 返回值：以 node 为根的子树的最大深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 递归计算左右子树的深度</span></span><br><span class="line">        <span class="type">int</span> leftH = <span class="built_in">calculateHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightH = <span class="built_in">calculateHeight</span>(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 【核心逻辑】</span></span><br><span class="line">        <span class="comment">// 在后序位置（拿到左右结果后），计算穿过当前节点的路径长度</span></span><br><span class="line">        <span class="comment">// 路径长度 = 左臂长 + 右臂长</span></span><br><span class="line">        <span class="comment">// 更新全局最大值</span></span><br><span class="line">        maxDiameter = <span class="built_in">max</span>(maxDiameter, leftH + rightH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回当前节点的高度给父节点</span></span><br><span class="line">        <span class="comment">// 当前高度 = 最长的那条胳膊 + 1 (我自己)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a><strong>时间复杂度：</strong></h4><ul>
<li>我们需要访问每一个节点一次来计算它的高度。</li>
</ul>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a><strong>空间复杂度：</strong></h4><ul>
<li>是树的高度。递归栈的深度取决于树高。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><p><strong>Q: 为什么 <code>maxDiameter</code> 要用 <code>L + R</code> 而不是 <code>L + R + 1</code>？</strong></p>
</li>
<li><p><strong>A:</strong> 题目问的是 <strong>“路径长度”</strong>（边的数量），而不是节点的数量。</p>
</li>
<li><p>如果左深度是 1，右深度是 1，说明左边有一条边，右边有一条边。总共 2 条边。所以是 <code>L + R</code>。</p>
</li>
<li><p>如果题目问的是“路径上的节点数”，那就是 <code>L + R + 1</code>。</p>
</li>
<li><p><strong>Q: 能不能不用全局变量？</strong></p>
</li>
<li><p><strong>A:</strong> 可以。你可以把 <code>maxDiameter</code> 作为一个引用参数 <code>int&amp; maxD</code> 传进递归函数里。这在工程上更干净，避免全局污染。</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与GitHub入门学习（二）</title>
    <url>/2025/07/19/Git/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<p>太棒了！你已经掌握了 Git 的基础操作，下面我们继续学习：</p>
<hr>
<h2 id="✅-一、修改文件并提交（更新版本）"><a href="#✅-一、修改文件并提交（更新版本）" class="headerlink" title="✅ 一、修改文件并提交（更新版本）"></a>✅ 一、修改文件并提交（更新版本）</h2><h3 id="✍️-假设你已经有一个-Git-仓库，并修改了某个文件，比如-readme-txt："><a href="#✍️-假设你已经有一个-Git-仓库，并修改了某个文件，比如-readme-txt：" class="headerlink" title="✍️ 假设你已经有一个 Git 仓库，并修改了某个文件，比如 readme.txt："></a>✍️ 假设你已经有一个 Git 仓库，并修改了某个文件，比如 <code>readme.txt</code>：</h3><p>你可以使用 VS Code、记事本、Sublime 等编辑器对文件进行修改。</p>
<p>然后在命令行中按以下步骤操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status                    <span class="comment"># 查看有哪些文件修改了</span></span><br><span class="line">git add .                     <span class="comment"># 添加所有修改（也可以单独 add 某个文件）</span></span><br><span class="line">git commit -m <span class="string">&quot;更新了 readme 内容&quot;</span>  <span class="comment"># 提交修改并写上说明</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 建议写清楚每次修改的内容，方便日后回溯。</p>
</blockquote>
<hr>
<h2 id="🧾-二、查看提交历史记录（版本历史）"><a href="#🧾-二、查看提交历史记录（版本历史）" class="headerlink" title="🧾 二、查看提交历史记录（版本历史）"></a>🧾 二、查看提交历史记录（版本历史）</h2><p>你可以使用以下命令：</p>
<h3 id="1-基本查看历史版本"><a href="#1-基本查看历史版本" class="headerlink" title="1. 基本查看历史版本"></a>1. <strong>基本查看历史版本</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 91e1b2aa7a1c3b5e5cb9a0dbd437bafcb89a74f6</span><br><span class="line">Author: yan dabi &lt;example@email.com&gt;</span><br><span class="line">Date:   Tue Jun 18 14:32:12 2024 +0800</span><br><span class="line"></span><br><span class="line">    更新了 readme 内容</span><br><span class="line"></span><br><span class="line">commit b72f6d3ccaa43cfe47c8cd522e4c93046cc25e1a</span><br><span class="line">Author: yan dabi &lt;example@email.com&gt;</span><br><span class="line">Date:   Tue Jun 17 22:14:11 2024 +0800</span><br><span class="line"></span><br><span class="line">    第一次提交：添加 readme.txt</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-一行一条记录（简洁模式）"><a href="#2-一行一条记录（简洁模式）" class="headerlink" title="2. 一行一条记录（简洁模式）"></a>2. <strong>一行一条记录（简洁模式）</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">91e1b2a 更新了 readme 内容</span><br><span class="line">b72f6d3 第一次提交：添加 readme.txt</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-查看具体某次提交内容"><a href="#3-查看具体某次提交内容" class="headerlink" title="3. 查看具体某次提交内容"></a>3. <strong>查看具体某次提交内容</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 提交ID</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 91e1b2a</span><br></pre></td></tr></table></figure>

<p>你会看到本次提交改了哪些文件、每一行增加或删除了什么。</p>
<hr>
<h2 id="🕰️-三、版本回退（可选）"><a href="#🕰️-三、版本回退（可选）" class="headerlink" title="🕰️ 三、版本回退（可选）"></a>🕰️ 三、版本回退（可选）</h2><p>如果你提交后发现问题，也可以回到上一个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 提交ID</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout b72f6d3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：你这样会进入“游离状态（detached HEAD）”，一般用于查看，不建议直接在这时修改文件。</p>
</blockquote>
<hr>
<h2 id="🛟-四、回到当前主分支"><a href="#🛟-四、回到当前主分支" class="headerlink" title="🛟 四、回到当前主分支"></a>🛟 四、回到当前主分支</h2><p>如果你用 <code>checkout</code> 进入了历史版本，可以这样回到主分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch main</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-总结流程图"><a href="#📌-总结流程图" class="headerlink" title="📌 总结流程图"></a>📌 总结流程图</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">修改文件 → git status → git add . → git commit -m &quot;说明&quot; → git push（可选）</span><br><span class="line">           ↓</span><br><span class="line">     git log / git show 查看历史</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你喜欢图形化查看历史，也可以使用：</p>
<ul>
<li><code>gitk</code>（在终端中输入）</li>
<li>VS Code 左边栏的 Git 图标</li>
<li>GitHub 上的 “Commits” 页面查看远程记录</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>206. 反转链表</title>
    <url>/2025/11/13/Hot100/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<p>题目：<br>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表的头节点。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1,2]<br>输出：[2,1]</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; []<br>输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>这道题是链表操作的“Hello World”，是所有链表题目的基石。</p>
<p>如果你能闭着眼睛手写出这道题的 <strong>迭代法</strong> 和 <strong>递归法</strong>，那么你对“指针”和“递归栈”的理解就已经及格了。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：反转链表 (Reverse Linked List)</p>
<p><strong>题目大意</strong>：</p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表头节点。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</code></p>
<p>输出：<code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL</code></p>
<hr>
<h3 id="2-核心思路分析：迭代法-Iterative"><a href="#2-核心思路分析：迭代法-Iterative" class="headerlink" title="2. 核心思路分析：迭代法 (Iterative)"></a>2. 核心思路分析：迭代法 (Iterative)</h3><p>这是最基础、最必须掌握的方法，空间复杂度为 $O(1)$。</p>
<h4 id="2-1-为什么不能直接反转？"><a href="#2-1-为什么不能直接反转？" class="headerlink" title="2.1 为什么不能直接反转？"></a>2.1 为什么不能直接反转？</h4><p>链表是单向的。节点 A 知道 B 在哪，但 B 不知道 A 在哪。</p>
<p>如果你直接把 A 指向 B 的指针断开，改成 B 指向 A，那么 <strong>C、D、E… 后面的整条链表就丢失了</strong>（因为唯一的线索断了）。</p>
<h4 id="2-2-核心策略：三指针法"><a href="#2-2-核心策略：三指针法" class="headerlink" title="2.2 核心策略：三指针法"></a>2.2 核心策略：三指针法</h4><p>我们需要三个“工人”来协作完成这个反转任务：</p>
<ol>
<li><strong><code>curr</code> (当前节点)</strong>：也就是我们现在正在处理的节点。</li>
<li><strong><code>prev</code> (前驱节点)</strong>：<code>curr</code> 的前一个节点。反转后，<code>curr</code> 要指向它。</li>
<li><strong><code>next</code> (后继节点)</strong>：<code>curr</code> 的下一个节点。<strong>最重要的新角色</strong>，它负责在断链之前，先保存好“下游”的地址，防止迷路。</li>
</ol>
<p><strong>操作流程（一步步来）</strong>：</p>
<p>在遍历链表的过程中，我们重复做以下 4 步动作：</p>
<ol>
<li><strong>备份</strong>：用 <code>next</code> 记下 <code>curr</code> 原本指向的下一个节点（保存现场）。</li>
<li><strong>反转</strong>：把 <code>curr</code> 的指针指向 <code>prev</code>（回马枪）。</li>
<li><strong>后移 prev</strong>：<code>prev</code> 往前走一步，走到 <code>curr</code> 的位置。</li>
<li><strong>后移 curr</strong>：<code>curr</code> 往前走一步，走到刚才备份的 <code>next</code> 的位置。</li>
</ol>
<p>当 <code>curr</code> 变成 <code>NULL</code> 时，说明所有节点都处理完了，此时 <code>prev</code> 刚好停在原来的尾巴（也就是新的头）上。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        // prev 初始化为 nullptr，因为反转后，原来的头变成了尾，尾指向空</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line"></span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            // 1. 【备份】保存当前节点的下一个节点，防止断链后找不到路</span><br><span class="line">            ListNode* nextNode = curr-&gt;next;</span><br><span class="line">            </span><br><span class="line">            // 2. 【反转】将当前节点的指针指回前一个节点</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            </span><br><span class="line">            // 3. 【推进】prev 指针向前一步</span><br><span class="line">            prev = curr;</span><br><span class="line">            </span><br><span class="line">            // 4. 【推进】curr 指针向前一步（去处理下一个节点）</span><br><span class="line">            curr = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 循环结束时，curr 指向 nullptr，prev 指向新的头节点</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们遍历了链表一次，每个节点只被处理一次。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了 <code>prev</code>, <code>curr</code>, <code>nextNode</code> 三个指针变量，没有使用额外的数组或栈空间。</li>
</ul>
<hr>
<h3 id="5-进阶：递归法-Recursive-——-面试加分项"><a href="#5-进阶：递归法-Recursive-——-面试加分项" class="headerlink" title="5. 进阶：递归法 (Recursive) —— 面试加分项"></a>5. 进阶：递归法 (Recursive) —— 面试加分项</h3><p>虽然迭代法是工程首选，但递归法能体现你对“函数栈帧”的理解。它的逻辑非常反直觉。</p>
<p><strong>核心思想</strong>：</p>
<p>假设链表是 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code>。</p>
<p>我们要反转它，可以看作：</p>
<ol>
<li>先让 <code>head-&gt;next</code> (也就是 <code>2</code> 开始的子链表) 去反转。</li>
<li>假设递归函数神奇地把后面反转好了，变成了 <code>1 -&gt; 2 &lt;- 3 &lt;- 4 &lt;- 5</code> (且返回了新的头 <code>5</code>)。</li>
<li>现在的关键是：<code>1</code> 还指着 <code>2</code>，但 <code>2</code> 还没指回 <code>1</code>。</li>
<li>操作：<code>head-&gt;next-&gt;next = head</code>。这句话的意思是：<strong>让 2 的 next 指向 1</strong>。</li>
<li>断后：<code>head-&gt;next = NULL</code>。让 1 指向空（成为新尾巴）。</li>
</ol>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        // 递归终止条件：空链表或只有一个节点，直接返回</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归调用：去反转“除了头节点以外剩下的链表”</span><br><span class="line">        // newHead 是反转完成后的新头节点（也就是原来的 5）</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line"></span><br><span class="line">        // --- 回溯阶段（神奇的事情发生了）---</span><br><span class="line">        // 此时 head 是 4，head-&gt;next 是 5</span><br><span class="line">        // 我们要做的是让 5 指向 4</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        // 让 4 指向空（防止形成环，虽然后面会被上一层覆盖，但最后一步必须置空）</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>注意：递归法的空间复杂度是 $O(n)$，因为需要 $n$ 层栈空间。</em></p>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 <code>prev</code> 要初始化为 <code>nullptr</code>？</strong><ul>
<li><strong>A:</strong> 反转后，原来的“头节点”变成了“尾节点”。链表的尾节点必须指向 <code>nullptr</code>。在第一轮循环中，<code>curr-&gt;next = prev</code> 就相当于把第一个节点的 next 指向了 <code>nullptr</code>，这是正确的。</li>
</ul>
</li>
<li><strong>Q: 循环条件写 <code>while (curr-&gt;next)</code> 可以吗？</strong><ul>
<li><strong>A:</strong> 不建议。如果写 <code>curr-&gt;next</code>，那么最后一个节点不会进入循环，也就不会被反转指向 <code>prev</code>。</li>
<li>正确的条件是 <code>while (curr)</code>，保证所有节点（包括最后一个）都被处理过。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 合并 K 个升序链表</title>
    <url>/2025/11/13/Hot100/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></p>
<p>题目：<br>给你一个链表数组，每个链表都已按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表被合并为一个升序链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**示例 2：**</span><br></pre></td></tr></table></figure>

<p>输入：lists &#x3D; []<br>输出：[]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**示例 3：**</span><br></pre></td></tr></table></figure>

<p>输入：lists &#x3D; [[]]<br>输出：[]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**提示：**</span><br><span class="line">- `k == lists.length`</span><br><span class="line">- `0 &lt;= k &lt;= 10⁴`</span><br><span class="line">- `0 &lt;= lists[i].length &lt;= 500`</span><br><span class="line">- `-10⁴ &lt;= lists[i][j] &lt;= 10⁴`</span><br><span class="line">- `lists[i]` 按升序排列</span><br></pre></td></tr></table></figure>

<p>这道题是 <strong>“合并两个有序链表”</strong> 的终极威力加强版。</p>
<p>它是力扣（LeetCode）第 23 题，难度为 <strong>Hard</strong>。</p>
<p>这道题是面试中非常经典的“分水岭”题目：</p>
<ul>
<li>写出暴力解法（两两合并） $\rightarrow$ 面试通过率一般。</li>
<li>写出 <strong>归并（分治）</strong> 或 <strong>优先队列（堆）</strong> 解法 $\rightarrow$ High Hire（高评价）。</li>
</ul>
<p>今天我们重点讲解 <strong>优先队列 (Priority Queue &#x2F; Min-Heap)</strong> 的解法，因为这种思路不仅能解这道题，还是处理 <strong>“多路归并”</strong> 问题的通用模板。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：合并 K 个升序链表 (Merge k Sorted Lists)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>lists = [[1,4,5], [1,3,4], [2,6]]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么两两合并不够快？"><a href="#2-1-为什么两两合并不够快？" class="headerlink" title="2.1 为什么两两合并不够快？"></a>2.1 为什么两两合并不够快？</h4><p>如果我们复用上一题的代码，先合并第1和第2个，结果再和第3个合并……</p>
<p>假设有 $k$ 个链表，每个链表长 $n$。</p>
<ul>
<li>第一次合并：处理 $2n$ 个点。</li>
<li>第二次合并：处理 $3n$ 个点。</li>
<li>…</li>
<li>越往后，累积的链表越长，重复遍历的次数越多。时间复杂度会达到 $O(k^2 n)$。当 $k$ 很大时，会超时。</li>
</ul>
<h4 id="2-2-核心策略：优先队列-最小堆"><a href="#2-2-核心策略：优先队列-最小堆" class="headerlink" title="2.2 核心策略：优先队列 (最小堆)"></a>2.2 核心策略：优先队列 (最小堆)</h4><p>想象一下，有 $k$ 个班级排成纵队，每个班级都是按身高从矮到高排的。现在要从这 $k$ 个队里选人，组成一个总的矮到高队列。</p>
<ul>
<li><strong>谁是目前最矮的？</strong></li>
<li>肯定是在这 $k$ 个队伍的 <strong>队头</strong> 里面选。</li>
<li>我们只需要比较这 $k$ 个队头，找出最小的那个，把他拉出来。</li>
<li>他走了之后，那个队伍的 <strong>下一个</strong> 人就变成了新的队头，加入比较。</li>
</ul>
<p><strong>我们需要一个“裁判”，能快速从 $k$ 个数里找出最小值。</strong></p>
<p>这就是 <strong>最小堆 (Min-Heap)</strong> 的拿手好戏！</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><strong>入堆</strong>：把 $k$ 个链表的 <strong>头节点</strong> 全部扔进最小堆。</li>
<li><strong>出堆</strong>：<ul>
<li>弹出堆顶元素（它是当前所有候选人里最小的）。</li>
<li>把它接在结果链表的后面。</li>
</ul>
</li>
<li><strong>补充</strong>：<ul>
<li>如果刚才弹出的那个节点还有 <code>next</code>（后面还有人），就把它的 <code>next</code> 扔进堆里。</li>
</ul>
</li>
<li><strong>循环</strong>：重复步骤 2-3，直到堆变空。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>在 C++ 中，我们使用 <code>std::priority_queue</code>。</p>
<p><strong>注意</strong>：C++ 的 <code>priority_queue</code> 默认是 <strong>最大堆</strong>。要实现最小堆，我们需要自定义比较规则（或者把值取反，但不推荐）。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 自定义比较结构体 (Functor)</span><br><span class="line">    // C++ 的 priority_queue 默认是大顶堆（最大的在上面）</span><br><span class="line">    // 为了实现【最小堆】，我们需要让比较函数“反着来”</span><br><span class="line">    // 返回 true 表示 a 的优先级【低于】b，a 会被排在后面</span><br><span class="line">    struct Compare &#123;</span><br><span class="line">        bool operator()(ListNode* a, ListNode* b) &#123;</span><br><span class="line">            return a-&gt;val &gt; b-&gt;val; // 值越小，优先级越高</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        // 定义最小堆</span><br><span class="line">        // 参数含义：&lt;元素类型, 底层容器类型, 比较方法&gt;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">        // 1. 初始化：把所有非空链表的头节点放入堆中</span><br><span class="line">        for (ListNode* list : lists) &#123;</span><br><span class="line">            if (list != nullptr) &#123;</span><br><span class="line">                pq.push(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 虚拟头节点，方便操作</span><br><span class="line">        ListNode* dummy = new ListNode(0);</span><br><span class="line">        ListNode* tail = dummy;</span><br><span class="line"></span><br><span class="line">        // 2. 循环处理</span><br><span class="line">        while (!pq.empty()) &#123;</span><br><span class="line">            // 取出当前最小的节点</span><br><span class="line">            ListNode* minNode = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            // 把它接在结果链表后面</span><br><span class="line">            tail-&gt;next = minNode;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line"></span><br><span class="line">            // 3. 如果这个节点后面还有节点，把它推入堆中</span><br><span class="line">            if (minNode-&gt;next != nullptr) &#123;</span><br><span class="line">                pq.push(minNode-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><p>假设共有 $k$ 个链表，所有链表的节点总数为 $N$。</p>
<h4 id="时间复杂度：-O-N-log-k"><a href="#时间复杂度：-O-N-log-k" class="headerlink" title="时间复杂度：$O(N \log k)$"></a><strong>时间复杂度：$O(N \log k)$</strong></h4><ul>
<li><strong>堆的大小</strong>：堆里最多同时只有 $k$ 个节点（每个链表贡献一个）。</li>
<li><strong>操作次数</strong>：每个节点都会被 <code>push</code> 进堆一次，也会被 <code>pop</code> 出堆一次。总共 $N$ 个节点。</li>
<li><strong>单次操作耗时</strong>：堆的插入和删除操作复杂度是 $O(\log (\text{堆大小}))$，即 $O(\log k)$。</li>
<li>总耗时：$O(N \log k)$。这是处理这类问题的理论最优解。</li>
</ul>
<h4 id="空间复杂度：-O-k"><a href="#空间复杂度：-O-k" class="headerlink" title="空间复杂度：$O(k)$"></a><strong>空间复杂度：$O(k)$</strong></h4><ul>
<li>堆需要存储 $k$ 个指针。</li>
<li>（不算输出结果占用的空间）。</li>
</ul>
<hr>
<h3 id="5-另一种解法：分治法-Divide-and-Conquer"><a href="#5-另一种解法：分治法-Divide-and-Conquer" class="headerlink" title="5. 另一种解法：分治法 (Divide and Conquer)"></a>5. 另一种解法：分治法 (Divide and Conquer)</h3><p>这种解法不需要额外的数据结构（堆），而是利用递归的思想。</p>
<p>它的逻辑和 <strong>归并排序</strong> 完全一样，或者说像 <strong>锦标赛</strong>。</p>
<ul>
<li>第一轮：第 0 个和第 1 个合并，第 2 个和第 3 个合并… 变成了 $k&#x2F;2$ 个链表。</li>
<li>第二轮：两两合并… 变成了 $k&#x2F;4$ 个链表。</li>
<li>…</li>
<li>直到只剩 1 个。</li>
</ul>
<p><strong>代码片段（分治逻辑）</strong>：</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 辅函数：合并两个 (复用上一题代码)</span><br><span class="line">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int left, int right) &#123;</span><br><span class="line">    if (left == right) return lists[left];</span><br><span class="line">    if (left &gt; right) return nullptr;</span><br><span class="line">    </span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    // 递归合并左半部分</span><br><span class="line">    ListNode* l1 = merge(lists, left, mid);</span><br><span class="line">    // 递归合并右半部分</span><br><span class="line">    ListNode* l2 = merge(lists, mid + 1, right);</span><br><span class="line">    // 合并两个结果</span><br><span class="line">    return mergeTwoLists(l1, l2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：也是 $O(N \log k)$。</li>
<li><strong>空间复杂度</strong>：$O(\log k)$（递归栈）。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么优先队列的比较函数 <code>a-&gt;val &gt; b-&gt;val</code> 代表最小堆？</strong><ul>
<li><strong>A:</strong> 这是一个反直觉的设计。</li>
<li><code>std::priority_queue</code> 默认将“最大”的元素放在顶部。</li>
<li>比较器 <code>comp(a, b)</code> 返回 <code>true</code> 意味着 “a &lt; b”（逻辑上）。在默认行为中，”小的” 被认为是 “优先级低的”（沉底）。</li>
<li>当我们写 <code>a &gt; b</code> 返回 <code>true</code> 时，我们是在骗编译器说：“大的那个其实是比较弱的（小的）”。于是编译器就把数值小的那个当成了“老大”放在了堆顶。</li>
</ul>
</li>
<li><strong>Q: <code>priority_queue</code> 里存 <code>ListNode\*</code> 还是 <code>int</code>？</strong><ul>
<li><strong>A:</strong> 必须存 <code>ListNode*</code>。</li>
<li>因为我们不仅需要知道最小值是多少，还需要知道<strong>这个最小值来自哪个链表</strong>，以便把该链表的下一个节点 (<code>node-&gt;next</code>) 推入堆中。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>分治</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2025/11/13/Hot100/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<p>题目：<br>将两个升序链表 <code>list1</code> 和 <code>list2</code> 合并为一个新的 <strong>升序</strong> 链表，并返回新链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong><br>输入：list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p>
<p><strong>示例 2：</strong><br>输入：list1 &#x3D; [], list2 &#x3D; []<br>输出：[]</p>
<p><strong>示例 3：</strong><br>输入：list1 &#x3D; [], list2 &#x3D; [0]<br>输出：[0]</p>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>list1</code> 和 <code>list2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p>这道题是链表操作的<strong>基本功</strong>，也是 <strong>归并排序 (Merge Sort)</strong> 的核心步骤之一。</p>
<p>如果把算法比作搭积木，那么“合并两个有序链表”就是教你怎么把两串已经穿好的珠子，按照顺序重新穿成一串。它考察的是你对<strong>指针断链与重连</strong>的熟练程度。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：合并两个有序链表 (Merge Two Sorted Lists)</p>
<p><strong>题目大意</strong>：</p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的（即<strong>原地</strong>拼接，尽量不要创建新节点）。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>l1 = [1, 2, 4]</code>, <code>l2 = [1, 3, 4]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么这像“拉拉链”？"><a href="#2-1-为什么这像“拉拉链”？" class="headerlink" title="2.1 为什么这像“拉拉链”？"></a>2.1 为什么这像“拉拉链”？</h4><p>因为两个链表本身已经是有序的（从小到大），我们不需要重新排序，只需要<strong>比较两个链表的头节点</strong>，谁小就把谁拉出来，接在结果链表的后面。</p>
<p>这就像拉拉链一样，左右两边的齿轮依次咬合。</p>
<h4 id="2-2-核心神器：虚拟头节点-Dummy-Head"><a href="#2-2-核心神器：虚拟头节点-Dummy-Head" class="headerlink" title="2.2 核心神器：虚拟头节点 (Dummy Head)"></a>2.2 核心神器：虚拟头节点 (Dummy Head)</h4><p>这是做链表题最实用、最能够减少 Bug 的技巧！</p>
<p><strong>痛点</strong>：</p>
<p>如果没有虚拟头节点，我们需要写一堆额外的 <code>if-else</code> 来确定新链表的<strong>第一个节点</strong>是谁（是 <code>l1</code> 的头还是 <code>l2</code> 的头？）。初始化 <code>head</code> 指针会很麻烦。</p>
<p><strong>解决方案</strong>：</p>
<p>我们人为地创建一个<strong>假节点</strong>（Dummy Node，通常值为 -1 或 0），把它放在新链表的最前面。</p>
<ul>
<li>我们只需要维护一个指针 <code>tail</code>（尾指针），永远指向新链表的最后一个节点。</li>
<li>开始时，<code>tail</code> 指向 <code>dummy</code>。</li>
<li>比较 <code>l1</code> 和 <code>l2</code> 的值，小的那个接在 <code>tail</code> 后面，然后 <code>tail</code> 往后移一步。</li>
<li>最后返回 <code>dummy-&gt;next</code> 即可。</li>
</ul>
<h4 id="2-3-算法流程"><a href="#2-3-算法流程" class="headerlink" title="2.3 算法流程"></a>2.3 算法流程</h4><ol>
<li>创建一个 <code>dummy</code> 节点。定义 <code>tail</code> 指针指向 <code>dummy</code>。</li>
<li><strong>循环比较</strong>：当 <code>list1</code> 和 <code>list2</code> 都还没走完时：<ul>
<li>如果 <code>list1-&gt;val &lt; list2-&gt;val</code>：把 <code>list1</code> 接在 <code>tail</code> 后面，<code>list1</code> 前移。</li>
<li>否则：把 <code>list2</code> 接在 <code>tail</code> 后面，<code>list2</code> 前移。</li>
<li><code>tail</code> 指针前移（始终指向结果链表的末尾）。</li>
</ul>
</li>
<li><strong>处理剩余</strong>：<ul>
<li>循环结束后，肯定有一个链表先空了，另一个链表可能还有剩。</li>
<li>因为剩下的链表本身就是有序的，<strong>直接把剩下的整条链表接在 <code>tail</code> 后面</strong>即可（不需要循环遍历）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;</span><br><span class="line">        // 1. 创建虚拟头节点 (Dummy Head)</span><br><span class="line">        // 技巧：使用栈上分配的对象而不是 new，可以避免内存泄漏（在 LeetCode 只要不返回局部变量地址即可）</span><br><span class="line">        // 但为了符合指针操作习惯，这里演示 new 的写法，实际工程要注意 delete</span><br><span class="line">        ListNode* dummy = new ListNode(-1);</span><br><span class="line">        </span><br><span class="line">        // tail 指针：始终指向当前合并链表的【最后一个节点】</span><br><span class="line">        ListNode* tail = dummy;</span><br><span class="line"></span><br><span class="line">        // 2. 双指针循环比对</span><br><span class="line">        // 只要两个链表都有节点，就继续比对</span><br><span class="line">        while (list1 != nullptr &amp;&amp; list2 != nullptr) &#123;</span><br><span class="line">            if (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">                // l1 小，把 l1 接到 tail 后面</span><br><span class="line">                tail-&gt;next = list1;</span><br><span class="line">                // l1 指针后移</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // l2 小，把 l2 接到 tail 后面</span><br><span class="line">                tail-&gt;next = list2;</span><br><span class="line">                // l2 指针后移</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            // 无论接了谁，tail 都要往后移动一步，准备接下一个</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 处理剩余部分</span><br><span class="line">        // 循环结束说明有一个链表空了。</span><br><span class="line">        // 直接把另一个非空链表的剩余部分接在 tail 后面</span><br><span class="line">        if (list1 != nullptr) &#123;</span><br><span class="line">            tail-&gt;next = list1;</span><br><span class="line">        &#125; else if (list2 != nullptr) &#123;</span><br><span class="line">            tail-&gt;next = list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 返回结果</span><br><span class="line">        // 真正的头节点是 dummy 的下一个</span><br><span class="line">        ListNode* result = dummy-&gt;next;</span><br><span class="line">        </span><br><span class="line">        // (可选) 释放 dummy 内存</span><br><span class="line">        delete dummy; </span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-M"><a href="#时间复杂度：-O-N-M" class="headerlink" title="时间复杂度：$O(N + M)$"></a><strong>时间复杂度：$O(N + M)$</strong></h4><ul>
<li>$N$ 和 $M$ 分别是两个链表的长度。</li>
<li>我们最多遍历两个链表中的每一个节点一次。</li>
<li>操作都是常数时间的指针修改。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只是调整了现有节点的 <code>next</code> 指针，除了 <code>dummy</code> 节点外，没有创建任何新的节点。</li>
<li><em>注：如果是递归解法，空间复杂度会是 $O(N+M)$ 的栈空间，所以迭代法更优。</em></li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么最后不需要 <code>while</code> 循环去接剩下的节点？</strong><ul>
<li><strong>A:</strong> 这就是链表的优势！</li>
<li>比如 <code>l1</code> 剩下了 <code>7 -&gt; 8 -&gt; 9</code>，<code>tail</code> 现在停在 <code>6</code>。</li>
<li>我们只需要执行 <code>tail-&gt;next = l1</code>。</li>
<li>此时 <code>tail</code> (也就是 6) 直接指到了 <code>7</code>。而 <code>7</code> 本来就指着 <code>8</code>，<code>8</code> 指着 <code>9</code>。</li>
<li><strong>一句话就把后面一串全接上了</strong>，不需要一个一个去接。</li>
</ul>
</li>
<li><strong>Q: 必须用 <code>new ListNode(-1)</code> 吗？</strong><ul>
<li><strong>A:</strong> 不一定。你也可以写 <code>ListNode dummy(-1);</code> 然后用 <code>ListNode* tail = &amp;dummy;</code>。</li>
<li>这样 <code>dummy</code> 是在栈上分配的，函数结束自动销毁，不需要手动 <code>delete</code>。这在 C++ 中是更推荐的写法，但在 LeetCode 指针题解中，<code>new</code> 更常见以便于理解“节点”的概念。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>56. 合并区间</title>
    <url>/2025/11/13/Hot100/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></p>
<p>题目：<br>给你一个二维整数数组 <code>intervals</code>，其中 <code>intervals[i] = [start_i, end_i]</code> 表示第 i 个区间的开始和结束。</p>
<p>请你合并所有重叠的区间，并返回一个不重叠的区间列表，该列表需恰好覆盖所有输入区间。</p>
<p><strong>示例 1：</strong><br>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：因为区间 [1,3] 和 [2,6] 重叠，所以它们可以合并成 [1,6]。</p>
<p><strong>示例 2：</strong><br>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 在端点处接触，通常视为可合并。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10⁴</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10⁴</code></li>
</ul>
<p>这道题是 <strong>区间问题 (Intervals)</strong> 的入门必修课。</p>
<p>在力扣（LeetCode）和其他算法面试中，区间类题目（如合并区间、插入区间、无重叠区间）非常常见。这道题的核心在于：<strong>通过排序将乱序的问题转化为线性扫描的问题</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：合并区间 (Merge Intervals)</p>
<p><strong>题目大意</strong>：</p>
<p>以数组 <code>intervals[i] = [start, end]</code> 的形式返回一组区间。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>intervals = [[1,3],[2,6],[8,10],[15,18]]</code></p>
<p>输出：<code>[[1,6],[8,10],[15,18]]</code></p>
<p>解释：</p>
<ul>
<li>区间 <code>[1,3]</code> 和 <code>[2,6]</code> 重叠（因为 2 在 1-3 之间），合并后变成 <code>[1,6]</code>。</li>
<li><code>[8,10]</code> 和 <code>[15,18]</code> 与前面的都不重叠，保持原样。</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力比对很困难？"><a href="#2-1-为什么暴力比对很困难？" class="headerlink" title="2.1 为什么暴力比对很困难？"></a>2.1 为什么暴力比对很困难？</h4><p>如果区间是乱序的（例如 <code>[[15,18], [1,3], [2,6]]</code>），我们要判断谁和谁重叠，可能需要拿每一个区间去和剩下的所有区间比较，复杂度会变成 $O(N^2)$。</p>
<h4 id="2-2-核心策略：排序-Sorting"><a href="#2-2-核心策略：排序-Sorting" class="headerlink" title="2.2 核心策略：排序 (Sorting)"></a>2.2 核心策略：排序 (Sorting)</h4><p><strong>直觉</strong>：如果我们按照区间的 <strong>左端点 (start)</strong> 从小到大排序，那么所有可能重叠的区间，在数组里一定是 <strong>相邻</strong> 的！</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><strong>排序</strong>：将所有区间按照 <code>start</code> 升序排列。</li>
<li><strong>初始化</strong>：将第一个区间放入结果数组 <code>result</code> 中作为“当前正在合并的区间”。</li>
<li><strong>遍历</strong>：从第二个区间开始，逐个考察：<ul>
<li>设结果数组里最后一个区间为 <code>last</code>（即我们目前合并到的进度）。</li>
<li>设当前遍历到的区间为 <code>curr</code>。</li>
<li><strong>判断是否有交集</strong>：<ul>
<li>如果 <code>curr.start &lt;= last.end</code>：说明这就好比两场会议时间冲突了（或者刚好接上）。<ul>
<li><strong>合并动作</strong>：我们需要延长 <code>last</code> 的右边界。</li>
<li>新的右边界是 <code>max(last.end, curr.end)</code>。</li>
<li><em>注意：为什么要取 max？</em> 因为可能存在 <code>[1, 10]</code> 和 <code>[2, 3]</code> 这种情况，<code>curr</code> 完全被 <code>last</code> 包裹住，此时右边界应该维持 10，而不是变成 3。</li>
</ul>
</li>
<li>如果 <code>curr.start &gt; last.end</code>：说明没有交集（断开了）。<ul>
<li><strong>推入动作</strong>：<code>last</code> 已经合并完毕，没它事了。直接把 <code>curr</code> 作为一个新的待合并区间放入 <code>result</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        // 0. 特判：如果为空，直接返回</span><br><span class="line">        if (intervals.empty()) return &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // 1. 核心步骤：排序</span><br><span class="line">        // 按照区间的左端点 (start) 进行升序排序</span><br><span class="line">        // C++ 的 vector 默认比较规则就是先比第一个元素，再比第二个，符合需求</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        </span><br><span class="line">        // 先把第一个区间放进去，作为“基准”</span><br><span class="line">        merged.push_back(intervals[0]);</span><br><span class="line"></span><br><span class="line">        // 2. 遍历后续区间</span><br><span class="line">        for (int i = 1; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            // 获取结果集中“当前正在处理”的区间（引用，方便修改）</span><br><span class="line">            // back() 获取 vector 的最后一个元素</span><br><span class="line">            vector&lt;int&gt;&amp; last = merged.back();</span><br><span class="line">            </span><br><span class="line">            // 获取当前遍历到的区间</span><br><span class="line">            vector&lt;int&gt;&amp; curr = intervals[i];</span><br><span class="line"></span><br><span class="line">            // 3. 判断是否重叠</span><br><span class="line">            // last: [1, 3]</span><br><span class="line">            // curr: [2, 6]</span><br><span class="line">            // 因为排序过，curr[0] 一定 &gt;= last[0]。</span><br><span class="line">            // 只要 curr 的左端点 &lt;= last 的右端点，就说明有重叠</span><br><span class="line">            if (curr[0] &lt;= last[1]) &#123;</span><br><span class="line">                // 合并：更新 last 的右端点</span><br><span class="line">                // 取两者右端点的最大值</span><br><span class="line">                last[1] = max(last[1], curr[1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不重叠，直接将当前区间加入结果集</span><br><span class="line">                merged.push_back(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-log-N"><a href="#时间复杂度：-O-N-log-N" class="headerlink" title="时间复杂度：$O(N \log N)$"></a><strong>时间复杂度：$O(N \log N)$</strong></h4><ul>
<li>这道题的瓶颈在于 <strong>排序</strong>。</li>
<li>排序的时间复杂度是 $O(N \log N)$。</li>
<li>排序后的线性扫描合并只需要 $O(N)$。</li>
<li>总体复杂度由排序决定，为 $O(N \log N)$。</li>
</ul>
<h4 id="空间复杂度：-O-log-N"><a href="#空间复杂度：-O-log-N" class="headerlink" title="空间复杂度：$O(\log N)$"></a><strong>空间复杂度：$O(\log N)$</strong></h4><ul>
<li>这里指的是排序所需要的栈空间（C++ <code>std::sort</code> 通常是 Introsort，空间复杂度为 $O(\log N)$）。</li>
<li>如果不算存储输出结果的 <code>merged</code> 数组，这是主要的空间开销。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么排序后只需要比较 <code>result</code> 的最后一个元素？</strong><ul>
<li><strong>A:</strong> 因为排序保证了区间的开始时间是递增的。如果我们跳过了中间某个区间去和后面的合并，那么中间那个区间一定也被包含在或者重叠在当前的范围内。排序让“重叠”这种关系具有了<strong>传递性</strong>。</li>
</ul>
</li>
<li><strong>Q: 遇到 <code>[1,4]</code> 和 <code>[4,5]</code> 这种算重叠吗？</strong><ul>
<li><strong>A:</strong> 算。题目要求覆盖所有区间。</li>
<li>代码中 <code>curr[0] &lt;= last[1]</code> 的 <code>&lt;=</code> 涵盖了这种情况。</li>
<li><code>last</code> 的右边界是 4，<code>curr</code> 的左边界是 4。满足条件，合并后变成 <code>max(4, 5) = 5</code>，即 <code>[1, 5]</code>。</li>
</ul>
</li>
<li><strong>Q: 为什么要用 <code>max(last[1], curr[1])</code>，直接用 <code>curr[1]</code> 不行吗？</strong><ul>
<li><strong>A:</strong> 绝对不行。这是最容易犯的错误。</li>
<li>例子：<code>[1, 10]</code> 和 <code>[2, 3]</code>。</li>
<li>这是一个“大鱼吃小鱼”的情况。如果你直接用 <code>curr[1]</code>（也就是 3）更新 <code>last[1]</code>，区间就会变成 <code>[1, 3]</code>，原本覆盖到 10 的部分就丢失了。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <url>/2025/11/13/Hot100/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个节点</a></p>
<p>题目：<br>给你一个链表，删除链表的倒数第 <code>n</code> 个节点，并返回链表的头节点。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[1, 20]</code></li>
<li><code>1 &lt;= n &lt;= 链表长度</code></li>
</ul>
<p>这道题是链表 <strong>“双指针”</strong> 技巧中非常优雅的一道。</p>
<p>它不需要像“环形链表”那样推导数学公式，也不需要像“反转链表”那样复杂的指针操作。它考验的是你对 <strong>“间距” (Gap)</strong> 的理解。</p>
<p>通常我们遍历链表只能从头走到尾，那如何“从后往前”数呢？答案就是：<strong>让一把尺子先行一步</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：删除链表的倒数第 N 个结点 (Remove Nth Node From End of List)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个链表，删除链表的 <strong>倒数</strong> 第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li>尝试使用 <strong>一趟扫描</strong> 实现。</li>
<li>链表长度未知。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>head = [1, 2, 3, 4, 5]</code>, <code>n = 2</code></p>
<p>输出：<code>[1, 2, 3, 5]</code></p>
<p>解释：倒数第 2 个节点是 4。删除它，剩下的连起来。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力法有点笨？"><a href="#2-1-为什么暴力法有点笨？" class="headerlink" title="2.1 为什么暴力法有点笨？"></a>2.1 为什么暴力法有点笨？</h4><p>如果我们不知道链表有多长，最直观的方法是：</p>
<ol>
<li><p>先从头走到尾，数一下一共有 $L$ 个节点。</p>
</li>
<li><p>倒数第 $n$ 个，就是正数第 $L - n + 1$ 个。</p>
</li>
<li><p>重置指针，再从头走 $L - n$ 步，找到目标的前驱节点，删除目标。</p>
<p>这需要走 <strong>两趟</strong>。虽然后果不严重，但面试官通常会问：能只走一趟吗？</p>
</li>
</ol>
<h4 id="2-2-核心策略：前后双指针-快慢指针的变种"><a href="#2-2-核心策略：前后双指针-快慢指针的变种" class="headerlink" title="2.2 核心策略：前后双指针 (快慢指针的变种)"></a>2.2 核心策略：前后双指针 (快慢指针的变种)</h4><p>想象两个人（指针）在跑步：</p>
<ol>
<li><strong>让快指针 (<code>fast</code>) 先跑 <code>n</code> 步</strong>。<ul>
<li>此时，<code>fast</code> 和 <code>slow</code>（还在起点）之间的<strong>间距</strong>刚好是 <code>n</code>。</li>
</ul>
</li>
<li><strong>然后两人同时跑</strong>，速度一样（每次都走一步）。<ul>
<li>这个间距 <code>n</code> 会一直保持不变。</li>
</ul>
</li>
<li><strong>当 <code>fast</code> 跑到终点 (NULL) 时</strong>：<ul>
<li>因为间距是 <code>n</code>，所以 <code>slow</code> 刚好就停在了 <strong>倒数第 <code>n</code> 个节点</strong> 的位置吗？</li>
<li>等等！如果要删除节点，我们需要找到被删除节点的 <strong>前一个节点 (<code>prev</code>)</strong>。</li>
<li>所以，我们需要让 <code>slow</code> 停在 <strong>倒数第 <code>n+1</code> 个节点</strong> 的位置。</li>
</ul>
</li>
</ol>
<p><strong>优化后的流程</strong>：</p>
<ol>
<li>创建一个 <strong>虚拟头节点 (<code>dummy</code>)</strong>，让 <code>slow</code> 和 <code>fast</code> 都指向 <code>dummy</code>。</li>
<li>让 <code>fast</code> 先走 <strong><code>n + 1</code></strong> 步。</li>
<li>两个指针同时移动，直到 <code>fast</code> 指向 <code>NULL</code>。</li>
<li>此时 <code>slow</code> 指向的就是 <strong>倒数第 <code>n</code> 个节点的前驱节点</strong>。</li>
<li>执行删除：<code>slow-&gt;next = slow-&gt;next-&gt;next</code>。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        // 1. 创建虚拟头节点 (Dummy Node)</span><br><span class="line">        // 为什么要用 dummy？</span><br><span class="line">        // 如果我们要删除的是【头节点】(倒数第 L 个)，没有 dummy 的话，</span><br><span class="line">        // 我们找不到头节点的前驱，就需要写额外的 if 判断。</span><br><span class="line">        // 有了 dummy，头节点也变成了“普通节点”。</span><br><span class="line">        ListNode* dummy = new ListNode(0);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = dummy;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line"></span><br><span class="line">        // 2. 让 fast 指针先走 n + 1 步</span><br><span class="line">        // 为什么是 n+1？因为我们要让 slow 停在被删除节点的前一个位置</span><br><span class="line">        for (int i = 0; i &lt;= n; ++i) &#123;</span><br><span class="line">            // 题目保证 n 有效，但在实际工程中这里要判空</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 两个指针同时移动，直到 fast 走到链表末尾</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 此时，slow 指向倒数第 n+1 个节点 (即被删除节点的前驱)</span><br><span class="line">        </span><br><span class="line">        // 4. 执行删除操作</span><br><span class="line">        ListNode* nodeToDelete = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        // (可选) 释放内存，养成好习惯</span><br><span class="line">        delete nodeToDelete;</span><br><span class="line"></span><br><span class="line">        // 5. 返回结果</span><br><span class="line">        // 注意：不能返回 head，因为如果 head 被删了，dummy-&gt;next 才是新的头</span><br><span class="line">        ListNode* result = dummy-&gt;next;</span><br><span class="line">        delete dummy; // 释放 dummy 节点</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-L"><a href="#时间复杂度：-O-L" class="headerlink" title="时间复杂度：$O(L)$"></a><strong>时间复杂度：$O(L)$</strong></h4><ul>
<li>$L$ 是链表长度。</li>
<li><code>fast</code> 指针遍历了 $L+1$ 步（算上 dummy），<code>slow</code> 指针遍历了 $L-n$ 步。</li>
<li>总体是一次遍历。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了常数个指针变量。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果没有虚拟头节点 <code>dummy</code> 怎么做？</strong><ul>
<li><strong>A:</strong> 如果不用 <code>dummy</code>，让 <code>fast</code> 先走 <code>n</code> 步。<ul>
<li>如果 <code>fast</code> 走了 <code>n</code> 步后直接变成 <code>NULL</code> 了，说明<strong>倒数第 <code>n</code> 个就是头节点</strong>（即 <code>n == 链表长度</code>）。这时候直接返回 <code>head-&gt;next</code>。</li>
<li>否则，<code>fast</code> 和 <code>slow</code> 一起走，直到 <code>fast</code> 到最后一个节点。此时 <code>slow</code> 在被删节点的前面。</li>
</ul>
</li>
<li><strong>结论</strong>：不用 <code>dummy</code> 需要多写一个 <code>if</code> 特判删除头节点的情况。用 <code>dummy</code> 更统一。</li>
</ul>
</li>
<li><strong>Q: 为什么 <code>fast</code> 先走 <code>n+1</code> 步？只走 <code>n</code> 步可以吗？</strong><ul>
<li><strong>A:</strong> 可以。</li>
<li>如果 <code>fast</code> 先走 <code>n</code> 步，那么当 <code>fast</code> 走到链表最后一个节点（不是 NULL）时，<code>slow</code> 刚好停在被删节点的前驱。</li>
<li>只要你把<strong>终止条件</strong>和<strong>步数</strong>对齐，两种写法都可以。我的写法（走 <code>n+1</code>，走到 <code>NULL</code>）在逻辑上更符合“间距”的直觉。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>560和为 K 的子数组</title>
    <url>/2025/11/13/Hot100/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p>题目：<br>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你统计并返回 <strong>该数组中和为 <code>k</code> 的连续子数组的个数</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10⁴</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-10⁷ &lt;= k &lt;= 10⁷</code></li>
</ul>
<p>这道题是 <strong>前缀和 (Prefix Sum)</strong> 结合 <strong>哈希表 (Hash Map)</strong> 的经典中的经典。</p>
<p>很多同学在做这道题时，第一反应是：“能不能用滑动窗口？”</p>
<p><strong>答案是：不能。</strong></p>
<p>这道题是很多初学者的“滑铁卢”，因为输入数组中可能包含 <strong>负数</strong>。如果有负数，窗口扩大时和不一定增加，缩小时和不一定减小，这就打破了滑动窗口的单调性条件。</p>
<p>所以，我们需要一把新武器：<strong>前缀和 + 哈希表</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：和为 K 的子数组 (Subarray Sum Equals K)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。请你统计数组中 <strong>和为 k</strong> 的 <strong>连续子数组</strong> 的个数。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>连续</strong>：子数组必须是数组中连续的一段。</li>
<li><strong>含负数</strong>：<code>nums</code> 中的数字可能是负数（这意味着不能用双指针&#x2F;滑动窗口）。</li>
<li><strong>复杂度</strong>：暴力解法 $O(n^2)$ 会超时，我们需要 $O(n)$ 的解法。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [1, 1, 1]</code>, <code>k = 2</code></p>
<p>输出：<code>2</code></p>
<p>解释：<code>[1, 1]</code> (前两个) 和 <code>[1, 1]</code> (后两个)。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-什么是前缀和？"><a href="#2-1-什么是前缀和？" class="headerlink" title="2.1 什么是前缀和？"></a>2.1 什么是前缀和？</h4><p>假设数组是 <code>nums = [1, 2, 3]</code>。</p>
<p>前缀和 <code>pre[i]</code> 表示从数组开头到下标 <code>i</code> 的所有元素之和。</p>
<ul>
<li><code>pre[0] = 1</code></li>
<li><code>pre[1] = 1 + 2 = 3</code></li>
<li><code>pre[2] = 1 + 2 + 3 = 6</code></li>
</ul>
<p><strong>神奇的公式</strong>：</p>
<p>任意一段子数组 <code>nums[j..i]</code> 的和，都可以用前缀和算出来：</p>
<p>$$\text{Sum}(j, i) &#x3D; \text{pre}[i] - \text{pre}[j-1]$$</p>
<p>(也就是：当前位置的前缀和 - 之前某个位置的前缀和)</p>
<h4 id="2-2-问题的转化-The-“Math”-Part"><a href="#2-2-问题的转化-The-“Math”-Part" class="headerlink" title="2.2 问题的转化 (The “Math” Part)"></a>2.2 问题的转化 (The “Math” Part)</h4><p>我们要找和为 <code>k</code> 的子数组，也就是要找满足下面公式的 <code>i</code> 和 <code>j</code>：</p>
<p>$$\text{pre}[i] - \text{pre}[j-1] &#x3D; k$$</p>
<p>我们可以把公式稍微移项变换一下：</p>
<p>$$\text{pre}[j-1] &#x3D; \text{pre}[i] - k$$</p>
<p><strong>这句话翻译成人话就是</strong>：</p>
<p>当我们遍历到第 <code>i</code> 个位置，手里的前缀和是 <code>pre[i]</code> 时，我们只需要回头看看：</p>
<blockquote>
<p><strong>“嘿，前面的历史记录里，有没有哪个位置的前缀和刚好等于 <code>pre[i] - k</code> ？”</strong></p>
</blockquote>
<ul>
<li>如果有 1 个，那就说明找到 1 个满足条件的子数组。</li>
<li>如果有 <code>N</code> 个，那就说明找到了 <code>N</code> 个。</li>
</ul>
<h4 id="2-3-为什么要用哈希表？"><a href="#2-3-为什么要用哈希表？" class="headerlink" title="2.3 为什么要用哈希表？"></a>2.3 为什么要用哈希表？</h4><p>我们需要快速查找“历史记录”里有没有某个值，以及它出现了几次。</p>
<ul>
<li><strong>Key (键)</strong>: 前缀和的值。</li>
<li><strong>Value (值)</strong>: 这个前缀和出现了多少次。</li>
</ul>
<p>这样，我们每遍历到一个新数字，只需要问哈希表：“有没有 <code>当前前缀和 - k</code>？” 这一步查询是 $O(1)$ 的。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 哈希表：记录【前缀和】出现的次数</span><br><span class="line">        // Key: 前缀和的值, Value: 该值出现的次数</span><br><span class="line">        unordered_map&lt;int, int&gt; mp;</span><br><span class="line">        </span><br><span class="line">        // 【关键初始化】</span><br><span class="line">        // 这一步非常重要！</span><br><span class="line">        // 含义是：前缀和为 0 的情况，默认已经出现过 1 次。</span><br><span class="line">        // 作用：如果某个子数组直接从 nums[0] 开始一直加到 nums[i] 刚好等于 k，</span><br><span class="line">        // 此时 pre - k = 0。如果没有这个初始化，我们会漏掉这种情况。</span><br><span class="line">        mp[0] = 1;</span><br><span class="line"></span><br><span class="line">        int pre = 0;   // 记录当前的前缀和</span><br><span class="line">        int count = 0; // 记录最终结果</span><br><span class="line"></span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            // 1. 更新当前的前缀和</span><br><span class="line">            pre += x;</span><br><span class="line"></span><br><span class="line">            // 2. 核心查询：</span><br><span class="line">            // 我们想找一段子数组结尾是当前位置，且和为 k。</span><br><span class="line">            // 相当于问：历史上有多少个前缀和等于 (pre - k)？</span><br><span class="line">            if (mp.count(pre - k)) &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 记录当前的前缀和</span><br><span class="line">            // 把当前算出的前缀和 pre 放入哈希表，供后面的元素查询</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们只需要遍历数组一次。</li>
<li>在每一轮循环中，哈希表的查找（<code>count</code>）和插入（<code>mp[pre]++</code>）操作平均复杂度是 $O(1)$。</li>
<li>总耗时：线性时间。</li>
</ul>
<h4 id="空间复杂度：-O-n"><a href="#空间复杂度：-O-n" class="headerlink" title="空间复杂度：$O(n)$"></a><strong>空间复杂度：$O(n)$</strong></h4><ul>
<li>最坏情况下（例如数组全是正数），每一个位置的前缀和都不一样，哈希表需要存储 $n$ 个键值对。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么一定要 <code>mp[0] = 1</code>？</strong><ul>
<li><strong>A:</strong> 举个例子：<code>nums = [3]</code>, <code>k = 3</code>。</li>
<li>循环开始：<code>pre</code> 变成 3。</li>
<li>我们需要找 <code>pre - k = 3 - 3 = 0</code>。</li>
<li>如果哈希表里没有 <code>&#123;0: 1&#125;</code>，我们就会以为没找到，结果返回 0，但实际上应该是 1。</li>
<li>这个初始化代表了“空数组的和为0”，是前缀和问题的标准起手式。</li>
</ul>
</li>
<li><strong>Q: 为什么是先查询 <code>mp[pre-k]</code>，然后再 <code>mp[pre]++</code>？</strong><ul>
<li><strong>A:</strong> 顺序不能乱！</li>
<li>我们要找的子数组必须是<strong>之前</strong>的某个位置作为起点。</li>
<li>如果先把自己存进去，当 <code>k=0</code> 时，<code>pre - 0</code> 就是 <code>pre</code> 自己，你会把自己误认为是满足条件的历史前缀和（这就变成了长度为0的子数组，不符合题目要求）。</li>
</ul>
</li>
<li><strong>Q: 如果数组全是正数，可以用滑动窗口吗？</strong><ul>
<li><strong>A:</strong> 可以！如果全是正数，可以用类似“无重复字符最长子串”的伸缩窗口方法，空间复杂度可以降到 $O(1)$。但因为这道题有负数，所以只能用前缀和+哈希表。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2025/11/13/Hot100/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p>
<p>题目：<br>给你一个单链表的头节点 <code>head</code>，判断这个链表是否为回文链表。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [1,2,2,1]<br>输出：true</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1,2]<br>输出：false</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[1, 10⁵]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p>这道题是链表问题的<strong>集大成者</strong>。</p>
<p>它之所以经典，是因为它<strong>一道题考了三个知识点</strong>：</p>
<ol>
<li><strong>快慢指针</strong>找链表中点。</li>
<li><strong>反转链表</strong>（刚才学过的）。</li>
<li><strong>双指针</strong>逐个对比。</li>
</ol>
<p>如果你能流畅解决这道题，说明你对链表的操作已经具备了“组合拳”的能力。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：回文链表 (Palindrome Linked List)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个单链表的头节点 <code>head</code>，请你判断该链表是否为回文链表。</p>
<ul>
<li><strong>回文</strong>：正着读和倒着读一样。例如 <code>1 -&gt; 2 -&gt; 2 -&gt; 1</code> 或 <code>1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1</code>。</li>
</ul>
<p><strong>关键约束</strong>：</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：<strong>$O(1)$</strong>。</li>
<li><em>注：如果允许 $O(n)$ 空间，直接把链表值复制到数组里用双指针做很简单，但面试通常要求 $O(1)$ 空间。</em></li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么不能直接从后往前读？"><a href="#2-1-为什么不能直接从后往前读？" class="headerlink" title="2.1 为什么不能直接从后往前读？"></a>2.1 为什么不能直接从后往前读？</h4><p>链表是单向的，没有 <code>prev</code> 指针。我们没法从尾巴倒着走到头。</p>
<h4 id="2-2-核心策略：折叠对比法-Find-Middle-Reverse"><a href="#2-2-核心策略：折叠对比法-Find-Middle-Reverse" class="headerlink" title="2.2 核心策略：折叠对比法 (Find Middle &amp; Reverse)"></a>2.2 核心策略：折叠对比法 (Find Middle &amp; Reverse)</h4><p>既然不能倒着走，我们能不能把链表的<strong>后半段</strong>“掰弯”，让它反过来指？</p>
<p><strong>操作流程</strong>：</p>
<ol>
<li><strong>找中点</strong>：使用 <strong>快慢指针</strong>。快指针一次走两步，慢指针一次走一步。当快指针走到尽头时，慢指针刚好走到中间。</li>
<li><strong>反转后半段</strong>：从慢指针的后面开始，将后半部分链表进行 <strong>原地反转</strong>（利用刚才学的反转链表技巧）。</li>
<li><strong>对比</strong>：<ul>
<li>一个指针 <code>p1</code> 从头开始。</li>
<li>一个指针 <code>p2</code> 从反转后的后半段头部开始。</li>
<li>两个指针同时向后走，逐个比较数值。如果不相等，就不是回文。</li>
</ul>
</li>
<li><strong>恢复现场（可选但推荐）</strong>：为了保持原始数据的完整性，对比完后最好把后半段再反转回去。</li>
</ol>
<p>[图解逻辑]</p>
<p>原始：<code>1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1</code></p>
<p>中点：<code>3</code></p>
<p>反转后半段：<code>1 -&gt; 2 -&gt; 3 &lt;- 2 &lt;- 1</code> (注意：3 指向了 NULL，新的尾巴是 3，新的头是最后的 1)</p>
<p>对比路径：</p>
<ul>
<li><p>左边：<code>1 -&gt; 2 -&gt; 3</code></p>
</li>
<li><p>右边：<code>1 -&gt; 2 -&gt; 3</code></p>
<p>完全一致 $\rightarrow$ True。</p>
</li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 【找中点】快慢指针法</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;          // 慢走1步</span><br><span class="line">            fast = fast-&gt;next-&gt;next;    // 快走2步</span><br><span class="line">        &#125;</span><br><span class="line">        // 此时 slow 指向的是前半段的末尾（如果是偶数长度，指向前半段最后一个）</span><br><span class="line">        // 比如 1-&gt;2-&gt;2-&gt;1，slow 指向第一个 2</span><br><span class="line"></span><br><span class="line">        // 2. 【反转后半段】</span><br><span class="line">        // slow-&gt;next 是后半段的开始</span><br><span class="line">        ListNode* secondHalfStart = reverseList(slow-&gt;next);</span><br><span class="line"></span><br><span class="line">        // 3. 【对比】双指针同时遍历</span><br><span class="line">        ListNode* p1 = head;            // 前半段指针</span><br><span class="line">        ListNode* p2 = secondHalfStart; // 后半段指针</span><br><span class="line">        bool result = true;</span><br><span class="line"></span><br><span class="line">        while (result &amp;&amp; p2 != nullptr) &#123;</span><br><span class="line">            if (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = false; // 发现不匹配</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 【恢复现场】(可选，但良好的代码习惯通常要求不破坏输入)</span><br><span class="line">        // 将后半段再反转回来接在 slow 后面</span><br><span class="line">        slow-&gt;next = reverseList(secondHalfStart);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 辅函数：反转链表 (复用上一题的代码)</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            ListNode* nextNode = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>找中点：快指针遍历一次，约 $n&#x2F;2$ 次操作。</li>
<li>反转后半段：遍历后半段，约 $n&#x2F;2$ 次操作。</li>
<li>对比：遍历后半段，约 $n&#x2F;2$ 次操作。</li>
<li>恢复现场：约 $n&#x2F;2$ 次操作。</li>
<li>总操作次数是线性的，即 $O(n)$。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们利用了链表自身的指针进行反转，只申请了几个临时指针变量。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 奇数长度和偶数长度的处理有区别吗？</strong><ul>
<li><strong>A:</strong> 在找中点时，<code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code> 这个条件保证了：<ul>
<li>奇数长度 (1-2-3-2-1)：<code>slow</code> 停在 3。后半段从 2 开始。</li>
<li>偶数长度 (1-2-2-1)：<code>slow</code> 停在第一个 2。后半段从第二个 2 开始。</li>
</ul>
</li>
<li>对比时，我们只看 <code>p2</code>（后半段）是否走完。因为前半段可能比后半段多一个节点（奇数时中间那个），但这不影响回文判断，多出来的那个中间节点不需要对比。</li>
</ul>
</li>
<li><strong>Q: 为什么要恢复链表？</strong><ul>
<li><strong>A:</strong> 在实际工程中，如果一个函数叫 <code>isCheck...</code>，它应该只是“读取”数据并返回判断结果，不应该“修改”原本的数据结构。如果你把传入的链表结构打乱了，可能会导致调用者的后续程序崩溃。这是一个很好的编程习惯。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>49字母异位词分组</title>
    <url>/2025/11/13/Hot100/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p>
<p>题目：<br>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词，且不区分大小写。所有源单词中的字母通常恰好只用一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: </span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 10⁴</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
<li></li>
</ul>
<p>这道题非常经典，因为它展示了哈希表最强大的功能之一：<strong>通过设计“键 (Key)”，将看似杂乱的数据归类。</strong></p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：字母异位词分组 (Group Anagrams)</p>
<p><strong>题目大意</strong>：<br>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>什么是“字母异位词”？</strong><br>就是由相同的字母按照不同顺序组成的单词。<br>比如：”eat”, “tea”, “ate” 是彼此的异位词，因为它们都包含 1个’a’, 1个’e’, 1个’t’。</p>
<p><strong>示例</strong>：<br>输入：<code>strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code><br>输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-寻找“身份证”-The-Canonical-Form"><a href="#2-1-寻找“身份证”-The-Canonical-Form" class="headerlink" title="2.1 寻找“身份证” (The Canonical Form)"></a>2.1 寻找“身份证” (The Canonical Form)</h4><p>我们需要把一堆单词扔进哈希表里，让互为异位词的单词自动跑到同一个“桶”里。<br>这就面临一个问题：<strong>用什么作为哈希表的 Key（键）？</strong></p>
<p>对于 “eat”, “tea”, “ate” 来说，它们虽然长得不一样，但本质是相同的。我们需要找到一个<strong>共性</strong>，作为它们的“身份证”。</p>
<p><strong>最直观的方法：排序</strong><br>如果我们将每个单词内部的字母按照字母表顺序排序：</p>
<ul>
<li>“eat”  排序后变成 <strong>“aet”</strong></li>
<li>“tea”  排序后变成 <strong>“aet”</strong></li>
<li>“ate”  排序后变成 <strong>“aet”</strong></li>
</ul>
<p><strong>破局点</strong>：<br>一旦排了序，所有的异位词都会变成<strong>完全一样</strong>的字符串！<br>我们可以把这个<strong>排序后的字符串</strong>作为哈希表的 <strong>Key</strong>。</p>
<h4 id="2-2-数据结构选择"><a href="#2-2-数据结构选择" class="headerlink" title="2.2 数据结构选择"></a>2.2 数据结构选择</h4><ul>
<li><strong>Key (键)</strong>: 排序后的字符串 (String)。这代表了这一组异位词的“标准形式”。</li>
<li><strong>Value (值)</strong>: 一个字符串列表 (<code>vector&lt;string&gt;</code>)。用来存放原始的单词。</li>
<li><strong>容器</strong>: <code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code>。</li>
</ul>
<h4 id="2-3-算法流程"><a href="#2-3-算法流程" class="headerlink" title="2.3 算法流程"></a>2.3 算法流程</h4><ol>
<li>遍历输入的每一个字符串 <code>s</code>。</li>
<li>创建一个临时变量 <code>key = s</code>，并将 <code>key</code> 进行内部排序（例如 “tea” 变成 “aet”）。</li>
<li>以这个 <code>key</code> 去哈希表中查找：</li>
</ol>
<ul>
<li>不管有没有，直接把原始字符串 <code>s</code> 扔进 <code>map[key]</code> 这个列表里。</li>
</ul>
<ol start="4">
<li>最后，把哈希表里所有的 <code>value</code> (即那些列表) 拿出来拼成结果返回。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="comment">// 核心数据结构：哈希表</span></span><br><span class="line">        <span class="comment">// Key: 排序后的字符串 (作为分组的 ID)</span></span><br><span class="line">        <span class="comment">// Value: 属于该组的原始字符串列表</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 遍历所有字符串，进行分组</span></span><br><span class="line">        <span class="keyword">for</span> (string&amp; s : strs) &#123;</span><br><span class="line">            <span class="comment">// 复制一份字符串用于排序，作为 Key</span></span><br><span class="line">            string key = s;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 排序：将 &quot;eat&quot; 变成 &quot;aet&quot;</span></span><br><span class="line">            <span class="comment">// 时间复杂度: O(K log K)，K 是字符串长度</span></span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将原始字符串 s 加入对应的 Key 分组中</span></span><br><span class="line">            <span class="comment">// C++ map 的特性：如果 key 不存在，会自动创建一个空 vector 然后 push_back</span></span><br><span class="line">            mp[key].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 将哈希表中的结果提取到最终的返回格式中</span></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : mp) &#123;</span><br><span class="line">            <span class="comment">// it.second 就是我们存好的 vector&lt;string&gt;</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><p>假设数组中有 N个字符串，每个字符串的最大长度为K 。</p>
<h4 id="时间复杂度：-O（NKlogK）"><a href="#时间复杂度：-O（NKlogK）" class="headerlink" title="**时间复杂度：*O（NKlogK）"></a>**时间复杂度：*<em>O（N</em>KlogK）</h4><ul>
<li>我们需要遍历 N个字符串。</li>
<li>对于每个字符串，我们需要进行排序。排序长度为K的字符串需要O(KlogK)的时间。</li>
<li>哈希表的插入操作平均是O(1)，但在最坏情况下（字符串很长），哈希计算和键比较需要O(K)。</li>
<li>综合来看，主要瓶颈在排序上，所以是O（N*KlogK）。</li>
<li><em>注：由于题目中K通常很小（比如 100 以内），这个复杂度是非常高效的。</em></li>
</ul>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a><strong>空间复杂度：</strong></h4><ul>
<li>我们需要存储所有的字符串。</li>
<li>哈希表中存了所有字符，结果列表里也存了所有字符。</li>
<li>总体空间消耗与输入数据的总字符数成正比。</li>
</ul>
<hr>
<h3 id="5-进阶思考：能不能更快？-面试加分项"><a href="#5-进阶思考：能不能更快？-面试加分项" class="headerlink" title="5. 进阶思考：能不能更快？(面试加分项)"></a>5. 进阶思考：能不能更快？(面试加分项)</h3><p>虽然排序法O（N<em>KlogK）已经足够通过题目，但如果k 非常大，排序可能会慢。有没有O(N</em>K)的方法？</p>
<p><strong>计数法 (Counting)</strong><br>我们可以不排序，而是统计每个字母出现的次数。<br>比如 “aab” 可以表示为：<code>a:2, b:1, c:0...</code>。<br>我们可以把这个计数结果（比如一个长度 26 的数组或特定格式的字符串 <code>&quot;a:2,b:1...&quot;</code>）作为 Key。<br>这样就不需要排序了，只需要遍历一遍字符串即可。</p>
<p><strong>但在 C++ 中</strong>，直接用 <code>vector&lt;int&gt;</code> 做 map 的 Key 稍微麻烦一点（因为 <code>vector</code> 默认没有哈希函数，需要自定义），或者需要把计数数组拼接成一个 unique 的字符串。<strong>对于初学者和大多数面试场景，排序法是最清晰、最不容易写出 Bug 的首选方案。</strong></p>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <url>/2025/11/13/Hot100/%E5%AE%9E%E7%8E%B0Trie(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p>
<p>题目：<br>实现一个 Trie（前缀树），支持以下操作：</p>
<ul>
<li><code>Trie()</code>：初始化 Trie 对象。</li>
<li><code>void insert(String word)</code>：将字符串插入 Trie。</li>
<li><code>boolean search(String word)</code>：如果字符串完全匹配某个单词，则返回 <code>true</code>。</li>
<li><code>boolean startsWith(String prefix)</code>：如果某个单词以给定前缀开头，则返回 <code>true</code>。</li>
</ul>
<p><strong>示例：</strong><br>输入：<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>输出：<br>[null, null, true, false, true, null, true]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li>最多调用 <code>insert</code>、<code>search</code> 和 <code>startsWith</code> 方法 <code>3 * 10⁴</code> 次</li>
</ul>
<p>这道题是 <strong>数据结构 (Data Structure)</strong> 中的明星题目。</p>
<p>它是力扣（LeetCode）第 208 题 <strong>“实现 Trie (前缀树)”</strong>。</p>
<p>Trie（读音类似 “try”）是一种专门用于处理字符串的树形数据结构。它在 <strong>自动补全 (Autocomplete)</strong>、<strong>拼写检查</strong>、<strong>IP 路由</strong> 等场景中有着极其广泛的应用。</p>
<p>面试官考这道题，不是考你算法逻辑（因为它逻辑很简单），而是考你 <strong>“如何设计一个数据结构”</strong> 以及 <strong>“指针操作”</strong>。</p>
<hr>
<h3 id="1-什么是-Trie（前缀树）？"><a href="#1-什么是-Trie（前缀树）？" class="headerlink" title="1. 什么是 Trie（前缀树）？"></a>1. 什么是 Trie（前缀树）？</h3><p>Trie 的核心思想是 <strong>“空间换时间”</strong>，利用字符串的 <strong>公共前缀</strong> 来减少查询时间，最大限度地减少无谓的字符串比较。</p>
<p><strong>Trie 的结构特点</strong>：</p>
<ol>
<li><strong>根节点 (Root)</strong> 不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p><strong>举个例子</strong>：</p>
<p>假设我们要存入单词 <code>&quot;apple&quot;</code>, <code>&quot;app&quot;</code>, <code>&quot;apply&quot;</code>, <code>&quot;bat&quot;</code>。</p>
<ul>
<li><code>root</code> -&gt; <code>a</code> -&gt; <code>p</code> -&gt; <code>p</code> (这里标记为 <strong>结束</strong>，因为 “app” 是一个词) -&gt; <code>l</code> -&gt; <code>e</code> (标记为 <strong>结束</strong>)。</li>
<li>同时在 <code>p</code> 下面分叉 -&gt; <code>l</code> -&gt; <code>y</code> (标记为 <strong>结束</strong>)。</li>
<li><code>root</code> -&gt; <code>b</code> -&gt; <code>a</code> -&gt; <code>t</code> (标记为 <strong>结束</strong>)。</li>
</ul>
<hr>
<h3 id="2-核心设计-Class-Design"><a href="#2-核心设计-Class-Design" class="headerlink" title="2. 核心设计 (Class Design)"></a>2. 核心设计 (Class Design)</h3><p>我们需要两个类：</p>
<ol>
<li><strong><code>TrieNode</code> (节点类)</strong>：<ul>
<li><strong><code>children</code></strong>：指向子节点的指针数组。通常题目限定只有小写字母 <code>a-z</code>，所以我们开一个大小为 26 的数组。</li>
<li><strong><code>isEnd</code></strong>：布尔值。标记当前节点是否是一个单词的<strong>结尾</strong>。<ul>
<li><em>为什么需要这个？</em> 因为 “apple” 存进去了，”app” 也是路径的一部分，但如果只有 “apple” 是单词，那么走到 “app” 的那个 <code>p</code> 时，<code>isEnd</code> 应该是 <code>false</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Trie</code> (树类)</strong>：<ul>
<li><strong><code>root</code></strong>：根节点。</li>
<li>提供 <code>insert</code>、<code>search</code>、<code>startsWith</code> 三个方法。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现"><a href="#3-C-代码实现" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 1. 定义 TrieNode 节点结构</span><br><span class="line">struct TrieNode &#123;</span><br><span class="line">    // 指向子节点的指针数组 (a-z)</span><br><span class="line">    TrieNode* children[26];</span><br><span class="line">    // 标记是否是单词的结尾</span><br><span class="line">    bool isEnd;</span><br><span class="line"></span><br><span class="line">    // 构造函数：初始化</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        isEnd = false;</span><br><span class="line">        // 将所有子节点初始化为 nullptr</span><br><span class="line">        for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">            children[i] = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">private:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 初始化 Trie</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 插入一个单词 (Insert)</span><br><span class="line">    // 时间复杂度：O(L), L 是单词长度</span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        for (char ch : word) &#123;</span><br><span class="line">            int index = ch - &#x27;a&#x27;; // 计算索引 (0-25)</span><br><span class="line">            // 如果对应字符的子节点不存在，就创建一个</span><br><span class="line">            if (node-&gt;children[index] == nullptr) &#123;</span><br><span class="line">                node-&gt;children[index] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            // 移动到下一个节点</span><br><span class="line">            node = node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        // 单词插入完毕，将最后一个节点标记为“结束”</span><br><span class="line">        node-&gt;isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. 查找单词是否存在 (Search)</span><br><span class="line">    // 时间复杂度：O(L)</span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        for (char ch : word) &#123;</span><br><span class="line">            int index = ch - &#x27;a&#x27;;</span><br><span class="line">            // 如果路径断了，说明单词不存在</span><br><span class="line">            if (node-&gt;children[index] == nullptr) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        // 走到最后，还需要判断 isEnd 是否为 true</span><br><span class="line">        // 比如 Trie 里只有 &quot;apple&quot;，你搜 &quot;app&quot;，路径存在，但 isEnd 是 false</span><br><span class="line">        return node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. 查找是否有以 prefix 为前缀的单词 (StartsWith)</span><br><span class="line">    // 时间复杂度：O(L)</span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        for (char ch : prefix) &#123;</span><br><span class="line">            int index = ch - &#x27;a&#x27;;</span><br><span class="line">            if (node-&gt;children[index] == nullptr) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        // 只要能顺利走完 prefix 的路径，就返回 true</span><br><span class="line">        // 不需要管 isEnd 是 true 还是 false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h4><ul>
<li><strong>Insert</strong>: $O(L)$，其中 $L$ 是单词的长度。</li>
<li><strong>Search</strong>: $O(L)$。</li>
<li><strong>StartsWith</strong>: $O(L)$。</li>
<li><strong>对比</strong>: 如果用哈希表 (HashSet)，虽然平均是 $O(1)$，但在处理大量字符串的前缀匹配时，哈希表需要遍历所有 key，效率极低。Trie 此时是无敌的。</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a><strong>空间复杂度</strong></h4><ul>
<li><strong>$O(N \times 26 \times L)$</strong>：其中 $N$ 是单词数量。</li>
<li>虽然 Trie 复用了公共前缀（比如 “apple” 和 “apply” 共享 “appl”），但每个节点都有一个长度 26 的数组，这在稀疏数据下会比较浪费空间。</li>
<li><em>优化</em>：工程中可以用 HashMap 代替数组来存 children，或者用压缩 Trie (Radix Tree) 来优化。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么不用 <code>unordered_map&lt;char, TrieNode\*&gt; children</code>？</strong><ul>
<li><strong>A:</strong> 可以用，省空间，但稍微慢一点。</li>
<li>在算法题中，通常明确说了是 <code>a-z</code>，用 <code>vector</code> 或数组 <code>children[26]</code> 访问速度最快（因为是直接偏移量访问内存），且代码写起来最简单。</li>
</ul>
</li>
<li><strong>Q: <code>search</code> 和 <code>startsWith</code> 的区别是什么？</strong><ul>
<li><strong>A:</strong><ul>
<li><code>insert(&quot;apple&quot;)</code></li>
<li><code>search(&quot;app&quot;)</code> -&gt; 返回 <strong>false</strong>。因为 “app” 只是路径，没有被标记为单词结尾。</li>
<li><code>startsWith(&quot;app&quot;)</code> -&gt; 返回 <strong>true</strong>。只要路径存在即可。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 析构函数（内存释放）呢？</strong><ul>
<li><strong>A:</strong> 在面试或 LeetCode 中，通常不要求写析构函数（因为程序跑完内存就回收了）。但在实际工程中，必须递归删除所有节点以防止 <strong>内存泄漏 (Memory Leak)</strong>。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>101. 对称二叉树</title>
    <url>/2025/11/13/Hot100/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<p>题目：<br>给你一个二叉树的根节点 <code>root</code>，检查它是否是镜像对称的。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是二叉树题目中 <strong>“美学”</strong> 的代表。</p>
<p>它是力扣（LeetCode）第 101 题。</p>
<p>这道题考察的不是单一节点的逻辑，而是 <strong>“两个节点之间的协作”</strong>。你需要同时控制两个指针，像照镜子一样同步移动，去验证树的结构。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：对称二叉树 (Symmetric Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个二叉树的根节点 <code>root</code> ，检查它是否是轴对称的。</p>
<p><strong>示例 1 (对称)</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>输出：<code>true</code></p>
<p><strong>示例 2 (不对称)</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p>输出：<code>false</code> (因为左边的 2 的右孩子是 3，而右边的 2 的右孩子也是 3，不对称。镜像应该是右边的 2 的左孩子是 3)。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-陷阱：不要只看单个节点"><a href="#2-1-陷阱：不要只看单个节点" class="headerlink" title="2.1 陷阱：不要只看单个节点"></a>2.1 陷阱：不要只看单个节点</h4><p>很多初学者会写出这样的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (root-&gt;left == root-&gt;right) return true;</span><br></pre></td></tr></table></figure>

<p>这是错的。因为你需要判断的是 <strong>子树</strong> 是否对称，而不是仅仅看左右孩子的值是否相等。</p>
<h4 id="2-2-核心策略：拆分为两个指针-p-q"><a href="#2-2-核心策略：拆分为两个指针-p-q" class="headerlink" title="2.2 核心策略：拆分为两个指针 (p, q)"></a>2.2 核心策略：拆分为两个指针 (p, q)</h4><p>要判断一棵树是否对称，等价于判断 <strong>“左子树”</strong> 和 <strong>“右子树”</strong> 是否互为镜像。</p>
<p>我们要定义一个辅助函数 <code>check(p, q)</code>，让指针 <code>p</code> 在左子树游走，指针 <code>q</code> 在右子树游走。</p>
<p><strong>“互为镜像”的三个条件</strong>：</p>
<ol>
<li><strong>中心对齐</strong>：当前两个节点 <code>p</code> 和 <code>q</code> 的值必须相等。</li>
<li><strong>外侧对齐</strong>：<code>p</code> 的 <strong>左</strong> 孩子，必须等于 <code>q</code> 的 <strong>右</strong> 孩子（外侧 vs 外侧）。</li>
<li><strong>内侧对齐</strong>：<code>p</code> 的 <strong>右</strong> 孩子，必须等于 <code>q</code> 的 <strong>左</strong> 孩子（内侧 vs 内侧）。</li>
</ol>
<p>[图解逻辑]</p>
<ul>
<li>左手的大拇指 vs 右手的大拇指（都在内侧）。</li>
<li>左手的小拇指 vs 右手的小拇指（都在外侧）。</li>
</ul>
<hr>
<h3 id="3-解法一：递归法-DFS-——-推荐解法"><a href="#3-解法一：递归法-DFS-——-推荐解法" class="headerlink" title="3. 解法一：递归法 (DFS) —— 推荐解法"></a>3. 解法一：递归法 (DFS) —— 推荐解法</h3><p>递归法最能体现对称的美感。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return true;</span><br><span class="line">        // 开启递归：比较 root 的左孩子和右孩子</span><br><span class="line">        return check(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 辅助函数：判断 p 和 q 这两棵树是否互为镜像</span><br><span class="line">    bool check(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 1. 递归终止条件</span><br><span class="line">        // 情况 A: 两个都为空 -&gt; 对称</span><br><span class="line">        if (p == nullptr &amp;&amp; q == nullptr) return true;</span><br><span class="line">        // 情况 B: 一个空一个不空 -&gt; 不对称</span><br><span class="line">        if (p == nullptr || q == nullptr) return false;</span><br><span class="line">        // 情况 C: 两个都有值，但值不相等 -&gt; 不对称</span><br><span class="line">        if (p-&gt;val != q-&gt;val) return false;</span><br><span class="line"></span><br><span class="line">        // 2. 递归比较</span><br><span class="line">        // 必须同时满足：</span><br><span class="line">        // (1) p 的左 vs q 的右 (外侧)</span><br><span class="line">        // (2) p 的右 vs q 的左 (内侧)</span><br><span class="line">        return check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-解法二：迭代法-BFS-Queue"><a href="#4-解法二：迭代法-BFS-Queue" class="headerlink" title="4. 解法二：迭代法 (BFS&#x2F;Queue)"></a>4. 解法二：迭代法 (BFS&#x2F;Queue)</h3><p>如果你不想用递归，也可以用 <strong>队列</strong> 来模拟。</p>
<p>我们每次往队列里放入 <strong>一对</strong> 节点，拿出来比较时也拿一对。</p>
<p><strong>注意入队顺序</strong>：</p>
<p>必须按照 <strong>相反</strong> 的顺序放入孩子节点。</p>
<ul>
<li>放 <code>u</code> 的左，必须紧接着放 <code>v</code> 的右。</li>
<li>放 <code>u</code> 的右，必须紧接着放 <code>v</code> 的左。</li>
</ul>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return true;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        // 初始化：放入左右子节点</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 每次取出两个节点进行比较</span><br><span class="line">            TreeNode* u = q.front(); q.pop();</span><br><span class="line">            TreeNode* v = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">            // 1. 两个都是空，说明这层都没孩子，继续比其他的</span><br><span class="line">            if (!u &amp;&amp; !v) continue;</span><br><span class="line"></span><br><span class="line">            // 2. 一个空一个不空，或者值不一样 -&gt; 失败</span><br><span class="line">            if ((!u || !v) || (u-&gt;val != v-&gt;val)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 将孩子成对加入队列（注意镜像顺序！）</span><br><span class="line">            // 外侧 vs 外侧</span><br><span class="line">            q.push(u-&gt;left);</span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line">            </span><br><span class="line">            // 内侧 vs 内侧</span><br><span class="line">            q.push(u-&gt;right);</span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们遍历了整棵树，每个节点仅被访问一次。</li>
</ul>
<h4 id="空间复杂度：-O-N"><a href="#空间复杂度：-O-N" class="headerlink" title="空间复杂度：$O(N)$"></a><strong>空间复杂度：$O(N)$</strong></h4><ul>
<li><strong>递归</strong>：最坏情况下（树退化成链），递归栈深度为 $N$。</li>
<li><strong>迭代</strong>：队列中最多同时存储每一层的节点数（即树的宽度），最坏也是 $O(N)$。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么是 <code>p-&gt;left</code> 和 <code>q-&gt;right</code> 比？</strong><ul>
<li><strong>A:</strong> 想象你站在镜子前举起<strong>左手</strong>。镜子里的你举起的是哪只手？从镜像的视角看，那是它的<strong>右手</strong>。这就是镜像对称的本质。</li>
</ul>
</li>
<li><strong>Q: 代码里的 <code>check</code> 函数能不能少写那个 <code>p-&gt;val != q-&gt;val</code>？</strong><ul>
<li><strong>A:</strong> 不能。如果值都不一样，结构再对称也没用。这是判断的核心逻辑之一。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <url>/2025/11/13/Hot100/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<p>题目：<br>给你两棵二叉树的前序遍历和中序遍历的结果，请你重建这棵树。</p>
<p>假设树中没有重复的值。</p>
<p><strong>示例 1：</strong><br>输入：preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出：[3,9,20,null,null,15,7]</p>
<p><strong>示例 2：</strong><br>输入：preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出：[-1]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li>
<li><code>preorder</code> 是 <code>inorder</code> 的前序遍历</li>
</ul>
<p>这道题是二叉树题目中 <strong>“还原大师”</strong> 级别的题目。</p>
<p>它是力扣（LeetCode）第 105 题。</p>
<p>这道题考察的是你对 <strong>“前序遍历”</strong> 和 <strong>“中序遍历”</strong> 特性的深刻理解。这就好比侦探破案：给你两个不同的侧面线索，让你还原出唯一的作案现场（二叉树结构）。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：从前序与中序遍历序列构造二叉树 (Construct Binary Tree from Preorder and Inorder Traversal)</p>
<p><strong>题目大意</strong>：</p>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code>，其中：</p>
<ul>
<li><code>preorder</code> 是二叉树的 <strong>先序遍历</strong>。</li>
<li><code>inorder</code> 是同一棵树的 <strong>中序遍历</strong>。</li>
<li>题目保证数组中 <strong>没有重复元素</strong>（这点至关重要）。</li>
</ul>
<p>请你构造并返回这棵二叉树。</p>
<p><strong>示例</strong>：</p>
<p>Input:</p>
<ul>
<li><code>preorder = [3, 9, 20, 15, 7]</code></li>
<li><code>inorder = [9, 3, 15, 20, 7]</code></li>
</ul>
<p>Output:</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-寻找突破口：根节点在哪里？"><a href="#2-1-寻找突破口：根节点在哪里？" class="headerlink" title="2.1 寻找突破口：根节点在哪里？"></a>2.1 寻找突破口：根节点在哪里？</h4><p>我们回顾一下两种遍历的特性：</p>
<ol>
<li><strong>前序遍历 (Preorder)</strong>：<code>[ 根 | 左子树... | 右子树... ]</code><ul>
<li><strong>铁律</strong>：前序遍历的 <strong>第一个元素</strong> 永远是当前的 <strong>根节点</strong>。</li>
</ul>
</li>
<li><strong>中序遍历 (Inorder)</strong>：<code>[ 左子树... | 根 | 右子树... ]</code><ul>
<li><strong>铁律</strong>：一旦确定了根节点，中序遍历中 <strong>根节点左边</strong> 的所有元素属于左子树，<strong>根节点右边</strong> 的所有元素属于右子树。</li>
</ul>
</li>
</ol>
<h4 id="2-2-算法流程-递归分治"><a href="#2-2-算法流程-递归分治" class="headerlink" title="2.2 算法流程 (递归分治)"></a>2.2 算法流程 (递归分治)</h4><p><strong>第一步：找根</strong></p>
<p>从 <code>preorder</code> 中取出第一个数 <code>3</code>。这就是整棵树的根。</p>
<p><strong>第二步：切分左右子树</strong></p>
<p>去 <code>inorder</code> 中找到 <code>3</code> 的位置（下标 1）。</p>
<ul>
<li><code>inorder</code> 变成了：<code>[9]</code> (左) + <code>3</code> (根) + <code>[15, 20, 7]</code> (右)。</li>
<li>我们可以得出结论：<ul>
<li><strong>左子树长度</strong>：1 个节点。</li>
<li><strong>右子树长度</strong>：3 个节点。</li>
</ul>
</li>
</ul>
<p><strong>第三步：切分前序数组</strong></p>
<p>回到 <code>preorder</code>，利用刚才算出的长度切分：</p>
<ul>
<li><code>preorder</code> 变成了：<code>3</code> (根) + <code>[9]</code> (左) + <code>[20, 15, 7]</code> (右)。</li>
</ul>
<p><strong>第四步：递归</strong></p>
<p>现在问题分解成了两个子问题：</p>
<ol>
<li><strong>左儿子</strong>：用 <code>pre = [9]</code>, <code>in = [9]</code> 构建。</li>
<li><strong>右儿子</strong>：用 <code>pre = [20, 15, 7]</code>, <code>in = [15, 20, 7]</code> 构建。</li>
</ol>
<hr>
<h3 id="3-优化技巧：哈希表-Hash-Map"><a href="#3-优化技巧：哈希表-Hash-Map" class="headerlink" title="3. 优化技巧：哈希表 (Hash Map)"></a>3. 优化技巧：哈希表 (Hash Map)</h3><p>在“第二步”中，我们需要在 <code>inorder</code> 数组中查找根节点的位置。</p>
<p>如果每次都用 <code>for</code> 循环遍历查找，时间复杂度是 $O(N)$，总复杂度会退化到 $O(N^2)$。</p>
<p><strong>优化</strong>：</p>
<p>我们可以提前把 <code>inorder</code> 数组中的 <code>元素 -&gt; 下标</code> 存到一个 <strong>哈希表</strong> 中。</p>
<p>这样查找根节点位置的操作就变成了 $O(1)$。</p>
<hr>
<h3 id="4-C-代码实现-OI-ACM-风格"><a href="#4-C-代码实现-OI-ACM-风格" class="headerlink" title="4. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>4. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 哈希表：存储 inorder 中 值 -&gt; 索引 的映射，方便快速定位根节点</span><br><span class="line">    unordered_map&lt;int, int&gt; indexMap;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        // 1. 初始化哈希表</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            indexMap[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 开启递归</span><br><span class="line">        // 传入参数：preorder 的范围 [p_start, p_end]，inorder 的范围 [i_start, i_end]</span><br><span class="line">        return myBuild(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 辅助递归函数</span><br><span class="line">    TreeNode* myBuild(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, </span><br><span class="line">                      int p_start, int p_end, int i_start, int i_end) &#123;</span><br><span class="line">        </span><br><span class="line">        // 递归终止条件：范围无效（比如 p_start &gt; p_end）</span><br><span class="line">        if (p_start &gt; p_end) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 获取根节点的值（前序遍历的第一个）</span><br><span class="line">        int rootVal = preorder[p_start];</span><br><span class="line">        </span><br><span class="line">        // 2. 建立根节点</span><br><span class="line">        TreeNode* root = new TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">        // 3. 在中序遍历中找到根节点的位置</span><br><span class="line">        int rootIndexInInorder = indexMap[rootVal];</span><br><span class="line"></span><br><span class="line">        // 4. 计算左子树的节点数量</span><br><span class="line">        // 这一步是核心！有了它才能正确划分前序数组</span><br><span class="line">        int leftSubtreeSize = rootIndexInInorder - i_start;</span><br><span class="line"></span><br><span class="line">        // 5. 递归构建左子树</span><br><span class="line">        // Preorder 范围：跳过根节点，往后数 leftSubtreeSize 个</span><br><span class="line">        // Inorder 范围：从开始到根节点前一个</span><br><span class="line">        root-&gt;left = myBuild(preorder, inorder, </span><br><span class="line">                             p_start + 1, p_start + leftSubtreeSize, </span><br><span class="line">                             i_start, rootIndexInInorder - 1);</span><br><span class="line"></span><br><span class="line">        // 6. 递归构建右子树</span><br><span class="line">        // Preorder 范围：跳过根节点和左子树，直到最后</span><br><span class="line">        // Inorder 范围：从根节点后一个到最后</span><br><span class="line">        root-&gt;right = myBuild(preorder, inorder, </span><br><span class="line">                              p_start + leftSubtreeSize + 1, p_end, </span><br><span class="line">                              rootIndexInInorder + 1, i_end);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>有了哈希表，查找根节点是 $O(1)$。</li>
<li>每个节点都会被构建一次，递归函数调用 $N$ 次。</li>
<li>总耗时 $O(N)$。</li>
</ul>
<h4 id="空间复杂度：-O-N"><a href="#空间复杂度：-O-N" class="headerlink" title="空间复杂度：$O(N)$"></a><strong>空间复杂度：$O(N)$</strong></h4><ul>
<li>哈希表存储了 $N$ 个映射。</li>
<li>递归栈的深度在最坏情况下（链状树）是 $O(N)$，平均是 $O(\log N)$。</li>
<li>总空间 $O(N)$。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么题目强调“没有重复元素”？</strong><ul>
<li><strong>A:</strong> 如果有重复元素（例如两个 <code>3</code>），当我们在 <code>inorder</code> 中查找 <code>3</code> 时，就不知道哪个 <code>3</code> 才是当前的根节点了，无法唯一确定左右子树的边界。</li>
</ul>
</li>
<li><strong>Q: 必须用前序 + 中序吗？后序 + 中序行不行？</strong><ul>
<li><strong>A:</strong> <strong>行！</strong><ul>
<li>前序：根在开头。</li>
<li>后序：根在末尾 (<code>[ 左... | 右... | 根 ]</code>)。</li>
<li>只要有 <strong>中序</strong>，再加上 <strong>前序或后序</strong> 的任意一个，就能还原树。</li>
<li><em>但是：前序 + 后序 是无法唯一还原二叉树的（除非是满二叉树），因为无法区分左右子树。</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 下标计算容易晕怎么办？</strong><ul>
<li><strong>A:</strong> 记住一个核心公式：<ul>
<li><strong>左子树大小 <code>size</code></strong> &#x3D; <code>root_idx - in_start</code>。</li>
<li>前序切分永远是：<code>[根]</code>, <code>[start+1, start+size]</code>, <code>[start+size+1, end]</code>。</li>
<li>中序切分永远是：<code>[start, root_idx-1]</code>, <code>[root]</code>, <code>[root_idx+1, end]</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2025/11/13/Hot100/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p>
<p>题目：<br>给你一个整数数组 <code>nums</code>，其中元素按升序排列。请你将其转换为一棵高度平衡的二叉搜索树。</p>
<p><strong>高度平衡二叉树</strong> 定义为：任意节点的左右子树高度差不超过 1。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也是一个有效答案。</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 也是一个有效答案。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10⁴</code></li>
<li><code>-10⁴ &lt;= nums[i] &lt;= 10⁴</code></li>
<li><code>nums</code> 是严格递增的</li>
</ul>
<p>这道题是 <strong>二叉搜索树 (BST)</strong> 构建问题的经典入门题。</p>
<p>它是力扣（LeetCode）第 108 题。</p>
<p>这道题考察的是你对 BST 性质的逆向思维：通常我们说“BST 的中序遍历是有序数组”，现在反过来，<strong>给你一个有序数组，让你还原出一棵平衡的 BST</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：将有序数组转换为二叉搜索树 (Convert Sorted Array to Binary Search Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列。</p>
<p>请你将其转换为一棵 <strong>高度平衡</strong> 的二叉搜索树。</p>
<p><strong>高度平衡</strong> 的定义：</p>
<p>一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [-10, -3, 0, 5, 9]</code></p>
<p>输出：<code>[0, -3, 9, -10, null, 5]</code></p>
<p>（或者其他平衡的变种，答案不唯一）</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么要找中间节点？"><a href="#2-1-为什么要找中间节点？" class="headerlink" title="2.1 为什么要找中间节点？"></a>2.1 为什么要找中间节点？</h4><p>如果我们要构建一棵 <strong>平衡</strong> 的树，意味着左右两边的节点数量要大致相等。</p>
<p>在一个有序数组中，<strong>中位数 (Middle Element)</strong> 天然地把数组分成了数量相等的左右两部分。</p>
<ul>
<li>如果我们选 <strong>数组中间的数</strong> 作为 <strong>根节点</strong>：<ul>
<li><strong>左边的数</strong> 都比它小 $\rightarrow$ 刚好构成 <strong>左子树</strong>。</li>
<li><strong>右边的数</strong> 都比它大 $\rightarrow$ 刚好构成 <strong>右子树</strong>。</li>
</ul>
</li>
</ul>
<p>这正是 <strong>分治法 (Divide and Conquer)</strong> 的完美应用场景。</p>
<h4 id="2-2-算法流程"><a href="#2-2-算法流程" class="headerlink" title="2.2 算法流程"></a>2.2 算法流程</h4><ol>
<li><strong>取中点</strong>：找到当前数组范围 <code>[left, right]</code> 的中间位置 <code>mid</code>。</li>
<li><strong>建根</strong>：用 <code>nums[mid]</code> 创建一个新节点。</li>
<li><strong>递归左边</strong>：用 <code>[left, mid - 1]</code> 这个范围去构建左子树，并挂在根节点的左边。</li>
<li><strong>递归右边</strong>：用 <code>[mid + 1, right]</code> 这个范围去构建右子树，并挂在根节点的右边。</li>
<li><strong>终止条件</strong>：当 <code>left &gt; right</code> 时，说明当前范围没有数字了，返回 <code>nullptr</code>。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-递归法"><a href="#3-C-代码实现-递归法" class="headerlink" title="3. C++ 代码实现 (递归法)"></a>3. C++ 代码实现 (递归法)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 调用辅助递归函数，传入整个数组的范围</span><br><span class="line">        return buildBST(nums, 0, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 辅助函数：在 nums[left...right] 范围内构建 BST</span><br><span class="line">    TreeNode* buildBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">        // 1. 递归终止条件 (Base Case)</span><br><span class="line">        // 如果左边界超过了右边界，说明区间为空</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 找中点 (总是选择中间位置左边的数字作为根)</span><br><span class="line">        // 防止 (left + right) 溢出的写法：left + (right - left) / 2</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line"></span><br><span class="line">        // 3. 创建根节点</span><br><span class="line">        TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        // 4. 递归构建左右子树</span><br><span class="line">        // 左子树范围：[left, mid - 1]</span><br><span class="line">        root-&gt;left = buildBST(nums, left, mid - 1);</span><br><span class="line">        </span><br><span class="line">        // 右子树范围：[mid + 1, right]</span><br><span class="line">        root-&gt;right = buildBST(nums, mid + 1, right);</span><br><span class="line"></span><br><span class="line">        // 5. 返回构建好的根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>每个元素都被访问一次用来创建节点。</li>
<li>递归过程没有重复计算。</li>
</ul>
<h4 id="空间复杂度：-O-log-N"><a href="#空间复杂度：-O-log-N" class="headerlink" title="空间复杂度：$O(\log N)$"></a><strong>空间复杂度：$O(\log N)$</strong></h4><ul>
<li>这里的空间主要消耗在 <strong>递归调用栈</strong>。</li>
<li>因为我们每次都取中点，构建出来的是一棵 <strong>平衡二叉树</strong>。</li>
<li>平衡二叉树的高度是 $\log N$，所以递归深度也是 $\log N$。</li>
<li><em>注：如果构建成链状树（比如每次取第一个元素做根），递归深度就是 $O(N)$，但本题算法保证了平衡。</em></li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 数组长度是偶数时，中间有两个数，选哪个？</strong><ul>
<li><strong>A:</strong> 选左边的或者右边的都可以。</li>
<li>比如 <code>[1, 2]</code>。</li>
<li>选左边 <code>1</code> 做根：<code>2</code> 是右孩子。</li>
<li>选右边 <code>2</code> 做根：<code>1</code> 是左孩子。</li>
<li>这两种都是平衡的 BST。题目通常接受任意一种解法。</li>
</ul>
</li>
<li><strong>Q: 为什么要用 <code>left + (right - left) / 2</code> 而不是 <code>(left + right) / 2</code>？</strong><ul>
<li><strong>A:</strong> 这是一个编程习惯问题。在 <code>left</code> 和 <code>right</code> 都非常大（接近整数最大值 <code>INT_MAX</code>）时，直接相加可能会导致 <strong>整型溢出 (Overflow)</strong> 变成负数。虽然这道题的数据范围可能不会溢出，但写成前者是更安全的工程规范。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与GitHub入门学习（一）</title>
    <url>/2025/07/18/Git/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<h1 id="🧰-Git-和-GitHub-零基础入门教程"><a href="#🧰-Git-和-GitHub-零基础入门教程" class="headerlink" title="🧰 Git 和 GitHub 零基础入门教程"></a>🧰 Git 和 GitHub 零基础入门教程</h1><blockquote>
<p>本教程适合从来没有用过 Git 和 GitHub 的朋友，一步步教你搭建开发环境、上传代码，并掌握最常用的命令。</p>
</blockquote>
<hr>
<h2 id="🧠一、什么是-Git-和-GitHub？"><a href="#🧠一、什么是-Git-和-GitHub？" class="headerlink" title="🧠一、什么是 Git 和 GitHub？"></a>🧠一、什么是 Git 和 GitHub？</h2><table>
<thead>
<tr>
<th>名称</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Git</strong></td>
<td>本地的版本控制工具，能记录文件修改历史，就像“时间机器”</td>
</tr>
<tr>
<td><strong>GitHub</strong></td>
<td>一个远程代码托管平台，让你把 Git 项目上传到云端，并支持协作开发</td>
</tr>
</tbody></table>
<hr>
<h2 id="🛠️-二、安装-Git"><a href="#🛠️-二、安装-Git" class="headerlink" title="🛠️ 二、安装 Git"></a>🛠️ 二、安装 Git</h2><h3 id="1-下载并安装-Git"><a href="#1-下载并安装-Git" class="headerlink" title="1. 下载并安装 Git"></a>1. 下载并安装 Git</h3><ul>
<li>打开官网：<a href="https://git-scm.com/">https://git-scm.com/</a></li>
<li>点击 <strong>Download</strong> 按钮，下载安装程序</li>
<li>一路点击“下一步”，保持默认设置即可</li>
</ul>
<h3 id="2-验证安装"><a href="#2-验证安装" class="headerlink" title="2. 验证安装"></a>2. 验证安装</h3><p>打开终端或命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">看到如下类似内容说明安装成功：</span><br><span class="line">git version 2.xx.x</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="👤-三、注册-GitHub-账号"><a href="#👤-三、注册-GitHub-账号" class="headerlink" title="👤 三、注册 GitHub 账号"></a>👤 三、注册 GitHub 账号</h2><ol>
<li>打开 <a href="https://github.com/">https://github.com</a></li>
<li>点击右上角 <strong>Sign up</strong></li>
<li>填写用户名、邮箱和密码，完成注册</li>
<li>登录成功后可以访问你的主页：<a href="https://github.com/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D">https://github.com/你的用户名</a></li>
</ol>
<hr>
<h2 id="📁-四、本地创建第一个-Git-项目"><a href="#📁-四、本地创建第一个-Git-项目" class="headerlink" title="📁 四、本地创建第一个 Git 项目"></a>📁 四、本地创建第一个 Git 项目</h2><h3 id="1-创建文件夹并进入"><a href="#1-创建文件夹并进入" class="headerlink" title="1. 创建文件夹并进入"></a>1. 创建文件夹并进入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-first-git</span><br><span class="line"><span class="built_in">cd</span> my-first-git</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化仓库"><a href="#2-初始化仓库" class="headerlink" title="2. 初始化仓库"></a>2. 初始化仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="3-添加一个文件"><a href="#3-添加一个文件" class="headerlink" title="3. 添加一个文件"></a>3. 添加一个文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, Git!&quot;</span> &gt; readme.txt</span><br></pre></td></tr></table></figure>

<h3 id="4-查看当前状态"><a href="#4-查看当前状态" class="headerlink" title="4. 查看当前状态"></a>4. 查看当前状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="5-添加到暂存区"><a href="#5-添加到暂存区" class="headerlink" title="5. 添加到暂存区"></a>5. 添加到暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure>

<h3 id="6-提交到仓库"><a href="#6-提交到仓库" class="headerlink" title="6. 提交到仓库"></a>6. 提交到仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;第一次提交：添加了 readme.txt&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="☁️-五、将项目上传到-GitHub"><a href="#☁️-五、将项目上传到-GitHub" class="headerlink" title="☁️ 五、将项目上传到 GitHub"></a>☁️ 五、将项目上传到 GitHub</h2><h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a>1. 创建远程仓库</h3><ul>
<li>登录 GitHub</li>
<li>点击右上角 ➕ &gt; <strong>New repository</strong></li>
<li>仓库名填入：<code>my-first-git</code></li>
<li>点击 “Create repository”</li>
</ul>
<h3 id="2-将本地项目关联到-GitHub"><a href="#2-将本地项目关联到-GitHub" class="headerlink" title="2. 将本地项目关联到 GitHub"></a>2. 将本地项目关联到 GitHub</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/你的用户名/my-first-git.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：第一次 push 可能需要登录 GitHub 账户或使用 Token，可以使用 GitHub Desktop 简化这个过程。</p>
</blockquote>
<hr>
<h2 id="🔁-六、日常操作流程（记住这三步）"><a href="#🔁-六、日常操作流程（记住这三步）" class="headerlink" title="🔁 六、日常操作流程（记住这三步）"></a>🔁 六、日常操作流程（记住这三步）</h2><p>每次改完文件后，执行这三步即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;你修改了什么&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🖼️-七、图形化工具推荐（不写命令也能用）"><a href="#🖼️-七、图形化工具推荐（不写命令也能用）" class="headerlink" title="🖼️ 七、图形化工具推荐（不写命令也能用）"></a>🖼️ 七、图形化工具推荐（不写命令也能用）</h2><table>
<thead>
<tr>
<th>工具</th>
<th>官网</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>GitHub Desktop</td>
<td><a href="https://desktop.github.com/">https://desktop.github.com</a></td>
<td>官方图形客户端</td>
</tr>
<tr>
<td>Sourcetree</td>
<td><a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com</a></td>
<td>专业 Git 可视化工具</td>
</tr>
</tbody></table>
<hr>
<h2 id="📚-八、可以继续学习的内容"><a href="#📚-八、可以继续学习的内容" class="headerlink" title="📚 八、可以继续学习的内容"></a>📚 八、可以继续学习的内容</h2><ul>
<li>Git 分支（branch）和合并（merge）</li>
<li>GitHub 的 Pull Request 协作流程</li>
<li>使用 <code>.gitignore</code> 忽略不必要的文件</li>
<li>VS Code 中的 Git 集成操作</li>
</ul>
<hr>
<h2 id="✅-九、常用命令总结"><a href="#✅-九、常用命令总结" class="headerlink" title="✅ 九、常用命令总结"></a>✅ 九、常用命令总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init              <span class="comment"># 初始化仓库</span></span><br><span class="line">git add .             <span class="comment"># 添加所有更改</span></span><br><span class="line">git commit -m <span class="string">&quot;说明&quot;</span>  <span class="comment"># 提交更改</span></span><br><span class="line">git status            <span class="comment"># 查看当前状态</span></span><br><span class="line">git push              <span class="comment"># 推送到 GitHub</span></span><br><span class="line">git pull              <span class="comment"># 拉取远程更新</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>200. 岛屿数量</title>
    <url>/2025/11/13/Hot100/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p>
<p>题目：<br>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的二维网格，请你计算网格中岛屿的数量。</p>
<p><strong>岛屿</strong> 是被水包围并且在水平方向或垂直方向上相邻的陆地单元格组成的集合。你可以假设网格的四个边缘都被水包围。</p>
<p><strong>示例 1：</strong><br>输入：grid &#x3D; [<br>[“1”,”1”,”1”,”1”,”0”],<br>[“1”,”1”,”0”,”1”,”0”],<br>[“1”,”1”,”0”,”0”,”0”],<br>[“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p>
<p><strong>示例 2：</strong><br>输入：grid &#x3D; [<br>[“1”,”1”,”0”,”0”,”0”],<br>[“1”,”1”,”0”,”0”,”0”],<br>[“0”,”0”,”1”,”0”,”0”],<br>[“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<p>这道题是 <strong>图论 (Graph Theory)</strong> 和 <strong>搜索算法 (DFS&#x2F;BFS)</strong> 的“开山之作”。</p>
<p>它是力扣（LeetCode）第 200 题 <strong>“岛屿数量 (Number of Islands)”</strong>。</p>
<p>恭喜你！在攻克了链表和二叉树之后，你正式进入了 <strong>二维网格 (Grid)</strong> 的世界。这道题是所有网格类题目（迷宫、扫雷、腐烂橘子）的鼻祖。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：岛屿数量 (Number of Islands)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的二维网格地图。</p>
<p>请你计算网格中岛屿的数量。</p>
<ul>
<li><strong>定义</strong>：岛屿总是被水包围，并且每座岛屿只能由 <strong>水平方向</strong> 或 <strong>竖直方向</strong> 上相邻的陆地连接形成。（<strong>斜着不算</strong>）</li>
<li>假设网格的四条边均被水包围。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：<code>1</code> （左上角那一坨全是连着的，算一个）</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：<code>3</code> （左上角一堆，中间一个，右下角一堆）</p>
<hr>
<h3 id="2-核心思路：沉岛策略-Sinking-Strategy"><a href="#2-核心思路：沉岛策略-Sinking-Strategy" class="headerlink" title="2. 核心思路：沉岛策略 (Sinking Strategy)"></a>2. 核心思路：沉岛策略 (Sinking Strategy)</h3><h4 id="2-1-怎么数？"><a href="#2-1-怎么数？" class="headerlink" title="2.1 怎么数？"></a>2.1 怎么数？</h4><p>如果我们是人类去数，我们会用手指按住一块陆地，然后沿着它的边缘把整块陆地描出来，记为“1个岛”。然后去找下一块没被描过的陆地。</p>
<h4 id="2-2-计算机怎么做？"><a href="#2-2-计算机怎么做？" class="headerlink" title="2.2 计算机怎么做？"></a>2.2 计算机怎么做？</h4><p>我们需要遍历网格中的每一个格子：</p>
<ol>
<li>当我们遇到 <strong>水 (<code>&#39;0&#39;</code>)</strong>：跳过，不管。</li>
<li>当我们遇到 <strong>陆地 (<code>&#39;1&#39;</code>)</strong>：<ul>
<li><strong>计数器 +1</strong>（发现新大陆了！）。</li>
<li><strong>关键步骤</strong>：为了不重复计算，我们需要把这块陆地，以及和它相连的所有陆地，全部 <strong>“炸沉”</strong>（把 <code>&#39;1&#39;</code> 改成 <code>&#39;0&#39;</code>）。</li>
<li>为什么要炸沉？如果不炸，当你遍历到它旁边的格子时，你又会把它当成一个新的岛屿。</li>
</ul>
</li>
</ol>
<p><strong>这个“炸沉”的过程，就是 DFS（深度优先搜索）或 BFS（广度优先搜索）。</strong></p>
<hr>
<h3 id="3-C-代码实现-DFS-推荐"><a href="#3-C-代码实现-DFS-推荐" class="headerlink" title="3. C++ 代码实现 (DFS - 推荐)"></a>3. C++ 代码实现 (DFS - 推荐)</h3><p>DFS 是写起来最爽、代码最短的方法。</p>
<p>我们定义一个 <code>dfs</code> 函数，它的作用只有一个：<strong>从当前位置开始，把所有相连的陆地都变成水。</strong></p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if (grid.empty()) return 0;</span><br><span class="line">        </span><br><span class="line">        int m = grid.size();    // 行数</span><br><span class="line">        int n = grid[0].size(); // 列数</span><br><span class="line">        int count = 0;</span><br><span class="line"></span><br><span class="line">        // 遍历每一个格子</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                // 只有当它是 &#x27;1&#x27; (陆地) 时，才开始计算</span><br><span class="line">                if (grid[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    // 发现一个岛屿，计数加 1</span><br><span class="line">                    count++;</span><br><span class="line">                    // 启动核武器：把这个岛及与其相连的陆地全部炸沉</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 辅函数：深度优先搜索 (负责炸沉岛屿)</span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) &#123;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size();</span><br><span class="line"></span><br><span class="line">        // 1. 递归终止条件 (Base Case)</span><br><span class="line">        // 越界了？或者 已经是水了？-&gt; 停止</span><br><span class="line">        if (r &lt; 0 || c &lt; 0 || r &gt;= m || c &gt;= n || grid[r][c] == &#x27;0&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 将当前陆地标记为水 (沉岛)</span><br><span class="line">        // 这一步非常重要，避免后续重复访问，导致死循环</span><br><span class="line">        grid[r][c] = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">        // 3. 递归访问上下左右四个方向</span><br><span class="line">        dfs(grid, r - 1, c); // 上</span><br><span class="line">        dfs(grid, r + 1, c); // 下</span><br><span class="line">        dfs(grid, r, c - 1); // 左</span><br><span class="line">        dfs(grid, r, c + 1); // 右</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-M-times-N"><a href="#时间复杂度：-O-M-times-N" class="headerlink" title="时间复杂度：$O(M \times N)$"></a><strong>时间复杂度：$O(M \times N)$</strong></h4><ul>
<li>$M$ 是行数，$N$ 是列数。</li>
<li>虽然看起来有两层 <code>for</code> 循环加上递归，但实际上<strong>每个格子最多被访问两次</strong>：<ol>
<li>在主循环中被检查一次。</li>
<li>在 <code>dfs</code> 中被变成 <code>&#39;0&#39;</code> 一次。</li>
</ol>
</li>
<li>变成 <code>&#39;0&#39;</code> 之后，永远不会再触发递归。</li>
</ul>
<h4 id="空间复杂度：-O-M-times-N"><a href="#空间复杂度：-O-M-times-N" class="headerlink" title="空间复杂度：$O(M \times N)$"></a><strong>空间复杂度：$O(M \times N)$</strong></h4><ul>
<li>最坏情况下（整个网格全是陆地），递归栈的深度会达到 $M \times N$（一条贪吃蛇填满格子）。</li>
</ul>
<hr>
<h3 id="5-另一种思路：BFS-广度优先"><a href="#5-另一种思路：BFS-广度优先" class="headerlink" title="5. 另一种思路：BFS (广度优先)"></a>5. 另一种思路：BFS (广度优先)</h3><p>虽然 DFS 代码短，但有时候面试官会问：“如果栈溢出怎么办？能不能用迭代？”</p>
<p>这时候就要祭出 <strong>队列 (Queue)</strong> 进行 BFS。</p>
<p><strong>逻辑</strong>：</p>
<ol>
<li>遇到 <code>&#39;1&#39;</code>，入队，计数 +1，<strong>立刻标记为 <code>&#39;0&#39;</code></strong>（防止被别人重复入队）。</li>
<li>循环取队头，把队头四周的 <code>&#39;1&#39;</code> 也入队，并标记为 <code>&#39;0&#39;</code>。</li>
<li>像病毒扩散一样一层层炸沉岛屿。</li>
</ol>
<p><em>(BFS 代码比 DFS 长很多，通常作为备选方案，除非求最短路径，否则首选 DFS)</em></p>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><p><strong>Q: 为什么要把 <code>&#39;1&#39;</code> 改成 <code>&#39;0&#39;</code>？能不能用一个 <code>visited</code> 数组？</strong></p>
<ul>
<li><strong>A:</strong> 可以用 <code>visited</code> 数组，但那样需要额外的 $O(M \times N)$ 空间。直接修改原数组（In-place）是最省空间的做法。如果面试官要求“不能修改原数组”，那你再开 <code>visited</code>。</li>
</ul>
</li>
<li><p><strong>Q: 四个方向怎么写更优雅？</strong></p>
<ul>
<li><p><strong>A:</strong> 工程中常定义方向数组：</p>
<p><code>int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</code></p>
<p>然后用循环 <code>for (auto d : dirs)</code> 来代替写四行递归。但在面试中，手写四行有时更直观，不容易写错下标。</p>
</li>
</ul>
</li>
<li><p><strong>Q: 斜着连接算不算？</strong></p>
<ul>
<li><strong>A:</strong> 题目说了不算。如果题目改成“斜着也算”，你只需要在 <code>dfs</code> 里多加 4 个递归方向（左上、右上、左下、右下）即可。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>438找到字符串中所有字母异位词</title>
    <url>/2025/11/13/Hot100/%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p>
<p>题目：<br>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>字母异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>字母异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10⁴</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<p>这道题是 <strong>定长滑动窗口 (Fixed-size Sliding Window)</strong> 的经典代表作。</p>
<p>如果说“无重复字符的最长子串”是窗口大小<strong>忽大忽小</strong>（不定长）的变形金刚，那么这道题的窗口就是<strong>固定框大小</strong>的扫描仪。它会教你如何在窗口平移的过程中，高效地更新数据，而不是每次都重算。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：找到字符串中所有字母异位词 (Find All Anagrams in a String)</p>
<p><strong>题目大意</strong>：</p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>。找到 <code>s</code> 中所有是 <code>p</code> 的 <strong>字母异位词</strong> 的子串，返回这些子串的起始索引。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>字母异位词</strong>：指由相同字母重排列形成的字符串（比如 “cba” 是 “abc” 的异位词）。</li>
<li><strong>子串</strong>：必须是连续的。</li>
<li><strong>隐含信息</strong>：要找的子串长度固定，<strong>必须等于 <code>p</code> 的长度</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>s = &quot;cbaebabacd&quot;</code>, <code>p = &quot;abc&quot;</code></p>
<p>输出：<code>[0, 6]</code></p>
<p>解释：</p>
<ul>
<li>起始索引 0 的子串是 “cba”，它是 “abc” 的异位词。</li>
<li>起始索引 6 的子串是 “bac”，它是 “abc” 的异位词。</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-暴力法为什么慢？"><a href="#2-1-暴力法为什么慢？" class="headerlink" title="2.1 暴力法为什么慢？"></a>2.1 暴力法为什么慢？</h4><p>假设 <code>s</code> 长度为 $N$，<code>p</code> 长度为 $M$。</p>
<p>如果我们遍历 <code>s</code> 中的每一个位置，截取长度为 $M$ 的子串，然后排序比较（或者统计字符），复杂度大概是 $O(N \cdot M \log M)$ 或 $O(N \cdot M)$。</p>
<p>当字符串很长时，重复统计每个窗口内的字符是非常浪费的。</p>
<h4 id="2-2-核心策略：定长滑动窗口-差量更新"><a href="#2-2-核心策略：定长滑动窗口-差量更新" class="headerlink" title="2.2 核心策略：定长滑动窗口 + 差量更新"></a>2.2 核心策略：定长滑动窗口 + 差量更新</h4><p>我们维护一个长度永远为 <code>p.size()</code> 的窗口。</p>
<p><strong>关键在于窗口移动时的变化</strong>：</p>
<p>当窗口向右移动一格：</p>
<ul>
<li><strong>进来了一个新字符</strong>（右边加入）。</li>
<li><strong>出去了一个旧字符</strong>（左边移除）。</li>
<li>中间的字符<strong>完全没变</strong>！</li>
</ul>
<p>利用这个特性，我们不需要每次都重新数窗口里有几个 ‘a’, 几个 ‘b’。我们只需要更新“进来的”和“出去的”那两个字符的计数即可。</p>
<h4 id="2-3-比较两个计数数组"><a href="#2-3-比较两个计数数组" class="headerlink" title="2.3 比较两个计数数组"></a>2.3 比较两个计数数组</h4><p>怎么判断窗口内的字符和 <code>p</code> 是不是异位词？</p>
<ul>
<li>给 <code>p</code> 做一个统计表（比如 <code>count_p</code>）。</li>
<li>给当前窗口做一个统计表（比如 <code>count_window</code>）。</li>
<li>如果这两个表一模一样（<code>vector</code> 可以直接 <code>==</code> 比较），那就是异位词。</li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这里我们使用长度为 26 的整数数组来充当哈希表（因为题目只包含小写字母），这比 <code>unordered_map</code> 更快且空间更省。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findAnagrams(string s, string p) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int m = p.size();</span><br><span class="line"></span><br><span class="line">        // 特判：如果 s 比 p 还短，根本凑不出，直接返回</span><br><span class="line">        if (n &lt; m) return result;</span><br><span class="line"></span><br><span class="line">        // 1. 初始化统计表</span><br><span class="line">        // p_count: 目标字符串 p 的字符统计</span><br><span class="line">        // window_count: 当前滑动窗口的字符统计</span><br><span class="line">        vector&lt;int&gt; p_count(26, 0);</span><br><span class="line">        vector&lt;int&gt; window_count(26, 0);</span><br><span class="line"></span><br><span class="line">        // 2. 先统计 p 的字符，并建立第一个窗口（前 m 个字符）</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            p_count[p[i] - &#x27;a&#x27;]++;</span><br><span class="line">            window_count[s[i] - &#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查第一个窗口（索引 0）是否符合</span><br><span class="line">        if (window_count == p_count) &#123;</span><br><span class="line">            result.push_back(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 开始滑动窗口</span><br><span class="line">        // left 指向窗口最左边，right 指向即将进入窗口的下一个字符</span><br><span class="line">        // 当前窗口范围是 [left, left + m - 1]</span><br><span class="line">        // 我们要让窗口整体右移，所以 i 代表 left 的位置，从 0 开始移到 1</span><br><span class="line">        for (int i = 0; i &lt; n - m; ++i) &#123;</span><br><span class="line">            // i 是当前窗口最左边的下标，它即将被移出窗口</span><br><span class="line">            // i + m 是当前窗口右边界的下一个下标，它即将加入窗口</span><br><span class="line">            </span><br><span class="line">            // 【移除】左边的字符 s[i]</span><br><span class="line">            window_count[s[i] - &#x27;a&#x27;]--;</span><br><span class="line">            </span><br><span class="line">            // 【加入】右边的字符 s[i + m]</span><br><span class="line">            window_count[s[i + m] - &#x27;a&#x27;]++;</span><br><span class="line"></span><br><span class="line">            // 【检查】新的窗口是否匹配</span><br><span class="line">            // i + 1 是新窗口的起始索引</span><br><span class="line">            if (window_count == p_count) &#123;</span><br><span class="line">                result.push_back(i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n-（更精确是-O-n-times-Sigma-）"><a href="#时间复杂度：-O-n-（更精确是-O-n-times-Sigma-）" class="headerlink" title="时间复杂度：$O(n)$ （更精确是 $O(n \times |\Sigma|)$）"></a><strong>时间复杂度：$O(n)$</strong> （更精确是 $O(n \times |\Sigma|)$）</h4><ul>
<li>我们遍历了一遍字符串 <code>s</code>，循环次数是 $n$。</li>
<li>在每次循环中，我们做了两次数组更新（$O(1)$）。</li>
<li>关键点：<code>window_count == p_count</code> 这一步比较，虽然是一行代码，但底层是比较两个长度为 26 的数组。这是一个常数操作（最多比较 26 次）。</li>
<li>所以总复杂度是 $O(26 \cdot n) \approx O(n)$。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只用了两个长度为 26 的固定数组。空间消耗不随输入字符串长度增长。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要用 vector 比较，而不是直接用个变量记录“匹配上的字符数量”？</strong><ul>
<li><strong>A:</strong> 这是一个很好的优化思路！</li>
<li>其实可以用一个变量 <code>diff</code> 来记录当前窗口和 <code>p</code> 之间有多少个字符计数不一样。</li>
<li>如果 <code>diff == 0</code>，就是异位词。</li>
<li>这种做法虽然能把比较的 $O(26)$ 降到 $O(1)$，但代码逻辑会复杂不少（要处理计数从 0 变 1，从 1 变 0 等各种情况）。对于面试，<strong>直接比较 vector (长度26) 既清晰又足够快</strong>，是性价比最高的写法。</li>
</ul>
</li>
<li><strong>Q: 为什么 <code>for</code> 循环只到 <code>n - m</code>？</strong><ul>
<li><strong>A:</strong> 因为我们的窗口大小是 <code>m</code>。</li>
<li>最后一个合法的窗口起始位置是 <code>n - m</code>（比如 s 长度 10，p 长度 3，最后一个窗口下标是 7, 8, 9）。</li>
<li>再往后，剩下的字符就不够凑满一个窗口了。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>148. 排序链表</title>
    <url>/2025/11/13/Hot100/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p>
<p>题目：<br>给你链表的头节点 <code>head</code>，请将其按升序排列并返回排序后的链表。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; []<br>输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5 * 10⁴]</code></li>
<li><code>-5 * 10⁴ &lt;= Node.val &lt;= 5 * 10⁴</code></li>
</ul>
<p>这道题是链表排序问题的“终极考核”。</p>
<p>题目要求对链表进行排序，且要求 <strong>时间复杂度 $O(n \log n)$</strong>。</p>
<p>这直接就把冒泡排序、插入排序（$O(n^2)$）给否定了。在 $O(n \log n)$ 级别的排序算法中（快排、堆排、归并），<strong>归并排序 (Merge Sort)</strong> 是最适合链表的。</p>
<p>为什么？</p>
<ol>
<li><strong>随机访问难</strong>：快排依赖下标随机访问（找 pivot），链表做不到。</li>
<li><strong>内存不连续</strong>：堆排需要构建二叉堆，通常依赖数组结构。</li>
<li><strong>指针优势</strong>：归并排序的核心是“合并”，链表合并只需要改变指针，不需要像数组那样搬移数据，非常高效。</li>
</ol>
<p>这道题其实是你之前学过的 <strong>“找中点”</strong> + <strong>“合并两个有序链表”</strong> 的组合拳。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：排序链表 (Sort List)</p>
<p><strong>题目大意</strong>：</p>
<p>给你链表的头结点 <code>head</code>，请将其按 <strong>升序</strong> 排列并返回排序后的链表。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>4 -&gt; 2 -&gt; 1 -&gt; 3</code></p>
<p>输出：<code>1 -&gt; 2 -&gt; 3 -&gt; 4</code></p>
<hr>
<h3 id="2-核心思路分析：归并排序-Divide-and-Conquer"><a href="#2-核心思路分析：归并排序-Divide-and-Conquer" class="headerlink" title="2. 核心思路分析：归并排序 (Divide and Conquer)"></a>2. 核心思路分析：归并排序 (Divide and Conquer)</h3><p>归并排序的思想是 <strong>“分而治之”</strong>：</p>
<ol>
<li><strong>分 (Divide)</strong>：把链表从中间一分为二，断开。</li>
<li><strong>治 (Conquer)</strong>：递归地对左半部分和右半部分分别进行排序。</li>
<li><strong>合 (Merge)</strong>：将两个已经排好序的子链表，合并成一个有序链表。</li>
</ol>
<h4 id="具体步骤拆解："><a href="#具体步骤拆解：" class="headerlink" title="具体步骤拆解："></a>具体步骤拆解：</h4><ol>
<li><strong>找中点（砍一刀）</strong>：<ul>
<li>使用 <strong>快慢指针</strong>。快指针一次走两步，慢指针一次走一步。</li>
<li>当快指针走到头时，慢指针刚好在中间。</li>
<li><strong>关键点</strong>：我们需要把链表断开 (<code>slow-&gt;next = nullptr</code>)，分成 <code>head</code> 开头的左链表和 <code>mid</code> 开头的右链表。</li>
</ul>
</li>
<li><strong>递归排序</strong>：<ul>
<li><code>left = sortList(leftHead)</code></li>
<li><code>right = sortList(rightHead)</code></li>
<li><strong>递归出口</strong>：当链表为空或只有一个节点时，默认有序，直接返回。</li>
</ul>
</li>
<li><strong>合并（缝合）</strong>：<ul>
<li>这正是我们之前讲过的 <strong>“合并两个有序链表”</strong> (LeetCode 21)。</li>
<li>使用一个虚拟头节点 (<code>dummy</code>)，谁小接谁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        // 1. 递归终止条件 (Base Case)</span><br><span class="line">        // 如果链表为空，或者只有一个节点，无需排序，直接返回</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 找中点并断开 (Cut)</span><br><span class="line">        // 技巧：让 fast 从 head-&gt;next 开始，</span><br><span class="line">        // 这样当 loop 结束时，slow 刚好停在【前半段的最后一个节点】</span><br><span class="line">        // 方便我们将链表断开</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // slow 是中点（前半段末尾），mid 是后半段开头</span><br><span class="line">        ListNode* mid = slow-&gt;next;</span><br><span class="line">        </span><br><span class="line">        // 【关键操作】切断链表</span><br><span class="line">        slow-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">        // 3. 递归排序左右两半 (Divide)</span><br><span class="line">        ListNode* left = sortList(head);</span><br><span class="line">        ListNode* right = sortList(mid);</span><br><span class="line"></span><br><span class="line">        // 4. 合并有序链表 (Merge)</span><br><span class="line">        return merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 辅函数：合并两个有序链表 (复用 LeetCode 21 的逻辑)</span><br><span class="line">    ListNode* merge(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode dummy(0);</span><br><span class="line">        ListNode* tail = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        while (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (l1) tail-&gt;next = l1;</span><br><span class="line">        if (l2) tail-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-log-N"><a href="#时间复杂度：-O-N-log-N" class="headerlink" title="时间复杂度：$O(N \log N)$"></a><strong>时间复杂度：$O(N \log N)$</strong></h4><ul>
<li><strong>分 (Divide)</strong>：每次找中点遍历 $N&#x2F;2$, $N&#x2F;4$… 总共 $\log N$ 层。</li>
<li><strong>合 (Merge)</strong>：每一层所有的节点都会被遍历一次进行合并，耗时 $O(N)$。</li>
<li>总耗时：$O(N \log N)$。</li>
</ul>
<h4 id="空间复杂度：-O-log-N"><a href="#空间复杂度：-O-log-N" class="headerlink" title="空间复杂度：$O(\log N)$"></a><strong>空间复杂度：$O(\log N)$</strong></h4><ul>
<li>这里使用的是 <strong>自顶向下 (Top-Down)</strong> 的递归方法。</li>
<li>递归调用栈的深度是 $\log N$（因为每次二分）。</li>
<li><em>注：虽然题目进阶要求 $O(1)$ 空间，但那需要使用“自底向上”的迭代法，代码极其复杂且可读性差，面试中通常写出递归版本并能解释空间主要消耗在栈上即可过关。</em></li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么找中点时 <code>fast</code> 要从 <code>head-&gt;next</code> 开始？</strong><ul>
<li><strong>A:</strong> 这是一个处理由偶数个节点组成的链表时的细节。</li>
<li>如果链表是 <code>[1, 2]</code>。<ul>
<li>若 <code>fast = head</code>: 循环结束时 <code>slow</code> 会停在 <code>2</code>。此时左半部分是 <code>[1, 2]</code>，右半部分是 <code>nullptr</code>。递归左半部分会<strong>死循环</strong>（永远切不出更小的）。</li>
<li>若 <code>fast = head-&gt;next</code>: 循环结束时 <code>slow</code> 停在 <code>1</code>。<code>mid</code> 是 <code>2</code>。切断后左边 <code>[1]</code>，右边 <code>[2]</code>。<strong>成功分割</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 链表可以用快速排序吗？</strong><ul>
<li><strong>A:</strong> 可以，但很麻烦。</li>
<li>你需要选取 Pivot，然后通过交换 <strong>值 (Value)</strong> 或者调整指针把比 Pivot 小的放左边，大的放右边。</li>
<li>但是因为无法像数组那样随机选取 Pivot，如果链表本身是有序的，快排会退化成 $O(N^2)$。归并排序则稳定在 $O(N \log N)$。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>240. 搜索二维矩阵 II</title>
    <url>/2025/11/13/Hot100/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></p>
<p>题目：<br>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的目标值 <code>target</code>。</p>
<p>该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong><br>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br>输出：true</p>
<p><strong>示例 2：</strong><br>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br>输出：false</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-10⁴ &lt;= matrix[i][j], target &lt;= 10⁴</code></li>
</ul>
<p>这道题非常经典，它虽然名字带“搜索”，但解法并不是传统的二分查找，而是一种巧妙的 <strong>“排除法”</strong>（或者说是 <strong>贪心策略</strong>）。</p>
<p>很多初学者拿到这道题，第一反应是对每一行都做一次二分查找，复杂度是 $O(m \log n)$。这虽然能过，但不是最优解。最优解的复杂度是 <strong>$O(m + n)$</strong>，不需要二分，只需要走一遍“迷宫”。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：搜索二维矩阵 II (Search a 2D Matrix II)</p>
<p><strong>题目大意</strong>：</p>
<p>编写一个高效的算法来搜索 $m \times n$ 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code>。该矩阵具有以下特性：</p>
<ol>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ol>
<p><strong>注意</strong>：下一行的第一个数 <strong>不一定</strong> 大于上一行的最后一个数（这点和“搜索二维矩阵 I”不同，所以不能把整个矩阵拉直成一个长有序数组）。</p>
<p><strong>示例</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 <code>target = 5</code>，返回 <code>true</code>。</p>
<p>给定 <code>target = 20</code>，返回 <code>false</code>。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么从左上角开始搜很难？"><a href="#2-1-为什么从左上角开始搜很难？" class="headerlink" title="2.1 为什么从左上角开始搜很难？"></a>2.1 为什么从左上角开始搜很难？</h4><p>如果我们在 <code>(0, 0)</code>（左上角，值最小），假设当前值比 <code>target</code> 小，我们需要找更大的数。</p>
<p>向右走？变大。向下走？也变大。</p>
<p><strong>歧义产生了</strong>：我们不知道该往哪个方向走才能找到 <code>target</code>。这就好比在一个分叉路口，两条路都通向“更大的数”，没法选。</p>
<h4 id="2-2-核心策略：站在右上角看世界-The-Top-Right-Corner"><a href="#2-2-核心策略：站在右上角看世界-The-Top-Right-Corner" class="headerlink" title="2.2 核心策略：站在右上角看世界 (The Top-Right Corner)"></a>2.2 核心策略：站在右上角看世界 (The Top-Right Corner)</h4><p>我们需要找一个位置，使得它的两个移动方向，一个是“变大”，一个是“变小”。这样我们就能根据 <code>target</code> 的大小明确方向。</p>
<p><strong>考察右上角元素 <code>(row, col)</code></strong>：</p>
<ul>
<li><strong>向左移动</strong>：数值减小（因为行是有序的）。</li>
<li><strong>向下移动</strong>：数值增大（因为列是有序的）。</li>
</ul>
<p>这简直就是一个 <strong>二叉搜索树 (BST)</strong> 的根节点！</p>
<ul>
<li>如果 <code>current &gt; target</code>：说明当前列下面的数都比 <code>current</code> 大，肯定更不可能是 <code>target</code>，所以<strong>排除整列</strong>，向<strong>左</strong>走（找小的）。</li>
<li>如果 <code>current &lt; target</code>：说明当前行左边的数都比 <code>current</code> 小，肯定更不可能是 <code>target</code>，所以<strong>排除整行</strong>，向<strong>下</strong>走（找大的）。</li>
<li>如果 <code>current == target</code>：找到了！</li>
</ul>
<p><strong>举例推导</strong>：找 <code>5</code></p>
<ol>
<li><strong>起点</strong> (0, 4) 是 <code>15</code>。<code>15 &gt; 5</code> $\rightarrow$ 太大了，向左。</li>
<li>(0, 3) 是 <code>11</code>。<code>11 &gt; 5</code> $\rightarrow$ 太大了，向左。</li>
<li>(0, 2) 是 <code>7</code>。<code>7 &gt; 5</code> $\rightarrow$ 太大了，向左。</li>
<li>(0, 1) 是 <code>4</code>。<code>4 &lt; 5</code> $\rightarrow$ 太小了，向下。</li>
<li>(1, 1) 是 <code>5</code>。<code>5 == 5</code> $\rightarrow$ <strong>Found!</strong></li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        // 边界条件处理</span><br><span class="line">        if (matrix.empty() || matrix[0].empty()) return false;</span><br><span class="line"></span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">        // 初始化起点：右上角</span><br><span class="line">        // row = 0 (第一行)</span><br><span class="line">        // col = n - 1 (最后一列)</span><br><span class="line">        int row = 0;</span><br><span class="line">        int col = n - 1;</span><br><span class="line"></span><br><span class="line">        // 只要没有走出矩阵边界，就继续搜索</span><br><span class="line">        while (row &lt; m &amp;&amp; col &gt;= 0) &#123;</span><br><span class="line">            int current = matrix[row][col];</span><br><span class="line"></span><br><span class="line">            if (current == target) &#123;</span><br><span class="line">                return true; // 找到了</span><br><span class="line">            &#125; </span><br><span class="line">            else if (current &gt; target) &#123;</span><br><span class="line">                // 当前值比目标大</span><br><span class="line">                // 因为列是递增的，下面的肯定更大，所以这一列都没戏了</span><br><span class="line">                // 向左移动，尝试变小</span><br><span class="line">                col--;</span><br><span class="line">            &#125; </span><br><span class="line">            else &#123; // current &lt; target</span><br><span class="line">                // 当前值比目标小</span><br><span class="line">                // 因为行是递增的，左边的肯定更小，所以这一行都没戏了</span><br><span class="line">                // 向下移动，尝试变大</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 走出循环说明找遍了所有可能的路径都没找到</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-m-n"><a href="#时间复杂度：-O-m-n" class="headerlink" title="时间复杂度：$O(m + n)$"></a><strong>时间复杂度：$O(m + n)$</strong></h4><ul>
<li>我们每次循环要么行索引增加（<code>row++</code>），要么列索引减少（<code>col--</code>）。</li>
<li>行最多加 $m$ 次，列最多减 $n$ 次。</li>
<li>所以最坏情况下的路径长度是 $m + n$（从右上角走到左下角）。</li>
<li>这比对每行二分查找的 $O(m \log n)$ 要快（当 $n$ 很大时）。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了 <code>row</code> 和 <code>col</code> 两个变量来定位，没有申请额外的数据结构。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么不能从右下角开始？</strong><ul>
<li><strong>A:</strong> 右下角的值最大。向左走（变小），向上走（变小）。如果 <code>current &gt; target</code>，两个方向都可能，依然存在<strong>歧义</strong>，没法做贪心决策。</li>
<li><strong>结论</strong>：只有 <strong>右上角</strong> 和 <strong>左下角</strong> 是满足“一个方向变大、一个方向变小”的完美起点。</li>
</ul>
</li>
<li><strong>Q: 这算是二分查找吗？</strong><ul>
<li><strong>A:</strong> 严格来说不算。二分查找是一次排除一半。这个算法是一次排除一行或一列。它更像是一个<strong>剪枝搜索</strong>或者<strong>贪心路径搜索</strong>。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>42接雨水</title>
    <url>/2025/11/13/Hot100/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p>
<p>题目：<br>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10⁴</code></li>
<li><code>0 &lt;= height[i] &lt;= 10⁵</code></li>
</ul>
<p>这道题是力扣（LeetCode）上的 <strong>Hard</strong> 级别题目，编号 42。它是面试中出现的“终极 Boss”之一，也是各大厂面试官特别喜欢用来考察思维深度的题目。</p>
<p>不要被“Hard”标签吓倒。只要我们拆解了物理原理，你会发现它其实是 <strong>双指针</strong> 思想的巅峰运用。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：接雨水 (Trapping Rain Water)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个数组 <code>height</code>，每个元素代表一个宽度为 1 的柱子的高度。计算当天下雨时，这些柱子围成的凹槽能接多少雨水。</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code></p>
<p>输出：<code>6</code></p>
<p><strong>直观理解</strong>：</p>
<p>想象这是一个高低不平的地面。下雨后，低洼的地方会积水，直到满溢出去。我们要算所有低洼处积水的总量。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-物理原理：按列求水-The-“Column”-Approach"><a href="#2-1-物理原理：按列求水-The-“Column”-Approach" class="headerlink" title="2.1 物理原理：按列求水 (The “Column” Approach)"></a>2.1 物理原理：按列求水 (The “Column” Approach)</h4><p>我们要算总水量，其实可以拆解成：<strong>每一根柱子的头顶上能存多少水？</strong></p>
<p>对于下标为 <code>i</code> 的柱子，它头顶的水量取决于什么？</p>
<p>取决于它 <strong>左边最高的柱子</strong> (<code>max_left</code>) 和 <strong>右边最高的柱子</strong> (<code>max_right</code>)。</p>
<p>这就好比“木桶效应”：水位的高度由两边较短的那块板决定。</p>
<p><strong>公式</strong>：</p>
<p>$$\text{柱子} i \text{ 的水量} &#x3D; \max(0, \min(\text{max_left}, \text{max_right}) - \text{height}[i])$$</p>
<h4 id="2-2-算法演进"><a href="#2-2-算法演进" class="headerlink" title="2.2 算法演进"></a>2.2 算法演进</h4><ol>
<li><strong>暴力法</strong>：对于每个柱子 <code>i</code>，都向左向右扫描找最高。$O(n^2)$。$\rightarrow$ <strong>太慢，会超时</strong>。</li>
<li><strong>动态规划</strong>：提前把每个位置的“左边最高”和“右边最高”算出来存数组里。$O(n)$ 时间，但需要 $O(n)$ 空间。$\rightarrow$ <strong>不够极致</strong>。</li>
<li><strong>双指针 (最优解)</strong>：能不能一边遍历一边确定最高？而且不需要额外的数组空间？</li>
</ol>
<h4 id="2-3-双指针解法详解-The-“Aha-”-Moment"><a href="#2-3-双指针解法详解-The-“Aha-”-Moment" class="headerlink" title="2.3 双指针解法详解 (The “Aha!” Moment)"></a>2.3 双指针解法详解 (The “Aha!” Moment)</h4><p>这是一个非常巧妙的思维转换。</p>
<p><strong>关键观察</strong>：</p>
<p>对于位置 <code>left</code>，如果 <code>max_left &lt; max_right</code>（注意：这里的 <code>max_right</code> 甚至不需要是 <code>left</code> 紧邻的右边最高，只要右边<strong>某处</strong>有一个比 <code>max_left</code> 高的墙即可），那么位置 <code>left</code> 的水位高度 <strong>一定</strong> 由 <code>max_left</code> 决定。</p>
<p><strong>为什么？</strong></p>
<p>因为短板在左边！不管右边那个高墙后面是不是还有更高的墙，水在 <code>left</code> 这个位置，最高只能蓄到 <code>max_left</code> 这么高，再高就从左边流出去了。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>定义双指针 <code>left</code>（头）和 <code>right</code>（尾）。</li>
<li>维护两个变量：<code>left_max</code>（左边已探索区域的最高值）和 <code>right_max</code>（右边已探索区域的最高值）。</li>
<li><strong>核心循环</strong>：<ul>
<li>如果 <code>height[left] &lt; height[right]</code>：说明左边是短板（或者瓶颈在左边）。<ul>
<li>如果 <code>height[left] &gt;= left_max</code>：更新 <code>left_max</code>（这个位置存不住水，它是新的墙）。</li>
<li>否则：<code>ans += left_max - height[left]</code>（因为右边一定有比 <code>left_max</code> 更高的挡着，所以可以安全地按 <code>left_max</code> 算水）。</li>
<li><code>left</code> 右移。</li>
</ul>
</li>
<li>如果 <code>height[left] &gt;= height[right]</code>：说明右边是短板。<ul>
<li>逻辑同上，处理右边。</li>
<li><code>right</code> 左移。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n = height.size();</span><br><span class="line">        // 边界条件：如果柱子少于 3 根，根本围不成坑，无法接水</span><br><span class="line">        if (n &lt; 3) return 0;</span><br><span class="line"></span><br><span class="line">        // 定义双指针</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n - 1;</span><br><span class="line"></span><br><span class="line">        // 定义左右两侧目前为止遇到的最大高度</span><br><span class="line">        int left_max = 0;</span><br><span class="line">        int right_max = 0;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        // 两个指针向中间逼近</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            // 贪心策略：谁低，就算谁。</span><br><span class="line">            // 为什么？因为水桶的短板效应。</span><br><span class="line">            // 如果 height[left] &lt; height[right]，说明“左边比较低”。</span><br><span class="line">            // 虽然我们不知道 left 和 right 中间的情况，</span><br><span class="line">            // 但我们知道右边至少有一个 height[right] 挡着。</span><br><span class="line">            // 所以，只要 left 这边有一个 limit (left_max)，水肯定能存到 left_max 那么多</span><br><span class="line">            // （除非 height[left] 本身比 left_max 还高）。</span><br><span class="line">            </span><br><span class="line">            if (height[left] &lt; height[right]) &#123;</span><br><span class="line">                // 处理左指针</span><br><span class="line">                if (height[left] &gt;= left_max) &#123;</span><br><span class="line">                    // 当前柱子比左边最高的还高，那它自己就是新的墙，存不住水</span><br><span class="line">                    left_max = height[left];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 当前柱子比左边最高的矮，形成凹槽，可以接水</span><br><span class="line">                    // 水量 = 左边最高墙 - 当前高度</span><br><span class="line">                    ans += (left_max - height[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++; // 移动左指针</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 处理右指针 (逻辑是对称的)</span><br><span class="line">                if (height[right] &gt;= right_max) &#123;</span><br><span class="line">                    right_max = height[right];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ans += (right_max - height[right]);</span><br><span class="line">                &#125;</span><br><span class="line">                right--; // 移动右指针</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><p>这是面试官最想听到的分析，因为它达到了时空的极限优化。</p>
<h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li><code>left</code> 和 <code>right</code> 指针分别从两头走到中间，每个元素只会被访问一次。</li>
<li>操作都是常数时间的比较和加减。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只用了 <code>left</code>, <code>right</code>, <code>left_max</code>, <code>right_max</code>, <code>ans</code> 这几个变量。</li>
<li>相比于动态规划解法（需要 <code>vector</code> 存储前后缀最大值，空间 $O(n)$），双指针法节省了大量内存，是真正的原地算法。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 <code>if (height[left] &lt; height[right])</code> 就能确定只看 <code>left_max</code> 就可以？右边中间万一有个更矮的坑怎么办？</strong><ul>
<li><strong>A:</strong> 这是一个非常好的直觉问题。</li>
<li>请注意，代码的逻辑是：如果 <code>height[left] &lt; height[right]</code>，我们处理的是 <strong><code>left</code></strong> 这个位置。</li>
<li>此时我们确定的信息是：左边有个 <code>left_max</code>，右边有个 <code>height[right]</code>，而且 <code>height[right]</code> 肯定比当前这一侧的某个值要大（或者是相等的短板）。</li>
<li>实际上，更准确的理解是：<strong>我们在找短板</strong>。<code>left</code> 和 <code>right</code> 哪个小，哪边就是短板。水的高度是由短板决定的。只要右边有个比 <code>left</code> 高的墙（哪怕隔得很远），<code>left</code> 位置的水位上限就被锁死在 <code>left_max</code> 上了。</li>
</ul>
</li>
<li><strong>Q: 为什么不需要单独处理 <code>left == right</code> 的情况？</strong><ul>
<li><strong>A:</strong> 循环条件是 <code>while (left &lt; right)</code>。当 <code>left == right</code> 时，两者重合在最高的那个柱子上（或者某个峰值上）。这根柱子顶上是存不住水的（因为它要么是最高的，要么两边都比它低但循环已经处理过了）。所以重合点不需要计算。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>3无重复字符的最长子串</title>
    <url>/2025/11/13/Hot100/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<p>题目：<br>给定一个字符串 <code>s</code>，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10⁴</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>这道题是 <strong>滑动窗口 (Sliding Window)</strong> 算法的开山之作。</p>
<p>如果说“双指针”通常用于解决“成对匹配”的问题（如两数之和、盛水容器），那么“滑动窗口”则是专门用来解决 <strong>“连续子数组&#x2F;子串”</strong> 问题的利器。</p>
<p>这道题在 LeetCode Hot 100 中名列前茅，掌握它，你就掌握了处理连续区间问题的通用模板。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：无重复字符的最长子串 (Longest Substring Without Repeating Characters)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>子串 (Substring)</strong>：必须是字符串中<strong>连续</strong>的一部分（比如 “abc” 是 “abcde” 的子串，但 “ace” 不是）。</li>
<li><strong>无重复</strong>：子串里不能有相同的字符。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>s = &quot;abcabcbb&quot;</code></p>
<p>输出：<code>3</code></p>
<p>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力法不可行？"><a href="#2-1-为什么暴力法不可行？" class="headerlink" title="2.1 为什么暴力法不可行？"></a>2.1 为什么暴力法不可行？</h4><p>暴力法是列出所有的子串，然后一个个检查是否有重复字符。</p>
<ul>
<li>子串总数是 $O(n^2)$。</li>
<li>检查一个子串是否有重复字符需要 $O(n)$。</li>
<li>总复杂度 $O(n^3)$。如果字符串长一点，电脑就跑不动了。</li>
</ul>
<h4 id="2-2-核心策略：伸缩的窗口-Sliding-Window"><a href="#2-2-核心策略：伸缩的窗口-Sliding-Window" class="headerlink" title="2.2 核心策略：伸缩的窗口 (Sliding Window)"></a>2.2 核心策略：伸缩的窗口 (Sliding Window)</h4><p>想象一下，我们在字符串上有一个“窗口”：</p>
<ul>
<li>窗口的左边界是 <code>left</code>，右边界是 <code>right</code>。</li>
<li>窗口里的字符就是我们当前正在考察的子串。</li>
</ul>
<p><strong>我们的目标</strong>：让这个窗口尽可能地<strong>变大</strong>，同时保证窗口里<strong>没有重复的字符</strong>。</p>
<p><strong>操作流程 (The “How”)</strong>：</p>
<ol>
<li><strong>扩张 (Expand)</strong>：<code>right</code> 指针主动向右走，把新字符加入窗口。</li>
<li><strong>检查 (Check)</strong>：每次加入新字符 <code>s[right]</code> 前，问问窗口里：“你们中间有没有人跟 <code>s[right]</code> 一样？”<ul>
<li><strong>没有冲突</strong>：太棒了！安全加入，计算一下当前窗口长度，更新最大值。</li>
<li><strong>有冲突</strong>：麻烦了。<code>s[right]</code> 已经在窗口里出现过了（假设出现在位置 X）。</li>
</ul>
</li>
<li><strong>收缩 (Shrink)</strong>：既然有冲突，我们就必须移动 <code>left</code> 指针，把窗口左边的字符一个个扔出去，<strong>直到</strong>把那个导致冲突的老字符扔掉为止。</li>
</ol>
<p><strong>数据结构选择</strong>：</p>
<p>我们需要快速判断“窗口里有没有这个字符”。</p>
<p>显然，<strong>哈希集合 (<code>unordered_set</code>)</strong> 是最佳选择，查找和删除都是 $O(1)$。</p>
<p><strong>举例演示</strong>：<code>s = &quot;pwwkew&quot;</code></p>
<ol>
<li><code>[p]</code>: 无重复，max&#x3D;1。</li>
<li><code>[pw]</code>: 无重复，max&#x3D;2。</li>
<li><code>[pww]</code>: <code>right</code> 指向第二个 <code>w</code>。冲突！<ul>
<li><code>left</code> 开始动：扔掉 <code>p</code>。窗口变成 <code>ww</code>。还有冲突！</li>
<li><code>left</code> 继续动：扔掉第一个 <code>w</code>。窗口变成 <code>w</code>。冲突解决！</li>
<li>加入新 <code>w</code>，窗口现在是 <code>[w]</code>。</li>
</ul>
</li>
<li><code>[wk]</code>: 无重复…</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        // 哈希集合：记录当前窗口内存在的字符</span><br><span class="line">        unordered_set&lt;char&gt; window;</span><br><span class="line">        </span><br><span class="line">        int n = s.size();</span><br><span class="line">        int left = 0;   // 窗口左边界</span><br><span class="line">        int max_len = 0; // 记录历史最大长度</span><br><span class="line"></span><br><span class="line">        // right 是窗口右边界，主动向右滑动</span><br><span class="line">        for (int right = 0; right &lt; n; ++right) &#123;</span><br><span class="line">            char current_char = s[right];</span><br><span class="line"></span><br><span class="line">            // 【核心逻辑：收缩窗口】</span><br><span class="line">            // 如果 current_char 已经在窗口里了（冲突），</span><br><span class="line">            // 我们就需要移动 left，不断从集合中删除左边的字符，</span><br><span class="line">            // 直到冲突消失（也就是把窗口里那个重复的字符删掉为止）。</span><br><span class="line">            while (window.count(current_char)) &#123;</span><br><span class="line">                window.erase(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 现在窗口是安全的了，把新字符加进去</span><br><span class="line">            window.insert(current_char);</span><br><span class="line"></span><br><span class="line">            // 更新最大长度</span><br><span class="line">            // 当前窗口长度 = right - left + 1</span><br><span class="line">            max_len = max(max_len, right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><p>很多初学者看到 <code>for</code> 循环里套了个 <code>while</code> 循环，会担心是 $O(n^2)$。</p>
<p><strong>其实是 $O(n)$，原因如下：</strong></p>
<ul>
<li><code>right</code> 指针从 0 走到 $n-1$，走了 $n$ 步。</li>
<li><code>left</code> 指针也只能从 0 走到 $n-1$，最多走 $n$ 步（它不回退）。</li>
<li>每个字符最多被 <code>insert</code> 一次，被 <code>erase</code> 一次。</li>
<li>总操作次数是 $2n$，所以是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-Sigma"><a href="#空间复杂度：-O-Sigma" class="headerlink" title="空间复杂度：$O(|\Sigma|)$"></a><strong>空间复杂度：$O(|\Sigma|)$</strong></h4><ul>
<li>我们需要一个 <code>unordered_set</code> 存储窗口内的字符。</li>
<li>$|\Sigma|$ 代表字符集的大小。如果全是 ASCII 码，set 最多存 128 个字符；如果是全是小写字母，最多 26 个。</li>
<li>所以空间复杂度是常数级的 $O(1)$ （或者说 $O(128)$）。</li>
</ul>
<hr>
<h3 id="5-进阶优化-面试加分项"><a href="#5-进阶优化-面试加分项" class="headerlink" title="5. 进阶优化 (面试加分项)"></a>5. 进阶优化 (面试加分项)</h3><p>虽然上面的代码已经是 $O(n)$，但在 C++ 中，<code>unordered_set</code> 还是有一定的开销。</p>
<p><strong>数组模拟哈希表</strong>：</p>
<p>由于字符（char）本质上就是整数（ASCII 码 0-127）。</p>
<p>我们可以用一个固定大小的数组 <code>int dict[128]</code> 来代替 <code>unordered_set</code>。</p>
<ul>
<li><code>dict[c] = true/false</code> (或者记录下标)。</li>
<li>数组访问比哈希表快得多，这在 ACM 竞赛中是标准写法。</li>
</ul>
<p><strong>跳跃优化</strong>：</p>
<p>上面的 <code>while</code> 循环是一步步移动 <code>left</code>。其实如果我们可以记录字符的<strong>下标</strong>（使用 <code>map</code> 或数组记录 <code>last_index</code>），我们可以直接让 <code>left</code> 跳到重复字符的下一位。</p>
<p><em>但这不会改变最坏时间复杂度（依然是 $O(n)$），只是减少了操作次数。对于初学者，掌握“一步步收缩”的模板更通用，因为很多题目（如“和大于K的最短子数组”）只能一步步缩。</em></p>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><p><strong>Q: 为什么计算长度是 <code>right - left + 1</code>？</strong></p>
<ul>
<li><strong>A:</strong> 这是一个经典的“植树问题”。比如下标 2 到 下标 4，包含 2, 3, 4 三个数。长度 &#x3D; $4 - 2 + 1 &#x3D; 3$。</li>
</ul>
</li>
<li><p><strong>Q: 如果字符串为空 <code>&quot;&quot;</code> 怎么办？</strong></p>
<ul>
<li><strong>A:</strong> 循环不执行，直接返回 <code>max_len</code> (初始化为0)，逻辑正确。</li>
</ul>
</li>
<li><p><strong>Q: 这和“最大连续 1 的个数”那类题一样吗？</strong></p>
<ul>
<li><p><strong>A:</strong> 非常像！它们都属于 <strong>不定长滑动窗口</strong>。核心逻辑都是：</p>
<ol>
<li><p><code>right</code> 进场。</p>
</li>
<li><p><code>while</code> (条件不满足) <code>left</code> 出场。</p>
</li>
<li><p>更新结果。</p>
<p>记住这个模板，能秒杀 80% 的滑动窗口题。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>53最大子数组和</title>
    <url>/2025/11/13/Hot100/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<p>这道题是 <strong>动态规划 (Dynamic Programming, DP)</strong> 的入门必修课。</p>
<p>它的官方名称叫 <strong>最大子数组和 (Maximum Subarray)</strong>，但在算法圈子里，它有一个更响亮的名字 —— <strong>Kadane 算法</strong>。</p>
<p>这道题之所以经典，是因为它教会了我们如何<strong>只遍历一遍数组</strong>，就做出每一步的“最优选择”，从而推导出全局的“最大结果”。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：最大子数组和 (Maximum Subarray)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code>，请你找出一个具有最大和的<strong>连续子数组</strong>（子数组最少包含一个元素），并返回其最大和。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>连续</strong>：必须是连在一起的一段。</li>
<li><strong>含负数</strong>：数组里可能有负数，这增加了难度（如果是全正数，把整个数组加起来就是最大的了）。</li>
<li><strong>复杂度</strong>：要求 <strong>$O(n)$</strong> 时间复杂度。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code></p>
<p>输出：<code>6</code></p>
<p>解释：连续子数组 <code>[4, -1, 2, 1]</code> 的和是 6，是最大的。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-暴力法的瓶颈"><a href="#2-1-暴力法的瓶颈" class="headerlink" title="2.1 暴力法的瓶颈"></a>2.1 暴力法的瓶颈</h4><p>如果用暴力法，我们需要枚举所有的起点和终点，复杂度是 $O(n^2)$。这显然不够好。</p>
<h4 id="2-2-核心思想：贪心-动态规划"><a href="#2-2-核心思想：贪心-动态规划" class="headerlink" title="2.2 核心思想：贪心 &#x2F; 动态规划"></a>2.2 核心思想：贪心 &#x2F; 动态规划</h4><p>想象你在玩一个<strong>累加游戏</strong>：</p>
<p>你走在数组上，每一步你都要决定：<strong>“我是要把当前的数字加到之前的累加和里？还是扔掉之前的累加和，从当前这个数字重新开始算？”</strong></p>
<p><strong>决策逻辑 (The “Why”)</strong>：</p>
<p>设 <code>pre</code> 为 <strong>“以当前数字结尾的最大子数组和”</strong>。</p>
<p>当我们遍历到数字 <code>x</code> 时：</p>
<ol>
<li><strong>如果之前的累加和 (<code>pre</code>) 是正数</strong>：<ul>
<li>太好了！正数对我有增益。</li>
<li>虽然 <code>x</code> 可能是负数，但我加上之前的正数，总比 <code>x</code> 孤零零一个人要大。</li>
<li><strong>决策</strong>：加入之前的队伍 (<code>pre + x</code>)。</li>
</ul>
</li>
<li><strong>如果之前的累加和 (<code>pre</code>) 是负数</strong>（或者 0）：<ul>
<li>之前的和是负的，它是“拖油瓶”。</li>
<li>不管 <code>x</code> 是几，<code>x</code> 加上一个负数，肯定比 <code>x</code> 自己还要小。</li>
<li><strong>决策</strong>：果断抛弃之前的队伍，另起炉灶，自己做开头 (<code>x</code>)。</li>
</ul>
</li>
</ol>
<p><strong>状态转移方程</strong>：</p>
<p>$$\text{pre} &#x3D; \max(\text{nums}[i], \text{pre} + \text{nums}[i])$$</p>
<p><strong>图解推导</strong> <code>[-2, 1, -3, 4, ...]</code>：</p>
<ol>
<li>遇到 <code>-2</code>：之前没数。<code>pre = -2</code>。最大值 <code>max = -2</code>。</li>
<li>遇到 <code>1</code>：之前的 <code>pre</code> 是 <code>-2</code> (拖油瓶)。抛弃！<code>pre</code> 变成 <code>1</code>。最大值 <code>max = 1</code>。</li>
<li>遇到 <code>-3</code>：之前的 <code>pre</code> 是 <code>1</code> (有益)。加入！<code>pre</code> 变成 <code>1 + (-3) = -2</code>。最大值 <code>max</code> 保持 <code>1</code>。</li>
<li>遇到 <code>4</code>：之前的 <code>pre</code> 是 <code>-2</code> (拖油瓶)。抛弃！<code>pre</code> 变成 <code>4</code>。最大值 <code>max</code> 更新为 <code>4</code>。</li>
<li>…以此类推。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // pre 记录的是：以当前位置结尾的最大子数组和</span><br><span class="line">        // 初始化为 0 是安全的吗？不一定。</span><br><span class="line">        // 但在这个循环逻辑中，第一轮 pre 会被赋值为 nums[0]</span><br><span class="line">        int pre = 0;</span><br><span class="line">        </span><br><span class="line">        // maxAns 记录的是：全局遇到的最大和</span><br><span class="line">        // 注意：初始化一定要是 nums[0]，不能是 0！</span><br><span class="line">        // 因为如果数组全是负数 [-2, -1]，最大值应该是 -1，而不是 0</span><br><span class="line">        int maxAns = nums[0];</span><br><span class="line">        </span><br><span class="line">        for (const int&amp; x : nums) &#123;</span><br><span class="line">            // 核心状态转移：</span><br><span class="line">            // 决策：是接着前面的 pre 继续加？还是自立门户（从 x 开始）？</span><br><span class="line">            // 取决于 pre + x 大，还是 x 自己大（本质就是看 pre 是否大于 0）</span><br><span class="line">            pre = max(pre + x, x);</span><br><span class="line">            </span><br><span class="line">            // 更新全局最大值</span><br><span class="line">            maxAns = max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们只遍历了一次数组。</li>
<li>内部的操作全是 $O(1)$ 的加法和比较。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>经典的动态规划通常需要一个 <code>dp</code> 数组（空间 $O(n)$），记录每一个位置的结果。</li>
<li>但我们发现，计算当前位置 <code>dp[i]</code> 时，只需要知道前一个位置 <code>dp[i-1]</code> 就行了。之前的历史不需要保留。</li>
<li>这种优化技巧叫做 <strong>“滚动数组”</strong> 思想（虽然这里只滚了一个变量），将空间降到了 $O(1)$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果数组全是负数怎么办？比如 <code>[-2, -5, -1]</code>。</strong><ul>
<li><strong>A:</strong> 算法依然有效。<ul>
<li>遇到 <code>-2</code>：<code>pre = -2</code>, <code>max = -2</code>。</li>
<li>遇到 <code>-5</code>：<code>pre = max(-5, -2 + -5) = -5</code> (自立门户), <code>max</code> 还是 <code>-2</code>。</li>
<li>遇到 <code>-1</code>：<code>pre = max(-1, -5 + -1) = -1</code> (自立门户), <code>max</code> 更新为 <code>-1</code>。</li>
<li>结果返回 <code>-1</code>。逻辑完美。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 为什么和滑动窗口不一样？</strong><ul>
<li><strong>A:</strong> 这是一个极好的问题！</li>
<li><strong>滑动窗口</strong>通常用于处理“窗口大小可变但具有<strong>单调性</strong>”或者“窗口大小固定”的问题。</li>
<li>因为这里有负数，窗口扩大时，和不一定增大；缩小时，和不一定减小。单调性被破坏了，所以标准的双指针滑动窗口失效。</li>
<li>Kadane 算法本质上是一种<strong>动态规划</strong>，它关注的是“状态转移”。</li>
</ul>
</li>
<li><strong>Q: 这道题能输出具体的子数组（起始和结束位置）吗？</strong><ul>
<li><strong>A:</strong> 可以。你需要额外的变量来记录。<ul>
<li>当 <code>pre</code> 重置（<code>x &gt; pre + x</code>）时，记录新的 <code>temp_start = i</code>。</li>
<li>当更新 <code>maxAns</code> 时，记录 <code>final_start = temp_start</code> 和 <code>final_end = i</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 旋转图像</title>
    <url>/2025/11/13/Hot100/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></p>
<p>题目：<br>给你一个 <code>n x n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵，不要使用另一个矩阵。</p>
<p><strong>示例 1：</strong><br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p>
<p><strong>示例 2：</strong><br>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<p>这道题是力扣（LeetCode）第 48 题 <strong>“旋转图像” (Rotate Image)</strong>。</p>
<p>这道题在面试中出现的频率极高，因为它考察的不是复杂的算法，而是你对 <strong>二维数组下标</strong> 的变换能力，以及数学思维的敏捷度。</p>
<p>很多初学者试图用“找规律”的方法直接推导旋转后的坐标公式，结果往往因为下标越界或逻辑复杂而写出一堆 Bug。今天我教你一个<strong>最优雅、最容易记住</strong>的方法——<strong>“折叠 + 翻转”法</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：旋转图像 (Rotate Image)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个 $n \times n$ 的二维矩阵 <code>matrix</code>（代表图像）。请你将图像 <strong>顺时针</strong> 旋转 90 度。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li>必须 <strong>原地</strong> 旋转。</li>
<li>这意味着你<strong>不能</strong>新建一个 $n \times n$ 的矩阵来存储旋转后的结果，必须在原矩阵上修改，空间复杂度只能是 $O(1)$。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  [4, 5, 6],</span><br><span class="line">  [7, 8, 9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [7, 4, 1],</span><br><span class="line">  [8, 5, 2],</span><br><span class="line">  [9, 6, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么直接找规律很难？"><a href="#2-1-为什么直接找规律很难？" class="headerlink" title="2.1 为什么直接找规律很难？"></a>2.1 为什么直接找规律很难？</h4><p>如果要直接把一个点 <code>(i, j)</code> 移动到旋转后的位置，公式是 <code>(j, n-1-i)</code>。</p>
<p>在原地修改时，如果你把 <code>(0,0)</code> 的值直接放到目标位置 <code>(0,2)</code>，那 <code>(0,2)</code> 原本的值就会被覆盖丢失。</p>
<p>为了解决这个问题，你必须同时交换 4 个点（四个角转圈圈），代码写起来会有很多 <code>i</code>, <code>j</code>, <code>n-1-i</code>, <code>n-1-j</code> 的嵌套，非常容易晕。</p>
<h4 id="2-2-核心策略：数学变换（转置-镜像）"><a href="#2-2-核心策略：数学变换（转置-镜像）" class="headerlink" title="2.2 核心策略：数学变换（转置 + 镜像）"></a>2.2 核心策略：数学变换（转置 + 镜像）</h4><p>与其痛苦地推导旋转坐标，不如利用线性代数的知识。</p>
<p><strong>顺时针旋转 90 度</strong> 可以拆解为两个简单的动作：</p>
<ol>
<li><strong>第一步：转置 (Transpose)</strong><ul>
<li>沿着<strong>主对角线</strong>（从左上角到右下角）对折矩阵。</li>
<li>也就是交换 <code>matrix[i][j]</code> 和 <code>matrix[j][i]</code>。</li>
</ul>
</li>
<li><strong>第二步：水平镜像翻转 (Reverse Rows)</strong><ul>
<li>把每一行倒序排列（左右翻转）。</li>
</ul>
</li>
</ol>
<p><strong>让我们看看魔法是如何发生的</strong>：</p>
<p><strong>原始矩阵</strong>：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  2  3</span><br><span class="line">4  5  6</span><br><span class="line">7  8  9</span><br></pre></td></tr></table></figure>

<p><strong>Step 1: 沿对角线转置</strong> (交换左下和右上)</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  4  7</span><br><span class="line">2  5  8</span><br><span class="line">3  6  9</span><br></pre></td></tr></table></figure>

<p><em>此时，第一行变成了第一列，但顺序是反的（1,4,7 而不是 7,4,1）。</em></p>
<p><strong>Step 2: 翻转每一行</strong> (Reverse)</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7  4  1</span><br><span class="line">8  5  2</span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure>

<p><em>看！完美变成了顺时针旋转 90 度的结果！</em></p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这个方法的代码非常简洁，甚至可以说“只有两段循环”。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line"></span><br><span class="line">        // Step 1: 转置矩阵 (Transpose)</span><br><span class="line">        // 沿主对角线对折，交换 matrix[i][j] 和 matrix[j][i]</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            // 注意：j 从 i 开始遍历，而不是从 0 开始！</span><br><span class="line">            // 为什么？</span><br><span class="line">            // 如果 j 从 0 开始，当你遍历到 (1, 0) 时会和 (0, 1) 交换，</span><br><span class="line">            // 等你遍历到 (0, 1) 时又会换回来，等于没做。</span><br><span class="line">            // 我们只需要遍历对角线右上方（或左下方）的三角形区域即可。</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 2: 翻转每一行 (Reverse each row)</span><br><span class="line">        // 这一步将每一行左右颠倒</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            // 使用 C++ STL 的 reverse 函数，简洁高效</span><br><span class="line">            // matrix[i].begin() 和 matrix[i].end() 分别指向该行的开头和结尾</span><br><span class="line">            reverse(matrix[i].begin(), matrix[i].end());</span><br><span class="line">            </span><br><span class="line">            // 如果不能用 STL，也可以手写双指针交换：</span><br><span class="line">            // int left = 0, right = n - 1;</span><br><span class="line">            // while (left &lt; right) swap(matrix[i][left++], matrix[i][right--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-2"><a href="#时间复杂度：-O-N-2" class="headerlink" title="时间复杂度：$O(N^2)$"></a><strong>时间复杂度：$O(N^2)$</strong></h4><ul>
<li><strong>转置过程</strong>：我们需要遍历矩阵的大约一半元素，操作次数是 $\frac{N^2}{2}$。</li>
<li><strong>翻转过程</strong>：我们需要遍历整个矩阵的每一个元素进行交换，操作次数是 $\frac{N^2}{2}$。</li>
<li>总时间复杂度是 $O(N^2)$。</li>
<li>对于二维矩阵问题，我们需要访问每个元素至少一次，所以 $O(N^2)$ 已经是理论最优解。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们在原矩阵上进行 <code>swap</code> 操作，只使用了常数个额外变量。</li>
<li>没有申请新的 $N \times N$ 矩阵。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果题目要求“逆时针”旋转 90 度怎么办？</strong><ul>
<li><strong>A:</strong> 依然可以用两次变换，只是顺序变一下：<ul>
<li><strong>顺时针</strong> &#x3D; 先转置，再左右翻转（翻转行）。</li>
<li><strong>逆时针</strong> &#x3D; 先转置，再上下翻转（交换行），或者先左右翻转再转置。</li>
<li><em>记忆技巧</em>：拿张纸画一下就出来了，不用死记。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 转置时 <code>j</code> 为什么要从 <code>i</code> (或 <code>i+1</code>) 开始？</strong><ul>
<li><strong>A:</strong> 这是转置操作最容易写错的地方。</li>
<li>我们的目标是交换主对角线两侧的元素。</li>
<li>如果你让 <code>j</code> 从 0 开始，那么 <code>(0, 1)</code> 和 <code>(1, 0)</code> 会被交换<strong>两次</strong>（复原了）。</li>
<li>让 <code>j</code> 从 <code>i</code> 开始，相当于我们只遍历了矩阵的<strong>上三角部分</strong>，把它和下三角部分交换，这样每个配对只会被处理一次。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>76最小覆盖子串</title>
    <url>/2025/11/13/Hot100/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p>
<p>题目：<br>给你一个字符串 <code>s</code>、一个字符串 <code>t</code>。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == s.length</code></li>
<li><code>n == t.length</code></li>
<li><code>1 &lt;= m, n &lt;= 10⁵</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p>这是力扣（LeetCode）第 76 题，也是 <strong>滑动窗口（Sliding Window）</strong> 系列中公认的 <strong>BOSS 级</strong> 题目。</p>
<p>之所以称它为困难（Hard），是因为它结合了 <strong>“不定长窗口”</strong> 的伸缩策略和 <strong>“哈希表计数”</strong> 的匹配逻辑，不仅要求你找出来，还要求找 <strong>“最小”</strong> 的，这对逻辑严密性要求极高。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：最小覆盖子串 (Minimum Window Substring)</p>
<p><strong>题目大意</strong>：</p>
<p>给你两个字符串 <code>s</code>（源字符串）和 <code>t</code>（目标字符串）。请你在 <code>s</code> 中找出包含 <code>t</code> 中所有字符的 <strong>最短子串</strong>。</p>
<p><strong>关键约束</strong>：</p>
<ol>
<li><strong>包含所有</strong>：如果 <code>t</code> 中包含重复字符（如 “AA”），那么结果子串中也必须至少包含两个 ‘A’。</li>
<li><strong>最短</strong>：在所有满足条件的子串中，返回长度最小的那个。</li>
<li><strong>不存在</strong>：如果找不到，返回空字符串 <code>&quot;&quot;</code>。</li>
<li><strong>复杂度</strong>：要求 $O(n)$ 时间复杂度。</li>
</ol>
<p><strong>示例</strong>：</p>
<p>输入：<code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code></p>
<p>输出：<code>&quot;BANC&quot;</code></p>
<p>解释：</p>
<ul>
<li>“ADOBEC” 包含 “ABC”，长度 6。</li>
<li>“BECODEBA” 包含 “ABC”，长度 8。</li>
<li>“BANC” 包含 “ABC”，长度 4。</li>
<li>最短的是 “BANC”。</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力法不可行？"><a href="#2-1-为什么暴力法不可行？" class="headerlink" title="2.1 为什么暴力法不可行？"></a>2.1 为什么暴力法不可行？</h4><p>暴力法是枚举 <code>s</code> 的所有子串，然后检查每个子串是否包含 <code>t</code>。</p>
<ul>
<li>子串数量级是 $O(n^2)$。</li>
<li>检查一次需要 $O(m)$。</li>
<li>总复杂度 $O(n^3)$ 或 $O(n^2)$。对于 $10^5$ 长度的字符串，绝对超时。</li>
</ul>
<h4 id="2-2-核心策略：滑动窗口-“欠债还钱”模型"><a href="#2-2-核心策略：滑动窗口-“欠债还钱”模型" class="headerlink" title="2.2 核心策略：滑动窗口 + “欠债还钱”模型"></a>2.2 核心策略：滑动窗口 + “欠债还钱”模型</h4><p>我们可以把 <code>t</code> 中的字符看作我们的 <strong>“债务”</strong>（Need）。</p>
<p>我们要控制一个窗口 <code>[left, right]</code> 在 <code>s</code> 上滑动：</p>
<ol>
<li><strong>进货（Expand）</strong>：<code>right</code> 向右扩张，遇到的字符加入窗口。如果是我们要找的字符，就说明还了一笔“债”。</li>
<li><strong>收缩（Shrink）</strong>：当<strong>所有债务都还清</strong>（窗口内包含了 <code>t</code> 所有字符）时，说明当前窗口是一个<strong>可行解</strong>。<ul>
<li>这时候我们要尝试<strong>优化</strong>：<code>left</code> 指针向右移，尝试扔掉左边的字符。</li>
<li><strong>为什么要扔？</strong> 因为我们要找<strong>最小</strong>的窗口。如果扔掉左边的字符后，窗口依然满足条件（比如扔掉了一个无关紧要的 ‘X’，或者多余的 ‘A’），那我们就得到了一个更短的答案。</li>
<li><strong>何时停止收缩？</strong> 直到扔掉某个关键字符，导致窗口不再满足条件（“债”又没还清了），这时候停止收缩，继续让 <code>right</code> 向右找货。</li>
</ul>
</li>
</ol>
<h4 id="2-3-如何判断“债务还清”？"><a href="#2-3-如何判断“债务还清”？" class="headerlink" title="2.3 如何判断“债务还清”？"></a>2.3 如何判断“债务还清”？</h4><p>我们需要两个哈希表（或数组）：</p>
<ul>
<li><code>need</code>：记录 <code>t</code> 中每个字符需要多少个。</li>
<li><code>window</code>：记录当前窗口中，每个字符已经收集了多少个。</li>
</ul>
<p><strong>关键变量 <code>valid</code></strong>：</p>
<p>为了避免每次都遍历哈希表去检查是否满足条件（那样检查一次是 $O(52)$ 或 $O(128)$），我们维护一个变量 <code>valid</code>。</p>
<ul>
<li>表示 <strong>“已经有多少种字符的数量达标了”</strong>。</li>
<li>比如 <code>t = &quot;AAB&quot;</code>, <code>need = &#123;&#39;A&#39;:2, &#39;B&#39;:1&#125;</code>。<ul>
<li>当窗口里有两个 ‘A’ 时，<code>valid</code> 加 1（说明 A 这一类达标了）。</li>
<li>当窗口里有一个 ‘B’ 时，<code>valid</code> 再加 1。</li>
<li>当 <code>valid == need.size()</code> 时，说明所有种类的字符都齐了。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        // need: 记录 t 中每个字符需要的数量</span><br><span class="line">        // window: 记录当前窗口中包含的字符数量</span><br><span class="line">        unordered_map&lt;char, int&gt; need, window;</span><br><span class="line">        </span><br><span class="line">        // 1. 初始化 need 哈希表</span><br><span class="line">        for (char c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        int valid = 0; // 记录有多少个字符种类已经满足要求</span><br><span class="line"></span><br><span class="line">        // 记录最小覆盖子串的起始位置和长度</span><br><span class="line">        // len 初始化为最大值，方便后续更新</span><br><span class="line">        int start = 0, len = INT_MAX;</span><br><span class="line"></span><br><span class="line">        // 2. 开始滑动窗口</span><br><span class="line">        while (right &lt; s.size()) &#123;</span><br><span class="line">            // c 是即将移入窗口的字符</span><br><span class="line">            char c = s[right];</span><br><span class="line">            // 右移窗口</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            // === 进行窗口内数据的一系列更新 ===</span><br><span class="line">            if (need.count(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                // 只有当 window[c] 的数量刚好达到 need[c] 时，valid 才加 1</span><br><span class="line">                // 比如 need[&#x27;A&#x27;]=2，window 从 1 变 2 时，valid++</span><br><span class="line">                // window 从 2 变 3 时，valid 不变（因为已经达标了）</span><br><span class="line">                if (window[c] == need[c]) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // === 判断左侧窗口是否要收缩 ===</span><br><span class="line">            // 当 valid 等于 need 的大小时，说明当前窗口已满足条件</span><br><span class="line">            while (valid == need.size()) &#123;</span><br><span class="line">                // 更新最小覆盖子串</span><br><span class="line">                if (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // d 是即将移出窗口的字符</span><br><span class="line">                char d = s[left];</span><br><span class="line">                // 左移窗口</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                // === 进行窗口内数据的一系列更新 ===</span><br><span class="line">                if (need.count(d)) &#123;</span><br><span class="line">                    // 如果移除这个字符会导致数量不达标，valid 减 1</span><br><span class="line">                    if (window[d] == need[d]) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果 len 没变过，说明没找到，返回空串；否则返回截取的子串</span><br><span class="line">        return len == INT_MAX ? &quot;&quot; : s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-M"><a href="#时间复杂度：-O-N-M" class="headerlink" title="时间复杂度：$O(N + M)$"></a><strong>时间复杂度：$O(N + M)$</strong></h4><ul>
<li>$N$ 是 <code>s</code> 的长度，$M$ 是 <code>t</code> 的长度。</li>
<li>我们先遍历 <code>t</code> 初始化哈希表：$O(M)$。</li>
<li><strong>双指针核心</strong>：<code>right</code> 指针从 0 走到 $N$，<code>left</code> 指针也最多从 0 走到 $N$。每个字符最多“进窗”一次，“出窗”一次。</li>
<li>哈希表操作是 $O(1)$。</li>
<li>总复杂度是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-Sigma"><a href="#空间复杂度：-O-Sigma" class="headerlink" title="空间复杂度：$O(|\Sigma|)$"></a><strong>空间复杂度：$O(|\Sigma|)$</strong></h4><ul>
<li>我们需要存储字符集大小的哈希表。对于 ASCII 字符，大小最多 128。</li>
<li>可以认为空间复杂度是 $O(1)$（常数级）。</li>
</ul>
<hr>
<h3 id="5-深度解惑：最容易写错的细节"><a href="#5-深度解惑：最容易写错的细节" class="headerlink" title="5. 深度解惑：最容易写错的细节"></a>5. 深度解惑：最容易写错的细节</h3><p><strong>Q1: 为什么 <code>if (window[c] == need[c])</code> 这里用 <code>==</code> 而不是 <code>&gt;=</code>？</strong></p>
<ul>
<li><strong>A:</strong> 这是一个精妙的去重逻辑。</li>
<li>假设 <code>need[&#39;A&#39;] = 2</code>。</li>
<li>当窗口有 1 个 ‘A’，<code>window[&#39;A&#39;]</code> 变 2：满足条件了，<code>valid++</code>。</li>
<li>当窗口有 2 个 ‘A’，又来 1 个 ‘A’，<code>window[&#39;A&#39;]</code> 变 3：虽然数量更多了，但“达标”这个状态没有变，所以不需要再次 <code>valid++</code>。<strong>我们只在“刚刚好满足”的那一瞬间记录。</strong></li>
</ul>
<p><strong>Q2: 为什么 <code>window[d] == need[d]</code> 时要 <code>valid--</code>？</strong></p>
<ul>
<li><strong>A:</strong> 对称逻辑。</li>
<li>假设 <code>need[&#39;A&#39;] = 2</code>，当前 <code>window[&#39;A&#39;] = 3</code>。</li>
<li>移出一个 ‘A’，剩 2 个：依然满足 <code>&gt;=2</code>，<code>valid</code> 不用变。</li>
<li>再移出一个 ‘A’，剩 1 个：<strong>坏了，不够了！</strong> 此时状态从“达标”变成了“不达标”，所以 <code>valid--</code>。</li>
</ul>
<p><strong>Q3: 为什么结果要存 <code>start</code> 和 <code>len</code>，而不是直接存字符串？</strong></p>
<ul>
<li><strong>A:</strong> 性能优化。</li>
<li>如果在循环里写 <code>res = s.substr(left, right - left)</code>，每次更新结果都会进行字符串拷贝，这会把时间复杂度退化成 $O(N^2)$。</li>
<li>只存下标，最后截取一次，保证 $O(N)$。</li>
</ul>
<hr>
<h3 id="6-通用模板总结"><a href="#6-通用模板总结" class="headerlink" title="6. 通用模板总结"></a>6. 通用模板总结</h3><p>至此，你已经学完了 Hot 100 中所有的滑动窗口题目。</p>
<p>你会发现它们都有一个<strong>通用骨架</strong>：</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 滑动窗口通用模板 */</span><br><span class="line">void slidingWindow(string s, string t) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; need, window;</span><br><span class="line">    for (char c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    int valid = 0; </span><br><span class="line">    </span><br><span class="line">    while (right &lt; s.size()) &#123;</span><br><span class="line">        // 1. c 是将移入窗口的字符</span><br><span class="line">        char c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        // 2. 执行右移后的数据更新 ...</span><br><span class="line">        </span><br><span class="line">        // 3. 判断窗口是否要收缩 (debug output...)</span><br><span class="line">        while (window needs shrink) &#123;</span><br><span class="line">            // 4. d 是将移出窗口的字符</span><br><span class="line">            char d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            // 5. 执行左移后的数据更新 ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>128最长连续序列</title>
    <url>/2025/11/13/Hot100/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<p>题目：<br>给定一个未排序的整数数组 <code>nums</code>，请你找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10⁵</code></li>
<li><code>-10⁹ &lt;= nums[i] &lt;= 10⁹</code></li>
</ul>
<p>它的难点不在于想出一个解法，而在于题目硬性规定了时间复杂度必须是 <strong>$O(n)$</strong>。这一限制直接判了“先排序再找”这种直观解法的“死刑”（因为排序最快也要 $O(n \log n)$）。</p>
<p>这道题是学习如何利用 <strong>HashSet (<code>unordered_set</code>)</strong> 进行 $O(1)$ 查找，以及如何通过<strong>剪枝</strong>（跳过不必要的计算）来优化算法的绝佳案例。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：最长连续序列 (Longest Consecutive Sequence)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个未排序的整数数组 <code>nums</code>，找出数字连续的最长序列（不要求序列在原数组中连续，只要求数值连续），并返回该序列的长度。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li>算法的时间复杂度必须是 <strong>$O(n)$</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [100, 4, 200, 1, 3, 2]</code></p>
<p>解释：</p>
<ol>
<li>数组里有的数字是：1, 2, 3, 4, 100, 200</li>
<li>其中最长的连续序列是 <code>[1, 2, 3, 4]</code>。</li>
<li>输出长度：<strong>4</strong>。</li>
</ol>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力法和排序法行不通？"><a href="#2-1-为什么暴力法和排序法行不通？" class="headerlink" title="2.1 为什么暴力法和排序法行不通？"></a>2.1 为什么暴力法和排序法行不通？</h4><ul>
<li><strong>暴力枚举</strong>：对每个数 <code>x</code>，去数组里找 <code>x+1</code>, <code>x+2</code>… 每次查找要遍历数组，复杂度 $O(n^2)$。太慢。</li>
<li><strong>排序法</strong>：先 <code>sort(nums)</code>，然后线性扫描。虽然好写，但排序瓶颈是 $O(n \log n)$。<strong>不符合题目要求</strong>。</li>
</ul>
<h4 id="2-2-破局思维：哈希集合-“找龙头”"><a href="#2-2-破局思维：哈希集合-“找龙头”" class="headerlink" title="2.2 破局思维：哈希集合 + “找龙头”"></a>2.2 破局思维：哈希集合 + “找龙头”</h4><p>我们需要一个数据结构，能让我们用 $O(1)$ 的时间快速判断“某个数字存不存在”。这显然是 <strong><code>unordered_set</code></strong> 的强项。</p>
<ol>
<li><p><strong>第一步：去重并存入集合</strong></p>
<p>把所有数字扔进 <code>unordered_set</code>。这样我们查找 <code>x+1</code> 是否存在只需要瞬间。</p>
</li>
<li><p><strong>第二步：如何避免重复计算？（关键！）</strong></p>
<p>假设数组是 <code>[1, 2, 3, 4, 5]</code>。</p>
<ul>
<li>如果我们从 <code>3</code> 开始数，会数 <code>3, 4, 5</code>（长度3）。</li>
<li>如果我们从 <code>2</code> 开始数，会数 <code>2, 3, 4, 5</code>（长度4）。</li>
<li>如果我们从 <code>1</code> 开始数，会数 <code>1, 2, 3, 4, 5</code>（长度5）。</li>
</ul>
<p><strong>你会发现</strong>：从 <code>2</code> 和 <code>3</code> 开始数完全是浪费时间，因为它们一定是 <code>1</code> 开头的序列的一部分。</p>
<p><strong>结论</strong>：我们只应该从序列的**起点（龙头）**开始数！</p>
<p><strong>怎么判断一个数 <code>x</code> 是不是“龙头”？</strong></p>
<p>很简单：只要看 <strong><code>x-1</code></strong> 是否存在。</p>
<ul>
<li>如果 <code>x-1</code> 存在，说明 <code>x</code> 前面还有数，<code>x</code> 不是龙头，<strong>直接跳过</strong>。</li>
<li>如果 <code>x-1</code> 不存在，说明 <code>x</code> 是一个新序列的起点，<strong>开始向后计数</strong> (<code>x+1</code>, <code>x+2</code>…)。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 1. 将所有数字放入哈希集合</span><br><span class="line">        // 作用：去重 + 提供 O(1) 的查找速度</span><br><span class="line">        unordered_set&lt;int&gt; num_set;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            num_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int longestStreak = 0;</span><br><span class="line"></span><br><span class="line">        // 2. 遍历集合中的每一个数</span><br><span class="line">        for (int num : num_set) &#123;</span><br><span class="line">            // 核心剪枝逻辑：</span><br><span class="line">            // 只有当 num-1 不存在时，num 才是一个连续序列的“起点”</span><br><span class="line">            // 否则，num 属于某个以 (num-1) 或更小数字开头的序列，我们直接跳过，避免重复计算</span><br><span class="line">            if (!num_set.count(num - 1)) &#123;</span><br><span class="line">                int currentNum = num;</span><br><span class="line">                int currentStreak = 1;</span><br><span class="line"></span><br><span class="line">                // 从起点开始，不断查找 num+1, num+2 ... 是否存在</span><br><span class="line">                while (num_set.count(currentNum + 1)) &#123;</span><br><span class="line">                    currentNum += 1;</span><br><span class="line">                    currentStreak += 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 更新最大长度</span><br><span class="line">                longestStreak = max(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析-这也是面试中最容易被问倒的地方"><a href="#4-复杂度分析-这也是面试中最容易被问倒的地方" class="headerlink" title="4. 复杂度分析 (这也是面试中最容易被问倒的地方)"></a>4. 复杂度分析 (这也是面试中最容易被问倒的地方)</h3><p>很多初学者看到代码里有一个 <code>for</code> 循环，里面还套了一个 <code>while</code> 循环，第一反应就是：“这不是 $O(n^2)$ 吗？”</p>
<p><strong>其实它是 $O(n)$。为什么？</strong></p>
<ul>
<li><strong>外层循环</strong>：虽然遍历了所有元素。</li>
<li><strong>内层循环 (<code>while</code>)</strong>：请注意 <code>if (!num_set.count(num - 1))</code> 这个判断条件。<ul>
<li>这个条件保证了<strong>只有是序列起点</strong>的数字，才会进入 <code>while</code> 循环。</li>
<li>比如序列 <code>[1, 2, 3, 4]</code>，只有 <code>1</code> 会进入 <code>while</code> 循环跑 4 次。<code>2, 3, 4</code> 在 <code>if</code> 判断时就被拦住了。</li>
</ul>
</li>
<li><strong>全局视角</strong>：<ul>
<li>数组中的每个数字，最多被访问<strong>两次</strong>：<ol>
<li>在 <code>for</code> 循环中被检查一次。</li>
<li>在 <code>while</code> 循环中作为序列的一部分被检查一次（如果它不是起点）。</li>
</ol>
</li>
<li>所以总操作次数是 $2n$，即线性复杂度 <strong>$O(n)$</strong>。</li>
</ul>
</li>
</ul>
<h4 id="空间复杂度：-O-n"><a href="#空间复杂度：-O-n" class="headerlink" title="空间复杂度：$O(n)$"></a><strong>空间复杂度：$O(n)$</strong></h4><ul>
<li>我们需要一个 <code>unordered_set</code> 来存储数组中所有的数，空间消耗取决于 <code>nums</code> 的长度。</li>
</ul>
<hr>
<h3 id="5-易错点与边界情况"><a href="#5-易错点与边界情况" class="headerlink" title="5. 易错点与边界情况"></a>5. 易错点与边界情况</h3><ol>
<li><strong>空数组</strong>：如果输入 <code>[]</code>，代码中的 <code>longestStreak</code> 初始化为 0，直接返回 0，逻辑正确。</li>
<li><strong>重复元素</strong>：题目说未排序数组，可能包含重复数字（如 <code>[1, 2, 0, 1]</code>）。<code>unordered_set</code> 自动帮我们去重了，所以重复元素不会影响连续序列长度的计算（序列长度看的是数值，不是个数）。</li>
<li><strong>整数溢出</strong>：虽然题目一般给 <code>int</code>，但在 <code>while</code> 循环中 <code>currentNum + 1</code> 理论上可能溢出。但在 LeetCode 的测试用例约束下通常不需要处理 <code>long long</code>，如果是在非常严格的比赛中，可以将 <code>currentNum</code> 设为 <code>long long</code> 或先检查 <code>INT_MAX</code>。</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>239滑动窗口最大值</title>
    <url>/2025/11/13/Hot100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<p>题目：<br>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <strong>滑动窗口中的最大值</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10⁵</code></li>
<li><code>-10⁴ &lt;= nums[i] &lt;= 10⁴</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<p>这道题是力扣（LeetCode）第 239 题，也是一道标着 <strong>Hard</strong> 的题目。</p>
<p>它是 <strong>单调队列 (Monotonic Queue)</strong> 数据结构的教科书级应用。如果说“接雨水”考的是双指针的灵性，那么这道题考的就是对数据结构特性的极致利用。</p>
<p>掌握了这道题，你就学会了如何在 $O(n)$ 时间内解决“区间最值”问题。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：滑动窗口最大值 (Sliding Window Maximum)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到最右侧。你只可以看到在窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>请你返回 <strong>每一个</strong> 窗口中的最大值。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>线性时间</strong>：如果你对每个窗口都遍历一次找最大值，复杂度是 $O(n \cdot k)$。当 $n$ 和 $k$ 都很大时（比如 $10^5$），会超时。我们需要一个 <strong>$O(n)$</strong> 的解法。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [1, 3, -1, -3, 5, 3, 6, 7]</code>, <code>k = 3</code></p>
<p>输出：<code>[3, 3, 5, 5, 6, 7]</code></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么普通队列不行？"><a href="#2-1-为什么普通队列不行？" class="headerlink" title="2.1 为什么普通队列不行？"></a>2.1 为什么普通队列不行？</h4><p>我们需要一个容器来存储窗口里的数。</p>
<ul>
<li>如果只存数，当窗口移动时，左边出、右边进，很简单。</li>
<li>但是，我们要找 <strong>最大值</strong>。普通队列没办法快速告诉我们最大值是谁。</li>
</ul>
<h4 id="2-2-核心策略：单调队列-Monotonic-Queue"><a href="#2-2-核心策略：单调队列-Monotonic-Queue" class="headerlink" title="2.2 核心策略：单调队列 (Monotonic Queue)"></a>2.2 核心策略：单调队列 (Monotonic Queue)</h4><p>我们需要一个既能像队列一样“先进先出”，又能像堆一样“快速取最大值”的结构。</p>
<p>这就引出了 <strong>单调递减队列</strong>。</p>
<p><strong>设计思想（残酷的职场法则）：</strong></p>
<p>想象每个数字是一个来应聘的员工，数值大小代表能力，下标代表入职时间。</p>
<ol>
<li><p><strong>淘汰机制（Pop Back）</strong>：</p>
<p>当一个新员工（当前元素 <code>nums[i]</code>）进来时，如果他的能力比排在他前面的老员工（队列尾部的元素）<strong>还要强</strong>（或者相等），那么这些老员工就彻底没戏了。</p>
<ul>
<li>为什么？因为新员工能力更强，而且比老员工<strong>更晚</strong>离开窗口（存活时间更长）。</li>
<li>只要新员工在，老员工永远不可能成为“最大值”。</li>
<li><strong>动作</strong>：把比当前元素小的老元素统统踢出队列。</li>
</ul>
</li>
<li><p><strong>保留潜力股（Push）</strong>：</p>
<p>如果新员工能力比前面的弱怎么办？</p>
<ul>
<li>也要招进来！因为前面的强者可能会过期（滑出窗口），到时候这个弱一点的新员工就有机会成为老大。</li>
<li><strong>结果</strong>：队列里的元素，从头到尾一定是<strong>从大到小</strong>排列的。</li>
</ul>
</li>
<li><p><strong>过期机制（Pop Front）</strong>：</p>
<p>每次窗口滑动，我们需要检查“现任老大”（队列头部的元素）是不是已经滑出窗口了。</p>
<ul>
<li>如果是（下标过期），就让他退休（移除队头）。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：</p>
<p><strong>队列头部 (Front)</strong> 永远存放着当前窗口的 <strong>最大值</strong> 的下标。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这里我们需要使用双端队列 <code>std::deque</code>，因为它支持在头部和尾部进行插入删除操作。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 双端队列，用于存储元素的下标（注意是下标，不是数值！）</span><br><span class="line">        // 队列性质：单调递减（队头对应的数值最大）</span><br><span class="line">        deque&lt;int&gt; dq;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            // 1. 入队前的“淘汰”过程 (保持单调性)</span><br><span class="line">            // 如果队列不为空，且当前元素 nums[i] 大于等于队尾元素</span><br><span class="line">            // 说明队尾那个元素在 nums[i] 面前已经是个“废人”了，直接剔除</span><br><span class="line">            while (!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2. 新元素入队</span><br><span class="line">            // 存储下标，方便判断是否过期</span><br><span class="line">            dq.push_back(i);</span><br><span class="line"></span><br><span class="line">            // 3. 检查队头元素是否过期</span><br><span class="line">            // 窗口大小为 k，当前右边界是 i</span><br><span class="line">            // 合法窗口范围是 [i - k + 1, i]</span><br><span class="line">            // 如果队头下标 &lt; i - k + 1，说明它已经滑出窗口左侧了</span><br><span class="line">            if (dq.front() &lt; i - k + 1) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 记录结果</span><br><span class="line">            // 当窗口完全形成后（即 i &gt;= k - 1 时），队头就是当前窗口最大值</span><br><span class="line">            if (i &gt;= k - 1) &#123;</span><br><span class="line">                result.push_back(nums[dq.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><p>很多同学看到 <code>for</code> 循环里套了个 <code>while</code>，第一反应是 $O(n^2)$。<strong>这是错误的直觉。</strong></p>
<h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们可以用 <strong>摊还分析 (Amortized Analysis)</strong> 来看：<ul>
<li>数组中的每个元素，<strong>最多被 <code>push_back</code> 进队列一次</strong>。</li>
<li>数组中的每个元素，<strong>最多被 <code>pop_back</code> 或 <code>pop_front</code> 出队列一次</strong>。</li>
</ul>
</li>
<li>也就是说，对于长度为 $n$ 的数组，所有入队和出队操作的总次数不会超过 $2n$ 次。</li>
<li>平均下来，每个元素的操作是常数时间的。所以整体是 $O(n)$。</li>
</ul>
<h4 id="空间复杂度：-O-k"><a href="#空间复杂度：-O-k" class="headerlink" title="空间复杂度：$O(k)$"></a><strong>空间复杂度：$O(k)$</strong></h4><ul>
<li>最坏情况下（比如数组是递减的 <code>[5, 4, 3, 2, 1]</code>），队列需要存储窗口内的所有 $k$ 个元素。</li>
<li>空间复杂度取决于窗口大小 $k$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么队列里要存下标，而不是直接存数值？</strong><ul>
<li><strong>A:</strong> 这是一个经典坑点。</li>
<li>如果存数值，当我们需要判断“队头元素是否过期”时，我们只知道队头的值是 <code>X</code>，但不知道这个 <code>X</code> 是刚才进来的，还是很久以前进来的。</li>
<li>存下标能让我们通过 <code>if (dq.front() &lt; i - k + 1)</code> 精准地判断位置。同时，拿到下标也能随时通过 <code>nums[index]</code> 拿到数值。</li>
</ul>
</li>
<li><strong>Q: 为什么 <code>while</code> 循环里是 <code>nums[dq.back()] &lt;= nums[i]</code>？能不能写 <code>&lt;</code>？</strong><ul>
<li><strong>A:</strong> 建议写 <code>&lt;=</code>。</li>
<li>如果有两个 <code>5</code>，即 <code>[5, 5]</code>。</li>
<li>如果不踢出前一个 <code>5</code>，队列里会有两个 <code>5</code>。</li>
<li>如果踢出前一个 <code>5</code>，队列里只剩最新的 <code>5</code>。</li>
<li>这两种都可以。但是剔除前一个 <code>5</code> 可以让队列更短一点，省一点空间，且逻辑上“旧的 5”确实比“新的 5”更早过期，没必要留着。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题展示了 <strong>单调队列</strong> 的威力。它的核心口诀是：</p>
<blockquote>
<p><strong>“如果有比我更强（数值更大）还比我更年轻（下标更大）的人存在，那我就毫无价值了。”</strong></p>
</blockquote>
<p>掌握了这个思想，你就能解决一系列“区间最大值&#x2F;最小值”或“带约束的动态规划优化”问题。</p>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2025/11/13/Hot100/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></p>
<p>题目：<br>给你一个链表的头节点 <code>head</code>，判断链表中是否有环。</p>
<p>如果链表中存在某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达该节点，则链表中存在环。<br>如果链表中存在环，则返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 10⁴]</code></li>
<li><code>-10⁵ &lt;= Node.val &lt;= 10⁵</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的某个有效索引</li>
</ul>
<p>这道题是链表中的**“国民级”**算法题。</p>
<p>几乎所有的算法入门教材都会讲它，因为它引入了一个极其经典、不仅限于计算机领域的算法思想——<strong>Floyd 判圈算法 (Floyd’s Cycle-Finding Algorithm)</strong>，俗称 <strong>“龟兔赛跑”</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：环形链表 (Linked List Cycle)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个链表的头节点 <code>head</code>，判断链表中是否有环。</p>
<ul>
<li>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。</li>
<li>如果存在环，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<p><strong>进阶要求</strong>：</p>
<ul>
<li>你能用 <strong>$O(1)$（即常数）内存</strong> 解决此问题吗？</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>3 -&gt; 2 -&gt; 0 -&gt; -4</code>，其中 <code>-4</code> 指向 <code>2</code>。</p>
<p>输出：<code>true</code></p>
<p>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-直观解法：哈希表-Hash-Set"><a href="#2-1-直观解法：哈希表-Hash-Set" class="headerlink" title="2.1 直观解法：哈希表 (Hash Set)"></a>2.1 直观解法：哈希表 (Hash Set)</h4><p>最容易想到的方法是：每遍历一个节点，就把它扔进一个哈希集合 (<code>unordered_set</code>)。</p>
<ul>
<li>如果当前节点已经在集合里了 $\rightarrow$ 说明我以前来过这里 $\rightarrow$ <strong>有环！</strong></li>
<li>如果走到 <code>NULL</code> 还没重复 $\rightarrow$ <strong>无环</strong>。</li>
</ul>
<p><strong>缺点</strong>：你需要存储所有访问过的节点，空间复杂度是 $O(N)$。题目希望能优化到 $O(1)$。</p>
<h4 id="2-2-核心策略：快慢指针-龟兔赛跑"><a href="#2-2-核心策略：快慢指针-龟兔赛跑" class="headerlink" title="2.2 核心策略：快慢指针 (龟兔赛跑)"></a>2.2 核心策略：快慢指针 (龟兔赛跑)</h4><p>想象你在操场跑步：</p>
<ul>
<li><strong>无环情况</strong>：如果操场是一条笔直的跑道，跑得快的人（兔子）永远会把跑得慢的人（乌龟）甩在后面，直到跑到终点。</li>
<li><strong>有环情况</strong>：如果跑道是一个圆圈，跑得快的人最终会<strong>超圈 (Lap)</strong>，从后面追上跑得慢的人。</li>
</ul>
<p><strong>算法逻辑</strong>：</p>
<ol>
<li>定义两个指针：<ul>
<li><strong><code>slow</code> (乌龟)</strong>：一次走 <strong>1</strong> 步。</li>
<li><strong><code>fast</code> (兔子)</strong>：一次走 <strong>2</strong> 步。</li>
</ul>
</li>
<li>让它们同时从起点出发。</li>
<li><strong>如果没环</strong>：<code>fast</code> 跑得快，会率先碰到 <code>NULL</code> (终点)，游戏结束，返回 <code>false</code>。</li>
<li><strong>如果有环</strong>：<code>fast</code> 会先进入环，<code>slow</code> 后进入。一旦两人都在环里，<code>fast</code> 就会在后面追 <code>slow</code>。由于 <code>fast</code> 每次比 <code>slow</code> 多跑一步，<strong>他们最终一定会在环内的某一点相遇</strong>。</li>
</ol>
<p><strong>为什么一定会相遇？</strong></p>
<p>这是一个相对速度的物理问题。</p>
<p>假设 <code>slow</code> 进环的时候，<code>fast</code> 已经在环里了，他们之间相差 $K$ 步。</p>
<ul>
<li>每一回合，<code>fast</code> 走 2 步，<code>slow</code> 走 1 步。</li>
<li>两人之间的距离缩短：$2 - 1 &#x3D; 1$ 步。</li>
<li>距离会变成 $K, K-1, K-2, …, 0$。</li>
<li>当距离为 0 时，即为相遇。也就是<strong>绝对不会跳过去</strong>。</li>
</ul>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        // 边界条件：空链表或只有一个节点且无环的情况</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 定义快慢指针</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">        // 开始赛跑</span><br><span class="line">        // 循环条件：fast 不能指向 NULL，fast-&gt;next 也不能指向 NULL</span><br><span class="line">        // 因为 fast 要一次跳两步，如果 fast-&gt;next 是 NULL，</span><br><span class="line">        // 那么 fast-&gt;next-&gt;next 就会空指针报错 (SegFault)</span><br><span class="line">        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;          // 慢指针走一步</span><br><span class="line">            fast = fast-&gt;next-&gt;next;    // 快指针走两步</span><br><span class="line"></span><br><span class="line">            // 检查是否相遇</span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                return true; // 兔子追上了乌龟，说明有环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果循环结束，说明 fast 跑到了尽头 (NULL)，链表无环</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li><strong>无环</strong>：<code>fast</code> 指针走完链表，$N&#x2F;2$ 步，时间 $O(N)$。</li>
<li><strong>有环</strong>：<ul>
<li>假设链表非环部分长度为 $L$，环长度为 $C$。</li>
<li><code>slow</code> 进环时，<code>fast</code> 已经在环里转悠了。</li>
<li>最坏情况下，<code>fast</code> 刚好在 <code>slow</code> 后面一步，需要追 $C-1$ 次才能追上。</li>
<li>总步数大约是 $L + C$，依然是线性的 $O(N)$。</li>
</ul>
</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了 <code>slow</code> 和 <code>fast</code> 两个指针，没有使用任何随输入规模增长的额外空间。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 <code>fast</code> 要走 2 步？走 3 步可以吗？</strong><ul>
<li><strong>A:</strong> 走 3 步也可以，但走 2 步是最优的。<ul>
<li>如果走 2 步：相对速度差是 1。任何距离 $K$ 都能被 1 整除，一定能相遇。</li>
<li>如果走 3 步：相对速度差是 2。如果初始距离是奇数，快指针可能会直接“跳过”慢指针（Distance: 1 -&gt; -1），虽然多跑几圈最终也能遇上，但代码逻辑复杂了，效率也可能变低。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q: 为什么循环条件要写 <code>fast-&gt;next != nullptr</code>？</strong><ul>
<li><strong>A:</strong> 因为我们在循环体里写了 <code>fast = fast-&gt;next-&gt;next</code>。如果 <code>fast</code> 已经在最后一个节点了（<code>fast</code> 有值，但 <code>fast-&gt;next</code> 是 NULL），你硬要去访问 <code>fast-&gt;next</code> 的 <code>next</code>，程序就会崩溃。这是链表题最容易出现的 Bug。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>11盛最多水的容器</title>
    <url>/2025/11/13/Hot100/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p>
<p>题目：<br>给定一个长度为 <code>n</code> 的整数数组 <code>height</code>。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code>。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 10⁵</code></li>
<li><code>0 &lt;= height[i] &lt;= 10⁴</code></li>
</ul>
<p>这道题是 <strong>双指针（Two Pointers）</strong> 算法中“左右端点向中间逼近”模型的教科书级题目。</p>
<p>如果说“移动零”是快慢指针的代表，那么 <strong>“盛最多水的容器”</strong> 就是 <strong>左右对撞指针</strong> 的代表。这道题的核心不在于写代码（代码非常短），而在于理解背后的 <strong>贪心策略</strong> —— 也就是“每一步我们为什么要这样走”。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：盛最多水的容器 (Container With Most Water)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>height</code>，数组中有 $n$ 个非负整数。每个数代表坐标轴上的一根竖线的长度。</p>
<p>我们要选取两根竖线，把它们作为容器的左右两壁，和 x 轴共同构成一个容器。</p>
<p>请你找出两根线，使得它们组成的容器能装最多的水（即面积最大）。</p>
<p><strong>计算公式</strong>：</p>
<p>$$\text{面积} &#x3D; (\text{右下标} - \text{左下标}) \times \min(\text{左边高度}, \text{右边高度})$$</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>height = [1,8,6,2,5,4,8,3,7]</code></p>
<p>输出：<code>49</code></p>
<p>解释：选取下标 1 (高度8) 和下标 8 (高度7)。</p>
<p>宽度 &#x3D; $8 - 1 &#x3D; 7$</p>
<p>高度 &#x3D; $\min(8, 7) &#x3D; 7$ (受限于较短的那根)</p>
<p>面积 &#x3D; $7 \times 7 &#x3D; 49$</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-暴力解法-TLE"><a href="#2-1-暴力解法-TLE" class="headerlink" title="2.1 暴力解法 (TLE)"></a>2.1 暴力解法 (TLE)</h4><p>最容易想到的就是两层循环：试遍所有的组合 $(i, j)$，算出面积，取最大值。</p>
<p>复杂度是 $O(n^2)$。当 $n$ 很大（题目通常是 $10^5$）时，绝对会超时。</p>
<h4 id="2-2-核心策略：双指针-贪心思维"><a href="#2-2-核心策略：双指针-贪心思维" class="headerlink" title="2.2 核心策略：双指针 + 贪心思维"></a>2.2 核心策略：双指针 + 贪心思维</h4><p><strong>初始状态</strong>：</p>
<p>我们想要面积最大，面积由 <strong>宽度</strong> 和 <strong>高度</strong> 决定。</p>
<p>一开始，我们不妨让 <strong>宽度最大</strong>。也就是说，让左指针 <code>left</code> 指向数组头，右指针 <code>right</code> 指向数组尾。</p>
<p><strong>移动策略 (The “Why”)</strong>：</p>
<p>现在的宽度已经是最大的了。接下来我们需要把指针向中间移动，<strong>宽度肯定会变小</strong>。</p>
<p>既然宽度变小了，我们只有让 <strong>高度变高</strong>，才有可能让整体面积变大。</p>
<p>这就引出了核心问题：<strong>应该移动哪一边的指针？左边还是右边？</strong></p>
<p><strong>决策逻辑（短板效应）</strong>：</p>
<p>假设 <code>height[left] = 5</code>，<code>height[right] = 10</code>。</p>
<p>当前高度是由 <strong>短</strong> 的那一根决定的（也就是左边的 5）。</p>
<ol>
<li><strong>如果我们移动高的那根（右边 10）</strong>：<ul>
<li>宽度变小了。</li>
<li>新的高度 <strong>绝不可能</strong> 超过 5（因为左边还是 5，瓶颈还在左边）。</li>
<li><strong>结论</strong>：宽度减小，高度不变或变小 $\rightarrow$ <strong>面积一定变小</strong>。这条路是死路。</li>
</ul>
</li>
<li><strong>如果我们移动短的那根（左边 5）</strong>：<ul>
<li>宽度变小了。</li>
<li>但是！如果我们运气好，碰到了一个更高的板子（比如 12），那么新的高度可能变成 10（受限于右边的 10）。</li>
<li><strong>结论</strong>：虽然宽度减小，但高度可能增加 $\rightarrow$ <strong>面积有机会变大</strong>。</li>
</ul>
</li>
</ol>
<p><strong>贪心算法总结</strong>：</p>
<p><strong>永远移动高度较小的那根指针。</strong> 如果两根一样高，移动任意一根（或两根同时移动）都可以。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        // 定义左右双指针</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.size() - 1;</span><br><span class="line">        </span><br><span class="line">        int max_res = 0; // 记录历史最大面积</span><br><span class="line"></span><br><span class="line">        // 当两个指针没有相遇时，循环继续</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            // 1. 计算当前面积</span><br><span class="line">            // 高度取决于短的那根板子 (木桶效应)</span><br><span class="line">            int current_height = min(height[left], height[right]);</span><br><span class="line">            int current_width = right - left;</span><br><span class="line">            int current_area = current_height * current_width;</span><br><span class="line"></span><br><span class="line">            // 2. 更新最大值</span><br><span class="line">            max_res = max(max_res, current_area);</span><br><span class="line"></span><br><span class="line">            // 3. 移动指针（核心策略）</span><br><span class="line">            // 谁短，就移动谁，试图找到更高的板子</span><br><span class="line">            if (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li><code>left</code> 和 <code>right</code> 两个指针一共遍历了整个数组一次。</li>
<li>每个元素只被访问一次，要么是 <code>left</code> 划过，要么是 <code>right</code> 划过。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>只使用了几个整型变量来存储下标和面积，没有使用额外的线性空间。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果 <code>height[left]</code> 和 <code>height[right]</code> 相等怎么办？</strong><ul>
<li><strong>A:</strong> 此时移动 <code>left</code> 或 <code>right</code> 都可以，甚至同时移动也可以。</li>
<li><strong>原因</strong>：假设两边都是 5。如果只移动左边，新的左边要是比 5 小，面积变小；比 5 大，高度还是受限于右边的 5，面积还是变小（因为宽度小了）。所以遇到相等的情况，当前的 5 已经是这两个边界能围成的最大面积了，这俩边界都可以“退休”了。代码中写 <code>else &#123; right--; &#125;</code> 包含了这种情况，处理也是正确的。</li>
</ul>
</li>
<li><strong>Q: 这种贪心策略真的不会错过最大值吗？</strong><ul>
<li><strong>A:</strong> 不会。这在数学上是可以证明的。简单来说，我们每一步排除掉的那些组合（比如移动短板时，我们排除掉了“短板不动，长板向内移动的所有情况”），这些被排除的情况的面积，<strong>一定</strong>小于当前算出来的面积。我们只是排除了“垃圾选项”，保留了“潜力股”。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>142. 环形链表 II</title>
    <url>/2025/11/13/Hot100/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p>
<p>题目：<br>给定一个链表的头节点 <code>head</code>，返回链表开始入环的第一个节点。如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos == -1</code>，则在该链表中没有环。注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：null<br>解释：链表中没有环。</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 10⁴]</code></li>
<li><code>-10⁵ &lt;= Node.val &lt;= 10⁵</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的某个有效索引</li>
</ul>
<p>这道题是“环形链表 I”的<strong>完美升华</strong>。</p>
<p>如果说第一题是在问“有没有鬼”，那这道题就是在问“<strong>鬼门关在哪里</strong>”。</p>
<p>解决这道题不需要新的数据结构，需要的只是一点点<strong>小学奥数</strong>级别的推导。一旦理解了那个数学关系，代码写起来比第一题还简单。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：环形链表 II (Linked List Cycle II)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个链表的头节点 <code>head</code>，如果链表中存在环，返回链表开始入环的第一个节点（即<strong>环的入口</strong>）；如果链表无环，返回 <code>null</code>。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li>不允许修改链表。</li>
<li>空间复杂度要求 <strong>$O(1)$</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>3 -&gt; 2 -&gt; 0 -&gt; -4</code>，<code>-4</code> 指回 <code>2</code>。</p>
<p>输出：节点 <code>2</code>。</p>
<p>解释：节点 <code>2</code> 是环的入口，<code>-4</code> 是环里的最后一个节点，它指向了入口。</p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么不能直接看出来？"><a href="#2-1-为什么不能直接看出来？" class="headerlink" title="2.1 为什么不能直接看出来？"></a>2.1 为什么不能直接看出来？</h4><p>当我们用快慢指针 (<code>slow</code>, <code>fast</code>) 相遇时，相遇点通常<strong>不是</strong>环的入口。</p>
<p>相遇点可能在环里的任何位置（取决于环的大小和入环前的直线长度）。我们需要一种方法，从这个“随机”的相遇点，反推出“入口点”。</p>
<h4 id="2-2-核心策略：数学推导-The-Math-Magic"><a href="#2-2-核心策略：数学推导-The-Math-Magic" class="headerlink" title="2.2 核心策略：数学推导 (The Math Magic)"></a>2.2 核心策略：数学推导 (The Math Magic)</h4><p>我们把链表分为三段距离（看下图辅助理解）：</p>
<ol>
<li><strong>$a$</strong>：从头节点 <code>head</code> 到环入口 <code>entry</code> 的距离（直线部分）。</li>
<li><strong>$b$</strong>：从环入口 <code>entry</code> 到快慢指针相遇点 <code>meet</code> 的距离。</li>
<li><strong>$c$</strong>：从相遇点 <code>meet</code> 继续走回到环入口 <code>entry</code> 的距离。</li>
</ol>
<p><strong>推导过程</strong>：</p>
<ol>
<li><strong>相遇时走了多远？</strong><ul>
<li><strong>Slow (乌龟)</strong> 走了：$a + b$</li>
<li><strong>Fast (兔子)</strong> 走了：$a + b + n(b + c)$<ul>
<li><em>(解释：兔子跑得快，在乌龟进环之前，兔子已经在圈里跑了 n 圈了，最后在 b 处追上乌龟)</em>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>速度关系</strong>：<ul>
<li>兔子的速度是乌龟的 2 倍。所以路程也是 2 倍。</li>
<li>$2 \times (a + b) &#x3D; a + b + n(b + c)$</li>
</ul>
</li>
<li><strong>化简方程</strong>（高光时刻）：<ul>
<li>$2a + 2b &#x3D; a + b + n(b + c)$</li>
<li>移项得：$a + b &#x3D; n(b + c)$</li>
<li>$a &#x3D; n(b + c) - b$</li>
<li>我们知道 $(b + c)$ 就是环的长度 $L$。</li>
<li>$a &#x3D; (n-1)L + (L - b)$</li>
<li>看图可知，$L - b$ 其实就是 <strong>$c$</strong>（剩下的距离）。</li>
<li><strong>结论：$a &#x3D; (n-1)L + c$</strong></li>
</ul>
</li>
</ol>
<p><strong>人话翻译结论</strong>：</p>
<p>$$a &#x3D; c$$</p>
<p>(忽略圈数 $n$，因为转圈不影响最终位置)</p>
<p>这意味着：<strong>从“头节点”走到“入口”的距离 ($a$)，竟然等于从“相遇点”继续往前走到“入口”的距离 ($c$)！</strong></p>
<h4 id="2-3-算法流程"><a href="#2-3-算法流程" class="headerlink" title="2.3 算法流程"></a>2.3 算法流程</h4><p>基于上面的结论，算法变得异常简单：</p>
<ol>
<li><strong>第一阶段</strong>：也就是上一题的逻辑。用快慢指针判断是否有环。如果没环，直接返回 NULL。</li>
<li><strong>第二阶段</strong>：如果相遇了（找到了 <code>meet</code> 点）：<ul>
<li>把其中一个指针（比如 <code>fast</code>）扔回 <strong>链表头部 (<code>head</code>)</strong>。</li>
<li>另一个指针（<code>slow</code>）保持在 <strong>相遇点 (<code>meet</code>)</strong> 不动。</li>
<li>现在，两个指针<strong>同时</strong>开始走，而且<strong>每次都只走 1 步</strong>。</li>
</ul>
</li>
<li><strong>相遇即入口</strong>：<ul>
<li>根据 $a &#x3D; c$，它们一定会在走了 $a$ 步之后，在<strong>环入口</strong>相遇。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        // 1. 快慢指针找相遇点</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        bool hasCycle = false;</span><br><span class="line"></span><br><span class="line">        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            if (slow == fast) &#123;</span><br><span class="line">                hasCycle = true;</span><br><span class="line">                break; // 找到相遇点了，跳出循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果跑完了都没相遇，说明没环</span><br><span class="line">        if (!hasCycle) return nullptr;</span><br><span class="line"></span><br><span class="line">        // 2. 寻找环入口</span><br><span class="line">        // 此时 slow 在相遇点，fast 也在相遇点</span><br><span class="line">        // 我们把 fast 扔回起点（利用数学结论 a = c）</span><br><span class="line">        fast = head;</span><br><span class="line"></span><br><span class="line">        // 两个指针同速前进，每次走一步</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当它们再次相遇时，所在的节点就是环的入口</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>判断环的过程是 $O(N)$。</li>
<li>寻找入口的过程，指针最多走 $a$ 步（直线长度），也是 $O(N)$。</li>
<li>总体依然是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只复用了 <code>slow</code> 和 <code>fast</code> 指针，没有申请额外空间。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么相遇时，乌龟一定没跑完一圈？</strong><ul>
<li><strong>A:</strong> 这是 Floyd 算法的一个特性。当乌龟刚进环时，兔子已经在环里了。兔子追乌龟，距离最多就是一圈。因为兔子速度是乌龟的2倍，所以在乌龟跑完一圈之前，兔子绝对能追上它。所以公式里乌龟的路程写 $a+b$ 是对的（不需要加 $n$ 圈）。</li>
</ul>
</li>
<li><strong>Q: 如果链表就是一个大环（头节点就在环里），算法还有效吗？</strong><ul>
<li><strong>A:</strong> 有效。此时 $a&#x3D;0$。</li>
<li>相遇点就是起点（或者起点附近的某点）。</li>
<li><code>fast</code> 回到 <code>head</code>，<code>slow</code> 在相遇点。</li>
<li>循环一开始 <code>while (slow != fast)</code> 就会发现它俩已经重合了，直接返回 <code>slow</code>（也就是 <code>head</code>）。逻辑自洽。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>73. 矩阵置零</title>
    <url>/2025/11/13/Hot100/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></p>
<p>题目：<br>给定一个 <code>m x n</code> 的矩阵 <code>matrix</code>，如果某个元素为 0，则将其所在行和列的所有元素都设为 0。</p>
<p>请在原地修改矩阵，不要使用额外的空间。</p>
<p><strong>示例 1：</strong><br>输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]<br>输出：[[1,0,1],[0,0,0],[1,0,1]]</p>
<p><strong>示例 2：</strong><br>输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br>输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-2³¹ &lt;= matrix[i][j] &lt;= 2³¹ - 1</code></li>
</ul>
<p>这道题是力扣（LeetCode）第 73 题。它的难度标记为 Medium，但如果你想达到它的进阶要求——<strong>$O(1)$ 空间复杂度</strong>，那它就是一道充满智慧的 Hard 级思维题。</p>
<p>这道题考察的不是算法的复杂性，而是<strong>利用现有数据结构本身作为存储空间</strong>的能力。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：矩阵置零 (Set Matrix Zeroes)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个 $m \times n$ 的矩阵，如果一个元素为 <strong>0</strong>，则将其所在行和所在列的所有元素都设为 <strong>0</strong>。请使用<strong>原地</strong>算法。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>原地操作</strong>：尽量少用额外空间。</li>
<li><strong>陷阱</strong>：如果你直接遍历，遇到 0 就把整行整列变 0，那么那些被你变成 0 的数字，在后续遍历中会被误认为是“原始的 0”，导致最后整个矩阵全变成 0 了。我们需要区分“原来的 0”和“后变的 0”。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 1, 1],</span><br><span class="line">  [1, 0, 1],</span><br><span class="line">  [1, 1, 1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 0, 1],</span><br><span class="line">  [0, 0, 0],</span><br><span class="line">  [1, 0, 1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么-O-m-n-空间很容易？"><a href="#2-1-为什么-O-m-n-空间很容易？" class="headerlink" title="2.1 为什么 $O(m+n)$ 空间很容易？"></a>2.1 为什么 $O(m+n)$ 空间很容易？</h4><p>最直观的做法是申请两个布尔数组：</p>
<ul>
<li><p><code>row_zero[m]</code>：记录哪一行有 0。</p>
</li>
<li><p><code>col_zero[n]</code>：记录哪一列有 0。</p>
<p>遍历一遍矩阵，填好这两个数组。然后再遍历一遍，根据这两个数组把对应位置设为 0。</p>
<p>但这不符合 $O(1)$ 的极致要求。</p>
</li>
</ul>
<h4 id="2-2-核心策略：投影法-O-1-空间"><a href="#2-2-核心策略：投影法-O-1-空间" class="headerlink" title="2.2 核心策略：投影法 ($O(1)$ 空间)"></a>2.2 核心策略：投影法 ($O(1)$ 空间)</h4><p>我们能不能把上面的 <code>row_zero</code> 和 <code>col_zero</code> 省掉？</p>
<p>其实，矩阵本身的 <strong>第一行</strong> 和 <strong>第一列</strong> 就可以充当这两个“记事本”！</p>
<p><strong>算法逻辑</strong>：</p>
<ol>
<li><strong>借用空间</strong>：<ul>
<li>如果 <code>matrix[i][j]</code> 是 0，我们就把它的 <strong>列首</strong> (<code>matrix[0][j]</code>) 和 <strong>行首</strong> (<code>matrix[i][0]</code>) 设为 0。</li>
<li>这样，第一行和第一列就变成了我们的标记数组。</li>
</ul>
</li>
<li><strong>解决冲突 (Corner Case)</strong>：<ul>
<li><code>matrix[0][0]</code> 这个位置很特殊，它既属于第一行，又属于第一列。</li>
<li>如果 <code>matrix[0][0]</code> 是 0，到底是因为第 0 行有 0，还是第 0 列有 0？这会混淆。</li>
<li><strong>解决方案</strong>：<ul>
<li>我们用 <code>matrix[0][0]</code> 专门记录 <strong>第 0 行</strong> 的状态。</li>
<li>我们用一个额外的变量 <code>col0_flag</code> 专门记录 <strong>第 0 列</strong> 的状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>两遍扫描</strong>：<ul>
<li><strong>第一遍</strong>：遍历矩阵，如果有 0，就在对应的行首和列首做记号（设为 0）。同时单独判断第 0 列是否包含 0，更新 <code>col0_flag</code>。</li>
<li><strong>第二遍</strong>：根据行首和列首的记号，把中间的元素设为 0。</li>
<li><strong>最后处理</strong>：根据 <code>matrix[0][0]</code> 和 <code>col0_flag</code>，决定是否把第一行和第一列全设为 0。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        </span><br><span class="line">        // col0_flag 用于标记【第一列】是否原本包含 0</span><br><span class="line">        // 为什么第一行不需要单独变量？因为我们复用了 matrix[0][0] 代表第一行的状态</span><br><span class="line">        bool col0_flag = false;</span><br><span class="line"></span><br><span class="line">        // 1. 第一遍遍历：做标记</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            // 单独判断第一列的情况</span><br><span class="line">            if (matrix[i][0] == 0) &#123;</span><br><span class="line">                col0_flag = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 判断其余列（从 j=1 开始）</span><br><span class="line">            for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">                if (matrix[i][j] == 0) &#123;</span><br><span class="line">                    // 将对应的行首和列首置为 0，作为标记</span><br><span class="line">                    matrix[i][0] = 0;</span><br><span class="line">                    matrix[0][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 第二遍遍历：根据标记置零</span><br><span class="line">        // 注意：我们要从底部向上，或者从内向外遍历，</span><br><span class="line">        // 但这里我们先处理非首行首列的元素 (i: 1-&gt;m, j: 1-&gt;n)</span><br><span class="line">        // 这样不会影响我们存储在 matrix[i][0] 和 matrix[0][j] 里的标记信息</span><br><span class="line">        for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">                // 只要行首或列首有一个是 0，这个位置就该是 0</span><br><span class="line">                if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123;</span><br><span class="line">                    matrix[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 最后处理第一行</span><br><span class="line">        // 如果 matrix[0][0] 是 0，说明第一行原本就有 0（或者被标记了）</span><br><span class="line">        if (matrix[0][0] == 0) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">                matrix[0][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 最后处理第一列</span><br><span class="line">        // 如果 col0_flag 是 true，说明第一列原本就有 0</span><br><span class="line">        if (col0_flag) &#123;</span><br><span class="line">            for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">                matrix[i][0] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-m-times-n"><a href="#时间复杂度：-O-m-times-n" class="headerlink" title="时间复杂度：$O(m \times n)$"></a><strong>时间复杂度：$O(m \times n)$</strong></h4><ul>
<li>我们遍历了矩阵两次。第一次做标记，第二次置换。</li>
<li>虽然有几个单独的 <code>for</code> 循环处理首行首列，但总体操作次数依然与元素总数成正比。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只用了一个布尔变量 <code>col0_flag</code> 和几个循环变量。</li>
<li>我们将标记信息直接存在了原数组的第一行和第一列中，没有申请额外的数组。这是<strong>原地算法</strong>的典范。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要从 <code>j=1</code> 开始遍历？</strong><ul>
<li><strong>A:</strong> 因为第一列 (<code>j=0</code>) 的状态我们是用 <code>col0_flag</code> 单独维护的。如果我们把 <code>j=0</code> 混在里面逻辑一起跑，<code>matrix[0][0]</code> 的状态就会变得混乱（不知道它代表行还是列），逻辑会非常复杂。<strong>将特殊行列（第一列）剥离出来单独处理，是简化逻辑的关键。</strong></li>
</ul>
</li>
<li><strong>Q: 为什么要最后才处理第一行和第一列？</strong><ul>
<li><strong>A:</strong> 因为第一行和第一列是我们的“记事本”。</li>
<li>如果我们在处理中间元素之前，先把第一行全变成 0 了，那我们在处理 <code>matrix[2][5]</code> 的时候，去查 <code>matrix[0][5]</code>，发现它是 0，就会错误地把 <code>matrix[2][5]</code> 也变成 0。</li>
<li><strong>必须等中间所有元素都根据“记事本”更新完了，才能撕掉这个“记事本”。</strong></li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>160. 相交链表</title>
    <url>/2025/11/13/Hot100/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p>
<p>题目：<br>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code>。</p>
<p><strong>示例 1：</strong><br>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8，在两个链表中都出现在第 3 个节点之后。</p>
<p><strong>示例 2：</strong><br>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’</p>
<p><strong>示例 3：</strong><br>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>listA.length == m</code></li>
<li><code>listB.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 3 * 10⁴</code></li>
<li><code>1 &lt;= Node.val &lt;= 10⁵</code></li>
</ul>
<p>这道题非常浪漫，被称为 <strong>“最浪漫的算法题”</strong>。</p>
<p>为什么说它浪漫？因为它的核心思想是：<strong>“我走过你走过的路，我们终将会相遇。”</strong></p>
<p>如果不使用 $O(N)$ 的额外空间（比如哈希表），这道题是考察 <strong>双指针</strong> 和 <strong>思维转换</strong> 的绝佳题目。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：相交链表 (Intersection of Two Linked Lists)</p>
<p><strong>题目大意</strong>：</p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>。如果两个链表相交，请返回相交的那个节点；如果不相交，返回 <code>null</code>。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>相交定义</strong>：指的是两个链表的节点在内存中是 <strong>同一个对象</strong>（指针地址相同），而不仅仅是值 (<code>val</code>) 相同。</li>
<li><strong>结构</strong>：相交后的形状像一个 <strong>“Y”</strong> 字型，而不是 “X” 字型（因为单链表只有一个 <code>next</code> 指针，一旦相交，后面所有的路都是共用的）。</li>
<li><strong>约束</strong>：时间复杂度 $O(N + M)$，空间复杂度 <strong>$O(1)$</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>链表 A: <code>a1 -&gt; a2 -&gt; c1 -&gt; c2</code></li>
<li>链表 B: <code>b1 -&gt; b2 -&gt; b3 -&gt; c1 -&gt; c2</code></li>
<li>相交点是 <code>c1</code>。</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么直接遍历碰不到？"><a href="#2-1-为什么直接遍历碰不到？" class="headerlink" title="2.1 为什么直接遍历碰不到？"></a>2.1 为什么直接遍历碰不到？</h4><p>A 链表长，B 链表短（或者反过来）。</p>
<p>如果我们同时让两个指针从 <code>headA</code> 和 <code>headB</code> 出发，一步一步走：</p>
<ul>
<li><p>A 走到 <code>c1</code> 时，B 还在 <code>b3</code>（因为它还没走完自己的独立部分）。</p>
</li>
<li><p>等 B 走到 <code>c1</code> 时，A 已经走到 <code>c2</code> 后面去了。</p>
<p><strong>速度虽然一样，但起跑线不同（长度不同），导致无法在交叉点相遇。</strong></p>
</li>
</ul>
<h4 id="2-2-核心策略：消除长度差-The-“Romantic”-Algorithm"><a href="#2-2-核心策略：消除长度差-The-“Romantic”-Algorithm" class="headerlink" title="2.2 核心策略：消除长度差 (The “Romantic” Algorithm)"></a>2.2 核心策略：消除长度差 (The “Romantic” Algorithm)</h4><p>我们要想办法消除两个链表的长度差。</p>
<p><strong>算法逻辑</strong>：</p>
<ol>
<li>指针 <code>pA</code> 先走链表 A，走完 A 后，<strong>立刻跳到链表 B 的头</strong> 继续走。</li>
<li>指针 <code>pB</code> 先走链表 B，走完 B 后，<strong>立刻跳到链表 A 的头</strong> 继续走。</li>
<li>如果它们相交，它们一定会在相交点相遇。</li>
<li>如果它们不相交，它们会同时走到 <code>NULL</code>。</li>
</ol>
<p><strong>数学证明 (The “Why”)</strong>：</p>
<p>假设：</p>
<ul>
<li>链表 A 独立部分的长度为 $a$。</li>
<li>链表 B 独立部分的长度为 $b$。</li>
<li>公共部分（相交后）的长度为 $c$。</li>
<li><strong>指针 pA 走的路径</strong>：先走 A，再走 B。<ul>
<li>总路程 &#x3D; $a + c + b$</li>
</ul>
</li>
<li><strong>指针 pB 走的路径</strong>：先走 B，再走 A。<ul>
<li>总路程 &#x3D; $b + c + a$</li>
</ul>
</li>
</ul>
<p><strong>惊人的发现</strong>：</p>
<p>$$a + c + b &#x3D; b + c + a$$</p>
<p>它们走的总路程完全一样！而且因为它们的速度也是一样的（一次一步），所以它们 <strong>一定会在第 $(a+b+c)$ 步的时候同时到达相交点</strong>。</p>
<p>如果两个链表不相交（$c &#x3D; 0$），它们走了 $a+b$ 步后，会同时到达 <code>NULL</code>，此时 <code>pA == pB == NULL</code>，循环结束，返回 NULL，逻辑依然成立。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * ListNode *next;</span><br><span class="line"> * ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        // 特判：如果任意一个链表为空，不可能相交</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 定义两个指针</span><br><span class="line">        ListNode *pA = headA;</span><br><span class="line">        ListNode *pB = headB;</span><br><span class="line"></span><br><span class="line">        // 循环直到 pA 和 pB 相遇</span><br><span class="line">        // 相遇的情况有两种：</span><br><span class="line">        // 1. 在交点相遇（找到答案）</span><br><span class="line">        // 2. 同时走到 NULL（说明不相交）</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            // pA 的逻辑：</span><br><span class="line">            // 如果 pA 走到了 NULL，就跳到 headB 继续走</span><br><span class="line">            // 否则，往前走一步</span><br><span class="line">            if (pA == nullptr) &#123;</span><br><span class="line">                pA = headB;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pA = pA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // pB 的逻辑：</span><br><span class="line">            // 如果 pB 走到了 NULL，就跳到 headA 继续走</span><br><span class="line">            // 否则，往前走一步</span><br><span class="line">            if (pB == nullptr) &#123;</span><br><span class="line">                pB = headA;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pB = pB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 极简写法（三元运算符）：</span><br><span class="line">            // pA = (pA == nullptr) ? headB : pA-&gt;next;</span><br><span class="line">            // pB = (pB == nullptr) ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回相遇点（或者是 nullptr）</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N-M"><a href="#时间复杂度：-O-N-M" class="headerlink" title="时间复杂度：$O(N + M)$"></a><strong>时间复杂度：$O(N + M)$</strong></h4><ul>
<li>$N$ 是链表 A 的长度，$M$ 是链表 B 的长度。</li>
<li>最坏情况下，两个指针都要遍历完两个链表：$N + M$。</li>
<li>操作是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了 <code>pA</code> 和 <code>pB</code> 两个指针变量，没有申请额外的哈希表或栈空间。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 如果两个链表不相交，会死循环吗？</strong><ul>
<li><strong>A:</strong> 不会。</li>
<li>如果不相交，A 走完走 B，B 走完走 A。</li>
<li>A 的路径长度是 $lenA + lenB$。</li>
<li>B 的路径长度是 $lenB + lenA$。</li>
<li>最后它们会<strong>同时</strong>指向 <code>NULL</code>。</li>
<li>条件 <code>pA != pB</code> 变假（因为 <code>NULL == NULL</code>），循环结束，返回 <code>NULL</code>。逻辑完美闭环。</li>
</ul>
</li>
<li><strong>Q: 为什么不直接算长度差？</strong><ul>
<li><strong>A:</strong> 算长度差也是一种 $O(1)$ 空间的解法（先算出 <code>lenA</code> 和 <code>lenB</code>，让长的先走 <code>diff</code> 步，然后一起走）。</li>
<li>但是**“走对方的路”**这种写法代码更短、逻辑更优雅，不容易在计算 <code>diff</code> 或者移动指针时写出 Off-by-one (差一) 错误，是面试时的首选。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>283移动零</title>
    <url>/2025/11/13/Hot100/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p>
<p>题目：<br>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10⁴</code></li>
<li><code>-2³¹ &lt;= nums[i] &lt;= 2³¹ - 1</code></li>
</ul>
<p>太棒了！正如我在上一个回答结尾提到的，<strong>“移动零” (Move Zeroes)</strong> 是开启 <strong>双指针 (Two Pointers)</strong> 算法大门的最佳钥匙。</p>
<p>这道题看起来非常简单，但它是很多高频面试题（如“快速排序”、“移除元素”）的雏形。掌握了它，你就学会了如何在数组内部“乾坤大挪移”而不占用额外空间。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：移动零 (Move Zeroes)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的<strong>末尾</strong>，同时保持<strong>非零元素</strong>的相对顺序。</p>
<p><strong>约束条件</strong>：</p>
<ol>
<li>必须在<strong>原数组</strong>上操作，不能拷贝额外的数组（Space: $O(1)$）。</li>
<li>尽量减少操作次数。</li>
</ol>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [0, 1, 0, 3, 12]</code></p>
<p>输出：<code>[1, 3, 12, 0, 0]</code></p>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么不能新建数组？"><a href="#2-1-为什么不能新建数组？" class="headerlink" title="2.1 为什么不能新建数组？"></a>2.1 为什么不能新建数组？</h4><p>如果允许新建数组，我们只需要遍历一遍，把非 0 的放进新数组，剩下补 0 就行了。但题目限制 <strong>空间复杂度 $O(1)$</strong>，意味着我们必须在原数组里“腾挪”。</p>
<h4 id="2-2-核心策略：快慢双指针-Fast-Slow-Pointers"><a href="#2-2-核心策略：快慢双指针-Fast-Slow-Pointers" class="headerlink" title="2.2 核心策略：快慢双指针 (Fast &amp; Slow Pointers)"></a>2.2 核心策略：快慢双指针 (Fast &amp; Slow Pointers)</h4><p>想象你在整理书架：</p>
<ul>
<li>书架上混杂着书（非0元素）和空盒子（0）。</li>
<li>你想把所有的书都紧凑地排在最左边，空盒子丢到右边。</li>
</ul>
<p>我们需要两个“指针”（也就是两个变量来记录下标）：</p>
<ol>
<li><strong>快指针 (<code>fast</code> &#x2F; <code>cur</code>)</strong>：它是<strong>探路者</strong>。负责遍历整个数组，寻找“非 0 元素”。</li>
<li><strong>慢指针 (<code>slow</code> &#x2F; <code>dest</code>)</strong>：它是<strong>管理员</strong>。它始终指向<strong>当前已处理好的非 0 序列的下一个空位</strong>。</li>
</ol>
<p><strong>算法逻辑</strong>：</p>
<ul>
<li><code>fast</code> 指针一直往后走。</li>
<li>如果 <code>nums[fast]</code> 是 <code>0</code>：<code>fast</code> 继续走（因为我们不关心 0，只要它不在前面就行）。</li>
<li>如果 <code>nums[fast]</code> <strong>不是</strong> <code>0</code>：<ul>
<li>这就意味着找到了一个需要保留的元素。</li>
<li>我们要把它放到 <code>slow</code> 指向的位置。</li>
<li><strong>怎么放？</strong> 最优雅的方式是 <strong>交换 (Swap)</strong> <code>nums[slow]</code> 和 <code>nums[fast]</code>。</li>
<li>交换后，<code>slow</code> 向前移动一步（准备接纳下一个非 0 元素）。</li>
</ul>
</li>
</ul>
<p><strong>图解推导</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 0, 3, 12]</span><br></pre></td></tr></table></figure>

<ol>
<li><code>fast</code> 遇到 0，跳过。</li>
<li><code>fast</code> 遇到 1 (非0)：与 <code>slow</code> (下标0) 交换。$\rightarrow$ <code>[1, 0, 0, 3, 12]</code>, <code>slow</code> 变 1。</li>
<li><code>fast</code> 遇到 0，跳过。</li>
<li><code>fast</code> 遇到 3 (非0)：与 <code>slow</code> (下标1) 交换。$\rightarrow$ <code>[1, 3, 0, 0, 12]</code>, <code>slow</code> 变 2。</li>
<li><code>fast</code> 遇到 12 (非0)：与 <code>slow</code> (下标2) 交换。$\rightarrow$ <code>[1, 3, 12, 0, 0]</code>, <code>slow</code> 变 3。</li>
<li>结束。</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // slow 指针：指向当前非零元素应该存放的位置</span><br><span class="line">        int slow = 0;</span><br><span class="line">        </span><br><span class="line">        // fast 指针：负责遍历数组寻找非零元素</span><br><span class="line">        for (int fast = 0; fast &lt; nums.size(); ++fast) &#123;</span><br><span class="line">            // 只有当 fast 遇到非零元素时，才进行操作</span><br><span class="line">            if (nums[fast] != 0) &#123;</span><br><span class="line">                // 将找到的非零元素交换到 slow 的位置</span><br><span class="line">                // 如果 slow == fast，说明中间没有 0，swap 相当于自己换自己（无副作用）</span><br><span class="line">                swap(nums[slow], nums[fast]);</span><br><span class="line">                </span><br><span class="line">                // 处理完一个非零元素，slow 向前移动，准备接收下一个</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果 nums[fast] 是 0，fast 自动 ++，slow 不动</span><br><span class="line">            // 这样 slow 就会停留在第一个 0 的位置（或者已排好序的末尾）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们只有一个 <code>for</code> 循环，<code>fast</code> 指针从头走到尾。</li>
<li>每个元素最多被访问和交换一次。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们只使用了 <code>slow</code> 和 <code>fast</code> 两个整型变量，没有申请额外的数组空间。这就是<strong>原地 (In-place)</strong> 算法。</li>
</ul>
<hr>
<h3 id="5-深度思考：为什么要用-swap？"><a href="#5-深度思考：为什么要用-swap？" class="headerlink" title="5. 深度思考：为什么要用 swap？"></a>5. 深度思考：为什么要用 <code>swap</code>？</h3><p>其实还有一种写法：</p>
<ol>
<li>先把所有非 0 元素按顺序覆盖到数组前面。</li>
<li>把剩下的位置全部赋值为 0。</li>
</ol>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 另一种写法（覆盖法）</span><br><span class="line">int slow = 0;</span><br><span class="line">for (int fast = 0; fast &lt; nums.size(); ++fast) &#123;</span><br><span class="line">    if (nums[fast] != 0) &#123;</span><br><span class="line">        nums[slow++] = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 剩下的位置补 0</span><br><span class="line">for (int i = slow; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">    nums[i] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比：</strong></p>
<ul>
<li><strong>覆盖法</strong>：写入操作可能更多（最后要补一堆 0）。</li>
<li><strong>Swap 法</strong>（我们采用的方法）：逻辑更统一，一次遍历搞定。而且，<code>swap</code> 操作在快速排序（Quick Sort）的 <code>partition</code> 过程中是核心思想，<strong>学会 Swap 写法有助于理解更复杂的排序算法</strong>。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>41. 缺失的第一个正数</title>
    <url>/2025/11/13/Hot100/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></p>
<p>题目：<br>给你一个未排序的整数数组 <code>nums</code>，请你找出其中最小的缺失正整数。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [1,2,0]<br>输出：3<br>解释：正整数 1 和 2 存在，但 3 缺失。</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [3,4,-1,1]<br>输出：2<br>解释：正整数 1 存在，2 缺失。</p>
<p><strong>示例 3：</strong><br>输入：nums &#x3D; [7,8,9,11,12]<br>输出：1<br>解释：没有出现 1，因此最小缺失正整数是 1。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10⁵</code></li>
<li><code>-5 * 10⁵ &lt;= nums[i] &lt;= 5 * 10⁵</code></li>
</ul>
<p>这道题是力扣（LeetCode）第 41 题，标记为 <strong>Hard</strong>。</p>
<p>很多同学一看到 “Hard” 就想退缩，但实际上这道题的难点不在于算法逻辑有多复杂，而在于它对<strong>空间复杂度</strong>的苛刻要求。</p>
<p>它要求我们在 $O(n)$ 时间内解决问题，同时<strong>只能使用 $O(1)$ 的额外空间</strong>。这意味着我们不能创建新的哈希表，也不能使用递归（栈空间），只能在<strong>原数组</strong>上动脑筋。</p>
<p>这道题是学习 <strong>“原地哈希 (In-place Hashing)”</strong> 技巧的最佳教具。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：缺失的第一个正数 (First Missing Positive)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个未排序的整数数组 <code>nums</code>。请你找出其中没有出现的<strong>最小的正整数</strong>。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(1)$。</li>
</ul>
<p><strong>示例</strong>：</p>
<ol>
<li>输入：<code>[1, 2, 0]</code> $\rightarrow$ 输出：<code>3</code> (1和2有了，下一个是3)</li>
<li>输入：<code>[3, 4, -1, 1]</code> $\rightarrow$ 输出：<code>2</code> (有1，缺2)</li>
<li>输入：<code>[7, 8, 9, 11, 12]</code> $\rightarrow$ 输出：<code>1</code> (最小的正整数1就不在)</li>
</ol>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-缩小搜索范围-关键洞察"><a href="#2-1-缩小搜索范围-关键洞察" class="headerlink" title="2.1 缩小搜索范围 (关键洞察)"></a>2.1 缩小搜索范围 (关键洞察)</h4><p>假设数组长度为 $N$。</p>
<p>我们需要找的“缺失的第一个正数”，它的值会在什么范围内？</p>
<ul>
<li><strong>最好的情况</strong>：数组里刚好是 <code>[1, 2, 3, ..., N]</code>。此时缺失的是 <strong>$N+1$</strong>。</li>
<li><strong>其他情况</strong>：数组里有一些负数、或者很大的数（比如 100）、或者重复的数。这些都会占据位置，导致 <code>[1, N]</code> 之间的某个整数无法出现。</li>
<li><strong>结论</strong>：答案一定在 <strong>$[1, N+1]$</strong> 之间！</li>
</ul>
<p>这意味着，我们只需要关注 <strong>$1$ 到 $N$</strong> 这几个数字是否存在。对于负数、0、或者大于 $N$ 的数，我们根本不用管，它们是“干扰项”。</p>
<h4 id="2-2-核心策略：萝卜坑原理-原地哈希"><a href="#2-2-核心策略：萝卜坑原理-原地哈希" class="headerlink" title="2.2 核心策略：萝卜坑原理 (原地哈希)"></a>2.2 核心策略：萝卜坑原理 (原地哈希)</h4><p>既然我们只关心 $1$ 到 $N$，我们可以把原数组当成一个<strong>哈希表</strong>来用。</p>
<p><strong>规则设计</strong>：</p>
<p>我们希望把数字 <code>x</code> 放到它应该出现的位置上。</p>
<ul>
<li>数字 <strong>1</strong> 应该放在下标 <strong>0</strong> 的位置。</li>
<li>数字 <strong>2</strong> 应该放在下标 <strong>1</strong> 的位置。</li>
<li>…</li>
<li>数字 <strong>k</strong> 应该放在下标 <strong>k-1</strong> 的位置。</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><strong>归位 (Swapping)</strong>：</p>
<p>遍历数组，当我们遇到一个数字 <code>x</code> (即 <code>nums[i]</code>) 时，如果它满足以下三个条件，我们就把它<strong>交换</strong>到它正确的位置 (<code>nums[x-1]</code>) 去：</p>
<ul>
<li>它是正数 (<code>x &gt; 0</code>)。</li>
<li>它在有效范围内 (<code>x &lt;= N</code>)。</li>
<li>它当前不在正确的位置上，且目标位置上没有放正确的数 (避免死循环，比如 <code>[1, 1]</code>)。</li>
</ul>
</li>
<li><p><strong>查岗 (Scanning)</strong>：</p>
<p>归位操作完成后，我们再遍历一遍数组。</p>
<ul>
<li>检查下标 <code>0</code>，是不是 <code>1</code>？是则通过。</li>
<li>检查下标 <code>1</code>，是不是 <code>2</code>？是则通过。</li>
<li>…</li>
<li>如果在下标 <code>i</code> 处发现 <code>nums[i] != i + 1</code>，说明 <strong>$i+1$</strong> 就是我们要找的那个缺失的数！</li>
</ul>
</li>
<li><p><strong>兜底</strong>：</p>
<p>如果所有位置都对上了（说明数组是 <code>[1, 2, ..., N]</code>），那么缺失的就是 <strong>$N+1$</strong>。</p>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line"></span><br><span class="line">        // 1. 核心步骤：原地交换，让每个数字回到它应该在的位置</span><br><span class="line">        // 目标：nums[i] 应该存放数字 i + 1</span><br><span class="line">        // 也就是说：数字 x 应该放在下标 x - 1 处</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            // 使用 while 是为了确保交换过来的新数字也能继续被处理</span><br><span class="line">            // 比如 [3, 4, -1, 1]，当 i=0 时，把 3 换走了，换来了 -1，</span><br><span class="line">            // 或者换来了 1，我们需要继续检查这个换来的 1。</span><br><span class="line">            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;</span><br><span class="line">                // nums[i] 是当前数字 x</span><br><span class="line">                // nums[i] - 1 是它应该去的下标</span><br><span class="line">                // nums[nums[i] - 1] 是目标下标位置上现在的数字</span><br><span class="line">                </span><br><span class="line">                // 只有当目标位置上的数字 不等于 当前数字时，才交换</span><br><span class="line">                // (这是为了防止 nums[i] 是 1，目标位置 nums[0] 也是 1 导致的死循环)</span><br><span class="line">                swap(nums[i], nums[nums[i] - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 再次遍历：检查哪个位置的数字不对劲</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            // 如果下标 i 的位置不是 i + 1，说明 i + 1 缺失</span><br><span class="line">            if (nums[i] != i + 1) &#123;</span><br><span class="line">                return i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 兜底情况</span><br><span class="line">        // 如果数组是 [1, 2, 3]，前面的循环都没返回</span><br><span class="line">        // 说明缺失的是下一个数 n + 1</span><br><span class="line">        return n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><p>很多同学看到 <code>for</code> 循环里套了个 <code>while</code>，第一反应是 $O(n^2)$。</p>
<p><strong>这是错误的。实际上是 $O(n)$。</strong></p>
<ul>
<li><strong>分析</strong>：每次 <code>swap</code> 操作，都会把一个数字放到它<strong>最终正确</strong>的位置上。</li>
<li>一旦一个数字归位了（比如 <code>3</code> 到了下标 <code>2</code>），它以后就不会再被移动了。</li>
<li>对于长度为 $n$ 的数组，最多只有 $n$ 个位置，所以最多只能发生 $n$ 次有效的交换。</li>
<li>均摊下来，时间复杂度是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们直接在输入数组 <code>nums</code> 上进行交换修改，只使用了常数个额外变量。</li>
<li>这也就是所谓的“原地算法”。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要用 <code>while</code> 而不是 <code>if</code>？</strong><ul>
<li><strong>A:</strong> 这是一个极好的细节。</li>
<li>举例：<code>nums = [3, 1, ...]</code>，<code>i=0</code>。</li>
<li>如果是 <code>if</code>：遇到 <code>3</code>，把它换到下标 2。此时下标 0 换回来了一个 <code>1</code>。如果不继续处理，指针 <code>i</code> 就往后走了，这个 <code>1</code> 就被留在了下标 0（虽然它恰好在正确位置，但如果是其他数就会错）。</li>
<li>如果是 <code>while</code>：遇到 <code>3</code>，换走。换回来 <code>1</code>。<code>while</code> 继续检查这个 <code>1</code>，发现它应该去下标 0，正好在，循环结束。或者换回来一个 <code>5</code>，继续把 <code>5</code> 换到下标 4… 直到换回来一个没法处理的数（负数或已归位的数）。</li>
</ul>
</li>
<li><strong>Q: <code>nums[nums[i] - 1] != nums[i]</code> 这个条件是干嘛的？</strong><ul>
<li><strong>A:</strong> 防止<strong>死循环</strong>和处理<strong>重复元素</strong>。</li>
<li>假设数组是 <code>[1, 1]</code>。</li>
<li>当处理第二个 <code>1</code> 时，它想去下标 0。但下标 0 已经有个 <code>1</code> 了。</li>
<li>如果没有这个判断，程序会无限交换这两个 <code>1</code>，导致超时 (TLE)。这个条件保证了“如果目标位置已经是正确的数了，我就不折腾了”。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>原地哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2025/11/13/Hot100/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<p>题目：<br>给你一棵二叉树的根节点 <code>root</code>，翻转这棵二叉树，并返回翻转后的树的根节点。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [2,1,3]<br>输出：[2,3,1]</p>
<p><strong>示例 3：</strong><br>输入：root &#x3D; []<br>输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[0, 100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这道题是力扣（LeetCode）第 226 题。</p>
<p>这道题在算法圈有一个非常著名的“梗”。Homebrew（Mac 上著名的软件包管理工具）的作者 Max Howell 曾经在推特上吐槽：</p>
<blockquote>
<p>“Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.”</p>
<p>（Google：我们 90% 的工程师都在用你写的软件，但你因为在白板上写不出反转二叉树，所以滚蛋吧。）</p>
</blockquote>
<p>虽然这是一个悲伤的故事，但也侧面说明了这道题是多么的基础和重要。它的本质其实就是 <strong>“镜像翻转”</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：翻转二叉树 (Invert Binary Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一棵二叉树的根节点 <code>root</code> ，请你翻转这棵二叉树，并返回其根节点。</p>
<p><strong>所谓的“翻转”</strong>：</p>
<p>就是把每一个节点的 <strong>左孩子</strong> 和 <strong>右孩子</strong> 进行交换。</p>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-直观理解"><a href="#2-1-直观理解" class="headerlink" title="2.1 直观理解"></a>2.1 直观理解</h4><p>你可以想象整棵树是一串挂在风铃上的挂件。</p>
<p>你抓住根节点，把每一个挂钩下面的左右两个分支，物理上交换一下位置。</p>
<p><strong>注意</strong>：不仅是根节点的左右孩子要换，<strong>孩子们的孩子</strong>也要换，直到叶子节点。</p>
<h4 id="2-2-核心策略：遍历-交换"><a href="#2-2-核心策略：遍历-交换" class="headerlink" title="2.2 核心策略：遍历 + 交换"></a>2.2 核心策略：遍历 + 交换</h4><p>只要我们能遍历这棵树的每一个节点，并对每一个节点执行 <code>swap(node-&gt;left, node-&gt;right)</code>，任务就完成了。</p>
<p>我们有两种遍历策略：</p>
<ol>
<li><strong>递归 (DFS)</strong>：<ul>
<li><strong>前序遍历</strong>（推荐）：先交换左右孩子，然后递归翻转左子树，再递归翻转右子树。</li>
<li><strong>后序遍历</strong>：先递归翻转左右子树，最后回到根节点交换左右孩子。</li>
<li><em>注：中序遍历比较麻烦，因为交换后左右孩子变了，容易重复处理或漏处理，不推荐。</em></li>
</ul>
</li>
<li><strong>迭代 (BFS&#x2F;层序)</strong>：<ul>
<li>利用队列，一层一层地处理。</li>
<li>拿出一个节点，交换它的左右孩子，然后把孩子扔进队列。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-递归法-Pre-order"><a href="#3-C-代码实现-递归法-Pre-order" class="headerlink" title="3. C++ 代码实现 (递归法 - Pre-order)"></a>3. C++ 代码实现 (递归法 - Pre-order)</h3><p>这是最简洁、最优雅的写法，也是面试首选。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        // 1. 终止条件：空节点不需要翻转</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 核心操作：交换当前节点的左右孩子</span><br><span class="line">        // 使用 C++ 标准库的 swap 函数，或者自己用临时变量 temp 换</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line"></span><br><span class="line">        // 3. 递归处理子树</span><br><span class="line">        // 此时 root-&gt;left 已经是原来的右孩子了，但没关系，</span><br><span class="line">        // 我们只需要保证“那个位置”的子树内部也被翻转即可。</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        // 4. 返回根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-C-代码实现-迭代法-BFS"><a href="#4-C-代码实现-迭代法-BFS" class="headerlink" title="4. C++ 代码实现 (迭代法 - BFS)"></a>4. C++ 代码实现 (迭代法 - BFS)</h3><p>如果你想展示你对队列的熟练度，可以用这种写法。它和“层序遍历”几乎一模一样。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            TreeNode* curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            // 核心操作：交换当前节点的左右孩子</span><br><span class="line">            swap(curr-&gt;left, curr-&gt;right);</span><br><span class="line"></span><br><span class="line">            // 将孩子加入队列（顺序无所谓，因为都要处理）</span><br><span class="line">            if (curr-&gt;left) q.push(curr-&gt;left);</span><br><span class="line">            if (curr-&gt;right) q.push(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>无论是递归还是迭代，我们都必须访问每一个节点一次，并进行一次交换操作。</li>
</ul>
<h4 id="空间复杂度：-O-N"><a href="#空间复杂度：-O-N" class="headerlink" title="空间复杂度：$O(N)$"></a><strong>空间复杂度：$O(N)$</strong></h4><ul>
<li><strong>递归</strong>：取决于树的高度，最坏情况（链状）为 $O(N)$，平均 $O(\log N)$。</li>
<li><strong>迭代</strong>：取决于树的宽度（队列大小），最坏情况（满二叉树）约为 $N&#x2F;2$，即 $O(N)$。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么中序遍历容易写错？</strong><ul>
<li><strong>A:</strong> 这是一个经典坑。</li>
<li>假设你写：<code>invert(left)</code> -&gt; <code>swap</code> -&gt; <code>invert(right)</code>。</li>
<li>执行完 <code>invert(left)</code> 后，左子树翻转好了。</li>
<li>执行 <code>swap</code>：现在的左变成了右，现在的右变成了左。</li>
<li>执行 <code>invert(right)</code>：注意！这时候的 <code>right</code> 指针指向的其实是<strong>原来的左子树</strong>（因为它刚才被换过来了）。</li>
<li><strong>结果</strong>：原来的左子树被翻转了两次（还原了），原来的右子树一次没动。</li>
</ul>
</li>
<li><strong>Q: 这道题是修改原树，还是返回新树？</strong><ul>
<li><strong>A:</strong> 题目要求返回 <code>root</code>，且没有说不能修改原树，所以默认是<strong>原地修改 (In-place)</strong>。如果要返回新树，就需要 <code>new TreeNode</code> 进行深拷贝，那是另一道题了。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="下一步建议"><a href="#下一步建议" class="headerlink" title="下一步建议"></a>下一步建议</h3><p>你已经掌握了：</p>
<ol>
<li><strong>二叉树的基本属性</strong>（最大深度）。</li>
<li><strong>二叉树的结构对比</strong>（对称二叉树）。</li>
<li><strong>二叉树的结构修改</strong>（翻转二叉树）。</li>
</ol>
<p>接下来，我们该挑战一个稍微复杂一点的“属性计算”问题了。这道题不是求深度，而是求宽度（直径），而且它有一个陷阱：<strong>最长路径不一定经过根节点</strong>。</p>
<p><strong>Would you like me to…</strong></p>
<p>为你讲解 <strong>“二叉树的直径 (Diameter of Binary Tree)”</strong>？</p>
<p>这道题能很好地训练你在递归过程中使用<strong>全局变量</strong>来记录最大值的技巧。</p>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>994. 腐烂的橘子</title>
    <url>/2025/11/13/Hot100/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></p>
<p>题目：<br>你在一个 <code>m x n</code> 的网格中，每个格子代表一个橘子，状态可以是：</p>
<ul>
<li><code>0</code> 表示空</li>
<li><code>1</code> 表示新鲜橘子</li>
<li><code>2</code> 表示腐烂橘子</li>
</ul>
<p>每分钟，任何与腐烂橘子相邻（上下左右）的新鲜橘子都会被感染并变腐烂。</p>
<p>返回直到所有橘子都腐烂所需的最小分钟数。如果不可能让所有橘子都腐烂，则返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong><br>输入：grid &#x3D; [[2,1,1],[1,1,0],[0,1,1]]<br>输出：4</p>
<p><strong>示例 2：</strong><br>输入：grid &#x3D; [[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子无法被感染。</p>
<p><strong>示例 3：</strong><br>输入：grid &#x3D; [[0,2]]<br>输出：0<br>解释：没有新鲜橘子。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[i].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code>, <code>1</code>, 或 <code>2</code></li>
</ul>
<p>这道题是 <strong>广度优先搜索 (BFS)</strong> 在网格图（Grid Graph）中的 <strong>教科书级应用</strong>。</p>
<p>它是力扣（LeetCode）第 994 题。</p>
<p>如果说“岛屿数量”教你如何遍历（DFS&#x2F;BFS皆可），那么“腐烂的橘子”则强制要求你使用 <strong>BFS</strong>，并且是 <strong>“多源 BFS” (Multi-source BFS)</strong>。</p>
<p>为什么？因为腐烂的过程是 <strong>“传染”</strong>。</p>
<p>所有烂橘子是 <strong>同时</strong> 向四周扩散的，而不是一个传完再传下一个。这就像病毒爆发，我们要算的是“第几分钟”全军覆没，这本质上是在求 <strong>最短路径&#x2F;最小层数</strong>。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：腐烂的橘子 (Rotting Oranges)</p>
<p><strong>题目大意</strong>：</p>
<p>在给定的 <code>m x n</code> 网格中，每个单元格有三种状态：</p>
<ul>
<li><code>0</code>：空单元格。</li>
<li><code>1</code>：新鲜橘子。</li>
<li><code>2</code>：腐烂的橘子。</li>
</ul>
<p><strong>规则</strong>：</p>
<p>每一分钟，腐烂的橘子会使其 <strong>上下左右</strong> 4 个方向上相邻的新鲜橘子变成腐烂的。</p>
<p>请你计算直到单元格中 <strong>没有新鲜橘子</strong> 为止所必须经过的最小分钟数。</p>
<p>如果不可能让所有新鲜橘子都腐烂，请返回 <code>-1</code>。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>第 0 分钟：左上角有一个烂橘子。</li>
<li>第 1 分钟：烂橘子的邻居（右边和下边）烂了。</li>
<li>第 2 分钟：新烂的橘子的邻居烂了。</li>
<li>…</li>
<li>第 4 分钟：全部烂完。返回 <code>4</code>。</li>
</ul>
<hr>
<h3 id="2-核心思路：为什么必须是-BFS？"><a href="#2-核心思路：为什么必须是-BFS？" class="headerlink" title="2. 核心思路：为什么必须是 BFS？"></a>2. 核心思路：为什么必须是 BFS？</h3><h4 id="2-1-为什么-DFS-不行？"><a href="#2-1-为什么-DFS-不行？" class="headerlink" title="2.1 为什么 DFS 不行？"></a>2.1 为什么 DFS 不行？</h4><p><strong>DFS (深度优先)</strong> 是“一条道走到黑”。</p>
<p>假设左上角有一个烂橘子，DFS 会先把一条路上的橘子全部烂完，算出比如需要 10 分钟。</p>
<p>但实际上，可能右下角也有一个烂橘子，它烂到中间只需要 2 分钟。</p>
<p>DFS 无法模拟 <strong>“齐头并进”</strong> 的物理过程。</p>
<h4 id="2-2-多源-BFS-Multi-source-BFS"><a href="#2-2-多源-BFS-Multi-source-BFS" class="headerlink" title="2.2 多源 BFS (Multi-source BFS)"></a>2.2 多源 BFS (Multi-source BFS)</h4><p>通常的 BFS 是从一个起点开始扩散。</p>
<p>这道题可能有 <strong>多个</strong> 烂橘子（多个起点）。</p>
<p>做法很简单：</p>
<ol>
<li><strong>初始化</strong>：把 <strong>所有</strong> 初始状态为 <code>2</code> 的烂橘子，全部加入队列。</li>
<li><strong>开始扩散</strong>：它们在队列里就像在同一个起跑线上，第一轮循环会处理所有这些起点的邻居。</li>
</ol>
<hr>
<h3 id="3-算法流程-层序遍历"><a href="#3-算法流程-层序遍历" class="headerlink" title="3. 算法流程 (层序遍历)"></a>3. 算法流程 (层序遍历)</h3><p>我们需要两个关键变量：</p>
<ol>
<li><strong><code>queue</code></strong>：存放当前这一轮所有烂橘子的坐标。</li>
<li><strong><code>freshCount</code></strong>：记录还剩多少新鲜橘子。<ul>
<li><em>作用：用来判断最后是否成功烂完，以及控制循环（如果没有新鲜橘子了，就没必要继续扩散了）。</em></li>
</ul>
</li>
</ol>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>扫描全图</strong>：<ul>
<li>遇到 <code>2</code>：入队。</li>
<li>遇到 <code>1</code>：<code>freshCount++</code>。</li>
</ul>
</li>
<li><strong>BFS 循环</strong>：<ul>
<li>只要 <code>queue</code> 不空 <strong>且 <code>freshCount &gt; 0</code></strong>：</li>
<li><code>time++</code>（时间过了一分钟）。</li>
<li><strong>批处理</strong>：记录当前队列大小 <code>size</code>（这一分钟内有多少个传染源）。</li>
<li>取出这 <code>size</code> 个烂橘子，分别去感染上下左右：<ul>
<li>如果是 <code>1</code>：把它变成 <code>2</code>，<code>freshCount--</code>，<strong>入队</strong>（成为下一分钟的传染源）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>结果判定</strong>：<ul>
<li>如果 <code>freshCount == 0</code>：返回 <code>time</code>。</li>
<li>如果 <code>freshCount &gt; 0</code>：说明有些橘子被墙隔开了，永远烂不到，返回 <code>-1</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-C-代码实现"><a href="#4-C-代码实现" class="headerlink" title="4. C++ 代码实现"></a>4. C++ 代码实现</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size();</span><br><span class="line">        </span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        int freshCount = 0;</span><br><span class="line"></span><br><span class="line">        // 1. 初始化：找出所有烂橘子进队，统计新鲜橘子数量</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 2) &#123;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125; else if (grid[i][j] == 1) &#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果一开始就没有新鲜橘子，直接返回 0</span><br><span class="line">        if (freshCount == 0) return 0;</span><br><span class="line"></span><br><span class="line">        int minutes = 0;</span><br><span class="line">        int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; // 上下左右</span><br><span class="line"></span><br><span class="line">        // 2. BFS 开始传染</span><br><span class="line">        // 只有当还有新鲜橘子时，我们才继续循环</span><br><span class="line">        while (!q.empty() &amp;&amp; freshCount &gt; 0) &#123;</span><br><span class="line">            minutes++; // 每一层循环代表一分钟</span><br><span class="line">            int size = q.size(); // 当前层的烂橘子数量</span><br><span class="line"></span><br><span class="line">            // 处理这一层的每一个烂橘子</span><br><span class="line">            for (int k = 0; k &lt; size; ++k) &#123;</span><br><span class="line">                auto [r, c] = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                // 检查四周</span><br><span class="line">                for (auto d : dirs) &#123;</span><br><span class="line">                    int nr = r + d[0];</span><br><span class="line">                    int nc = c + d[1];</span><br><span class="line"></span><br><span class="line">                    // 越界或者不是新鲜橘子，跳过</span><br><span class="line">                    if (nr &lt; 0 || nc &lt; 0 || nr &gt;= m || nc &gt;= n || grid[nr][nc] != 1) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 传染：</span><br><span class="line">                    grid[nr][nc] = 2; // 标记为烂，避免重复访问</span><br><span class="line">                    q.push(&#123;nr, nc&#125;); // 加入下一轮传染源</span><br><span class="line">                    freshCount--;     // 新鲜橘子少了一个</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 检查是否还有幸存者</span><br><span class="line">        return freshCount == 0 ? minutes : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-M-times-N"><a href="#时间复杂度：-O-M-times-N" class="headerlink" title="时间复杂度：$O(M \times N)$"></a><strong>时间复杂度：$O(M \times N)$</strong></h4><ul>
<li>网格中的每个格子最多被访问一次（入队一次，出队一次）。</li>
<li>即使我们有两层循环（初始化 + BFS），总体操作次数是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-M-times-N"><a href="#空间复杂度：-O-M-times-N" class="headerlink" title="空间复杂度：$O(M \times N)$"></a><strong>空间复杂度：$O(M \times N)$</strong></h4><ul>
<li>队列的大小。在最坏情况下（比如整个网格全是烂橘子），队列需要存储所有格子的坐标。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么循环条件里要加 <code>freshCount &gt; 0</code>？</strong><ul>
<li><strong>A:</strong> 这是一个防止“多算一分钟”的技巧。</li>
<li>假设最后一轮，烂橘子把所有剩下的新鲜橘子都感染了。此时 <code>freshCount</code> 变为 0。</li>
<li>如果不加这个判断，新感染的橘子已经进队了，循环会再跑一轮（队列不空）。虽然这新一轮不会感染任何东西，但 <code>minutes</code> 会再加 1，导致结果偏大。</li>
<li>加上 <code>freshCount &gt; 0</code>，一旦全感染完，立刻停止计时。</li>
</ul>
</li>
<li><strong>Q: 需要用 <code>visited</code> 数组吗？</strong><ul>
<li><strong>A:</strong> <strong>不需要。</strong></li>
<li>我们可以直接修改原数组 <code>grid</code>。</li>
<li>把 <code>1</code> 改成 <code>2</code>，就天然起到了“标记已访问”的作用。再遇到 <code>2</code> 或者 <code>0</code> 我们都跳过，只找 <code>1</code>。</li>
</ul>
</li>
<li><strong>Q: 只有 <code>0</code> 和 <code>2</code>，没有 <code>1</code> 的情况会怎样？</strong><ul>
<li><strong>A:</strong><ul>
<li>初始化时 <code>freshCount</code> 为 0。</li>
<li>代码一开始的 <code>if (freshCount == 0) return 0;</code> 会直接拦截，返回正确答案 <code>0</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>54. 螺旋矩阵</title>
    <url>/2025/11/13/Hot100/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p>
<p>题目：<br>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code>，按顺时针螺旋顺序返回其所有元素。</p>
<p><strong>示例 1：</strong><br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p><strong>示例 2：</strong><br>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<p>这道题不考什么高深的算法思想（比如动态规划或递归），它考的是你的<strong>代码掌控力</strong>。</p>
<p><strong>“螺旋矩阵” (Spiral Matrix)</strong> 属于典型的 <strong>模拟题</strong>。也就是题目怎么说，你就怎么做。</p>
<p>但是，许多初学者（甚至老手）在写这道题时，往往会陷入“死循环”或者“下标越界”的泥潭，因为边界条件实在太多了。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：螺旋矩阵 (Spiral Matrix)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个 $m$ 行 $n$ 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<p>Plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出：<code>[1, 2, 3, 6, 9, 8, 7, 4, 5]</code></p>
<p>路径：</p>
<ol>
<li>向右：1, 2, 3</li>
<li>向下：6, 9</li>
<li>向左：8, 7</li>
<li>向上：4</li>
<li>向右：5 (结束)</li>
</ol>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-核心策略：设定四面“墙”"><a href="#2-1-核心策略：设定四面“墙”" class="headerlink" title="2.1 核心策略：设定四面“墙”"></a>2.1 核心策略：设定四面“墙”</h4><p>想象你是一个机器人，在这个矩阵里走迷宫。你只能顺时针走：<strong>右 $\rightarrow$ 下 $\rightarrow$ 左 $\rightarrow$ 上</strong>。</p>
<p>为了控制方向，我们需要定义四个边界（四面墙）：</p>
<ul>
<li><strong><code>top</code> (上边界)</strong>：初始为 0。</li>
<li><strong><code>bottom</code> (下边界)</strong>：初始为 $m-1$。</li>
<li><strong><code>left</code> (左边界)</strong>：初始为 0。</li>
<li><strong><code>right</code> (右边界)</strong>：初始为 $n-1$。</li>
</ul>
<h4 id="2-2-动作循环"><a href="#2-2-动作循环" class="headerlink" title="2.2 动作循环"></a>2.2 动作循环</h4><p>每走完一行或一列，对应的“墙”就要向内逼近一步：</p>
<ol>
<li><strong>向右走</strong>：遍历 <code>matrix[top][left...right]</code>。走完后，<strong>上墙下压 (<code>top++</code>)</strong>。</li>
<li><strong>向下走</strong>：遍历 <code>matrix[top...bottom][right]</code>。走完后，<strong>右墙左移 (<code>right--</code>)</strong>。</li>
<li><strong>向左走</strong>：遍历 <code>matrix[bottom][right...left]</code>。走完后，<strong>下墙上移 (<code>bottom--</code>)</strong>。</li>
<li><strong>向上走</strong>：遍历 <code>matrix[bottom...top][left]</code>。走完后，<strong>左墙右移 (<code>left++</code>)</strong>。</li>
</ol>
<h4 id="2-3-致命陷阱：边界碰撞"><a href="#2-3-致命陷阱：边界碰撞" class="headerlink" title="2.3 致命陷阱：边界碰撞"></a>2.3 致命陷阱：边界碰撞</h4><p>最容易出的 Bug 是：当你向右走完，<code>top++</code> 了，此时可能 <code>top</code> 已经超过 <code>bottom</code> 了（比如只有一行的情况）。如果你紧接着尝试向下走或向左走，就会重复访问元素甚至越界。</p>
<p><strong>解决方案</strong>：每走完一个方向并更新边界后，<strong>立刻检查</strong>是否“撞墙”。如果 <code>top &gt; bottom</code> 或 <code>left &gt; right</code>，说明遍历结束，立刻 <code>break</code> 跳出循环。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>这里推荐一种**“死循环 + 内部 Break”**的写法，这是处理螺旋矩阵最简洁、最不容易出错的模板。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (matrix.empty()) return res; // 特判空矩阵</span><br><span class="line"></span><br><span class="line">        // 定义四个边界</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom = matrix.size() - 1;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = matrix[0].size() - 1;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 1. 向右移动 (Left -&gt; Right)</span><br><span class="line">            for (int i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 走完这一行，上边界下移。如果越界，直接退出</span><br><span class="line">            if (++top &gt; bottom) break;</span><br><span class="line"></span><br><span class="line">            // 2. 向下移动 (Top -&gt; Bottom)</span><br><span class="line">            for (int i = top; i &lt;= bottom; ++i) &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 走完这一列，右边界左移。如果越界，直接退出</span><br><span class="line">            if (--right &lt; left) break;</span><br><span class="line"></span><br><span class="line">            // 3. 向左移动 (Right -&gt; Left)</span><br><span class="line">            for (int i = right; i &gt;= left; --i) &#123;</span><br><span class="line">                res.push_back(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 走完这一行，下边界上移。如果越界，直接退出</span><br><span class="line">            if (--bottom &lt; top) break;</span><br><span class="line"></span><br><span class="line">            // 4. 向上移动 (Bottom -&gt; Top)</span><br><span class="line">            for (int i = bottom; i &gt;= top; --i) &#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 走完这一列，左边界右移。如果越界，直接退出</span><br><span class="line">            if (++left &gt; right) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-m-times-n"><a href="#时间复杂度：-O-m-times-n" class="headerlink" title="时间复杂度：$O(m \times n)$"></a><strong>时间复杂度：$O(m \times n)$</strong></h4><ul>
<li>我们需要访问矩阵中的每一个元素，且每个元素只被访问一次。</li>
<li>$m$ 是行数，$n$ 是列数。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>除了用于存储结果的 <code>res</code> 数组外，我们只使用了 4 个边界变量 (<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>)。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><p><strong>Q: 为什么代码里用 <code>++top</code> 而不是 <code>top++</code>？</strong></p>
<ul>
<li><p><strong>A:</strong> 这只是为了写法紧凑。<code>if (++top &gt; bottom)</code> 等价于：</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top++; </span><br><span class="line">if (top &gt; bottom) break;</span><br></pre></td></tr></table></figure>

<p>这种写法能确保我们在更新边界的<strong>瞬间</strong>就检查是否结束，防止后续步骤出错。</p>
</li>
</ul>
</li>
<li><p><strong>Q: 如果只有一行 <code>[1, 2, 3]</code> 会发生什么？</strong></p>
<ul>
<li><strong>A:</strong><ol>
<li>执行“向右移动”循环，加入 1, 2, 3。</li>
<li><code>top</code> 变成 1。</li>
<li><code>top (1) &gt; bottom (0)</code>，条件满足，<code>break</code>。</li>
<li>直接返回结果。代码完美兼容。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>207. 课程表</title>
    <url>/2025/11/13/Hot100/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></p>
<p>题目：<br>你总共需要修 <code>numCourses</code> 门课，课程编号从 <code>0</code> 到 <code>numCourses - 1</code>。</p>
<p>给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> 表示你要学习课程 <code>ai</code>，必须先完成课程 <code>bi</code>。</p>
<p>判断是否可能完成所有课程的学习。</p>
<p><strong>示例 1：</strong><br>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]<br>输出：true<br>解释：总共有 2 门课程，学习课程 1 之前必须完成课程 0。所以可以完成所有课程。</p>
<p><strong>示例 2：</strong><br>输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出：false<br>解释：总共有 2 门课程，学习课程 1 之前必须完成课程 0，而学习课程 0 之前又必须完成课程 1。因此无法完成所有课程。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>ai != bi</code></li>
</ul>
<p>这道题是 <strong>图论 (Graph Theory)</strong> 中 <strong>“拓扑排序 (Topological Sort)”</strong> 的入门必修课。</p>
<p>它是力扣（LeetCode）第 207 题。</p>
<p>这道题不再是像“岛屿数量”那样在网格里乱跑，而是解决现实生活中最常见的 <strong>“依赖关系” (Dependency)</strong> 问题。</p>
<p>比如：修高数 II 之前必须修高数 I；安装 React 之前必须安装 Node.js。</p>
<p>如果你能解决这道题，你就掌握了 <strong>“有向无环图 (DAG)”</strong> 和 <strong>“环检测 (Cycle Detection)”</strong> 的核心。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：课程表 (Course Schedule)</p>
<p><strong>题目大意</strong>：</p>
<p>你必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。</p>
<p>给你一个数组 <code>prerequisites</code>，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示想要学习课程 <code>ai</code> ，你需要先完成课程 <code>bi</code>。</p>
<ul>
<li>也就是存在一条有向边：<strong>$b_i \rightarrow a_i$</strong>。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？</p>
<p><strong>示例</strong>：</p>
<p>输入：<code>numCourses = 2</code>, <code>prerequisites = [[1,0]]</code></p>
<p>输出：<code>true</code></p>
<p>解释：想修课程 1，必须先修 0。完全没问题，先 0 后 1。</p>
<p>输入：<code>numCourses = 2</code>, <code>prerequisites = [[1,0], [0,1]]</code></p>
<p>输出：<code>false</code></p>
<p>解释：想修 1 得先修 0，想修 0 得先修 1。</p>
<p><strong>死锁了（形成了环）</strong>，谁都修不了。</p>
<hr>
<h3 id="2-核心思路：有向图找环"><a href="#2-核心思路：有向图找环" class="headerlink" title="2. 核心思路：有向图找环"></a>2. 核心思路：有向图找环</h3><p>这个问题本质上就是：<strong>判断这个有向图中是否存在“环” (Cycle)？</strong></p>
<ul>
<li>如果有环 $\rightarrow$ 没法修完（False）。</li>
<li>如果没环 $\rightarrow$ 这就是一个 DAG (Directed Acyclic Graph)，可以修完（True）。</li>
</ul>
<p>我们有两种经典的解法：<strong>BFS (Kahn 算法)</strong> 和 <strong>DFS (三色标记法)</strong>。</p>
<p>面试中 <strong>BFS (入度表法)</strong> 最容易理解，也是首选。</p>
<h4 id="解法一：BFS-入度表法-Kahn-算法"><a href="#解法一：BFS-入度表法-Kahn-算法" class="headerlink" title="解法一：BFS (入度表法 &#x2F; Kahn 算法)"></a>解法一：BFS (入度表法 &#x2F; Kahn 算法)</h4><p><strong>生活常识</strong>：</p>
<p>如果你想修一门课，前提是什么？</p>
<p><strong>前提是它的“前置课程”都已经修完了。</strong></p>
<p>换句话说，如果一门课 <strong>没有任何前置课程</strong>（或者前置都搞定了），那这门课就是 <strong>“入度为 0”</strong> 的，你可以直接去上。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><strong>建图</strong>：用邻接表 (<code>adj</code>) 存储图结构，同时维护一个 <strong>入度数组 (<code>indegree</code>)</strong>。<ul>
<li><code>indegree[i]</code> 表示课程 <code>i</code> 还有几门课没修。</li>
</ul>
</li>
<li><strong>找起点</strong>：把所有 <strong>入度为 0</strong> 的课程（不需要先修的课）扔进 <strong>队列</strong>。</li>
<li><strong>BFS 拆课</strong>：<ul>
<li>从队列里拿出一门课 <code>u</code>（这门课我修了！）。</li>
<li>计数器 <code>count++</code>。</li>
<li>找到 <code>u</code> 的所有后修课程 <code>v</code>（也就是 <code>u -&gt; v</code>）。</li>
<li>告诉 <code>v</code>：“你的前置 <code>u</code> 我搞定了，你的入度减 1”。</li>
<li><strong>关键</strong>：如果 <code>v</code> 的入度减到了 <strong>0</strong>，说明 <code>v</code> 的所有前置都修完了，把 <code>v</code> 也扔进队列。</li>
</ul>
</li>
<li><strong>判断</strong>：如果最后修完的课程数 <code>count</code> 等于总课程数 <code>numCourses</code>，说明没环，成功！</li>
</ol>
<hr>
<h3 id="3-C-代码实现-BFS-推荐"><a href="#3-C-代码实现-BFS-推荐" class="headerlink" title="3. C++ 代码实现 (BFS - 推荐)"></a>3. C++ 代码实现 (BFS - 推荐)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        // 1. 建图 + 统计入度</span><br><span class="line">        // 邻接表：adj[u] 存储依赖 u 的后续课程列表</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; adj(numCourses);</span><br><span class="line">        // 入度数组：indegree[i] 存储课程 i 需要先修几门课</span><br><span class="line">        vector&lt;int&gt; indegree(numCourses, 0);</span><br><span class="line"></span><br><span class="line">        for (auto&amp; p : prerequisites) &#123;</span><br><span class="line">            int cur = p[0];   // 要修的课</span><br><span class="line">            int pre = p[1];   // 先修课</span><br><span class="line">            adj[pre].push_back(cur); // pre -&gt; cur</span><br><span class="line">            indegree[cur]++;         // cur 的入度 +1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 将所有入度为 0 的节点入队 (作为 BFS 的起点)</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            if (indegree[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. BFS 拓扑排序</span><br><span class="line">        int count = 0; // 记录能修完的课程数</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            // 遍历 u 的所有后续课程 v</span><br><span class="line">            for (int v : adj[u]) &#123;</span><br><span class="line">                indegree[v]--; // 既然 u 修完了，v 的依赖就少了一个</span><br><span class="line">                // 如果 v 的依赖全搞定了，v 也可以修了</span><br><span class="line">                if (indegree[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 如果修完的数量 == 总数，说明没环</span><br><span class="line">        return count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-解法二：DFS-三色标记法"><a href="#4-解法二：DFS-三色标记法" class="headerlink" title="4. 解法二：DFS (三色标记法)"></a>4. 解法二：DFS (三色标记法)</h3><p>DFS 找环的逻辑稍微绕一点。我们需要给每个节点打标记，防止死循环。</p>
<p>我们定义三种状态：</p>
<ol>
<li><strong>0 (未访问)</strong>：这门课还没检查过。</li>
<li><strong>1 (正在访问)</strong>：正在检查这门课的后续依赖链。<strong>如果在 DFS 过程中又遇到了状态 1 的节点，说明遇到了自己（形成环了）！</strong></li>
<li><strong>2 (已完成)</strong>：这门课及其所有后续都检查过了，没问题，是安全的。</li>
</ol>
<p><strong>算法流程</strong>：</p>
<p>对每门课发起 DFS。</p>
<ul>
<li>如果遇到 1 $\rightarrow$ <strong>有环，返回 False</strong>。</li>
<li>如果遇到 2 $\rightarrow$ 安全，直接返回 True。</li>
<li>标记为 1，继续 DFS 后续。</li>
<li>DFS 结束，标记为 2。</li>
</ul>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; adj(numCourses);</span><br><span class="line">        for (auto&amp; p : prerequisites) &#123;</span><br><span class="line">            adj[p[1]].push_back(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // visited 数组：0=未访问, 1=正在访问, 2=已完成</span><br><span class="line">        vector&lt;int&gt; visited(numCourses, 0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            // 如果这门课还没查过，且查出有环，直接返回 false</span><br><span class="line">            if (visited[i] == 0 &amp;&amp; !dfs(adj, visited, i)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回 true 表示没环（安全），返回 false 表示有环</span><br><span class="line">    bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; visited, int u) &#123;</span><br><span class="line">        // 1. 正在访问中又遇到了 u -&gt; 说明转了一圈回来了 -&gt; 有环</span><br><span class="line">        if (visited[u] == 1) return false;</span><br><span class="line">        // 2. 已经验证过没问题的 -&gt; 直接返回 true</span><br><span class="line">        if (visited[u] == 2) return true;</span><br><span class="line"></span><br><span class="line">        // 3. 标记为“正在访问”</span><br><span class="line">        visited[u] = 1;</span><br><span class="line"></span><br><span class="line">        // 4. 递归检查后续课程</span><br><span class="line">        for (int v : adj[u]) &#123;</span><br><span class="line">            if (!dfs(adj, visited, v)) &#123;</span><br><span class="line">                return false; // 只要后面有环，我也算有环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5. 检查完毕，标记为“已完成”</span><br><span class="line">        visited[u] = 2;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-V-E"><a href="#时间复杂度：-O-V-E" class="headerlink" title="时间复杂度：$O(V + E)$"></a><strong>时间复杂度：$O(V + E)$</strong></h4><ul>
<li>$V$ 是课程数，$E$ 是先修关系数。</li>
<li><strong>BFS</strong>: 我们初始化图遍历了所有的边 ($E$)，然后每个节点入队出队一次 ($V$)。</li>
<li><strong>DFS</strong>: 每个节点最多被访问一次（状态变了就不进去了）。</li>
</ul>
<h4 id="空间复杂度：-O-V-E"><a href="#空间复杂度：-O-V-E" class="headerlink" title="空间复杂度：$O(V + E)$"></a><strong>空间复杂度：$O(V + E)$</strong></h4><ul>
<li>邻接表需要存储所有的点和边。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 BFS 这种方法叫“拓扑排序”？</strong><ul>
<li><strong>A:</strong> 因为它不仅能判断是否有环，还能顺便生成一个 <strong>线性序列</strong>。</li>
<li>如果你把出队的 <code>u</code> 按顺序存进一个数组，那个数组就是修课的顺序（例如：先修 Math 101，再修 Math 102）。</li>
<li>这就是力扣 210 题 <strong>“课程表 II”</strong> 的解法（只需改一行代码，把 <code>count++</code> 换成 <code>res.push_back(u)</code>）。</li>
</ul>
</li>
<li><strong>Q: 为什么 DFS 需要 3 种状态？用布尔值 <code>visited</code> 不行吗？</strong><ul>
<li><strong>A:</strong> 不行。</li>
<li>普通的 <code>visited</code> 只能表示“去过”。</li>
<li>但我们需要区分 <strong>“这趟递归还没结束（正在栈里）”</strong> 和 <strong>“以前那趟递归已经查完了”</strong>。</li>
<li>如果遇到“以前查完了”的节点（状态 2），那是<strong>交叉路径</strong>（菱形结构），是合法的。</li>
<li>只有遇到“正在栈里”的节点（状态 1），才是<strong>回边</strong>，才意味着有环。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>437. 路径总和 III</title>
    <url>/2025/11/13/Hot100/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></p>
<p>题目：<br>给定一个二叉树的根节点 <code>root</code> 和一个整数目标值 <code>targetSum</code>，找出所有从根节点到叶子节点路径上节点值之和等于 <code>targetSum</code> 的路径总数。</p>
<p><strong>注意</strong>：路径不需要从根节点开始，也不需要在叶子节点结束。但路径必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8<br>输出：3<br>解释：有三条路径满足条件：<br>5 -&gt; 3<br>5 -&gt; 2 -&gt; 1<br>-3 -&gt; 11</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[0, 1000]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p>这道题是 <strong>二叉树 (Binary Tree)</strong> 题目中难度系数较高的 <strong>Medium</strong> 题。</p>
<p>它是力扣（LeetCode）第 437 题。</p>
<p>之所以说它难，是因为它融合了 <strong>“树的遍历”</strong> 和 <strong>“前缀和 (Prefix Sum)”</strong> 两个概念。如果你只用暴力的递归解法（双重递归），时间复杂度是 $O(N^2)$，面试官通常不会满意。</p>
<p>我们要讲的是 <strong>$O(N)$</strong> 的最优解法，这需要你把“数组里的前缀和”思想迁移到“树”上。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：路径总和 III (Path Sum III)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径的数目</strong>。</p>
<p><strong>关键约束</strong>：</p>
<ol>
<li><strong>路径方向</strong>：必须是 <strong>向下</strong> 的（只能从父节点到子节点）。</li>
<li><strong>起止点</strong>：<strong>不一定</strong> 要从根节点开始，也 <strong>不一定</strong> 要在叶子节点结束。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root = [10, 5, -3, 3, 2, null, 11, 3, -2, null, 1]`, `targetSum = 8</span><br></pre></td></tr></table></figure>

<p>输出：<code>3</code></p>
<p>解释：和为 8 的路径有：</p>
<ol>
<li><code>5 -&gt; 3</code></li>
<li><code>5 -&gt; 2 -&gt; 1</code></li>
<li><code>-3 -&gt; 11</code></li>
</ol>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-为什么暴力法慢？"><a href="#2-1-为什么暴力法慢？" class="headerlink" title="2.1 为什么暴力法慢？"></a>2.1 为什么暴力法慢？</h4><p>暴力法的思路是：</p>
<ol>
<li><p>遍历每个节点（比如 A）。</p>
</li>
<li><p>以 A 为起点，向下 DFS，看有多少路径等于 <code>targetSum</code>。</p>
<p>这意味着树越深，重复计算越多。就像你在数组里找子数组和，如果你对每个起点都重新累加一遍，那就是 $O(N^2)$。</p>
</li>
</ol>
<h4 id="2-2-核心策略：前缀和-Prefix-Sum-哈希表"><a href="#2-2-核心策略：前缀和-Prefix-Sum-哈希表" class="headerlink" title="2.2 核心策略：前缀和 (Prefix Sum) + 哈希表"></a>2.2 核心策略：前缀和 (Prefix Sum) + 哈希表</h4><p>这就好比是在做一个 <strong>“两数之和”</strong> 的变种。</p>
<p><strong>定义</strong>：</p>
<ul>
<li><p><strong>当前路径和 (<code>currSum</code>)</strong>：从 <strong>根节点</strong> 到 <strong>当前节点</strong> 的所有节点值之和。</p>
</li>
<li><p>我们想要找一条中间的路径（比如 <code>Node A -&gt; ... -&gt; Node B</code>），它的和是 <code>targetSum</code>。</p>
</li>
<li><p>根据数学关系：</p>
<p>$$\text{中间路径和} &#x3D; \text{B 的前缀和} - \text{A 的前缀和}$$</p>
<p>即：</p>
<p>$$\text{targetSum} &#x3D; \text{currSum} - \text{oldSum}$$</p>
</li>
<li><p>移项得：</p>
<p>$$\text{oldSum} &#x3D; \text{currSum} - \text{targetSum}$$</p>
</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>我们维护一个全局的 <strong>哈希表 (<code>prefixMap</code>)</strong>，记录：<code>&#123; 前缀和 : 出现的次数 &#125;</code>。</li>
<li>当我们遍历到一个节点时，算出从根到它的 <code>currSum</code>。</li>
<li><strong>查表</strong>：看看哈希表里有没有 <code>currSum - targetSum</code> 这个值？<ul>
<li>如果有，说明如果不算上面那一段，剩下的这段路径和刚好是 <code>targetSum</code>。</li>
<li>答案加上 <code>prefixMap[currSum - targetSum]</code> 的次数。</li>
</ul>
</li>
<li><strong>更新表</strong>：把当前的 <code>currSum</code> 存入哈希表（次数 +1），继续递归子节点。</li>
<li><strong>回溯 (Backtracking)</strong>：这是最关键的一步！<ul>
<li>当离开当前节点（递归返回）时，要把当前的 <code>currSum</code> 从哈希表里 <strong>减掉</strong>。</li>
<li><strong>为什么？</strong> 因为二叉树有分叉。左子树里的前缀和，不能被右子树用到（它们不在同一条路径上）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-最优解"><a href="#3-C-代码实现-最优解" class="headerlink" title="3. C++ 代码实现 (最优解)"></a>3. C++ 代码实现 (最优解)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // key: 前缀和</span><br><span class="line">    // value: 该前缀和出现的次数</span><br><span class="line">    unordered_map&lt;long long, int&gt; prefixMap;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        // 初始化：前缀和为 0 的情况出现 1 次</span><br><span class="line">        // 这是为了处理“从根节点直接开始”的路径</span><br><span class="line">        // 比如路径和本身就是 targetSum，那么 currSum - targetSum = 0</span><br><span class="line">        prefixMap[0] = 1;</span><br><span class="line">        </span><br><span class="line">        // 开启 DFS</span><br><span class="line">        dfs(root, 0, targetSum);</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // currSum 使用 long long 防止溢出</span><br><span class="line">    void dfs(TreeNode* node, long long currSum, int target) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 更新当前路径的前缀和</span><br><span class="line">        currSum += node-&gt;val;</span><br><span class="line"></span><br><span class="line">        // 2. 核心判断：看看我们要找的“前一段”是否存在</span><br><span class="line">        // 如果存在，说明中间有一段路径和等于 target</span><br><span class="line">        if (prefixMap.count(currSum - target)) &#123;</span><br><span class="line">            count += prefixMap[currSum - target];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 将当前前缀和加入哈希表</span><br><span class="line">        prefixMap[currSum]++;</span><br><span class="line"></span><br><span class="line">        // 4. 递归处理左右子树</span><br><span class="line">        dfs(node-&gt;left, currSum, target);</span><br><span class="line">        dfs(node-&gt;right, currSum, target);</span><br><span class="line"></span><br><span class="line">        // 5. 【关键回溯】</span><br><span class="line">        // 离开当前节点前，必须把当前的前缀和从 map 中移除（次数 -1）</span><br><span class="line">        // 因为我们马上要退回父节点去遍历另一边的子树了，</span><br><span class="line">        // 另一边的子树不应该看到当前这边的前缀和。</span><br><span class="line">        prefixMap[currSum]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们只遍历了一次树（DFS）。</li>
<li>哈希表的查找和插入操作平均是 $O(1)$。</li>
<li>所以总时间是线性的。</li>
</ul>
<h4 id="空间复杂度：-O-N"><a href="#空间复杂度：-O-N" class="headerlink" title="空间复杂度：$O(N)$"></a><strong>空间复杂度：$O(N)$</strong></h4><ul>
<li>哈希表最坏情况存储 $N$ 个节点的前缀和。</li>
<li>递归栈深度最坏也是 $N$。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么要回溯 <code>prefixMap[currSum]--</code>？</strong><ul>
<li><strong>A:</strong> 想象一下，左子树里有一条路径前缀和是 10。现在我们退回根节点，准备去遍历右子树。如果不减掉，右子树在查表时，可能会误以为自己的路径上也有一个前缀和是 10 的节点。但实际上那个节点在左边，跟右边不在一条路上（<strong>不在同一条向下的路径中</strong>）。</li>
</ul>
</li>
<li><strong>Q: 为什么要用 <code>long long</code>？</strong><ul>
<li><strong>A:</strong> 题目数据范围中，节点值可能是很大的整数，累加后可能会超过 <code>int</code> 的范围（溢出）。在 C++ 中，涉及累加和的题目，最好都用 <code>long long</code> 保平安。</li>
</ul>
</li>
<li><strong>Q: <code>prefixMap[0] = 1</code> 是什么意思？</strong><ul>
<li><strong>A:</strong> 这是一个通用的技巧。</li>
<li>假设 <code>target = 8</code>，当前路径和 <code>currSum</code> 刚好也是 <code>8</code>。</li>
<li>公式：<code>oldSum = 8 - 8 = 0</code>。</li>
<li>我们需要找前缀和为 0 的次数。如果没有初始化，哈希表里没有 0，我们就会漏掉这条“从根节点开始刚好等于 target”的路径。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>189. 轮转数组</title>
    <url>/2025/11/13/Hot100/%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></p>
<p>题目：<br>给定一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出：[5,6,7,1,2,3,4]<br>解释：向右轮转 3 步。[1,2,3,4,5,6,7] -&gt; [7,1,2,3,4,5,6] -&gt; [6,7,1,2,3,4,5] -&gt; [5,6,7,1,2,3,4]</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2<br>输出：[3,99,-1,-100]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10⁵</code></li>
<li><code>-2³¹ &lt;= nums[i] &lt;= 2³¹ - 1</code></li>
<li><code>0 &lt;= k &lt;= 10⁵</code></li>
</ul>
<p>这道题是数组操作中的“魔术题”。</p>
<p>为什么叫它“魔术题”？因为它有一个经典的解法，初次见到时会觉得“极其反直觉”，但一旦理解了，你会感叹数学的对称美。而且，这道题考察的是<strong>空间复杂度 $O(1)$</strong> 的原地操作能力。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：轮转数组 (Rotate Array)</p>
<p><strong>题目大意</strong>：</p>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右移动 <code>k</code> 个位置。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li><strong>原地算法</strong>：尽可能在原始数组上操作，使用 $O(1)$ 的额外空间。</li>
<li><code>k</code> 是非负数，但 <code>k</code> 可能大于数组长度 <code>n</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [1, 2, 3, 4, 5, 6, 7]</code>, <code>k = 3</code></p>
<p>输出：<code>[5, 6, 7, 1, 2, 3, 4]</code></p>
<p>解释：</p>
<ul>
<li>向右轮转 1 步: <code>[7, 1, 2, 3, 4, 5, 6]</code></li>
<li>向右轮转 2 步: <code>[6, 7, 1, 2, 3, 4, 5]</code></li>
<li>向右轮转 3 步: <code>[5, 6, 7, 1, 2, 3, 4]</code></li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-坑点预警：k-可能很大"><a href="#2-1-坑点预警：k-可能很大" class="headerlink" title="2.1 坑点预警：k 可能很大"></a>2.1 坑点预警：<code>k</code> 可能很大</h4><p>如果数组长度 <code>n = 5</code>，让你轮转 <code>k = 7</code> 次。</p>
<p>实际上，轮转 5 次等于没动。轮转 7 次的效果 等于 轮转 2 次。</p>
<p><strong>第一步预处理</strong>：<code>k = k % n</code>。这是所有解法的前提。</p>
<h4 id="2-2-为什么暴力法和辅助数组法不够好？"><a href="#2-2-为什么暴力法和辅助数组法不够好？" class="headerlink" title="2.2 为什么暴力法和辅助数组法不够好？"></a>2.2 为什么暴力法和辅助数组法不够好？</h4><ol>
<li><strong>暴力法</strong>：每次把最后一个数挪到最前面，其余后移。移动一次 $O(n)$，移动 $k$ 次就是 $O(n \times k)$。<strong>超时</strong>。</li>
<li><strong>辅助数组法</strong>：新建一个数组，直接把算好位置的数放进去。时间 $O(n)$，但空间也是 $O(n)$。<strong>不符合“原地”的高级要求</strong>。</li>
</ol>
<h4 id="2-3-核心策略：三次翻转法-The-“Three-Reversals”-Trick"><a href="#2-3-核心策略：三次翻转法-The-“Three-Reversals”-Trick" class="headerlink" title="2.3 核心策略：三次翻转法 (The “Three Reversals” Trick)"></a>2.3 核心策略：三次翻转法 (The “Three Reversals” Trick)</h4><p>我们需要把数组的<strong>后 k 个元素</strong>（尾巴），搬到数组的<strong>最前面</strong>（头部）。</p>
<p>观察示例：<code>[1, 2, 3, 4, 5, 6, 7]</code>, <code>k = 3</code></p>
<p>目标是：<code>[5, 6, 7]</code> (原尾部) + <code>[1, 2, 3, 4]</code> (原头部)</p>
<p><strong>神奇的操作步骤</strong>：</p>
<ol>
<li><p><strong>翻转整个数组</strong>：</p>
<p><code>[7, 6, 5, 4, 3, 2, 1]</code></p>
<ul>
<li><em>观察</em>：现在的顺序是反的，但是 <code>5, 6, 7</code> 已经成功跑到了最左边（头部），<code>1, 2, 3, 4</code> 跑到了最右边。只是它们内部的顺序也是反的。</li>
</ul>
</li>
<li><p><strong>翻转前 k 个元素</strong>（也就是前 3 个）：</p>
<p><code>[5, 6, 7]</code> <code>[4, 3, 2, 1]</code></p>
<ul>
<li><em>观察</em>：头部的顺序恢复正常了！</li>
</ul>
</li>
<li><p><strong>翻转剩余的元素</strong>（也就是后 n-k 个）：</p>
<p><code>[5, 6, 7]</code> <code>[1, 2, 3, 4]</code></p>
<ul>
<li><em>观察</em>：大功告成！</li>
</ul>
</li>
</ol>
<p><strong>为什么有效？</strong></p>
<p>本质上，翻转操作类似于矩阵转置 $(AB)^T &#x3D; B^T A^T$。</p>
<p>我们想把数组看作两部分 $A$ (头部)和 $B$ (尾部)，原数组是 $AB$。我们想要 $BA$。</p>
<p>$(A^R B^R)^R &#x3D; (B^R)^R (A^R)^R &#x3D; BA$。</p>
<p>（这里 $R$ 代表 Reverse 翻转）。</p>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++ 标准库提供了非常强大的 <code>std::reverse</code> 函数，但在面试中，最好也能手写一个 <code>reverse</code> 函数来展示你对双指针的理解。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 自定义翻转函数：使用双指针交换两端元素</span><br><span class="line">    // 作用：将 nums 中范围 [start, end] 的元素进行翻转</span><br><span class="line">    void myReverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        </span><br><span class="line">        // 【关键防御】</span><br><span class="line">        // 如果 k &gt; n，我们不需要转那么多圈，取余数即可</span><br><span class="line">        k = k % n; </span><br><span class="line">        </span><br><span class="line">        // 如果 k 是 0，或者数组为空，直接不用动</span><br><span class="line">        if (k == 0 || n == 0) return;</span><br><span class="line"></span><br><span class="line">        // 【核心三步走】</span><br><span class="line">        </span><br><span class="line">        // 1. 翻转整个数组</span><br><span class="line">        // 变成: [7, 6, 5, 4, 3, 2, 1]</span><br><span class="line">        myReverse(nums, 0, n - 1);</span><br><span class="line">        </span><br><span class="line">        // 2. 翻转前 k 个元素 (修正前半部分的顺序)</span><br><span class="line">        // 变成: [5, 6, 7, 4, 3, 2, 1]</span><br><span class="line">        myReverse(nums, 0, k - 1);</span><br><span class="line">        </span><br><span class="line">        // 3. 翻转剩余的元素 (修正后半部分的顺序)</span><br><span class="line">        // 变成: [5, 6, 7, 1, 2, 3, 4]</span><br><span class="line">        myReverse(nums, k, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>第一次翻转整个数组：遍历 $n$ 个元素。</li>
<li>第二次翻转前 $k$ 个：遍历 $k$ 个。</li>
<li>第三次翻转后 $n-k$ 个：遍历 $n-k$ 个。</li>
<li>总遍历次数：$n + k + (n-k) &#x3D; 2n$。</li>
<li>忽略常数，结果为线性时间 <strong>$O(n)$</strong>。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>我们没有申请新的数组 (<code>new vector</code>)。</li>
<li><code>myReverse</code> 函数只使用了常数个变量 (<code>start</code>, <code>end</code>, <code>temp</code> 交换用)。</li>
<li>符合题目要求的<strong>原地算法</strong>。</li>
</ul>
<hr>
<h3 id="5-进阶思考：环状替换-Cyclic-Replacements"><a href="#5-进阶思考：环状替换-Cyclic-Replacements" class="headerlink" title="5. 进阶思考：环状替换 (Cyclic Replacements)"></a>5. 进阶思考：环状替换 (Cyclic Replacements)</h3><p>除了翻转法，还有一种方法叫 <strong>环状替换</strong>。</p>
<p>它的思路是：直接把 <code>nums[i]</code> 放到它该去的位置 <code>(i+k)%n</code>，把那个位置原本的数拿出来，再找下一个位置…</p>
<p><strong>为什么不推荐首选这种方法？</strong></p>
<p>虽然空间也是 $O(1)$，但代码很难写对。</p>
<ul>
<li>如果 $n$ 和 $k$ 的最大公约数不是 1（比如 n&#x3D;6, k&#x3D;2），你会发现你在这个环里转圈圈，回到了原点，但还有很多元素没动过！</li>
<li>你需要处理这种“多轮循环”的情况，代码逻辑复杂，边界条件多，面试时容易翻车。</li>
<li><strong>翻转法</strong>逻辑清晰，不易出错，是最佳选择。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>238. 除了自身以外数组的乘积</title>
    <url>/2025/11/13/Hot100/%E9%99%A4%E4%BA%86%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除了自身以外数组的乘积</a></p>
<p>题目：<br>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code>，返回一个数组 <code>output</code>，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 外其余所有元素的乘积。</p>
<p><strong>示例 1：</strong><br>输入：nums &#x3D; [1,2,3,4]<br>输出：[24,12,8,6]<br>解释：对于索引 0，结果是 2×3×4&#x3D;24；索引 1 是 1×3×4&#x3D;12，依此类推。</p>
<p><strong>示例 2：</strong><br>输入：nums &#x3D; [-1,1,0,-3,3]<br>输出：[0,0,9,0,0]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10⁵</code></li>
<li><code>-10⁴ &lt;= nums[i] &lt;= 10⁴</code></li>
<li>保证答案在 32 位整数范围内。</li>
</ul>
<p>这道题是 <strong>前缀和&#x2F;后缀和</strong> 思想的变种，在面试中出现频率极高。</p>
<p>它的难点在于题目给出的两个“反人性”限制：</p>
<ol>
<li><strong>不能使用除法</strong>（否则算出所有数的乘积，再除以当前数就搞定了，虽然还要处理 0 的情况）。</li>
<li><strong>时间复杂度 $O(n)$</strong> 且 <strong>空间复杂度 $O(1)$</strong>（结果数组不计入空间）。</li>
</ol>
<p>这实际上是在考察你对 <strong>“左右乘积列表”</strong> 技巧的掌握和空间复用的优化能力。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：除自身以外数组的乘积 (Product of Array Except Self)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个整数数组 <code>nums</code>，返回一个数组 <code>answer</code>，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除了 <code>nums[i]</code> 之外其余所有元素的乘积。</p>
<p><strong>关键约束</strong>：</p>
<ul>
<li>题目数据保证数组中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内（不用担心溢出）。</li>
<li><strong>请不要使用除法</strong>。</li>
<li>进阶：在 $O(1)$ 的额外空间复杂度内完成。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>nums = [1, 2, 3, 4]</code></p>
<p>输出：<code>[24, 12, 8, 6]</code></p>
<p>解释：</p>
<ul>
<li>索引 0: $2 \times 3 \times 4 &#x3D; 24$</li>
<li>索引 1: $1 \times 3 \times 4 &#x3D; 12$</li>
<li>…以此类推</li>
</ul>
<hr>
<h3 id="2-核心思路分析"><a href="#2-核心思路分析" class="headerlink" title="2. 核心思路分析"></a>2. 核心思路分析</h3><h4 id="2-1-朴素思想：左右拆解"><a href="#2-1-朴素思想：左右拆解" class="headerlink" title="2.1 朴素思想：左右拆解"></a>2.1 朴素思想：左右拆解</h4><p>既然不能用除法，那我们只能硬乘。</p>
<p>对于数组中任意一个元素 <code>nums[i]</code>，它的“除自身以外的乘积”其实就是：</p>
<p>$$\text{answer}[i] &#x3D; (\text{i 左边所有数的乘积}) \times (\text{i 右边所有数的乘积})$$</p>
<p>如果我们能快速知道每个位置的 <strong>左积 (Left Product)</strong> 和 <strong>右积 (Right Product)</strong>，相乘就是答案。</p>
<h4 id="2-2-空间-O-n-的解法（预处理）"><a href="#2-2-空间-O-n-的解法（预处理）" class="headerlink" title="2.2 空间 $O(n)$ 的解法（预处理）"></a>2.2 空间 $O(n)$ 的解法（预处理）</h4><p>我们可以开两个辅助数组：</p>
<ol>
<li><code>L[i]</code>: 表示下标 <code>i</code> 左边所有元素的乘积。</li>
<li><code>R[i]</code>: 表示下标 <code>i</code> 右边所有元素的乘积。</li>
</ol>
<p>举例 <code>[1, 2, 3, 4]</code>：</p>
<ul>
<li><code>L</code> 数组：<code>[1, 1, 2, 6]</code> (注意：索引0左边没有数，乘积初始化为1)</li>
<li><code>R</code> 数组：<code>[24, 12, 4, 1]</code> (注意：索引3右边没有数，乘积初始化为1)</li>
<li><code>answer</code>：<code>L[i] * R[i]</code> $\rightarrow$ <code>[24, 12, 8, 6]</code></li>
</ul>
<p>虽然这样满足时间 $O(n)$，但用了两个辅助数组，空间是 $O(n)$。</p>
<h4 id="2-3-空间-O-1-的极致优化（空间复用）"><a href="#2-3-空间-O-1-的极致优化（空间复用）" class="headerlink" title="2.3 空间 $O(1)$ 的极致优化（空间复用）"></a>2.3 空间 $O(1)$ 的极致优化（空间复用）</h4><p>题目允许 <strong>返回数组 <code>answer</code> 不计入空间复杂度</strong>。我们可以利用 <code>answer</code> 数组本身来充当中间容器。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><strong>第一轮遍历（从左往右）</strong>：</p>
<p>先用 <code>answer[i]</code> 存储 <strong>i 左边所有元素的乘积</strong>。</p>
<p>此时 <code>answer</code> 数组就是刚才提到的 <code>L</code> 数组。</p>
</li>
<li><p><strong>第二轮遍历（从右往左）</strong>：</p>
<p>我们需要把 <strong>i 右边所有元素的乘积</strong> 乘进去。</p>
<p>由于我们不能再开一个数组存右积，我们用一个<strong>临时变量 <code>R</code></strong> 来动态维护当前位置右边的乘积。</p>
<ul>
<li>初始 <code>R = 1</code>。</li>
<li>对于下标 <code>i</code> (从最后往前遍历)：<ul>
<li><code>answer[i]</code> 目前存的是左积。</li>
<li><code>answer[i] = answer[i] * R</code> （这就变成了 左积 * 右积）。</li>
<li>更新 <code>R = R * nums[i]</code> （把当前数乘进 R，为处理前一个数做准备）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-C-代码实现-OI-ACM-风格"><a href="#3-C-代码实现-OI-ACM-风格" class="headerlink" title="3. C++ 代码实现 (OI&#x2F;ACM 风格)"></a>3. C++ 代码实现 (OI&#x2F;ACM 风格)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        </span><br><span class="line">        // answer 数组用来存放结果</span><br><span class="line">        // 初始化大小为 n，且不计入额外空间复杂度</span><br><span class="line">        vector&lt;int&gt; answer(n);</span><br><span class="line"></span><br><span class="line">        // ==========================================</span><br><span class="line">        // 第一步：计算【左侧乘积】</span><br><span class="line">        // answer[i] 将存储 nums[0]...nums[i-1] 的乘积</span><br><span class="line">        // ==========================================</span><br><span class="line">        </span><br><span class="line">        // 初始化：索引 0 的左边没有元素，所以左积为 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line"></span><br><span class="line">        // 从索引 1 开始遍历</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 当前位置的左积 = (前一个位置的左积) * (前一个位置的数值)</span><br><span class="line">            answer[i] = answer[i - 1] * nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        // 此时，answer 数组变成了 [1, 1, 2, 6] (对于输入 1,2,3,4)</span><br><span class="line"></span><br><span class="line">        // ==========================================</span><br><span class="line">        // 第二步：计算【右侧乘积】并乘入结果</span><br><span class="line">        // 我们不需要额外的数组来存右积，只需一个变量 R 动态维护</span><br><span class="line">        // ==========================================</span><br><span class="line">        </span><br><span class="line">        int R = 1; // R 代表当前元素右侧所有元素的乘积，初始为 1</span><br><span class="line"></span><br><span class="line">        // 从倒数第一个元素开始往前遍历</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            // 最终结果 = (已有的左积) * (当前的右积)</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line"></span><br><span class="line">            // 更新 R，把当前元素 nums[i] 乘进去，</span><br><span class="line">            // 以便给更左边的元素使用</span><br><span class="line">            R = R * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h3><h4 id="时间复杂度：-O-n"><a href="#时间复杂度：-O-n" class="headerlink" title="时间复杂度：$O(n)$"></a><strong>时间复杂度：$O(n)$</strong></h4><ul>
<li>我们进行了两次遍历：<ol>
<li>从左到右计算左积：$O(n)$。</li>
<li>从右到左计算右积并更新结果：$O(n)$。</li>
</ol>
</li>
<li>总复杂度 $2n \approx O(n)$。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>除了用于返回的 <code>answer</code> 数组外，我们只使用了常数个变量 (<code>n</code>, <code>i</code>, <code>R</code>)。</li>
<li>完全符合题目进阶要求。</li>
</ul>
<hr>
<h3 id="5-初学者常见疑问-Q-A"><a href="#5-初学者常见疑问-Q-A" class="headerlink" title="5. 初学者常见疑问 (Q&amp;A)"></a>5. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么可以不用除法？这背后的数学原理是什么？</strong><ul>
<li><strong>A:</strong> 这利用了乘法的<strong>结合律</strong>。$A \times B \times C \times D$ 除以 $B$，等价于 $(A) \times (C \times D)$。也就是把 $B$ 挖掉，算出左边的积，再算出右边的积，拼起来就行。</li>
</ul>
</li>
<li><strong>Q: 如果数组里有 0 怎么办？</strong><ul>
<li><strong>A:</strong> 这个算法完美兼容 0。</li>
<li>如果数组里有一个 0（比如 <code>[1, 0, 3, 4]</code>），那么算出结果是 <code>[0, 12, 0, 0]</code>，只有 0 那个位置有值。</li>
<li>如果数组里有两个及以上的 0，那么结果全是 0。</li>
<li>我们的算法只是单纯的乘法，0 乘任何数都是 0，逻辑上不需要特殊处理。而如果用“总积除以当前数”的方法，遇到 0 做除数程序就崩了。</li>
</ul>
</li>
<li><strong>Q: 初始化 <code>answer[0] = 1</code> 和 <code>R = 1</code> 容易忘怎么办？</strong><ul>
<li><strong>A:</strong> 记住“乘法单位元”的概念。乘法的“空状态”就是 1（就像加法的空状态是 0）。对于最左边的数，它左边“空空如也”，所以左积是 1；对于最右边的数同理。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>前缀积</tag>
      </tags>
  </entry>
  <entry>
    <title>138. 随机链表的复制</title>
    <url>/2025/11/13/Hot100/%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></p>
<p>题目：<br>给你一个长度为 <code>n</code> 的链表，每个节点除了 <code>next</code> 指针外，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p>请你返回这个链表的深拷贝。</p>
<p><strong>示例 1：</strong><br>输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><strong>示例 2：</strong><br>输入：head &#x3D; [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]</p>
<p><strong>示例 3：</strong><br>输入：head &#x3D; [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>-10⁴ &lt;= Node.val &lt;= 10⁴</code></li>
<li><code>Node.random</code> 是指向链表中任意节点或者 <code>null</code></li>
</ul>
<p>这道题是链表问题中非常独特的一道 <strong>“深拷贝” (Deep Copy)</strong> 题目。</p>
<p>它考察的不是复杂的算法逻辑，而是你对 <strong>数据结构内存模型</strong> 的理解，以及如何巧妙地利用 <strong>指针映射</strong> 关系。</p>
<p>面试中，这道题通常有两种解法：</p>
<ol>
<li><strong>哈希表法</strong>：易于理解，空间复杂度 $O(N)$。</li>
<li><strong>拼接（交织）法</strong>：技巧性极强，空间复杂度 <strong>$O(1)$</strong>（最优解）。</li>
</ol>
<p>我们将重点讲解 <strong>拼接法</strong>，这是能让面试官眼前一亮的解法。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：随机链表的复制 (Copy List with Random Pointer)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外指针 <code>random</code>，该指针可以指向链表中的任何节点或空节点。</p>
<p>请你 <strong>深拷贝</strong> 这个链表。</p>
<ul>
<li><strong>深拷贝</strong> 意味着你需要创建全新的节点，新节点的 <code>next</code> 和 <code>random</code> 指针必须指向<strong>新的</strong>对应节点，而不能指向原链表的节点。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>输入：<code>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</code></p>
<p>（<code>[val, random_index]</code>，比如 <code>13</code> 的 <code>random</code> 指向下标 0 的节点 <code>7</code>）</p>
<p>输出：一个新的链表，结构和值完全一样，但内存地址完全不同。</p>
<hr>
<h3 id="2-核心挑战"><a href="#2-核心挑战" class="headerlink" title="2. 核心挑战"></a>2. 核心挑战</h3><p><strong>为什么不能直接遍历复制？</strong></p>
<p>当我们复制节点 <code>A</code> 时，它的 <code>random</code> 指针可能指向节点 <code>Z</code>。</p>
<ul>
<li><p>此时节点 <code>Z</code> 可能还没有被创建出来（在链表后面）。</p>
</li>
<li><p>或者 <code>Z</code> 已经被创建了，但我们手里没有新节点 <code>Z&#39;</code> 的地址，只有旧节点 <code>Z</code> 的地址。</p>
<p><strong>我们需要建立“旧节点”到“新节点”的一一对应关系。</strong></p>
</li>
</ul>
<hr>
<h3 id="3-解法一：哈希表法-Hash-Map-——-直观思路"><a href="#3-解法一：哈希表法-Hash-Map-——-直观思路" class="headerlink" title="3. 解法一：哈希表法 (Hash Map) —— 直观思路"></a>3. 解法一：哈希表法 (Hash Map) —— 直观思路</h3><p>这是最符合人类直觉的做法。</p>
<ol>
<li><strong>第一遍遍历</strong>：<ul>
<li>只管创建新节点。</li>
<li>建立一个哈希表 <code>unordered_map&lt;Node*, Node*&gt; map</code>。</li>
<li>存入映射：<code>map[旧节点 A] = 新节点 A&#39;</code>。</li>
</ul>
</li>
<li><strong>第二遍遍历</strong>：<ul>
<li>再次遍历链表。</li>
<li>配置指针：<code>map[curr]-&gt;next = map[curr-&gt;next]</code>。</li>
<li>配置随机：<code>map[curr]-&gt;random = map[curr-&gt;random]</code>。</li>
<li>因为所有新节点在第一遍都创建好了，所以这里直接查表就能拿到地址。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>优点</strong>：代码简单，逻辑清晰。</li>
<li><strong>缺点</strong>：空间复杂度 $O(N)$。</li>
</ul>
<hr>
<h3 id="4-解法二：拼接（交织）法-——-空间优化-O-1"><a href="#4-解法二：拼接（交织）法-——-空间优化-O-1" class="headerlink" title="4. 解法二：拼接（交织）法 —— 空间优化 $O(1)$"></a>4. 解法二：拼接（交织）法 —— 空间优化 $O(1)$</h3><p>如果我们不想用哈希表，怎么找到 <code>旧 A</code> 对应的 <code>新 A&#39;</code> 呢？</p>
<p>我们可以利用链表本身的结构，把新节点 <strong>“藏”</strong> 在旧节点的旁边！</p>
<p><strong>核心三步走</strong>：</p>
<h4 id="Step-1-复制节点并拼接-Clone-Splicing"><a href="#Step-1-复制节点并拼接-Clone-Splicing" class="headerlink" title="Step 1: 复制节点并拼接 (Clone &amp; Splicing)"></a><strong>Step 1: 复制节点并拼接 (Clone &amp; Splicing)</strong></h4><p>遍历链表，为每个节点 <code>A</code> 创建副本 <code>A&#39;</code>，并将 <code>A&#39;</code> 插入到 <code>A</code> 和 <code>B</code> 之间。</p>
<ul>
<li>原链表：<code>A -&gt; B -&gt; C</code></li>
<li>变形后：<code>A -&gt; A&#39; -&gt; B -&gt; B&#39; -&gt; C -&gt; C&#39;</code></li>
</ul>
<p>此时，<code>A-&gt;next</code> 就是 <code>A&#39;</code>。我们可以通过 <code>旧节点-&gt;next</code> 直接找到它对应的 <code>新节点</code>，不再需要哈希表。</p>
<h4 id="Step-2-复制随机指针-Copy-Random"><a href="#Step-2-复制随机指针-Copy-Random" class="headerlink" title="Step 2: 复制随机指针 (Copy Random)"></a><strong>Step 2: 复制随机指针 (Copy Random)</strong></h4><p>遍历链表（注意步长是 2，只看旧节点）。</p>
<ul>
<li><p><code>A</code> 的 <code>random</code> 指向 <code>C</code>。</p>
</li>
<li><p>那么 <code>A&#39;</code> (<code>A-&gt;next</code>) 的 <code>random</code> 应该指向 <code>C&#39;</code>。</p>
</li>
<li><p><code>C&#39;</code> 在哪里？它就在 <code>C</code> 的后面，也就是 <code>C-&gt;next</code>！</p>
</li>
<li><p><strong>公式</strong>：<code>curr-&gt;next-&gt;random = curr-&gt;random-&gt;next</code>。</p>
<p><em>(注意判空：如果 <code>curr-&gt;random</code> 是 NULL，那么 <code>curr-&gt;next-&gt;random</code> 也是 NULL)</em></p>
</li>
</ul>
<h4 id="Step-3-拆分链表-Unweaving"><a href="#Step-3-拆分链表-Unweaving" class="headerlink" title="Step 3: 拆分链表 (Unweaving)"></a><strong>Step 3: 拆分链表 (Unweaving)</strong></h4><p>把交织在一起的长链表拆回两个独立的链表。</p>
<ul>
<li>恢复原链表：<code>A -&gt; B -&gt; C</code></li>
<li>提取新链表：<code>A&#39; -&gt; B&#39; -&gt; C&#39;</code></li>
</ul>
<hr>
<h3 id="5-C-代码实现-拼接法"><a href="#5-C-代码实现-拼接法" class="headerlink" title="5. C++ 代码实现 (拼接法)"></a>5. C++ 代码实现 (拼接法)</h3><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = NULL;</span><br><span class="line">        random = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if (head == nullptr) return nullptr;</span><br><span class="line"></span><br><span class="line">        // Step 1: 复制节点，构建 A -&gt; A&#x27; -&gt; B -&gt; B&#x27;</span><br><span class="line">        Node* curr = head;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            Node* newNode = new Node(curr-&gt;val);</span><br><span class="line">            newNode-&gt;next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = newNode;</span><br><span class="line">            </span><br><span class="line">            // 指针移动到下一个【原节点】</span><br><span class="line">            curr = newNode-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 2: 复制 random 指针</span><br><span class="line">        curr = head;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            // curr 是旧节点，curr-&gt;next 是新节点</span><br><span class="line">            if (curr-&gt;random != nullptr) &#123;</span><br><span class="line">                // 新节点的 random = 旧节点 random 的 next (也就是旧 random 对应的副本)</span><br><span class="line">                curr-&gt;next-&gt;random = curr-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            // 移动到下一个【原节点】(跨过新节点)</span><br><span class="line">            curr = curr-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 3: 拆分链表 (恢复原链表，提取新链表)</span><br><span class="line">        Node* dummy = new Node(0); // 虚拟头节点帮助提取新链表</span><br><span class="line">        Node* copyTail = dummy;</span><br><span class="line">        </span><br><span class="line">        curr = head;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            // 记录下一次要处理的原节点 (A -&gt; A&#x27; -&gt; B 中的 B)</span><br><span class="line">            Node* nextOriginal = curr-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            // 提取新节点 (curr-&gt;next 就是 A&#x27;)</span><br><span class="line">            Node* copyNode = curr-&gt;next;</span><br><span class="line">            copyTail-&gt;next = copyNode;</span><br><span class="line">            copyTail = copyNode;</span><br><span class="line"></span><br><span class="line">            // 恢复原链表 (A 指回 B)</span><br><span class="line">            curr-&gt;next = nextOriginal;</span><br><span class="line"></span><br><span class="line">            // 指针后移</span><br><span class="line">            curr = nextOriginal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-复杂度分析"><a href="#6-复杂度分析" class="headerlink" title="6. 复杂度分析"></a>6. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们遍历了链表三次（拼接、连 Random、拆分）。</li>
<li>$3N$ 依然是线性时间。</li>
</ul>
<h4 id="空间复杂度：-O-1"><a href="#空间复杂度：-O-1" class="headerlink" title="空间复杂度：$O(1)$"></a><strong>空间复杂度：$O(1)$</strong></h4><ul>
<li>除了用于结果的新节点（这是必须的，不计入额外空间），我们只用了几个指针变量。</li>
<li>我们没有使用哈希表来存储映射关系，利用了链表自身的结构特性完成了“映射”。</li>
</ul>
<hr>
<h3 id="7-初学者常见疑问-Q-A"><a href="#7-初学者常见疑问-Q-A" class="headerlink" title="7. 初学者常见疑问 (Q&amp;A)"></a>7. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么 Step 3 拆分时 <code>curr-&gt;next = nextOriginal</code> 很重要？</strong><ul>
<li><strong>A:</strong> 题目通常要求“深拷贝”，不仅要返回新链表，<strong>原链表也不能被破坏</strong>。如果你不把原链表恢复成 <code>A-&gt;B-&gt;C</code> 的样子，虽然答案对了，但在工程上这叫“有副作用 (Side Effect)”，通常是不合格的。</li>
</ul>
</li>
<li><strong>Q: Step 2 为什么要判断 <code>curr-&gt;random != nullptr</code>？</strong><ul>
<li><strong>A:</strong> 因为题目说 <code>random</code> 可能指向 <code>null</code>。如果 <code>curr-&gt;random</code> 是空，去访问 <code>curr-&gt;random-&gt;next</code> 就会报空指针异常 (Segmentation Fault)。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>98. 验证二叉搜索树</title>
    <url>/2025/11/13/Hot100/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<p>题目：<br>给你一个二叉树的根节点 <code>root</code>，判断该二叉树是否是一个有效的二叉搜索树（BST）。</p>
<p><strong>有效 BST 定义如下：</strong></p>
<ul>
<li>左子树中所有节点的值都小于当前节点的值。</li>
<li>右子树中所有节点的值都大于当前节点的值。</li>
<li>左右子树也必须是有效的二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong><br>输入：root &#x3D; [2,1,3]<br>输出：true</p>
<p><strong>示例 2：</strong><br>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5，但右子树中存在值为 3 的节点，违反了 BST 性质。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 10⁴]</code></li>
<li><code>-2³¹ &lt;= Node.val &lt;= 2³¹ - 1</code></li>
</ul>
<p>这道题是 <strong>二叉搜索树 (BST)</strong> 的入门必修课。</p>
<p>它是力扣（LeetCode）第 98 题。</p>
<p>这道题有一个非常著名的 <strong>“陷阱”</strong>，90% 的初学者第一次做的时候都会掉进去。它考察的不仅仅是树的遍历，更是对 <strong>递归状态传递</strong> 的理解。</p>
<hr>
<h3 id="1-明确问题描述"><a href="#1-明确问题描述" class="headerlink" title="1. 明确问题描述"></a>1. 明确问题描述</h3><p><strong>题目名称</strong>：验证二叉搜索树 (Validate Binary Search Tree)</p>
<p><strong>题目大意</strong>：</p>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树 (BST)。</p>
<p><strong>有效 BST 的定义</strong>：</p>
<ol>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li><strong>所有左子树和右子树自身必须也是二叉搜索树。</strong></li>
</ol>
<p><strong>示例</strong>：</p>
<p>输入：<code>[2, 1, 3]</code></p>
<p>输出：<code>true</code> (左 1 &lt; 根 2 &lt; 右 3)</p>
<p>输入：<code>[5, 1, 4, null, null, 3, 6]</code></p>
<p>输出：<code>false</code></p>
<p>解释：根节点是 5，右孩子是 4。虽然 4 的左孩子 3 小于 4（局部成立），但 3 在 5 的右子树里，<strong>3 必须大于 5</strong>，所以不合法。</p>
<hr>
<h3 id="2-核心陷阱：不要只看“局部”"><a href="#2-核心陷阱：不要只看“局部”" class="headerlink" title="2. 核心陷阱：不要只看“局部”"></a>2. 核心陷阱：不要只看“局部”</h3><p>很多人的第一反应是写出这样的代码：</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误写法！</span><br><span class="line">if (root-&gt;left &amp;&amp; root-&gt;left-&gt;val &gt;= root-&gt;val) return false;</span><br><span class="line">if (root-&gt;right &amp;&amp; root-&gt;right-&gt;val &lt;= root-&gt;val) return false;</span><br><span class="line">return isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span><br></pre></td></tr></table></figure>

<p><strong>为什么错了？</strong></p>
<p>因为它只检查了 <strong>“父子”</strong> 关系，没检查 <strong>“祖孙”</strong> 关系。</p>
<p>看上图的例子：</p>
<ul>
<li>根节点是 <strong>10</strong>。</li>
<li>右孩子是 <strong>15</strong>（大于 10，合法）。</li>
<li>15 的左孩子是 <strong>6</strong>。</li>
<li><strong>6 &lt; 15</strong>（局部合法）。</li>
<li><strong>但是！</strong> 6 在 10 的右子树里，它必须大于 10。这里 $6 &lt; 10$，所以整棵树是无效的。</li>
</ul>
<p><strong>结论</strong>：这就意味着，当我们往左走时，所有节点必须小于“祖先”；往右走时，所有节点必须大于“祖先”。我们需要把这个 <strong>范围 (Range)</strong> 传下去。</p>
<hr>
<h3 id="3-解法一：递归-范围限定-Recursion-with-Range"><a href="#3-解法一：递归-范围限定-Recursion-with-Range" class="headerlink" title="3. 解法一：递归 + 范围限定 (Recursion with Range)"></a>3. 解法一：递归 + 范围限定 (Recursion with Range)</h3><p>我们在递归函数中增加两个参数：<code>lower</code> (下界) 和 <code>upper</code> (上界)。</p>
<ol>
<li><strong>根节点</strong>：范围是 $(-\infty, +\infty)$。</li>
<li><strong>往左走</strong>：上界变小。范围变成 $(lower, root.val)$。</li>
<li><strong>往右走</strong>：下界变大。范围变成 $(root.val, upper)$。</li>
<li><strong>检查</strong>：如果当前节点的值不在 $(lower, upper)$ 开区间内，直接返回 <code>false</code>。</li>
</ol>
<h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++ 代码实现"></a>C++ 代码实现</h4><p><em>注意：由于题目测试用例可能包含 <code>INT_MAX</code>，我们需要用 <code>long long</code> 来存储边界。</em></p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        // 初始范围：负无穷 到 正无穷</span><br><span class="line">        return validate(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 辅函数：带有范围限制的递归</span><br><span class="line">    bool validate(TreeNode* node, long long lower, long long upper) &#123;</span><br><span class="line">        // 1. 空节点是合法的 BST</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 检查当前节点是否越界</span><br><span class="line">        // 必须严格小于 upper，且严格大于 lower</span><br><span class="line">        if (node-&gt;val &lt;= lower || node-&gt;val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 递归检查左右子树</span><br><span class="line">        // 左子树：上界变为当前节点值</span><br><span class="line">        // 右子树：下界变为当前节点值</span><br><span class="line">        return validate(node-&gt;left, lower, node-&gt;val) &amp;&amp;</span><br><span class="line">               validate(node-&gt;right, node-&gt;val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-解法二：中序遍历-In-order-Traversal-——-最优雅"><a href="#4-解法二：中序遍历-In-order-Traversal-——-最优雅" class="headerlink" title="4. 解法二：中序遍历 (In-order Traversal) —— 最优雅"></a>4. 解法二：中序遍历 (In-order Traversal) —— 最优雅</h3><p>利用 BST 的核心性质：</p>
<blockquote>
<p><strong>二叉搜索树的中序遍历结果，一定是一个严格递增的有序数组。</strong></p>
</blockquote>
<p>我们不需要真的把所有数存进数组里（浪费空间）。我们只需要在遍历过程中，记录 <strong>前一个访问的节点值 (<code>prev</code>)</strong>。</p>
<p>只要 <code>current_val &gt; prev_val</code> 一直成立，它就是合法的。一旦出现 <code>current &lt;= prev</code>，立刻报错。</p>
<h4 id="C-代码实现-1"><a href="#C-代码实现-1" class="headerlink" title="C++ 代码实现"></a>C++ 代码实现</h4><p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 用于记录中序遍历的前一个节点的值</span><br><span class="line">    // 初始化为最小值，或者用一个指针指向 null 表示还没开始</span><br><span class="line">    long long prev = LONG_MIN; </span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return true;</span><br><span class="line"></span><br><span class="line">        // 1. 递归访问左子树 (Left)</span><br><span class="line">        if (!isValidBST(root-&gt;left)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 访问当前节点 (Root)</span><br><span class="line">        // 如果当前节点小于等于前一个节点，说明不是升序，非法</span><br><span class="line">        if (root-&gt;val &lt;= prev) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新 prev 为当前值，供下一个节点比较</span><br><span class="line">        prev = root-&gt;val;</span><br><span class="line"></span><br><span class="line">        // 3. 递归访问右子树 (Right)</span><br><span class="line">        return isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. 复杂度分析</h3><h4 id="时间复杂度：-O-N"><a href="#时间复杂度：-O-N" class="headerlink" title="时间复杂度：$O(N)$"></a><strong>时间复杂度：$O(N)$</strong></h4><ul>
<li>我们需要访问每一个节点一次。</li>
</ul>
<h4 id="空间复杂度：-O-H"><a href="#空间复杂度：-O-H" class="headerlink" title="空间复杂度：$O(H)$"></a><strong>空间复杂度：$O(H)$</strong></h4><ul>
<li>$H$ 是树的高度。递归栈的深度。</li>
</ul>
<hr>
<h3 id="6-初学者常见疑问-Q-A"><a href="#6-初学者常见疑问-Q-A" class="headerlink" title="6. 初学者常见疑问 (Q&amp;A)"></a>6. 初学者常见疑问 (Q&amp;A)</h3><ul>
<li><strong>Q: 为什么代码里要用 <code>long long</code>？</strong><ul>
<li><strong>A:</strong> 因为题目中节点的值可能是 <code>INT_MAX</code> (2147483647)。</li>
<li>如果我们初始上界设为 <code>INT_MAX</code>，当根节点就是 <code>INT_MAX</code> 时，<code>root-&gt;val &gt;= upper</code> 会误判为 <code>false</code>（或者逻辑混乱）。使用 <code>LONG_MAX</code> 可以规避这个问题。</li>
</ul>
</li>
<li><strong>Q: 能够用 BFS 做吗？</strong><ul>
<li><strong>A:</strong> 可以，但很麻烦。你需要在一个队列里同时存储 <code>节点</code>、<code>下界</code>、<code>上界</code> 三个信息。不如 DFS 直观。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>力扣Hot100题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow深度学习框架：核心原理、组件、流程与实战详解</title>
    <url>/2025/09/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/TensorFlow/</url>
    <content><![CDATA[<p>TensorFlow是由谷歌（Google）开源的<strong>端到端深度学习框架</strong>，自2015年首次发布以来，凭借其强大的灵活性、完善的生态系统和跨平台部署能力，成为工业界和学术界最主流的深度学习工具之一。它支持从模型设计、训练、可视化到部署的全流程，可用于计算机视觉、自然语言处理、推荐系统、强化学习等各类AI场景。本文将从TensorFlow的核心概念、架构组件、工作流程、关键特性到实战示例，全面解析这一框架的原理与应用。</p>
<h2 id="一、TensorFlow的核心定位与版本演进"><a href="#一、TensorFlow的核心定位与版本演进" class="headerlink" title="一、TensorFlow的核心定位与版本演进"></a>一、TensorFlow的核心定位与版本演进</h2><p>在深入技术细节前，先明确TensorFlow的核心价值与版本变化——这是理解其设计思路的基础。</p>
<h3 id="1-核心定位"><a href="#1-核心定位" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h3><ul>
<li><strong>端到端工具链</strong>：覆盖“数据预处理→模型构建→训练优化→可视化→部署”全流程，无需依赖第三方工具拼接；</li>
<li><strong>多场景适配</strong>：支持单机训练、分布式训练（多GPU&#x2F;TPU），以及移动设备、嵌入式设备、浏览器、云服务等多平台部署；</li>
<li><strong>分层API设计</strong>：提供“高层API（如tf.keras）”降低入门门槛，“底层API（如tf.Tensor、tf.Operation）”满足自定义需求，平衡易用性与灵活性。</li>
</ul>
<h3 id="2-关键版本演进（核心是TF1→TF2的变革）"><a href="#2-关键版本演进（核心是TF1→TF2的变革）" class="headerlink" title="2. 关键版本演进（核心是TF1→TF2的变革）"></a>2. 关键版本演进（核心是TF1→TF2的变革）</h3><p>TensorFlow的版本迭代围绕“简化开发流程、提升性能、增强部署能力”展开，其中<strong>TF2（2019年发布）是里程碑式更新</strong>，解决了TF1的诸多痛点：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>核心特点</th>
<th>关键变化</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TensorFlow 1.x（2015-2019）</td>
<td>静态计算图优先、依赖Session、API分散</td>
<td>需先定义计算图，再通过<code>tf.Session()</code>运行；支持分布式，但配置复杂；高层API（如tf.layers）易用性差</td>
<td>早期工业级大规模训练（需手动优化计算图）</td>
</tr>
<tr>
<td>TensorFlow 2.x（2019至今）</td>
<td>动态计算图（Eager Execution）优先、tf.keras统一高层API、简化分布式</td>
<td>默认即时执行（代码逐行运行，调试更直观）；用<code>tf.function</code>实现静态图加速；API更简洁，移除冗余接口；内置tf.data、TensorBoard等工具</td>
<td>绝大多数场景（科研快速迭代、工业级开发、多平台部署）</td>
</tr>
</tbody></table>
<p>目前TF2已成为绝对主流，官方不再维护TF1的新特性，因此本文内容均基于<strong>TensorFlow 2.x</strong>（以最新稳定版2.16为例）。</p>
<h2 id="二、TensorFlow的核心概念"><a href="#二、TensorFlow的核心概念" class="headerlink" title="二、TensorFlow的核心概念"></a>二、TensorFlow的核心概念</h2><p>TensorFlow的名字源于两个核心概念：<strong>Tensor（张量）</strong> 和<strong>Flow（流，即计算图）</strong>。理解这些基础概念是使用TensorFlow的前提。</p>
<h3 id="1-张量（Tensor）：数据的载体"><a href="#1-张量（Tensor）：数据的载体" class="headerlink" title="1. 张量（Tensor）：数据的载体"></a>1. 张量（Tensor）：数据的载体</h3><p>张量是TensorFlow中<strong>最基本的数据结构</strong>，本质是“多维数组”，用于存储模型的输入数据、中间计算结果和输出结果。它与NumPy数组类似，但支持GPU加速、自动微分和分布式存储。</p>
<h4 id="（1）张量的核心属性"><a href="#（1）张量的核心属性" class="headerlink" title="（1）张量的核心属性"></a>（1）张量的核心属性</h4><ul>
<li><strong>阶（Rank）</strong>：张量的维度数，对应NumPy的“ndim”。例如：<ul>
<li>0阶张量（标量）：<code>tf.constant(5)</code> → 形状<code>()</code>；</li>
<li>1阶张量（向量）：<code>tf.constant([1,2,3])</code> → 形状<code>(3,)</code>；</li>
<li>2阶张量（矩阵）：<code>tf.constant([[1,2],[3,4]])</code> → 形状<code>(2,2)</code>；</li>
<li>高阶张量：如3阶张量（<code>(2,3,4)</code>）可表示“2个3行4列的矩阵”，常用于存储图像（<code>[batch_size, height, width, channels]</code>）。</li>
</ul>
</li>
<li><strong>形状（Shape）</strong>：各维度的元素个数，如<code>(2,3)</code>表示2行3列。</li>
<li><strong>数据类型（Dtype）</strong>：张量中元素的类型，如<code>tf.int32</code>、<code>tf.float32</code>、<code>tf.string</code>，需注意与NumPy类型的兼容（可通过<code>tf.cast()</code>转换）。</li>
</ul>
<h4 id="（2）常用张量操作"><a href="#（2）常用张量操作" class="headerlink" title="（2）常用张量操作"></a>（2）常用张量操作</h4><p>TensorFlow提供了丰富的张量运算API，与NumPy接口高度一致，示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建张量</span></span><br><span class="line">a = tf.constant([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=tf.float32)  <span class="comment"># 常量张量（不可修改）</span></span><br><span class="line">b = tf.Variable([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=tf.float32)  <span class="comment"># 变量张量（可训练，用于模型参数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 基本运算</span></span><br><span class="line">c = a + b  <span class="comment"># 元素加法（等价于tf.add(a, b)）</span></span><br><span class="line">d = a * b  <span class="comment"># 元素乘法（等价于tf.multiply(a, b)）</span></span><br><span class="line">e = tf.matmul(a, b)  <span class="comment"># 矩阵乘法（等价于a @ b）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 与NumPy数组转换</span></span><br><span class="line">np_a = a.numpy()  <span class="comment"># 张量→NumPy数组</span></span><br><span class="line">tf_np = tf.convert_to_tensor(np_a)  <span class="comment"># NumPy数组→张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 张量变形</span></span><br><span class="line">f = tf.reshape(a, (<span class="number">1</span>, <span class="number">4</span>))  <span class="comment"># 形状从(2,2)转为(1,4)</span></span><br><span class="line">g = tf.squeeze(f)  <span class="comment"># 移除维度为1的轴，形状从(1,4)转为(4,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵乘法结果:\n&quot;</span>, e.numpy())</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 矩阵乘法结果:</span></span><br><span class="line"><span class="comment">#  [[19. 22.]</span></span><br><span class="line"><span class="comment">#  [43. 50.]]</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）常量vs变量"><a href="#（3）常量vs变量" class="headerlink" title="（3）常量vs变量"></a>（3）常量vs变量</h4><ul>
<li><strong>tf.constant</strong>：创建不可修改的常量张量，用于存储固定数据（如输入数据、标签）；</li>
<li><strong>tf.Variable</strong>：创建可修改的变量张量，用于存储模型的可训练参数（如权重<code>W</code>、偏置<code>b</code>），会自动被TensorFlow的自动微分机制追踪梯度。</li>
</ul>
<h3 id="2-计算图（Computation-Graph）：运算的流程"><a href="#2-计算图（Computation-Graph）：运算的流程" class="headerlink" title="2. 计算图（Computation Graph）：运算的流程"></a>2. 计算图（Computation Graph）：运算的流程</h3><p>计算图是TensorFlow中<strong>描述运算流程的抽象表示</strong>，由“节点（Node，代表运算）”和“边（Edge，代表张量流向）”组成。</p>
<h4 id="（1）TF2的动态图与静态图"><a href="#（1）TF2的动态图与静态图" class="headerlink" title="（1）TF2的动态图与静态图"></a>（1）TF2的动态图与静态图</h4><p>TF2默认启用<strong>动态图（Eager Execution）</strong>，即“代码逐行执行，运算即时返回结果”，调试体验与Python原生代码一致（如用<code>print()</code>查看中间结果）；<br>若需提升训练性能（如大规模训练），可通过<code>tf.function</code>将动态图转为<strong>静态图（Graph Execution）</strong>——静态图会先优化运算流程（如合并冗余操作、并行化），再执行，效率更高。</p>
<p>示例：动态图与静态图的切换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 动态图（默认）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_dynamic</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">3</span>)</span><br><span class="line">b = tf.constant(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;动态图结果:&quot;</span>, add_dynamic(a, b).numpy())  <span class="comment"># 即时输出8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 静态图（用tf.function装饰）</span></span><br><span class="line"><span class="meta">@tf.function  </span><span class="comment"># 装饰后，函数会被转为静态图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_static</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次调用时构建静态图，后续调用复用图</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;静态图结果:&quot;</span>, add_static(a, b).numpy())  <span class="comment"># 输出8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;静态图结果（复用）:&quot;</span>, add_static(tf.constant(<span class="number">4</span>), tf.constant(<span class="number">6</span>)).numpy())  <span class="comment"># 输出10</span></span><br></pre></td></tr></table></figure>


<h3 id="3-自动微分（Automatic-Differentiation）：梯度计算的核心"><a href="#3-自动微分（Automatic-Differentiation）：梯度计算的核心" class="headerlink" title="3. 自动微分（Automatic Differentiation）：梯度计算的核心"></a>3. 自动微分（Automatic Differentiation）：梯度计算的核心</h3><p>深度学习的训练依赖“反向传播求梯度”，TensorFlow通过<strong>tf.GradientTape</strong>实现自动微分——它会“记录”上下文内的张量运算，然后反向计算指定变量的梯度。</p>
<p>示例：用tf.GradientTape求梯度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型参数（可训练变量）</span></span><br><span class="line">W = tf.Variable(<span class="number">2.0</span>, name=<span class="string">&quot;weight&quot;</span>)</span><br><span class="line">b = tf.Variable(<span class="number">1.0</span>, name=<span class="string">&quot;bias&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型（y = W*x + b）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> W * x + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数（均方误差）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss_fn</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.reduce_mean(tf.square(y_true - y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟输入数据和标签</span></span><br><span class="line">x = tf.constant([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line">y_true = tf.constant([<span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>])  <span class="comment"># 真实关系：y=2x+1，理论上损失应为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录运算，求梯度</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    y_pred = model(x)  <span class="comment"># 前向传播</span></span><br><span class="line">    loss = loss_fn(y_true, y_pred)  <span class="comment"># 计算损失</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求损失对W和b的梯度</span></span><br><span class="line">grads = tape.gradient(loss, [W, b])</span><br><span class="line">grad_W, grad_b = grads</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;损失:&quot;</span>, loss.numpy())  <span class="comment"># 输出0.0（因参数刚好匹配）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d(loss)/dW:&quot;</span>, grad_W.numpy())  <span class="comment"># 输出0.0（梯度为0，参数已最优）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d(loss)/db:&quot;</span>, grad_b.numpy())  <span class="comment"># 输出0.0</span></span><br></pre></td></tr></table></figure>


<h2 id="三、TensorFlow的核心组件（TF2生态）"><a href="#三、TensorFlow的核心组件（TF2生态）" class="headerlink" title="三、TensorFlow的核心组件（TF2生态）"></a>三、TensorFlow的核心组件（TF2生态）</h2><p>TF2的生态系统围绕“简化开发、提升效率、支持全场景部署”设计，核心组件可分为<strong>模型构建</strong>、<strong>数据处理</strong>、<strong>训练优化</strong>、<strong>可视化</strong>、<strong>部署</strong>五大类，各组件无缝协作。</p>
<h3 id="1-tf-keras：高层模型构建API（核心）"><a href="#1-tf-keras：高层模型构建API（核心）" class="headerlink" title="1. tf.keras：高层模型构建API（核心）"></a>1. tf.keras：高层模型构建API（核心）</h3><p><code>tf.keras</code>是TensorFlow官方推荐的<strong>高层模型构建API</strong>，源于Keras框架（2019年被谷歌整合进TF2），具有“简洁易用、模块化、可扩展”的特点，支持快速构建各类深度学习模型（如CNN、RNN、Transformer）。</p>
<h4 id="（1）tf-keras的两种模型构建方式"><a href="#（1）tf-keras的两种模型构建方式" class="headerlink" title="（1）tf.keras的两种模型构建方式"></a>（1）tf.keras的两种模型构建方式</h4><ul>
<li><strong>Sequential模型</strong>：适用于“线性堆叠的网络”（无分支、无跨层连接），如简单的全连接网络、基础CNN；</li>
<li><strong>Functional API</strong>：适用于“复杂网络”（有分支、跨层连接，如ResNet、Inception），灵活性更高。</li>
</ul>
<h4 id="示例1：用Sequential构建全连接网络（MNIST分类）"><a href="#示例1：用Sequential构建全连接网络（MNIST分类）" class="headerlink" title="示例1：用Sequential构建全连接网络（MNIST分类）"></a>示例1：用Sequential构建全连接网络（MNIST分类）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers, models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 构建Sequential模型</span></span><br><span class="line">model = models.Sequential([</span><br><span class="line">    layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),  <span class="comment"># 输入层：将28x28图像展平为784维向量</span></span><br><span class="line">    layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),  <span class="comment"># 隐藏层：128个神经元，ReLU激活</span></span><br><span class="line">    layers.Dropout(<span class="number">0.2</span>),  <span class="comment">#  dropout层：防止过拟合，随机丢弃20%的神经元</span></span><br><span class="line">    layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)  <span class="comment"># 输出层：10个类别（MNIST数字0-9），softmax激活</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看模型结构</span></span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment"># 输出模型各层的参数数量、输入输出形状：</span></span><br><span class="line"><span class="comment"># Model: &quot;sequential&quot;</span></span><br><span class="line"><span class="comment"># _________________________________________________________________</span></span><br><span class="line"><span class="comment">#  Layer (type)                Output Shape              Param #   </span></span><br><span class="line"><span class="comment"># =================================================================</span></span><br><span class="line"><span class="comment">#  flatten (Flatten)           (None, 784)               0         </span></span><br><span class="line"><span class="comment">#                                                                 </span></span><br><span class="line"><span class="comment">#  dense (Dense)               (None, 128)               100480    </span></span><br><span class="line"><span class="comment">#                                                                 </span></span><br><span class="line"><span class="comment">#  dropout (Dropout)           (None, 128)               0         </span></span><br><span class="line"><span class="comment">#                                                                 </span></span><br><span class="line"><span class="comment">#  dense_1 (Dense)             (None, 10)                1290      </span></span><br><span class="line"><span class="comment"># =================================================================</span></span><br><span class="line"><span class="comment"># Total params: 101,770</span></span><br><span class="line"><span class="comment"># Trainable params: 101,770</span></span><br><span class="line"><span class="comment"># Non-trainable params: 0</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2：用Functional-API构建残差块（ResNet核心）"><a href="#示例2：用Functional-API构建残差块（ResNet核心）" class="headerlink" title="示例2：用Functional API构建残差块（ResNet核心）"></a>示例2：用Functional API构建残差块（ResNet核心）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义残差块（有跨层连接）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">residual_block</span>(<span class="params">x, filters</span>):</span><br><span class="line">    <span class="comment"># 主路径</span></span><br><span class="line">    shortcut = x  <span class="comment">#  shortcut路径（跨层连接）</span></span><br><span class="line">    x = layers.Conv2D(filters, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    x = layers.Conv2D(filters, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 若shortcut与主路径输出通道数不一致，调整shortcut</span></span><br><span class="line">    <span class="keyword">if</span> shortcut.shape[-<span class="number">1</span>] != filters:</span><br><span class="line">        shortcut = layers.Conv2D(filters, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&#x27;same&#x27;</span>)(shortcut)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 主路径+shortcut，ReLU激活</span></span><br><span class="line">    x = layers.Add()([x, shortcut])</span><br><span class="line">    x = layers.Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ResNet-like模型</span></span><br><span class="line">inputs = layers.Input(shape=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>))  <span class="comment"># 输入：224x224 RGB图像</span></span><br><span class="line">x = layers.Conv2D(<span class="number">64</span>, (<span class="number">7</span>, <span class="number">7</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(inputs)</span><br><span class="line">x = layers.MaxPooling2D((<span class="number">3</span>, <span class="number">3</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠3个残差块</span></span><br><span class="line">x = residual_block(x, <span class="number">64</span>)</span><br><span class="line">x = residual_block(x, <span class="number">64</span>)</span><br><span class="line">x = residual_block(x, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局平均池化+全连接输出</span></span><br><span class="line">x = layers.GlobalAveragePooling2D()(x)</span><br><span class="line">outputs = layers.Dense(<span class="number">1000</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x)  <span class="comment"># 1000类（如ImageNet）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">model = tf.keras.Model(inputs=inputs, outputs=outputs)</span><br><span class="line">model.summary()  <span class="comment"># 查看复杂模型结构</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）tf-keras的核心功能"><a href="#（2）tf-keras的核心功能" class="headerlink" title="（2）tf.keras的核心功能"></a>（2）tf.keras的核心功能</h4><ul>
<li><strong>模型编译（compile）</strong>：指定优化器（如Adam）、损失函数（如SparseCategoricalCrossentropy）、评估指标（如accuracy）；</li>
<li><strong>模型训练（fit）</strong>：接收输入数据和标签，自动完成前向传播、反向求梯度、参数更新；</li>
<li><strong>模型评估（evaluate）</strong>：在测试集上评估模型性能；</li>
<li><strong>模型预测（predict）</strong>：对新数据进行预测；</li>
<li><strong>模型保存&#x2F;加载</strong>：支持<code>model.save()</code>保存完整模型（含结构、参数、优化器状态），<code>tf.keras.models.load_model()</code>加载模型。</li>
</ul>
<h3 id="2-tf-data：高效数据输入流水线"><a href="#2-tf-data：高效数据输入流水线" class="headerlink" title="2. tf.data：高效数据输入流水线"></a>2. tf.data：高效数据输入流水线</h3><p>深度学习训练常需处理海量数据（如百万级图像、TB级文本），<code>tf.data</code>是TensorFlow提供的<strong>高效数据输入管道API</strong>，支持：</p>
<ul>
<li>批量加载数据（从文件、内存、数据库等）；</li>
<li>自动预处理（如图像 resize、文本 tokenize）；</li>
<li>并行处理（多线程读取数据，缓解GPU等待CPU的“瓶颈”）；</li>
<li>数据打乱（shuffle）、重复（repeat）、预取（prefetch）等优化。</li>
</ul>
<h4 id="示例：用tf-data加载MNIST数据集"><a href="#示例：用tf-data加载MNIST数据集" class="headerlink" title="示例：用tf.data加载MNIST数据集"></a>示例：用tf.data加载MNIST数据集</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载MNIST数据集（tf.keras.datasets提供常用数据集）</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据预处理（归一化、类型转换）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">x, y</span>):</span><br><span class="line">    x = tf.cast(x, tf.float32) / <span class="number">255.0</span>  <span class="comment"># 图像归一化到[0,1]</span></span><br><span class="line">    x = tf.expand_dims(x, axis=-<span class="number">1</span>)  <span class="comment"># 增加通道维度：(28,28)→(28,28,1)</span></span><br><span class="line">    y = tf.cast(y, tf.int32)  <span class="comment"># 标签转为int32</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 构建训练数据流水线</span></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">train_ds = tf.data.Dataset.from_tensor_slices((x_train, y_train))  <span class="comment"># 从内存创建数据集</span></span><br><span class="line">train_ds = train_ds.shuffle(buffer_size=<span class="number">10000</span>)  <span class="comment"># 打乱数据（buffer_size越大，打乱越充分）</span></span><br><span class="line">train_ds = train_ds.<span class="built_in">map</span>(preprocess, num_parallel_calls=tf.data.AUTOTUNE)  <span class="comment"># 并行预处理</span></span><br><span class="line">train_ds = train_ds.batch(batch_size)  <span class="comment"># 按批次划分</span></span><br><span class="line">train_ds = train_ds.prefetch(tf.data.AUTOTUNE)  <span class="comment"># 预取数据（CPU准备下一批，GPU同时训练当前批）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 构建测试数据流水线（无需shuffle）</span></span><br><span class="line">test_ds = tf.data.Dataset.from_tensor_slices((x_test, y_test))</span><br><span class="line">test_ds = test_ds.<span class="built_in">map</span>(preprocess, num_parallel_calls=tf.data.AUTOTUNE)</span><br><span class="line">test_ds = test_ds.batch(batch_size)</span><br><span class="line">test_ds = test_ds.prefetch(tf.data.AUTOTUNE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 遍历数据集（训练时用fit直接接收train_ds）</span></span><br><span class="line"><span class="keyword">for</span> x_batch, y_batch <span class="keyword">in</span> train_ds.take(<span class="number">1</span>):  <span class="comment"># 取1批数据查看</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;批次图像形状:&quot;</span>, x_batch.shape)  <span class="comment"># (32, 28, 28, 1)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;批次标签形状:&quot;</span>, y_batch.shape)  <span class="comment"># (32,)</span></span><br></pre></td></tr></table></figure>


<h3 id="3-TensorBoard：训练过程可视化工具"><a href="#3-TensorBoard：训练过程可视化工具" class="headerlink" title="3. TensorBoard：训练过程可视化工具"></a>3. TensorBoard：训练过程可视化工具</h3><p>TensorBoard是TensorFlow内置的<strong>可视化工具</strong>，可实时监控训练过程中的关键指标（如损失、准确率）、查看模型结构、可视化张量分布、调试梯度等，帮助开发者分析模型训练情况（如是否过拟合、梯度是否消失）。</p>
<h4 id="示例：用TensorBoard监控MNIST训练"><a href="#示例：用TensorBoard监控MNIST训练" class="headerlink" title="示例：用TensorBoard监控MNIST训练"></a>示例：用TensorBoard监控MNIST训练</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 构建模型（复用之前的Sequential模型）</span></span><br><span class="line">model = tf.keras.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 配置TensorBoard回调（指定日志保存路径）</span></span><br><span class="line">log_dir = <span class="string">&quot;logs/fit/&quot;</span> + time.strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>, time.localtime())</span><br><span class="line">tensorboard_callback = TensorBoard(log_dir=log_dir, histogram_freq=<span class="number">1</span>)  <span class="comment"># histogram_freq=1：每1轮记录参数分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 训练模型（传入TensorBoard回调）</span></span><br><span class="line">history = model.fit(</span><br><span class="line">    train_ds,  <span class="comment"># 用tf.data构建的训练集</span></span><br><span class="line">    epochs=<span class="number">5</span>,  <span class="comment"># 训练5轮</span></span><br><span class="line">    validation_data=test_ds,  <span class="comment"># 验证集</span></span><br><span class="line">    callbacks=[tensorboard_callback]  <span class="comment"># 启用TensorBoard</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动TensorBoard（终端执行）</span></span><br><span class="line"><span class="comment"># tensorboard --logdir=logs/fit</span></span><br></pre></td></tr></table></figure>
<p>执行后，在浏览器访问<code>http://localhost:6006</code>，即可看到：</p>
<ul>
<li><strong>Scalars</strong>：损失、准确率随训练轮次的变化曲线；</li>
<li><strong>Graphs</strong>：模型的计算图结构；</li>
<li><strong>Histograms</strong>：权重、偏置的分布变化；</li>
<li><strong>Images</strong>：输入图像的样本展示。</li>
</ul>
<h3 id="4-tf-distribute：分布式训练"><a href="#4-tf-distribute：分布式训练" class="headerlink" title="4. tf.distribute：分布式训练"></a>4. tf.distribute：分布式训练</h3><p>当模型规模大（如Transformer）或数据量多时，单机单GPU训练速度慢，<code>tf.distribute</code>提供<strong>分布式训练API</strong>，支持多GPU、多机器、TPU（谷歌张量处理单元）训练，核心策略包括：</p>
<ul>
<li><strong>MirroredStrategy</strong>：单机多GPU训练，所有GPU复制相同的模型参数，数据分片处理，梯度同步更新（最常用）；</li>
<li><strong>MultiWorkerMirroredStrategy</strong>：多机多GPU训练，适用于超大规模模型；</li>
<li><strong>TPUStrategy</strong>：使用TPU训练，适合谷歌云TPU或Colab TPU。</li>
</ul>
<h4 id="示例：用MirroredStrategy实现单机多GPU训练"><a href="#示例：用MirroredStrategy实现单机多GPU训练" class="headerlink" title="示例：用MirroredStrategy实现单机多GPU训练"></a>示例：用MirroredStrategy实现单机多GPU训练</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 初始化分布式策略（自动检测可用GPU）</span></span><br><span class="line">strategy = tf.distribute.MirroredStrategy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;可用GPU数量: <span class="subst">&#123;strategy.num_replicas_in_sync&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在策略范围内构建和编译模型（确保参数在所有GPU间同步）</span></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">    model = tf.keras.Sequential([</span><br><span class="line">        tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">        tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    model.<span class="built_in">compile</span>(</span><br><span class="line">        optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">        metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 训练模型（与单机训练代码一致，tf.distribute自动处理数据分片和梯度同步）</span></span><br><span class="line">model.fit(</span><br><span class="line">    train_ds,</span><br><span class="line">    epochs=<span class="number">5</span>,</span><br><span class="line">    validation_data=test_ds</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="5-tf-lite：模型轻量化与部署"><a href="#5-tf-lite：模型轻量化与部署" class="headerlink" title="5. tf.lite：模型轻量化与部署"></a>5. tf.lite：模型轻量化与部署</h3><p>训练好的深度学习模型通常体积大、计算量大，难以直接部署到移动设备（手机）、嵌入式设备（树莓派）或物联网设备（传感器）。<code>tf.lite</code>（TensorFlow Lite）是TensorFlow的<strong>模型轻量化工具</strong>，通过以下方式优化模型：</p>
<ul>
<li><strong>量化（Quantization）</strong>：将32位浮点数（float32）参数转为8位整数（int8）或16位浮点数（float16），模型体积缩小4倍，速度提升2-4倍；</li>
<li><strong>剪枝（Pruning）</strong>：移除模型中冗余的参数和神经元，进一步减小模型体积；</li>
<li><strong>优化算子</strong>：替换复杂算子为轻量级算子，适配嵌入式硬件。</li>
</ul>
<h4 id="示例：将MNIST模型转为TFLite格式并部署"><a href="#示例：将MNIST模型转为TFLite格式并部署" class="headerlink" title="示例：将MNIST模型转为TFLite格式并部署"></a>示例：将MNIST模型转为TFLite格式并部署</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载训练好的模型（假设已保存为mnist_model.h5）</span></span><br><span class="line">model = tf.keras.models.load_model(<span class="string">&quot;mnist_model.h5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 转换模型为TFLite格式（启用int8量化）</span></span><br><span class="line">converter = tf.lite.TFLiteConverter.from_keras_model(model)</span><br><span class="line"><span class="comment"># 启用全整数量化（需提供代表性数据集，用于校准量化范围）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">representative_data_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> x_batch, _ <span class="keyword">in</span> train_ds.take(<span class="number">100</span>):  <span class="comment"># 取100批数据作为代表性数据</span></span><br><span class="line">        <span class="keyword">yield</span> [x_batch]</span><br><span class="line"></span><br><span class="line">converter.optimizations = [tf.lite.Optimize.DEFAULT]</span><br><span class="line">converter.representative_dataset = representative_data_gen</span><br><span class="line">converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]</span><br><span class="line">converter.inference_input_type = tf.int8  <span class="comment"># 输入类型为int8</span></span><br><span class="line">converter.inference_output_type = tf.int8  <span class="comment"># 输出类型为int8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换模型</span></span><br><span class="line">tflite_quant_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 保存TFLite模型</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mnist_model_quant.tflite&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(tflite_quant_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 在Python中测试TFLite模型（嵌入式设备中用C++/Java API加载）</span></span><br><span class="line">interpreter = tf.lite.Interpreter(model_path=<span class="string">&quot;mnist_model_quant.tflite&quot;</span>)</span><br><span class="line">interpreter.allocate_tensors()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输入/输出张量索引</span></span><br><span class="line">input_details = interpreter.get_input_details()</span><br><span class="line">output_details = interpreter.get_output_details()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试单张图像</span></span><br><span class="line">x_test_sample = tf.cast(x_test[<span class="number">0</span>:<span class="number">1</span>] / <span class="number">255.0</span>, tf.float32)  <span class="comment"># 预处理（与训练时一致）</span></span><br><span class="line">x_test_sample = tf.expand_dims(x_test_sample, axis=-<span class="number">1</span>)</span><br><span class="line">x_test_sample_quant = tf.cast(x_test_sample, tf.int8)  <span class="comment"># 转为int8（与量化模型输入一致）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输入数据</span></span><br><span class="line">interpreter.set_tensor(input_details[<span class="number">0</span>][<span class="string">&#x27;index&#x27;</span>], x_test_sample_quant)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行推理</span></span><br><span class="line">interpreter.invoke()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输出结果</span></span><br><span class="line">output_data = interpreter.get_tensor(output_details[<span class="number">0</span>][<span class="string">&#x27;index&#x27;</span>])</span><br><span class="line">pred_label = tf.argmax(output_data, axis=<span class="number">1</span>).numpy()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;预测标签: <span class="subst">&#123;pred_label&#125;</span>, 真实标签: <span class="subst">&#123;y_test[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>


<h2 id="四、TensorFlow的典型应用场景"><a href="#四、TensorFlow的典型应用场景" class="headerlink" title="四、TensorFlow的典型应用场景"></a>四、TensorFlow的典型应用场景</h2><p>TensorFlow的灵活性和生态完善性使其适用于各类深度学习场景，以下是最常见的应用领域：</p>
<h3 id="1-计算机视觉（Computer-Vision-CV）"><a href="#1-计算机视觉（Computer-Vision-CV）" class="headerlink" title="1. 计算机视觉（Computer Vision, CV）"></a>1. 计算机视觉（Computer Vision, CV）</h3><p>TensorFlow提供<code>tf.keras.applications</code>（预训练模型库），包含ResNet、MobileNet、EfficientNet、YOLO（第三方集成）等主流CV模型，可直接用于：</p>
<ul>
<li><strong>图像分类</strong>：如识别图片中的物体（猫、狗、汽车）；</li>
<li><strong>目标检测</strong>：如检测图像中多个物体的位置和类别（如自动驾驶中的行人、车辆检测）；</li>
<li><strong>图像分割</strong>：如医学影像中的肿瘤分割、自动驾驶中的道路分割；</li>
<li><strong>图像生成</strong>：如GAN（生成对抗网络）生成逼真图像、StyleGAN实现图像风格迁移。</li>
</ul>
<h4 id="示例：用预训练MobileNetV2做图像分类"><a href="#示例：用预训练MobileNetV2做图像分类" class="headerlink" title="示例：用预训练MobileNetV2做图像分类"></a>示例：用预训练MobileNetV2做图像分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> MobileNetV2</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载预训练MobileNetV2（不含顶层分类层，需自定义）</span></span><br><span class="line">base_model = MobileNetV2(</span><br><span class="line">    input_shape=(<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>),</span><br><span class="line">    include_top=<span class="literal">False</span>,  <span class="comment"># 不包含顶层分类层</span></span><br><span class="line">    weights=<span class="string">&#x27;imagenet&#x27;</span>  <span class="comment"># 使用ImageNet预训练权重</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 冻结基础模型（仅训练顶层分类层）</span></span><br><span class="line">base_model.trainable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加顶层分类层（假设分类10类）</span></span><br><span class="line">model = tf.keras.Sequential([</span><br><span class="line">    base_model,</span><br><span class="line">    tf.keras.layers.GlobalAveragePooling2D(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 编译模型（仅训练顶层）</span></span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. （可选）微调基础模型（训练后期解冻部分层，提升精度）</span></span><br><span class="line"><span class="comment"># base_model.trainable = True</span></span><br><span class="line"><span class="comment"># fine_tune_at = 100  # 解冻第100层之后的层</span></span><br><span class="line"><span class="comment"># for layer in base_model.layers[:fine_tune_at]:</span></span><br><span class="line"><span class="comment">#     layer.trainable = False</span></span><br><span class="line"><span class="comment"># model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-5), ...)</span></span><br></pre></td></tr></table></figure>


<h3 id="2-自然语言处理（Natural-Language-Processing-NLP）"><a href="#2-自然语言处理（Natural-Language-Processing-NLP）" class="headerlink" title="2. 自然语言处理（Natural Language Processing, NLP）"></a>2. 自然语言处理（Natural Language Processing, NLP）</h3><p>TensorFlow提供<code>tf.keras.preprocessing.text</code>（文本处理）、<code>tf.keras.layers.Embedding</code>（词嵌入），以及<code>TensorFlow Hub</code>（预训练NLP模型库，如BERT、GPT-2），支持：</p>
<ul>
<li><strong>文本分类</strong>：如垃圾邮件检测、情感分析（正面&#x2F;负面评价）；</li>
<li><strong>机器翻译</strong>：如中英互译（用Transformer模型）；</li>
<li><strong>问答系统</strong>：如基于BERT的抽取式问答（从文本中提取答案）；</li>
<li><strong>文本生成</strong>：如自动写文章、诗歌（用GPT类模型）。</li>
</ul>
<h4 id="示例：用TensorFlow-Hub加载预训练BERT做文本分类"><a href="#示例：用TensorFlow-Hub加载预训练BERT做文本分类" class="headerlink" title="示例：用TensorFlow Hub加载预训练BERT做文本分类"></a>示例：用TensorFlow Hub加载预训练BERT做文本分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow_hub <span class="keyword">as</span> hub</span><br><span class="line"><span class="keyword">import</span> tensorflow_text <span class="keyword">as</span> text  <span class="comment"># 处理BERT输入的文本预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载预训练BERT模型（从TensorFlow Hub）</span></span><br><span class="line">bert_preprocess = hub.KerasLayer(<span class="string">&quot;https://tfhub.dev/tensorflow/bert_en_uncased_preprocess/3&quot;</span>)</span><br><span class="line">bert_encoder = hub.KerasLayer(<span class="string">&quot;https://tfhub.dev/tensorflow/bert_en_uncased_L-12_H-768_A-12/4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构建BERT文本分类模型</span></span><br><span class="line">inputs = tf.keras.Input(shape=(), dtype=tf.string, name=<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">preprocessed_text = bert_preprocess(inputs)</span><br><span class="line">outputs = bert_encoder(preprocessed_text)</span><br><span class="line"><span class="comment"># 取BERT的[CLS] token输出作为文本表示</span></span><br><span class="line">pooled_output = outputs[<span class="string">&#x27;pooled_output&#x27;</span>]</span><br><span class="line"><span class="comment"># 分类层（二分类：正面/负面情感）</span></span><br><span class="line">predctions = tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)(pooled_output)</span><br><span class="line"></span><br><span class="line">model = tf.keras.Model(inputs=inputs, outputs=predctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 训练模型（假设已准备好文本数据和标签）</span></span><br><span class="line"><span class="comment"># model.fit(texts, labels, epochs=5, validation_split=0.2)</span></span><br></pre></td></tr></table></figure>


<h3 id="3-推荐系统"><a href="#3-推荐系统" class="headerlink" title="3. 推荐系统"></a>3. 推荐系统</h3><p>TensorFlow的<code>tf.keras</code>和<code>tf.distribute</code>支持构建大规模推荐模型，如：</p>
<ul>
<li><strong>协同过滤</strong>：基于用户-物品交互数据推荐（如“喜欢该商品的用户还喜欢”）；</li>
<li><strong>深度学习推荐模型（DeepFM、Wide &amp; Deep）</strong>：结合用户特征、物品特征、上下文特征，提升推荐精度；</li>
<li><strong>实时推荐</strong>：用TensorFlow Serving部署模型，低延迟响应推荐请求。</li>
</ul>
<h3 id="4-强化学习（Reinforcement-Learning-RL）"><a href="#4-强化学习（Reinforcement-Learning-RL）" class="headerlink" title="4. 强化学习（Reinforcement Learning, RL）"></a>4. 强化学习（Reinforcement Learning, RL）</h3><p>TensorFlow提供<code>tf_agents</code>（强化学习库），支持构建和训练强化学习智能体，应用于：</p>
<ul>
<li><strong>游戏AI</strong>：如Atari游戏、围棋（AlphaGo的核心框架之一）；</li>
<li><strong>机器人控制</strong>：如机械臂抓取、无人机导航；</li>
<li><strong>资源调度</strong>：如数据中心的GPU资源调度、网络流量优化。</li>
</ul>
<h2 id="五、TensorFlow的优缺点与适用人群"><a href="#五、TensorFlow的优缺点与适用人群" class="headerlink" title="五、TensorFlow的优缺点与适用人群"></a>五、TensorFlow的优缺点与适用人群</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul>
<li><strong>生态完善</strong>：覆盖数据处理、模型构建、训练、可视化、部署全流程，工具链成熟；</li>
<li><strong>部署能力强</strong>：支持多平台（PC、移动、嵌入式、云、浏览器），尤其在工业级部署中占主导地位；</li>
<li><strong>文档丰富</strong>：官方文档详细，教程覆盖从入门到进阶，社区活跃（Stack Overflow、GitHub）；</li>
<li><strong>大规模训练支持</strong>：tf.distribute和TPU支持超大规模模型训练（如GPT-3类模型）；</li>
<li><strong>兼容性好</strong>：与Python生态（NumPy、Pandas）无缝集成，支持自定义算子和模型。</li>
</ul>
<h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ul>
<li><strong>动态图调试体验略逊于PyTorch</strong>：虽然TF2支持动态图，但在复杂模型的梯度调试、中间结果查看上，PyTorch更直观；</li>
<li><strong>入门门槛稍高</strong>：相比PyTorch的“简洁API”，TensorFlow的API层次更多（如tf.keras、tf.raw_ops），新手需适应；</li>
<li><strong>部分特性依赖第三方库</strong>：如目标检测（需用TensorFlow Models库中的Object Detection API），集成成本略高。</li>
</ul>
<h3 id="3-适用人群"><a href="#3-适用人群" class="headerlink" title="3. 适用人群"></a>3. 适用人群</h3><ul>
<li><strong>工业级开发人员</strong>：需部署模型到多平台，或处理大规模数据&#x2F;模型；</li>
<li><strong>科研人员</strong>：需使用预训练模型快速迭代，或构建复杂网络（如Transformer、GAN）；</li>
<li><strong>初学者</strong>：建议从tf.keras入手，逐步深入底层API；</li>
<li><strong>不适用场景</strong>：快速原型开发（如几行代码验证简单想法），PyTorch更合适。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>TensorFlow是一款“全面且强大”的深度学习框架，其核心优势在于<strong>完善的生态系统、跨平台部署能力和大规模训练支持</strong>。TF2通过动态图、tf.keras等设计，大幅降低了入门门槛，同时保留了底层灵活性，既能满足初学者快速构建模型的需求，也能支撑工业界超大规模AI系统的开发。</p>
<p>对于开发者而言，掌握TensorFlow的关键是：</p>
<ol>
<li>理解核心概念（张量、计算图、自动微分）；</li>
<li>熟练使用tf.keras构建和训练模型；</li>
<li>利用tf.data、TensorBoard提升开发效率；</li>
<li>根据场景选择部署方式（如tf.lite用于嵌入式，TensorFlow Serving用于云服务）。</li>
</ol>
<p>随着AI技术的发展，TensorFlow持续迭代（如支持大语言模型训练、强化学习），仍是未来深度学习领域的核心工具之一。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch深度学习框架：核心原理、组件、流程与实战详解</title>
    <url>/2025/09/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/pytorch/</url>
    <content><![CDATA[<h1 id="title-PyTorch深度学习框架：核心原理、组件、实战与生态详解"><a href="#title-PyTorch深度学习框架：核心原理、组件、实战与生态详解" class="headerlink" title="title: PyTorch深度学习框架：核心原理、组件、实战与生态详解"></a>title: PyTorch深度学习框架：核心原理、组件、实战与生态详解</h1><p>PyTorch是由Meta（原Facebook）开源的<strong>端到端深度学习框架</strong>，自2016年首次发布以来，凭借其<strong>动态计算图的灵活性、简洁直观的API设计、强大的科研适配能力</strong>，迅速成为学术界和工业界的主流选择。它既支持快速原型开发（如几行代码验证算法想法），也能支撑大规模模型训练（如大语言模型、计算机视觉模型），尤其在科研创新、中小规模工业应用场景中占据主导地位。本文将从PyTorch的核心定位、核心概念、架构组件、实战示例到生态系统，全面解析这一框架的原理与应用，帮助读者掌握其核心用法。</p>
<h2 id="一、PyTorch的核心定位与版本演进"><a href="#一、PyTorch的核心定位与版本演进" class="headerlink" title="一、PyTorch的核心定位与版本演进"></a>一、PyTorch的核心定位与版本演进</h2><p>在深入技术细节前，先明确PyTorch的核心价值——它的设计理念是“<strong>让深度学习更简单、更灵活</strong>”，这与TensorFlow（早期侧重静态图和工业部署）形成鲜明对比，也决定了其在科研领域的优势。</p>
<h3 id="1-核心定位"><a href="#1-核心定位" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h3><ul>
<li><strong>动态优先</strong>：默认采用动态计算图（Eager Execution），代码“逐行执行、即时反馈”，调试体验与Python原生代码一致（如直接<code>print</code>中间结果）；</li>
<li><strong>科研友好</strong>：支持灵活的模型结构（如条件分支、循环、动态修改网络层数），无需提前定义完整计算图，适配科研中“快速迭代算法”的需求；</li>
<li><strong>API简洁</strong>：接口设计贴近Python直觉（如张量操作与NumPy高度兼容），学习成本低，新手可快速上手；</li>
<li><strong>生态完善</strong>：围绕核心框架形成了丰富的扩展库（如TorchVision、TorchText、Hugging Face Transformers），覆盖计算机视觉、自然语言处理、强化学习等领域。</li>
</ul>
<h3 id="2-关键版本演进"><a href="#2-关键版本演进" class="headerlink" title="2. 关键版本演进"></a>2. 关键版本演进</h3><p>PyTorch的版本迭代围绕“提升性能、完善部署能力、扩展生态”展开，核心里程碑版本如下：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th>核心特性</th>
</tr>
</thead>
<tbody><tr>
<td>PyTorch 0.1</td>
<td>2016年</td>
<td>首次发布，奠定动态计算图核心，支持基本张量操作和神经网络模块</td>
</tr>
<tr>
<td>PyTorch 1.0</td>
<td>2018年</td>
<td>引入TorchScript（动态图转静态图，支持部署）、分布式训练（torch.distributed）</td>
</tr>
<tr>
<td>PyTorch 1.5</td>
<td>2020年</td>
<td>增强自动微分稳定性、优化CUDA支持，引入TorchServe（模型服务化部署）</td>
</tr>
<tr>
<td>PyTorch 1.10+</td>
<td>2021-2023年</td>
<td>完善大语言模型（LLM）训练支持、优化Transformer性能、增强移动部署（TorchMobile）</td>
</tr>
<tr>
<td>PyTorch 2.0</td>
<td>2023年</td>
<td>引入Compile（即时编译优化，提升静态图性能）、改进分布式训练效率，性能接近TensorFlow</td>
</tr>
</tbody></table>
<p>目前PyTorch 2.x已成为主流，其核心改进（如<code>torch.compile</code>）在保留动态图灵活性的同时，大幅提升了训练和推理性能，缩小了与静态图框架的性能差距。</p>
<h2 id="二、PyTorch的核心概念"><a href="#二、PyTorch的核心概念" class="headerlink" title="二、PyTorch的核心概念"></a>二、PyTorch的核心概念</h2><p>PyTorch的核心概念围绕“<strong>张量（Tensor）</strong>”和“<strong>动态计算图（Dynamic Computation Graph）</strong>”展开，理解这两个概念是使用PyTorch的基础。</p>
<h3 id="1-张量（Tensor）：数据的载体"><a href="#1-张量（Tensor）：数据的载体" class="headerlink" title="1. 张量（Tensor）：数据的载体"></a>1. 张量（Tensor）：数据的载体</h3><p>张量是PyTorch中最基本的数据结构，本质是“<strong>多维数组</strong>”，用于存储输入数据、模型参数、中间计算结果。它与NumPy数组类似，但支持GPU加速、自动微分追踪，是PyTorch所有运算的基础。</p>
<h4 id="（1）张量的核心属性"><a href="#（1）张量的核心属性" class="headerlink" title="（1）张量的核心属性"></a>（1）张量的核心属性</h4><ul>
<li><strong>阶（Rank）</strong>：张量的维度数，对应NumPy的“ndim”。例如：<ul>
<li>0阶张量（标量）：<code>torch.tensor(5)</code> → 形状<code>()</code>；</li>
<li>1阶张量（向量）：<code>torch.tensor([1,2,3])</code> → 形状<code>(3,)</code>；</li>
<li>2阶张量（矩阵）：<code>torch.tensor([[1,2],[3,4]])</code> → 形状<code>(2,2)</code>；</li>
<li>高阶张量：如3阶张量（<code>(2,3,4)</code>）可表示“2个3行4列的矩阵”，4阶张量（<code>(batch_size, channels, height, width)</code>）是计算机视觉中图像数据的标准格式（如<code>(32, 3, 224, 224)</code>表示32张3通道224x224的RGB图像）。</li>
</ul>
</li>
<li><strong>形状（Shape）</strong>：各维度的元素个数，可通过<code>tensor.shape</code>或<code>tensor.size()</code>获取。</li>
<li><strong>数据类型（Dtype）</strong>：张量元素的类型，常用类型包括<code>torch.float32</code>（默认浮点类型）、<code>torch.int32</code>、<code>torch.bool</code>，需注意与NumPy类型的兼容（可通过<code>torch.as_tensor()</code>或<code>numpy()</code>转换）。</li>
<li><strong>设备（Device）</strong>：张量存储的硬件位置，分为<code>cpu</code>和<code>cuda</code>（GPU），可通过<code>tensor.device</code>获取，通过<code>tensor.to(device)</code>迁移。</li>
</ul>
<h4 id="（2）张量的创建与操作"><a href="#（2）张量的创建与操作" class="headerlink" title="（2）张量的创建与操作"></a>（2）张量的创建与操作</h4><p>PyTorch提供了丰富的张量创建和运算API，与NumPy接口高度一致，降低学习成本。示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 张量创建</span></span><br><span class="line"><span class="comment"># 从Python列表创建</span></span><br><span class="line">t1 = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=torch.float32)</span><br><span class="line"><span class="comment"># 从NumPy数组创建（共享内存，修改一个会影响另一个）</span></span><br><span class="line">np_arr = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float32)</span><br><span class="line">t2 = torch.as_tensor(np_arr)</span><br><span class="line"><span class="comment"># 创建全零/全一张量</span></span><br><span class="line">t3 = torch.zeros((<span class="number">2</span>, <span class="number">3</span>))  <span class="comment"># 形状(2,3)的全零张量</span></span><br><span class="line">t4 = torch.ones((<span class="number">3</span>, <span class="number">3</span>), dtype=torch.int32)  <span class="comment"># 形状(3,3)的全一张量</span></span><br><span class="line"><span class="comment"># 创建随机张量（正态分布）</span></span><br><span class="line">t5 = torch.randn((<span class="number">2</span>, <span class="number">2</span>))  <span class="comment"># 均值0、方差1的正态分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 基本运算（支持广播机制）</span></span><br><span class="line">t_add = t1 + t2  <span class="comment"># 元素加法（等价于torch.add(t1, t2)）</span></span><br><span class="line">t_mul = t1 * t2  <span class="comment"># 元素乘法（等价于torch.mul(t1, t2)）</span></span><br><span class="line">t_matmul = torch.matmul(t1, t2)  <span class="comment"># 矩阵乘法（等价于t1 @ t2）</span></span><br><span class="line">t_reshape = t1.view((<span class="number">1</span>, <span class="number">4</span>))  <span class="comment"># 形状重塑（从(2,2)到(1,4)，需保证元素总数一致）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设备迁移（CPU ↔ GPU）</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">t1_cuda = t1.to(device)  <span class="comment"># 迁移到GPU（若有GPU）</span></span><br><span class="line">t1_cpu = t1_cuda.cpu()   <span class="comment"># 迁移回CPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 与NumPy转换</span></span><br><span class="line">t1_np = t1.numpy()  <span class="comment"># 张量→NumPy数组（CPU张量才可转换）</span></span><br><span class="line">np_to_t = torch.from_numpy(np_arr)  <span class="comment"># NumPy数组→张量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵乘法结果:\n&quot;</span>, t_matmul)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 矩阵乘法结果:</span></span><br><span class="line"><span class="comment">#  tensor([[19., 22.],</span></span><br><span class="line"><span class="comment">#         [43., 50.]])</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）可训练张量：requires-grad与梯度追踪"><a href="#（3）可训练张量：requires-grad与梯度追踪" class="headerlink" title="（3）可训练张量：requires_grad与梯度追踪"></a>（3）可训练张量：requires_grad与梯度追踪</h4><p>PyTorch的张量通过<code>requires_grad=True</code>标记为“<strong>可训练张量</strong>”（通常是模型的权重和偏置），自动微分机制会追踪其参与的所有运算，以便后续计算梯度。示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可训练张量（requires_grad=True）</span></span><br><span class="line">w = torch.tensor(<span class="number">2.0</span>, requires_grad=<span class="literal">True</span>)  <span class="comment"># 权重</span></span><br><span class="line">b = torch.tensor(<span class="number">1.0</span>, requires_grad=<span class="literal">True</span>)  <span class="comment"># 偏置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义运算（y = w*x + b）</span></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line">y_pred = w * x + b</span><br><span class="line">y_true = torch.tensor([<span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>])  <span class="comment"># 真实标签（y=2x+1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算损失（均方误差）</span></span><br><span class="line">loss = torch.mean((y_pred - y_true) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向传播计算梯度（对w和b求导）</span></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度（d(loss)/dw 和 d(loss)/db）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w的梯度:&quot;</span>, w.grad)  <span class="comment"># 输出0.0（因参数刚好匹配，损失为0）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b的梯度:&quot;</span>, b.grad)  <span class="comment"># 输出0.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;是否追踪梯度:&quot;</span>, w.requires_grad)  <span class="comment"># 输出True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键说明</strong>：只有<code>requires_grad=True</code>的张量才会被追踪梯度；运算结果（如<code>y_pred</code>、<code>loss</code>）会自动继承<code>requires_grad</code>属性；<code>backward()</code>后，梯度会存储在<code>tensor.grad</code>中，下次反向传播前需用<code>optimizer.zero_grad()</code>或<code>tensor.grad.zero_()</code>清空梯度，避免累积。</li>
</ul>
<h3 id="2-动态计算图（Dynamic-Computation-Graph）：灵活的运算流程"><a href="#2-动态计算图（Dynamic-Computation-Graph）：灵活的运算流程" class="headerlink" title="2. 动态计算图（Dynamic Computation Graph）：灵活的运算流程"></a>2. 动态计算图（Dynamic Computation Graph）：灵活的运算流程</h3><p>计算图是描述“张量运算依赖关系”的抽象结构（节点&#x3D;运算，边&#x3D;张量流向），PyTorch的核心优势是“<strong>动态计算图</strong>”——运算与图构建同步进行，支持实时修改图结构（如条件、循环），调试更直观。</p>
<h4 id="动态图vs静态图（以TensorFlow-1-x为例）"><a href="#动态图vs静态图（以TensorFlow-1-x为例）" class="headerlink" title="动态图vs静态图（以TensorFlow 1.x为例）"></a>动态图vs静态图（以TensorFlow 1.x为例）</h4><table>
<thead>
<tr>
<th>特性</th>
<th>PyTorch动态图</th>
<th>TensorFlow 1.x静态图</th>
</tr>
</thead>
<tbody><tr>
<td>图构建时机</td>
<td>运算执行时实时构建</td>
<td>先定义完整图，再通过Session执行</td>
</tr>
<tr>
<td>灵活性</td>
<td>支持条件（if）、循环（for）、动态修改网络</td>
<td>需通过控制流算子（如tf.cond），灵活性低</td>
</tr>
<tr>
<td>调试体验</td>
<td>可直接print中间结果，报错定位清晰</td>
<td>需通过Session.run()获取结果，调试复杂</td>
</tr>
<tr>
<td>适用场景</td>
<td>科研快速迭代、复杂动态模型</td>
<td>大规模工业部署、固定流程模型</td>
</tr>
</tbody></table>
<h4 id="动态图示例：带条件分支的模型"><a href="#动态图示例：带条件分支的模型" class="headerlink" title="动态图示例：带条件分支的模型"></a>动态图示例：带条件分支的模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_model</span>(<span class="params">x, use_relu</span>):</span><br><span class="line">    <span class="comment"># 动态条件分支：根据use_relu决定是否使用ReLU激活</span></span><br><span class="line">    <span class="keyword">if</span> use_relu:</span><br><span class="line">        y = torch.relu(x ** <span class="number">2</span> - <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y = x ** <span class="number">2</span> - <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试两种分支（动态构建不同计算图）</span></span><br><span class="line">x = torch.tensor([-<span class="number">3.0</span>, -<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支1：使用ReLU</span></span><br><span class="line">y1 = dynamic_model(x, use_relu=<span class="literal">True</span>)</span><br><span class="line">y1.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ReLU分支x的梯度:&quot;</span>, x.grad)  <span class="comment"># 梯度仅非负部分有值</span></span><br><span class="line">x.grad.zero_()  <span class="comment"># 清空梯度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支2：不使用ReLU</span></span><br><span class="line">y2 = dynamic_model(x, use_relu=<span class="literal">False</span>)</span><br><span class="line">y2.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无ReLU分支x的梯度:&quot;</span>, x.grad)  <span class="comment"># 梯度全量计算</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>核心优势</strong>：上述代码中，<code>use_relu</code>为<code>True</code>或<code>False</code>时，计算图结构完全不同，PyTorch可实时适配，无需提前定义两种图结构——这对科研中“动态调整模型逻辑”（如根据输入长度修改网络层数）至关重要。</li>
</ul>
<h3 id="3-自动微分（Autograd）：梯度计算的核心"><a href="#3-自动微分（Autograd）：梯度计算的核心" class="headerlink" title="3. 自动微分（Autograd）：梯度计算的核心"></a>3. 自动微分（Autograd）：梯度计算的核心</h3><p>PyTorch的<code>autograd</code>模块是动态计算图的“梯度引擎”，通过<strong>反向模式自动微分</strong>（Reverse Mode Automatic Differentiation）计算张量的梯度，无需手动推导导数公式。其核心逻辑是：</p>
<ol>
<li><strong>前向传播</strong>：执行张量运算时，<code>autograd</code>记录运算操作和依赖关系（存储在<code>Function</code>对象中）；</li>
<li><strong>反向传播</strong>：调用<code>loss.backward()</code>时，从损失张量（标量）出发，沿依赖关系反向遍历计算图，通过链式法则计算每个<code>requires_grad=True</code>张量的梯度；</li>
<li><strong>梯度存储</strong>：梯度结果存储在张量的<code>grad</code>属性中，供优化器更新参数。</li>
</ol>
<h4 id="关键特性："><a href="#关键特性：" class="headerlink" title="关键特性："></a>关键特性：</h4><ul>
<li><strong>支持非标量梯度</strong>：若输出是向量&#x2F;矩阵，需通过<code>backward()</code>的<code>grad_tensors</code>参数指定“梯度权重”（如<code>y.backward(torch.ones_like(y))</code>）；</li>
<li><strong>梯度切断</strong>：通过<code>torch.no_grad()</code>或<code>tensor.detach()</code>临时禁用梯度追踪（如验证阶段冻结模型参数）；</li>
<li><strong>自定义梯度</strong>：通过<code>torch.autograd.Function</code>自定义运算的前向和反向传播逻辑（如实现自定义算子）。</li>
</ul>
<h2 id="三、PyTorch的核心组件（架构与生态）"><a href="#三、PyTorch的核心组件（架构与生态）" class="headerlink" title="三、PyTorch的核心组件（架构与生态）"></a>三、PyTorch的核心组件（架构与生态）</h2><p>PyTorch的核心组件围绕“模型构建→数据处理→训练优化→可视化→部署”全流程设计，各组件简洁直观，且无缝协作。</p>
<h3 id="1-torch-nn：神经网络构建核心"><a href="#1-torch-nn：神经网络构建核心" class="headerlink" title="1. torch.nn：神经网络构建核心"></a>1. torch.nn：神经网络构建核心</h3><p><code>torch.nn</code>是PyTorch用于构建神经网络的核心模块，提供了“<strong>层（Layers）</strong>”、“<strong>损失函数（Loss Functions）</strong>”、“<strong>模型容器（Containers）</strong>”等基础组件，支持快速搭建各类深度学习模型（如CNN、RNN、Transformer）。</p>
<h4 id="（1）核心容器：Sequential与Module"><a href="#（1）核心容器：Sequential与Module" class="headerlink" title="（1）核心容器：Sequential与Module"></a>（1）核心容器：Sequential与Module</h4><ul>
<li><strong>Sequential</strong>：适用于“线性堆叠的网络”（无分支、无跨层连接），如简单全连接网络、基础CNN，使用简单但灵活性低；</li>
<li><strong>Module</strong>：自定义模型的基类，适用于“复杂网络”（有分支、跨层连接、动态逻辑），需重写<code>__init__</code>（定义层）和<code>forward</code>（定义前向传播逻辑），灵活性最高。</li>
</ul>
<h4 id="示例1：用Sequential构建全连接网络（MNIST分类）"><a href="#示例1：用Sequential构建全连接网络（MNIST分类）" class="headerlink" title="示例1：用Sequential构建全连接网络（MNIST分类）"></a>示例1：用Sequential构建全连接网络（MNIST分类）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建线性堆叠网络</span></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Flatten(input_size=(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)),  <span class="comment"># 输入层：展平28x28单通道图像→784维向量</span></span><br><span class="line">    nn.Linear(<span class="number">784</span>, <span class="number">128</span>),                 <span class="comment"># 隐藏层：784→128维</span></span><br><span class="line">    nn.ReLU(),                           <span class="comment"># ReLU激活函数</span></span><br><span class="line">    nn.Dropout(<span class="number">0.2</span>),                     <span class="comment"># Dropout层：防止过拟合，随机丢弃20%神经元</span></span><br><span class="line">    nn.Linear(<span class="number">128</span>, <span class="number">10</span>),                  <span class="comment"># 输出层：128→10维（MNIST 0-9分类）</span></span><br><span class="line">    nn.Softmax(dim=<span class="number">1</span>)                    <span class="comment"># Softmax激活：输出类别概率</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模型结构</span></span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Sequential(</span></span><br><span class="line"><span class="comment">#   (0): Flatten(start_dim=1, end_dim=-1)</span></span><br><span class="line"><span class="comment">#   (1): Linear(in_features=784, out_features=128, bias=True)</span></span><br><span class="line"><span class="comment">#   (2): ReLU()</span></span><br><span class="line"><span class="comment">#   (3): Dropout(p=0.2, inplace=False)</span></span><br><span class="line"><span class="comment">#   (4): Linear(in_features=128, out_features=10, bias=True)</span></span><br><span class="line"><span class="comment">#   (5): Softmax(dim=1)</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试模型输入输出</span></span><br><span class="line">x = torch.randn(<span class="number">32</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)  <span class="comment"># 32个样本，1通道，28x28图像</span></span><br><span class="line">y_pred = model(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出形状:&quot;</span>, y_pred.shape)  <span class="comment"># 输出(32, 10)：32个样本，每个样本10个类别概率</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2：用Module自定义残差块（ResNet核心）"><a href="#示例2：用Module自定义残差块（ResNet核心）" class="headerlink" title="示例2：用Module自定义残差块（ResNet核心）"></a>示例2：用Module自定义残差块（ResNet核心）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义残差块（有跨层连接）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResidualBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResidualBlock, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="comment"># 主路径：两个3x3卷积+ReLU</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#  shortcut路径：若输入输出通道数不一致，用1x1卷积调整</span></span><br><span class="line">        <span class="variable language_">self</span>.shortcut = nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">1</span>) <span class="keyword">if</span> in_channels != out_channels <span class="keyword">else</span> nn.Identity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 前向传播逻辑</span></span><br><span class="line">        residual = <span class="variable language_">self</span>.shortcut(x)  <span class="comment"># shortcut路径</span></span><br><span class="line">        out = F.relu(<span class="variable language_">self</span>.conv1(x))  <span class="comment"># 主路径第一卷积+ReLU</span></span><br><span class="line">        out = <span class="variable language_">self</span>.conv2(out)        <span class="comment"># 主路径第二卷积</span></span><br><span class="line">        out += residual              <span class="comment"># 主路径+shortcut路径（残差连接）</span></span><br><span class="line">        out = F.relu(out)            <span class="comment"># 最终ReLU</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建ResNet-like模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleResNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">1000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleResNet, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>)  <span class="comment"># 输入3通道（RGB）</span></span><br><span class="line">        <span class="variable language_">self</span>.pool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.block1 = ResidualBlock(<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.block2 = ResidualBlock(<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.block3 = ResidualBlock(<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.avg_pool = nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># 自适应全局平均池化→(1,1)</span></span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(<span class="number">64</span>, num_classes)          <span class="comment"># 全连接层：64→1000类（ImageNet）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.conv1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.pool(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.block1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.block2(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.block3(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.avg_pool(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)  <span class="comment"># 展平：(batch_size, 64, 1, 1)→(batch_size, 64)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试模型</span></span><br><span class="line">model = SimpleResNet(num_classes=<span class="number">1000</span>)</span><br><span class="line">x = torch.randn(<span class="number">32</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)  <span class="comment"># 32个RGB图像，224x224</span></span><br><span class="line">y_pred = model(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模型输出形状:&quot;</span>, y_pred.shape)  <span class="comment"># 输出(32, 1000)</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）常用层与损失函数"><a href="#（2）常用层与损失函数" class="headerlink" title="（2）常用层与损失函数"></a>（2）常用层与损失函数</h4><ul>
<li><strong>卷积层</strong>：<code>nn.Conv2d</code>（2D卷积，用于图像）、<code>nn.Conv1d</code>（1D卷积，用于文本）；</li>
<li><strong>池化层</strong>：<code>nn.MaxPool2d</code>（最大池化）、<code>nn.AvgPool2d</code>（平均池化）；</li>
<li><strong>循环层</strong>：<code>nn.RNN</code>、<code>nn.LSTM</code>、<code>nn.GRU</code>（用于序列数据，如文本、时序）；</li>
<li><strong>Transformer层</strong>：<code>nn.Transformer</code>、<code>nn.TransformerEncoder</code>、<code>nn.TransformerDecoder</code>（用于大语言模型、机器翻译）；</li>
<li><strong>损失函数</strong>：<code>nn.MSELoss</code>（均方误差，用于回归）、<code>nn.CrossEntropyLoss</code>（交叉熵，用于分类）、<code>nn.BCELoss</code>（二分类交叉熵）。</li>
</ul>
<h3 id="2-torch-optim：优化器与参数更新"><a href="#2-torch-optim：优化器与参数更新" class="headerlink" title="2. torch.optim：优化器与参数更新"></a>2. torch.optim：优化器与参数更新</h3><p><code>torch.optim</code>提供了主流的<strong>优化算法</strong>，用于根据<code>autograd</code>计算的梯度更新模型参数（如权重<code>w</code>、偏置<code>b</code>）。核心逻辑是：</p>
<ol>
<li>初始化优化器，传入待更新的模型参数和超参数（如学习率<code>lr</code>）；</li>
<li>每次训练迭代前，调用<code>optimizer.zero_grad()</code>清空梯度（避免梯度累积）；</li>
<li>前向传播计算损失；</li>
<li>反向传播计算梯度（<code>loss.backward()</code>）；</li>
<li>调用<code>optimizer.step()</code>更新参数。</li>
</ol>
<h4 id="示例：用Adam优化器训练线性模型"><a href="#示例：用Adam优化器训练线性模型" class="headerlink" title="示例：用Adam优化器训练线性模型"></a>示例：用Adam优化器训练线性模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义模型（简单线性回归：y = w*x + b）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearModel, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 输入1维，输出1维</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.linear(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初始化模型、损失函数、优化器</span></span><br><span class="line">model = LinearModel()</span><br><span class="line">criterion = nn.MSELoss()  <span class="comment"># 均方误差损失</span></span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># Adam优化器，学习率0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 模拟训练数据（y = 2x + 3 + 噪声）</span></span><br><span class="line">x = torch.randn(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># 100个样本，1维输入</span></span><br><span class="line">y_true = <span class="number">2</span> * x + <span class="number">3</span> + <span class="number">0.1</span> * torch.randn(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># 带噪声的真实标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 训练循环（100轮）</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    y_pred = model(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = criterion(y_pred, y_true)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每10轮打印损失</span></span><br><span class="line">    <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, Loss: <span class="subst">&#123;loss.item():<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看训练后的参数（接近真实值w=2，b=3）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练后的权重:&quot;</span>, model.linear.weight.data.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练后的偏置:&quot;</span>, model.linear.bias.data.item())</span><br></pre></td></tr></table></figure>

<h4 id="常用优化器："><a href="#常用优化器：" class="headerlink" title="常用优化器："></a>常用优化器：</h4><ul>
<li><strong>SGD</strong>：随机梯度下降，基础优化器，需配合动量（<code>momentum</code>）提升性能；</li>
<li><strong>Adam</strong>：自适应学习率优化器，收敛快，适用于大多数场景；</li>
<li><strong>RMSprop</strong>：自适应学习率，适合非平稳目标（如RNN训练）；</li>
<li><strong>AdamW</strong>：Adam的改进版，加入权重衰减（Weight Decay），缓解过拟合。</li>
</ul>
<h3 id="3-torch-utils-data：高效数据输入流水线"><a href="#3-torch-utils-data：高效数据输入流水线" class="headerlink" title="3. torch.utils.data：高效数据输入流水线"></a>3. torch.utils.data：高效数据输入流水线</h3><p>深度学习训练需处理海量数据（如百万级图像、TB级文本），<code>torch.utils.data</code>提供了“<strong>数据集抽象</strong>”和“<strong>批量加载</strong>”功能，支持：</p>
<ul>
<li>自定义数据集（通过<code>Dataset</code>基类）；</li>
<li>批量加载（<code>DataLoader</code>）；</li>
<li>数据打乱（<code>shuffle</code>）、并行预处理（<code>num_workers</code>）；</li>
<li>数据划分（<code>random_split</code>）。</li>
</ul>
<h4 id="示例1：自定义图像数据集（加载本地图像）"><a href="#示例1：自定义图像数据集（加载本地图像）" class="headerlink" title="示例1：自定义图像数据集（加载本地图像）"></a>示例1：自定义图像数据集（加载本地图像）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义数据集（继承Dataset）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomImageDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, img_dir, label_file, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            img_dir: 图像文件夹路径</span></span><br><span class="line"><span class="string">            label_file: 标签文件路径（每行格式：图像名 标签）</span></span><br><span class="line"><span class="string">            transform: 图像预处理函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.img_dir = img_dir</span><br><span class="line">        <span class="variable language_">self</span>.transform = transform</span><br><span class="line">        <span class="comment"># 读取标签文件</span></span><br><span class="line">        <span class="variable language_">self</span>.labels = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(label_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                img_name, label = line.strip().split()</span><br><span class="line">                <span class="variable language_">self</span>.labels[img_name] = <span class="built_in">int</span>(label)</span><br><span class="line">        <span class="variable language_">self</span>.img_names = <span class="built_in">list</span>(<span class="variable language_">self</span>.labels.keys())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 返回数据集总样本数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.img_names)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="comment"># 根据索引返回单个样本（图像+标签）</span></span><br><span class="line">        img_name = <span class="variable language_">self</span>.img_names[idx]</span><br><span class="line">        img_path = os.path.join(<span class="variable language_">self</span>.img_dir, img_name)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&#x27;RGB&#x27;</span>)  <span class="comment"># 读取图像并转为RGB</span></span><br><span class="line">        label = <span class="variable language_">self</span>.labels[img_name]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 图像预处理（如 resize、归一化）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.transform:</span><br><span class="line">            image = <span class="variable language_">self</span>.transform(image)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义图像预处理</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 缩放为224x224</span></span><br><span class="line">    transforms.ToTensor(),          <span class="comment"># 转为张量（0-1归一化）</span></span><br><span class="line">    transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])  <span class="comment"># 标准化（ImageNet均值/标准差）</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据集</span></span><br><span class="line">dataset = CustomImageDataset(</span><br><span class="line">    img_dir=<span class="string">&quot;path/to/images&quot;</span>,</span><br><span class="line">    label_file=<span class="string">&quot;path/to/labels.txt&quot;</span>,</span><br><span class="line">    transform=transform</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和验证集（8:2）</span></span><br><span class="line">train_size = <span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(dataset))</span><br><span class="line">val_size = <span class="built_in">len</span>(dataset) - train_size</span><br><span class="line">train_dataset, val_dataset = torch.utils.data.random_split(dataset, [train_size, val_size])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化DataLoader（批量加载）</span></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    train_dataset,</span><br><span class="line">    batch_size=<span class="number">32</span>,  <span class="comment"># 批次大小</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,   <span class="comment"># 训练集打乱</span></span><br><span class="line">    num_workers=<span class="number">4</span>   <span class="comment"># 4个进程并行加载数据（缓解CPU瓶颈）</span></span><br><span class="line">)</span><br><span class="line">val_loader = DataLoader(</span><br><span class="line">    val_dataset,</span><br><span class="line">    batch_size=<span class="number">32</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,  <span class="comment"># 验证集不打乱</span></span><br><span class="line">    num_workers=<span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历DataLoader（训练时使用）</span></span><br><span class="line"><span class="keyword">for</span> batch_idx, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Batch <span class="subst">&#123;batch_idx+<span class="number">1</span>&#125;</span>, Images shape: <span class="subst">&#123;images.shape&#125;</span>, Labels shape: <span class="subst">&#123;labels.shape&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 输出：Batch 1, Images shape: torch.Size([32, 3, 224, 224]), Labels shape: torch.Size([32])</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2：使用内置数据集（TorchVision提供）"><a href="#示例2：使用内置数据集（TorchVision提供）" class="headerlink" title="示例2：使用内置数据集（TorchVision提供）"></a>示例2：使用内置数据集（TorchVision提供）</h4><p>PyTorch的<code>torchvision.datasets</code>提供了常用公开数据集（如MNIST、CIFAR10、ImageNet），可直接调用，无需手动处理文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载MNIST数据集（自动下载到./data目录）</span></span><br><span class="line">train_dataset = MNIST(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,  <span class="comment"># 训练集</span></span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=transforms.ToTensor()  <span class="comment"># 转为张量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化DataLoader</span></span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>


<h3 id="4-可视化工具：TensorBoard与Weights-Biases"><a href="#4-可视化工具：TensorBoard与Weights-Biases" class="headerlink" title="4. 可视化工具：TensorBoard与Weights &amp; Biases"></a>4. 可视化工具：TensorBoard与Weights &amp; Biases</h3><p>PyTorch支持与主流可视化工具集成，实时监控训练过程（如损失、准确率、梯度分布），帮助分析模型训练情况。</p>
<h4 id="（1）TensorBoard"><a href="#（1）TensorBoard" class="headerlink" title="（1）TensorBoard"></a>（1）TensorBoard</h4><p>PyTorch通过<code>torch.utils.tensorboard</code>集成TensorBoard，需先安装TensorBoard（<code>pip install tensorboard</code>）。示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 初始化SummaryWriter（日志保存路径）</span></span><br><span class="line">writer = SummaryWriter(log_dir=<span class="string">&quot;runs/mnist_experiment&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 加载数据和模型（复用之前的线性模型）</span></span><br><span class="line">train_dataset = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transforms.ToTensor())</span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">model = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>), nn.Softmax(dim=<span class="number">1</span>))</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 训练并记录日志</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="comment"># 每100批次记录一次损失</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            avg_loss = running_loss / <span class="number">100</span></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;Training Loss&#x27;</span>, avg_loss, epoch * <span class="built_in">len</span>(train_loader) + i)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录每轮的模型参数分布（如第一层权重）</span></span><br><span class="line">    writer.add_histogram(<span class="string">&#x27;Layer 1 Weight&#x27;</span>, model[<span class="number">1</span>].weight.data, epoch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 关闭Writer</span></span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动TensorBoard（终端执行）</span></span><br><span class="line"><span class="comment"># tensorboard --logdir=runs</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可视化内容</strong>：在浏览器访问<code>http://localhost:6006</code>，可查看“Training Loss”曲线（损失变化）、“Layer 1 Weight”直方图（参数分布）。</li>
</ul>
<h4 id="（2）Weights-Biases（W-B）"><a href="#（2）Weights-Biases（W-B）" class="headerlink" title="（2）Weights &amp; Biases（W&amp;B）"></a>（2）Weights &amp; Biases（W&amp;B）</h4><p>W&amp;B是更强大的实验管理工具，支持多实验对比、模型版本控制、团队协作，PyTorch集成简单（<code>pip install wandb</code>），适合科研和团队开发。</p>
<h3 id="5-分布式训练：torch-distributed"><a href="#5-分布式训练：torch-distributed" class="headerlink" title="5. 分布式训练：torch.distributed"></a>5. 分布式训练：torch.distributed</h3><p>当模型规模大（如大语言模型）或数据量多时，单机单GPU训练速度慢，PyTorch通过<code>torch.distributed</code>支持<strong>多GPU、多机器训练</strong>，核心策略包括：</p>
<ul>
<li><strong>DataParallel（DP）</strong>：单机多GPU，简单易用但性能一般（仅主GPU计算梯度，再广播到其他GPU）；</li>
<li><strong>DistributedDataParallel（DDP）</strong>：单机&#x2F;多机多GPU，性能更优（各GPU独立计算梯度，再同步梯度），是主流选择；</li>
<li><strong>RPC</strong>：远程过程调用，支持分布式模型（如模型并行）。</li>
</ul>
<h4 id="示例：用DDP实现单机多GPU训练"><a href="#示例：用DDP实现单机多GPU训练" class="headerlink" title="示例：用DDP实现单机多GPU训练"></a>示例：用DDP实现单机多GPU训练</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel <span class="keyword">as</span> DDP</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, DistributedSampler</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化分布式环境</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_distributed</span>(<span class="params">rank, world_size</span>):</span><br><span class="line">    os.environ[<span class="string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="string">&#x27;localhost&#x27;</span>  <span class="comment"># 主节点地址</span></span><br><span class="line">    os.environ[<span class="string">&#x27;MASTER_PORT&#x27;</span>] = <span class="string">&#x27;12355&#x27;</span>       <span class="comment"># 主节点端口</span></span><br><span class="line">    dist.init_process_group(backend=<span class="string">&#x27;nccl&#x27;</span>, rank=rank, world_size=world_size)  <span class="comment"># NCCL是GPU间通信后端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">rank, world_size</span>):</span><br><span class="line">    <span class="comment"># 初始化分布式环境</span></span><br><span class="line">    init_distributed(rank, world_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置当前GPU</span></span><br><span class="line">    torch.cuda.set_device(rank)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加载数据（使用DistributedSampler分片数据）</span></span><br><span class="line">    transform = transforms.ToTensor()</span><br><span class="line">    dataset = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">    sampler = DistributedSampler(dataset, num_replicas=world_size, rank=rank)  <span class="comment"># 数据分片</span></span><br><span class="line">    dataloader = DataLoader(dataset, batch_size=<span class="number">32</span>, sampler=sampler)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化模型并迁移到GPU</span></span><br><span class="line">    model = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>), nn.Softmax(dim=<span class="number">1</span>)).cuda(rank)</span><br><span class="line">    model = DDP(model, device_ids=[rank])  <span class="comment"># 包装为DDP模型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 损失函数和优化器</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练循环</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        sampler.set_epoch(epoch)  <span class="comment"># 每轮打乱数据分片</span></span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> images, labels <span class="keyword">in</span> dataloader:</span><br><span class="line">            images, labels = images.cuda(rank), labels.cuda(rank)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            running_loss += loss.item()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Rank <span class="subst">&#123;rank&#125;</span>, Epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>, Loss: <span class="subst">&#123;running_loss/<span class="built_in">len</span>(dataloader):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 销毁分布式环境</span></span><br><span class="line">    dist.destroy_process_group()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    world_size = torch.cuda.device_count()  <span class="comment"># 可用GPU数量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Using <span class="subst">&#123;world_size&#125;</span> GPUs&quot;</span>)</span><br><span class="line">    mp.spawn(train, args=(world_size,), nprocs=world_size, join=<span class="literal">True</span>)  <span class="comment"># 启动多进程</span></span><br></pre></td></tr></table></figure>


<h3 id="6-模型部署：从科研到产品"><a href="#6-模型部署：从科研到产品" class="headerlink" title="6. 模型部署：从科研到产品"></a>6. 模型部署：从科研到产品</h3><p>PyTorch早期的部署能力弱于TensorFlow，但随着版本迭代，已形成完善的部署生态，支持多平台部署：</p>
<h4 id="（1）TorchScript：动态图转静态图"><a href="#（1）TorchScript：动态图转静态图" class="headerlink" title="（1）TorchScript：动态图转静态图"></a>（1）TorchScript：动态图转静态图</h4><p>TorchScript将PyTorch动态图模型转换为“<strong>静态图模型</strong>”（TorchScript Module），支持脱离Python环境运行（如C++部署），核心步骤：</p>
<ol>
<li>用<code>torch.jit.trace</code>（追踪式）或<code>torch.jit.script</code>（脚本式）转换模型；</li>
<li>保存转换后的模型（<code>.pt</code>或<code>.pth</code>）；</li>
<li>在C++中用LibTorch加载模型并推理。</li>
</ol>
<h4 id="示例：TorchScript转换与保存"><a href="#示例：TorchScript转换与保存" class="headerlink" title="示例：TorchScript转换与保存"></a>示例：TorchScript转换与保存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear = nn.Linear(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.relu(<span class="variable language_">self</span>.linear(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化并训练模型（省略训练步骤）</span></span><br><span class="line">model = SimpleModel()</span><br><span class="line">model.<span class="built_in">eval</span>()  <span class="comment"># 切换到评估模式（禁用Dropout、BatchNorm等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 追踪式转换（需提供示例输入）</span></span><br><span class="line">example_input = torch.randn(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">traced_model = torch.jit.trace(model, example_input)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 脚本式转换（支持动态逻辑，无需示例输入）</span></span><br><span class="line">scripted_model = torch.jit.script(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 保存模型</span></span><br><span class="line">traced_model.save(<span class="string">&quot;traced_model.pt&quot;</span>)</span><br><span class="line">scripted_model.save(<span class="string">&quot;scripted_model.pt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 加载模型（Python或C++）</span></span><br><span class="line">loaded_model = torch.jit.load(<span class="string">&quot;traced_model.pt&quot;</span>)</span><br><span class="line">output = loaded_model(example_input)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加载模型输出:&quot;</span>, output.shape)  <span class="comment"># 输出(1, 2)</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）ONNX：跨框架转换"><a href="#（2）ONNX：跨框架转换" class="headerlink" title="（2）ONNX：跨框架转换"></a>（2）ONNX：跨框架转换</h4><p>ONNX（Open Neural Network Exchange）是跨框架模型格式，支持将PyTorch模型转换为ONNX格式，再部署到TensorRT（NVIDIA GPU加速）、TensorFlow Lite（移动设备）等框架。</p>
<h4 id="（3）TorchServe：模型服务化部署"><a href="#（3）TorchServe：模型服务化部署" class="headerlink" title="（3）TorchServe：模型服务化部署"></a>（3）TorchServe：模型服务化部署</h4><p>TorchServe是PyTorch官方的“<strong>模型服务框架</strong>”，支持快速部署模型为HTTP&#x2F;HTTPS服务，提供负载均衡、模型版本控制、A&#x2F;B测试等功能，适合云服务部署。</p>
<h4 id="（4）TorchMobile：移动与嵌入式部署"><a href="#（4）TorchMobile：移动与嵌入式部署" class="headerlink" title="（4）TorchMobile：移动与嵌入式部署"></a>（4）TorchMobile：移动与嵌入式部署</h4><p>TorchMobile是PyTorch的移动部署库，支持将模型优化后部署到Android、iOS设备，通过量化（Quantization）、剪枝（Pruning）减小模型体积、提升推理速度。</p>
<h2 id="四、PyTorch的典型应用场景"><a href="#四、PyTorch的典型应用场景" class="headerlink" title="四、PyTorch的典型应用场景"></a>四、PyTorch的典型应用场景</h2><p>PyTorch的灵活性和生态完善性使其适用于各类深度学习场景，尤其在科研和中小规模工业应用中表现突出：</p>
<h3 id="1-计算机视觉（Computer-Vision-CV）"><a href="#1-计算机视觉（Computer-Vision-CV）" class="headerlink" title="1. 计算机视觉（Computer Vision, CV）"></a>1. 计算机视觉（Computer Vision, CV）</h3><p>PyTorch的<code>torchvision</code>库是CV领域的核心工具，包含预训练模型、数据集、图像预处理函数，支持各类CV任务：</p>
<ul>
<li><strong>图像分类</strong>：用ResNet、EfficientNet、ViT（Vision Transformer）等模型做图像识别；</li>
<li><strong>目标检测</strong>：用Faster R-CNN、YOLOv5（第三方）、SSD等模型检测图像中的物体；</li>
<li><strong>图像分割</strong>：用U-Net、Mask R-CNN等模型做语义分割、实例分割；</li>
<li><strong>图像生成</strong>：用GAN（生成对抗网络）、StyleGAN、Diffusion Models（扩散模型）生成逼真图像。</li>
</ul>
<h4 id="示例：用预训练ResNet做图像分类"><a href="#示例：用预训练ResNet做图像分类" class="headerlink" title="示例：用预训练ResNet做图像分类"></a>示例：用预训练ResNet做图像分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models, transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载预训练ResNet50（ImageNet预训练权重）</span></span><br><span class="line">model = models.resnet50(pretrained=<span class="literal">True</span>)  <span class="comment"># 或用weights=models.ResNet50_Weights.IMAGENET1K_V1（PyTorch 2.x）</span></span><br><span class="line">model.<span class="built_in">eval</span>()  <span class="comment"># 评估模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 图像预处理（与预训练模型一致）</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 加载并预处理图像</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;cat.jpg&quot;</span>).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">image_tensor = transform(image).unsqueeze(<span class="number">0</span>)  <span class="comment"># 增加batch维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 推理</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():  <span class="comment"># 禁用梯度追踪，提升速度</span></span><br><span class="line">    outputs = model(image_tensor)</span><br><span class="line">    _, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)  <span class="comment"># 获取预测类别索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 加载ImageNet类别标签并输出结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;imagenet_classes.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    classes = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;预测类别: <span class="subst">&#123;classes[predicted.item()]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="2-自然语言处理（Natural-Language-Processing-NLP）"><a href="#2-自然语言处理（Natural-Language-Processing-NLP）" class="headerlink" title="2. 自然语言处理（Natural Language Processing, NLP）"></a>2. 自然语言处理（Natural Language Processing, NLP）</h3><p>PyTorch在NLP领域的优势显著，尤其是Hugging Face的<code>transformers</code>库（基于PyTorch）成为主流，支持各类NLP任务：</p>
<ul>
<li><strong>文本分类</strong>：情感分析、垃圾邮件检测；</li>
<li><strong>机器翻译</strong>：基于Transformer的中英互译；</li>
<li><strong>问答系统</strong>：抽取式问答（如BERT）、生成式问答（如GPT）；</li>
<li><strong>大语言模型（LLM）</strong>：训练&#x2F;微调GPT、LLaMA、ChatGLM等模型。</li>
</ul>
<h4 id="示例：用Hugging-Face-Transformers加载BERT做文本分类"><a href="#示例：用Hugging-Face-Transformers加载BERT做文本分类" class="headerlink" title="示例：用Hugging Face Transformers加载BERT做文本分类"></a>示例：用Hugging Face Transformers加载BERT做文本分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertForSequenceClassification</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载预训练BERT模型和Tokenizer（情感分析任务）</span></span><br><span class="line">model_name = <span class="string">&quot;bert-base-uncased-finetuned-sst-2-english&quot;</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(model_name)</span><br><span class="line">model = BertForSequenceClassification.from_pretrained(model_name)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 预处理文本（Tokenize）</span></span><br><span class="line">text = <span class="string">&quot;I love PyTorch! It&#x27;s very easy to use.&quot;</span></span><br><span class="line">inputs = tokenizer(text, return_tensors=<span class="string">&quot;pt&quot;</span>, padding=<span class="literal">True</span>, truncation=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 推理</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    outputs = model(**inputs)</span><br><span class="line">    logits = outputs.logits</span><br><span class="line">    predicted_class_id = torch.argmax(logits, dim=<span class="number">1</span>).item()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 输出结果（0=负面，1=正面）</span></span><br><span class="line">class_names = [<span class="string">&quot;Negative&quot;</span>, <span class="string">&quot;Positive&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文本情感: <span class="subst">&#123;class_names[predicted_class_id]&#125;</span>&quot;</span>)  <span class="comment"># 输出Positive</span></span><br></pre></td></tr></table></figure>


<h3 id="3-强化学习（Reinforcement-Learning-RL）"><a href="#3-强化学习（Reinforcement-Learning-RL）" class="headerlink" title="3. 强化学习（Reinforcement Learning, RL）"></a>3. 强化学习（Reinforcement Learning, RL）</h3><p>PyTorch的动态图特性非常适合强化学习（需频繁调整策略网络、价值网络），主流RL库（如Stable Baselines3、TorchRL）均基于PyTorch构建，支持：</p>
<ul>
<li><strong>游戏AI</strong>：Atari游戏、围棋、星际争霸；</li>
<li><strong>机器人控制</strong>：机械臂抓取、无人机导航；</li>
<li><strong>资源调度</strong>：数据中心GPU调度、交通流量优化。</li>
</ul>
<h3 id="4-科学计算与AI-科学"><a href="#4-科学计算与AI-科学" class="headerlink" title="4. 科学计算与AI+科学"></a>4. 科学计算与AI+科学</h3><p>PyTorch的张量运算和自动微分能力也被用于科学计算领域，如：</p>
<ul>
<li><strong>物理模拟</strong>：流体力学、量子力学模拟；</li>
<li><strong>生物医学</strong>：蛋白质结构预测（如AlphaFold 2基于PyTorch）；</li>
<li><strong>气候预测</strong>：基于深度学习的气象数据建模。</li>
</ul>
<h2 id="五、PyTorch的优缺点与适用人群"><a href="#五、PyTorch的优缺点与适用人群" class="headerlink" title="五、PyTorch的优缺点与适用人群"></a>五、PyTorch的优缺点与适用人群</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul>
<li><strong>动态图灵活性高</strong>：支持条件、循环、动态修改网络，调试直观（可直接<code>print</code>中间结果），科研友好；</li>
<li><strong>API简洁直观</strong>：接口设计贴近Python直觉，学习成本低，新手易上手；</li>
<li><strong>生态完善</strong>：TorchVision、Hugging Face Transformers、Stable Baselines3等扩展库覆盖全场景；</li>
<li><strong>科研社区活跃</strong>：学术界多数论文（如LLM、扩散模型）优先提供PyTorch实现，便于复现；</li>
<li><strong>性能持续提升</strong>：PyTorch 2.x的<code>torch.compile</code>大幅提升静态图性能，缩小与TensorFlow的差距。</li>
</ul>
<h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ul>
<li><strong>大规模工业部署生态稍逊</strong>：虽然支持多平台部署，但在超大规模集群（如谷歌TPU集群）的优化上，仍不如TensorFlow成熟；</li>
<li><strong>早期版本兼容性问题</strong>：PyTorch 1.x到2.x的部分API有变化，旧代码需适配；</li>
<li><strong>多GPU训练配置复杂</strong>：DDP的配置（如分布式环境初始化）比TensorFlow的<code>tf.distribute</code>稍繁琐。</li>
</ul>
<h3 id="3-适用人群"><a href="#3-适用人群" class="headerlink" title="3. 适用人群"></a>3. 适用人群</h3><ul>
<li><strong>科研人员</strong>：需快速迭代算法、复现论文、构建复杂动态模型；</li>
<li><strong>初学者</strong>：希望低门槛入门深度学习，享受直观的调试体验；</li>
<li><strong>中小规模工业开发者</strong>：需快速开发产品原型，部署到移动端、嵌入式或小型云服务；</li>
<li><strong>不适用场景</strong>：超大规模工业部署（如谷歌、阿里的万亿级数据训练），TensorFlow更优。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>PyTorch是一款“<strong>以灵活性和易用性为核心</strong>”的深度学习框架，其动态计算图设计彻底改变了深度学习的开发体验，尤其适配科研领域“快速迭代、复杂创新”的需求。随着PyTorch 2.x的发布，其在性能和部署能力上的短板不断弥补，形成了“科研→原型→产品”的全流程支持能力。</p>
<p>对于开发者而言，掌握PyTorch的关键是：</p>
<ol>
<li>理解核心概念（张量、动态计算图、自动微分）；</li>
<li>熟练使用<code>torch.nn</code>构建自定义模型，<code>torch.optim</code>优化参数；</li>
<li>用<code>torch.utils.data</code>构建高效数据流水线；</li>
<li>根据场景选择可视化（TensorBoard）和部署方式（TorchScript、ONNX）。</li>
</ol>
<p>PyTorch的成功不仅在于技术设计，更在于其“以开发者为中心”的理念——它让深度学习不再是“复杂的图定义游戏”，而是回归到“直观的代码逻辑”，这也是其在科研和开发者社区中持续流行的核心原因。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的static和final</title>
    <url>/2025/08/18/Java/Java%E4%B8%AD%E7%9A%84static%E5%92%8Cfinal/</url>
    <content><![CDATA[<h1 id="Java中的static和final关键字"><a href="#Java中的static和final关键字" class="headerlink" title="Java中的static和final关键字"></a>Java中的static和final关键字</h1><h3 id="1-static-关键字"><a href="#1-static-关键字" class="headerlink" title="1. static 关键字"></a>1. <code>static</code> 关键字</h3><p><strong>含义</strong>：<code>static</code> 表示“<strong>静态的</strong>”或“<strong>属于类的</strong>”，而不是属于某个具体的对象实例。</p>
<p><strong>修饰变量时的特点</strong>：</p>
<ul>
<li><strong>类变量</strong>：被 <code>static</code> 修饰的变量称为<strong>类变量</strong>或<strong>静态变量</strong>。它属于类本身，而不是类的任何特定实例。</li>
<li><strong>共享性</strong>：无论创建多少个该类的对象，<code>static</code> 变量在内存中<strong>只有一份拷贝</strong>。所有实例共享这个变量。</li>
<li><strong>生命周期</strong>：<code>static</code> 变量在<strong>类加载时</strong>被初始化，并且在程序的整个生命周期内存在，直到类被卸载。</li>
<li><strong>访问方式</strong>：可以通过 <code>类名.变量名</code> 直接访问，也可以通过 <code>对象实例.变量名</code> 访问（但不推荐，容易引起误解）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量，所有实例共享</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 每创建一个实例，count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(); <span class="comment">// count = 1</span></span><br><span class="line"><span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(); <span class="comment">// count = 2</span></span><br><span class="line"><span class="type">Counter</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(); <span class="comment">// count = 3</span></span><br><span class="line"></span><br><span class="line">System.out.println(Counter.count); <span class="comment">// 输出: 3 (推荐通过类名访问)</span></span><br><span class="line">System.out.println(c1.count);      <span class="comment">// 输出: 3 (也可以，但不推荐)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-final-关键字"><a href="#2-final-关键字" class="headerlink" title="2. final 关键字"></a>2. <code>final</code> 关键字</h3><p><strong>含义</strong>：<code>final</code> 表示“<strong>最终的</strong>”或“<strong>不可改变的</strong>”。</p>
<p><strong>修饰变量时的特点</strong>：</p>
<ul>
<li><strong>不可变性</strong>：一旦被 <code>final</code> 修饰的变量被赋值（初始化），它的值就<strong>不能再被修改</strong>。</li>
<li><strong>赋值时机</strong>：<ul>
<li><strong>final 成员变量</strong>：必须在<strong>声明时</strong>初始化，或者在<strong>构造器</strong>中初始化。确保在对象构造完成前，<code>final</code> 变量已被赋值。</li>
<li><strong>final 局部变量</strong>：可以在声明时初始化，也可以在后续的代码中赋值，但<strong>只能赋值一次</strong>。</li>
</ul>
</li>
<li><strong>引用类型</strong>：如果 <code>final</code> 修饰的是一个<strong>对象引用</strong>，那么这个引用本身不能改变（即不能指向另一个对象），但<strong>对象内部的状态（其成员变量）是可以改变的</strong>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;          <span class="comment">// final 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;     <span class="comment">// final 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; list; <span class="comment">// final 引用变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;           <span class="comment">// 在构造器中初始化 final 变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;       <span class="comment">// 在构造器中初始化 final 变量</span></span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 在构造器中初始化 final 引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// id = 10; // ❌ 编译错误！不能修改 final 变量</span></span><br><span class="line">        <span class="comment">// name = &quot;New Name&quot;; // ❌ 编译错误！</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// ✅ OK！可以修改 final 引用所指向对象的内部状态</span></span><br><span class="line">        <span class="comment">// list = new ArrayList&lt;&gt;(); // ❌ 编译错误！不能改变 final 引用本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final 局部变量</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    x = <span class="number">5</span>; <span class="comment">// ✅ 第一次赋值</span></span><br><span class="line">    <span class="comment">// x = 10; // ❌ 编译错误！不能再次赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-static-final-组合使用"><a href="#3-static-final-组合使用" class="headerlink" title="3. static final 组合使用"></a>3. <code>static final</code> 组合使用</h3><p>当 <code>static</code> 和 <code>final</code> 同时修饰一个变量时，它表示一个<strong>全局常量</strong>。</p>
<ul>
<li><strong><code>static</code></strong>：表示这个变量属于类，所有实例共享。</li>
<li><strong><code>final</code></strong>：表示这个变量的值不可改变。</li>
</ul>
<p>因此，<code>static final</code> 变量通常用来定义<strong>常量</strong>，并且命名习惯上使用<strong>全大写字母和下划线</strong>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>; <span class="comment">// 数学常数 π</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;   <span class="comment">// 最大尺寸</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_NAME</span> <span class="operator">=</span> <span class="string">&quot;MyApp&quot;</span>; <span class="comment">// 应用名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">double</span> <span class="variable">circumference</span> <span class="operator">=</span> <span class="number">2</span> * Constants.PI * radius;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>在类加载时初始化（对于基本类型和字符串字面量，通常在编译期就能确定，称为“编译期常量”）。</li>
<li>值不可变。</li>
<li>通过 <code>类名.常量名</code> 访问。</li>
</ul>
<hr>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>static</code></th>
<th align="left"><code>final</code></th>
<th align="left"><code>static final</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所属</strong></td>
<td align="left">属于类，不依赖实例</td>
<td align="left">属于变量本身，可以是实例变量或类变量</td>
<td align="left">属于类，是类级别的常量</td>
</tr>
<tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">值可以改变（除非也用 <code>final</code> 修饰）</td>
<td align="left">值不可改变</td>
<td align="left">值不可改变</td>
</tr>
<tr>
<td align="left"><strong>实例共享</strong></td>
<td align="left">是，所有实例共享一份</td>
<td align="left">否，每个实例有自己的 <code>final</code> 实例变量（但值固定）</td>
<td align="left">是，所有实例共享同一个常量值</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">类加载时创建，程序结束时销毁</td>
<td align="left">实例变量：对象创建时初始化，对象销毁时结束<br>局部变量：方法执行期间</td>
<td align="left">类加载时初始化，程序结束时销毁</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">计数器、共享资源</td>
<td align="left">防止变量被意外修改、定义实例常量</td>
<td align="left">定义全局常量（如配置、数学常数）</td>
</tr>
</tbody></table>
<p><strong>简单记忆</strong>：</p>
<ul>
<li><code>static</code> &#x3D; <strong>共享</strong> (One copy for all instances)</li>
<li><code>final</code> &#x3D; <strong>不变</strong> (Value cannot be changed)</li>
<li><code>static final</code> &#x3D; <strong>共享且不变</strong> (A constant shared by all instances)</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>Java</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash与PowerShell语法入门：命令行工具的双雄对决</title>
    <url>/2025/08/07/Shell_powershell/bash%E5%92%8Cpowershell%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>命令行工具是开发者日常工作中不可或缺的利器，其中Bash和PowerShell分别在类Unix系统（Linux&#x2F;macOS）和Windows系统中占据主导地位。尽管两者都用于命令行交互和脚本编程，但语法风格和设计理念却大相径庭。本文将系统讲解Bash与PowerShell的核心语法，通过对比帮助你快速上手这两种工具。</p>
<span id="more"></span>

<h3 id="一、核心定位与设计理念"><a href="#一、核心定位与设计理念" class="headerlink" title="一、核心定位与设计理念"></a>一、核心定位与设计理念</h3><p>在学习语法前，先理解两者的本质区别有助于更好地掌握它们的使用方式：</p>
<ul>
<li><p><strong>Bash（Bourne Again SHell）</strong></p>
<ul>
<li>基于传统Unix Shell（sh）发展而来，是Linux&#x2F;macOS的默认shell</li>
<li>设计理念：文本流处理，所有操作围绕文本展开</li>
<li>优势：轻量高效，命令简洁，适合系统管理和自动化脚本</li>
</ul>
</li>
<li><p><strong>PowerShell</strong></p>
<ul>
<li>微软开发的跨平台shell（支持Windows&#x2F;Linux&#x2F;macOS）</li>
<li>设计理念：对象模型，命令输出为结构化对象而非纯文本</li>
<li>优势：功能强大，集成.NET框架，适合Windows系统管理和复杂脚本</li>
</ul>
</li>
</ul>
<h3 id="二、基础语法对比"><a href="#二、基础语法对比" class="headerlink" title="二、基础语法对比"></a>二、基础语法对比</h3><h4 id="1-命令格式与命名规范"><a href="#1-命令格式与命名规范" class="headerlink" title="1. 命令格式与命名规范"></a>1. 命令格式与命名规范</h4><table>
<thead>
<tr>
<th>特性</th>
<th>Bash</th>
<th>PowerShell</th>
</tr>
</thead>
<tbody><tr>
<td>命令格式</td>
<td>小写字母+短横线（如<code>ls -l</code>）</td>
<td>动词-名词格式（如<code>Get-ChildItem</code>）</td>
</tr>
<tr>
<td>参数表示</td>
<td>短参数用<code>-</code>（如<code>-l</code>），长参数用<code>--</code>（如<code>--help</code>）</td>
<td>统一用<code>-</code>（如<code>-Path</code>），支持参数别名</td>
</tr>
<tr>
<td>命令别名</td>
<td>大量简写（如<code>ls</code>是<code>list</code>的简写）</td>
<td>保留完整动词名词结构，同时提供简写（如<code>dir</code>是<code>Get-ChildItem</code>的别名）</td>
</tr>
</tbody></table>
<p>示例：列出目录内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash</span></span><br><span class="line"><span class="built_in">ls</span> -l /home  <span class="comment"># 长格式列出/home目录</span></span><br><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span>    <span class="comment"># 查看帮助</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> C:\Users <span class="operator">-File</span>  <span class="comment"># 列出C:\Users下的文件</span></span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-h</span>                    <span class="comment"># 查看帮助（-h是-Help的别名）</span></span><br><span class="line"><span class="built_in">dir</span>                                 <span class="comment"># 等效于Get-ChildItem（Windows风格别名）</span></span><br></pre></td></tr></table></figure>

<h4 id="2-变量操作"><a href="#2-变量操作" class="headerlink" title="2. 变量操作"></a>2. 变量操作</h4><ul>
<li><strong>变量定义与使用</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash</span></span><br><span class="line">name=<span class="string">&quot;John&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span>          <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span>  <span class="comment"># 双引号中可直接解析变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello $name&#x27;</span>  <span class="comment"># 单引号中变量不解析，输出Hello $name</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&quot;John&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="variable">$name</span>          <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span>  <span class="comment"># 双引号中解析变量</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&#x27;Hello $name&#x27;</span>  <span class="comment"># 单引号中不解析，输出Hello $name</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>环境变量</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span>                <span class="comment"># 查看环境变量</span></span><br><span class="line"><span class="built_in">export</span> NEW_VAR=<span class="string">&quot;value&quot;</span>    <span class="comment"># 设置临时环境变量（当前会话有效）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="variable">$env:PATH</span>                 <span class="comment"># 查看环境变量</span></span><br><span class="line"><span class="variable">$env:NEW_VAR</span> = <span class="string">&quot;value&quot;</span>    <span class="comment"># 设置临时环境变量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-管道操作（Pipeline）"><a href="#3-管道操作（Pipeline）" class="headerlink" title="3. 管道操作（Pipeline）"></a>3. 管道操作（Pipeline）</h4><p>管道用于将一个命令的输出作为另一个命令的输入，是命令行工具的核心功能，但两者的处理方式不同：</p>
<ul>
<li><strong>Bash</strong>：管道传递的是文本流</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找包含&quot;error&quot;的日志行，并统计数量</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/syslog | grep <span class="string">&quot;error&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录文件，按大小排序（从大到小）</span></span><br><span class="line"><span class="built_in">ls</span> -l | <span class="built_in">sort</span> -k5,5nr</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PowerShell</strong>：管道传递的是对象，可直接操作对象属性</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找C盘下大于100MB的文件</span></span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> C:\ <span class="literal">-Recurse</span> <span class="operator">-File</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.Length <span class="operator">-gt</span> <span class="number">100</span>MB&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出进程，按内存使用排序，并只显示名称和内存</span></span><br><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> <span class="literal">-Property</span> WorkingSet <span class="literal">-Descending</span> | <span class="built_in">Select-Object</span> Name, WorkingSet</span><br></pre></td></tr></table></figure>

<h4 id="4-条件判断"><a href="#4-条件判断" class="headerlink" title="4. 条件判断"></a>4. 条件判断</h4><ul>
<li><strong>Bash</strong>：使用<code>[ ]</code>或<code>[[ ]]</code>，语法较为紧凑</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;file.txt&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ -d <span class="string">&quot;dir&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;目录存在&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值比较</span></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> &lt; <span class="variable">$b</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PowerShell</strong>：使用<code>if/elseif/else</code>，条件表达式更直观</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="string">&quot;file.txt&quot;</span> <span class="literal">-PathType</span> Leaf) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;文件存在&quot;</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="built_in">Test-Path</span> <span class="string">&quot;dir&quot;</span> <span class="literal">-PathType</span> Container) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;目录存在&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值比较</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">10</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span> <span class="operator">-lt</span> <span class="variable">$b</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;<span class="variable">$a</span> &lt; <span class="variable">$b</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-循环结构"><a href="#5-循环结构" class="headerlink" title="5. 循环结构"></a>5. 循环结构</h4><ul>
<li><strong>for循环</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash：遍历列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> Alice Bob Charlie; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.txt; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell：遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$name</span> <span class="keyword">in</span> <span class="selector-tag">@</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$file</span> <span class="keyword">in</span> <span class="built_in">Get-ChildItem</span> <span class="literal">-Filter</span> *.txt) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="variable">$file</span>.Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>while循环</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash</span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Count: <span class="variable">$count</span>&quot;</span></span><br><span class="line">    count=$((count + <span class="number">1</span>))  <span class="comment"># 数值计算</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="variable">$count</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$count</span> <span class="operator">-le</span> <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Count: <span class="variable">$count</span>&quot;</span></span><br><span class="line">    <span class="variable">$count</span>++  <span class="comment"># 自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、常用命令功能对比"><a href="#三、常用命令功能对比" class="headerlink" title="三、常用命令功能对比"></a>三、常用命令功能对比</h3><table>
<thead>
<tr>
<th>功能</th>
<th>Bash命令</th>
<th>PowerShell命令</th>
</tr>
</thead>
<tbody><tr>
<td>列出目录内容</td>
<td><code>ls</code></td>
<td><code>Get-ChildItem</code>（别名<code>dir</code>、<code>ls</code>）</td>
</tr>
<tr>
<td>切换目录</td>
<td><code>cd</code></td>
<td><code>Set-Location</code>（别名<code>cd</code>）</td>
</tr>
<tr>
<td>创建目录</td>
<td><code>mkdir</code></td>
<td><code>New-Item -ItemType Directory</code>（别名<code>mkdir</code>）</td>
</tr>
<tr>
<td>删除文件</td>
<td><code>rm</code></td>
<td><code>Remove-Item</code>（别名<code>rm</code>、<code>del</code>）</td>
</tr>
<tr>
<td>复制文件</td>
<td><code>cp</code></td>
<td><code>Copy-Item</code>（别名<code>cp</code>、<code>copy</code>）</td>
</tr>
<tr>
<td>移动文件</td>
<td><code>mv</code></td>
<td><code>Move-Item</code>（别名<code>mv</code>、<code>move</code>）</td>
</tr>
<tr>
<td>查看文件内容</td>
<td><code>cat</code>、<code>less</code>、<code>more</code></td>
<td><code>Get-Content</code>（别名<code>cat</code>）、<code>more</code></td>
</tr>
<tr>
<td>查找文件</td>
<td><code>find</code>、<code>grep</code></td>
<td><code>Get-ChildItem -Recurse</code> + <code>Where-Object</code></td>
</tr>
<tr>
<td>进程管理</td>
<td><code>ps</code>、<code>kill</code></td>
<td><code>Get-Process</code>、<code>Stop-Process</code></td>
</tr>
<tr>
<td>网络测试</td>
<td><code>ping</code>、<code>curl</code></td>
<td><code>Test-Connection</code>、<code>Invoke-WebRequest</code></td>
</tr>
</tbody></table>
<h3 id="四、脚本编程基础"><a href="#四、脚本编程基础" class="headerlink" title="四、脚本编程基础"></a>四、脚本编程基础</h3><h4 id="1-脚本文件格式"><a href="#1-脚本文件格式" class="headerlink" title="1. 脚本文件格式"></a>1. 脚本文件格式</h4><ul>
<li><strong>Bash脚本</strong>：文件扩展名为<code>.sh</code>，首行指定解释器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这是一个Bash脚本示例</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前时间：<span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录：<span class="subst">$(pwd)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行方式：<code>chmod +x script.sh</code>（添加执行权限）→ <code>./script.sh</code></p>
<ul>
<li><strong>PowerShell脚本</strong>：文件扩展名为<code>.ps1</code>，默认需要设置执行权限</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个PowerShell脚本示例</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;当前时间：<span class="variable">$</span>(Get-Date)&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;当前目录：<span class="variable">$</span>(Get-Location)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行方式：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首次执行需设置执行策略（管理员权限）</span></span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">.\script.ps1</span><br></pre></td></tr></table></figure>

<h4 id="2-函数定义"><a href="#2-函数定义" class="headerlink" title="2. 函数定义"></a>2. 函数定义</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bash函数</span></span><br><span class="line"><span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> name=<span class="variable">$1</span>  <span class="comment"># 接收第一个参数</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet <span class="string">&quot;World&quot;</span>  <span class="comment"># 调用函数，输出Hello, World!</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greet</span></span> &#123;</span><br><span class="line">    <span class="keyword">param</span>([<span class="built_in">string</span>]<span class="variable">$name</span>)  <span class="comment"># 定义参数</span></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greet <span class="literal">-name</span> <span class="string">&quot;World&quot;</span>  <span class="comment"># 调用函数</span></span><br><span class="line">Greet <span class="string">&quot;World&quot;</span>        <span class="comment"># 简写形式</span></span><br></pre></td></tr></table></figure>

<h3 id="五、适用场景与选择建议"><a href="#五、适用场景与选择建议" class="headerlink" title="五、适用场景与选择建议"></a>五、适用场景与选择建议</h3><ol>
<li><p><strong>按操作系统选择</strong></p>
<ul>
<li>Linux&#x2F;macOS系统：优先使用Bash，与系统工具集成更紧密</li>
<li>Windows系统：优先使用PowerShell，能更好地管理Windows服务、注册表等</li>
</ul>
</li>
<li><p><strong>按任务类型选择</strong></p>
<ul>
<li>简单的文件操作、系统管理：Bash语法更简洁</li>
<li>复杂的自动化任务、对象处理：PowerShell的对象模型更有优势</li>
<li>跨平台需求：两者均可，但PowerShell在Windows上功能更完整，Bash在类Unix系统上更自然</li>
</ul>
</li>
<li><p><strong>学习建议</strong></p>
<ul>
<li>如果你主要使用Linux&#x2F;macOS：先掌握Bash核心语法，再了解PowerShell作为扩展</li>
<li>如果你主要使用Windows：从PowerShell入手，同时了解Bash（可通过WSL使用）</li>
<li>重点掌握管道、变量和循环这三个核心概念，它们是两种shell的共通基础</li>
</ul>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>Bash和PowerShell作为主流的命令行工具，各有其独特优势：Bash以简洁高效的文本处理能力在类Unix系统中占据统治地位，而PowerShell凭借对象导向的设计理念在复杂系统管理中表现出色。</p>
<p>学习这两种工具时，不必追求”二选一”，而应根据实际场景灵活选用。理解它们的语法差异和设计理念，掌握核心操作（变量、管道、循环、函数），就能在日常开发和系统管理中得心应手，大幅提升工作效率。</p>
<p>随着PowerShell的跨平台化和WSL（Windows Subsystem for Linux）的普及，这两种工具的使用场景正逐渐融合，掌握它们将成为开发者的重要技能。</p>
]]></content>
      <categories>
        <category>Shell_powershell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>PowerShell</tag>
        <tag>命令行</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 编程入门</title>
    <url>/2025/07/22/Shell_powershell/shell%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>在 Linux&#x2F;Unix 系统中，Shell 不仅是命令行解释器，更是一种强大的脚本编程语言。通过 Shell 脚本，我们可以将一系列命令组合起来实现自动化任务，从简单的文件批量处理到复杂的系统管理均可胜任。本文将从基础语法到实际应用，全面讲解 Shell 编程的入门知识，为自动化运维和开发效率提升奠定基础。</p>
<h3 id="一、Shell-与-Shell-脚本基础"><a href="#一、Shell-与-Shell-脚本基础" class="headerlink" title="一、Shell 与 Shell 脚本基础"></a>一、Shell 与 Shell 脚本基础</h3><h4 id="1-什么是-Shell？"><a href="#1-什么是-Shell？" class="headerlink" title="1. 什么是 Shell？"></a>1. 什么是 Shell？</h4><p>Shell 是用户与操作系统内核交互的接口，它接收用户输入的命令并传递给内核执行。常见的 Shell 解释器包括：</p>
<ul>
<li><p><strong>Bash（Bourne Again SHell）</strong>：Linux 系统默认 Shell，兼容 Bourne Shell 并扩展了诸多功能；</p>
</li>
<li><p><strong>Zsh</strong>：增强了交互体验，支持更多插件和主题，适合终端爱好者；</p>
</li>
<li><p><strong>Dash</strong>：轻量级 Shell，注重执行效率，常用于脚本执行而非交互。</p>
</li>
</ul>
<p>Shell 脚本是包含一系列 Shell 命令的文本文件，通过解释器逐行执行，无需编译，具有跨平台（在兼容 Shell 的系统中）和易用性特点。</p>
<h4 id="2-第一个-Shell-脚本"><a href="#2-第一个-Shell-脚本" class="headerlink" title="2. 第一个 Shell 脚本"></a>2. 第一个 Shell 脚本</h4><p>创建一个简单的脚本文件（<a href="http://hello.sh/">hello.sh</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 这是一个注释，输出Hello World</span><br><span class="line">echo &quot;Hello, Shell Programming!&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行#!&#x2F;bin&#x2F;bash称为<strong>shebang</strong>，指定脚本使用 Bash 解释器执行；</p>
</li>
<li><p>#用于单行注释，echo命令用于输出字符串。</p>
</li>
</ul>
<p>执行脚本需先赋予执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x hello.sh  # 添加可执行权限</span><br><span class="line">（#默认是给「所有用户」添加可执行权限</span><br><span class="line">#等价于chmod u+x,g+x,o+x hello.sh</span><br><span class="line">#给特定身份加权限可以</span><br><span class="line">chmod u+x hello.sh   # 仅拥有者可执行</span><br><span class="line">chmod g+x hello.sh   # 仅同组用户可执行</span><br><span class="line">chmod o+x hello.sh   # 仅其他用户可执行）</span><br><span class="line"></span><br><span class="line">./hello.sh         # 执行脚本</span><br></pre></td></tr></table></figure>

<p>输出结果：Hello, Shell Programming!</p>
<h3 id="二、Shell-变量与参数传递"><a href="#二、Shell-变量与参数传递" class="headerlink" title="二、Shell 变量与参数传递"></a>二、Shell 变量与参数传递</h3><p>变量是 Shell 脚本存储数据的基本单元，其语法规则与其他编程语言存在差异。</p>
<h4 id="1-变量定义与使用"><a href="#1-变量定义与使用" class="headerlink" title="1. 变量定义与使用"></a>1. 变量定义与使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">name=&quot;Shell&quot;          # 定义变量，等号两侧无空格</span><br><span class="line">version=5.1           # 数值变量无需引号</span><br><span class="line">echo &quot;Name: $name&quot;    # 使用$引用变量</span><br><span class="line">echo &quot;Version: $&#123;version&#125;&quot;  # 变量名与其他字符相邻时用$&#123;&#125;包裹</span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量名由字母、数字和下划线组成，区分大小写；</p>
</li>
<li><p><strong>变量赋值时，等号 <code>=</code> 前后不能有空格</strong>（Shell 的设计哲学是：<strong>以空格作为命令与参数的分隔符</strong>。）</p>
</li>
<li><p>字符串变量建议用双引号包裹，允许包含空格和特殊字符（单引号会禁用变量扩展）。</p>
</li>
<li><p>不加引号内容里有空格特殊变量或变量就会出现问题（如：</p>
<p>多个空格被压缩成一个、变量中有空格被拆分、通配符*被展开等等）。</p>
</li>
<li><p>单引号原样输出，不解析变量。</p>
</li>
<li><p>双引号保留空格、支持变量展开。</p>
</li>
</ul>
<p><strong>总结：如果你不确定内容里有没有空格、变量或特殊字符，就加双引号 <code>&quot; &quot;</code>，这是最安全、最通用的做法。</strong></p>
<h4 id="2-环境变量与内置变量"><a href="#2-环境变量与内置变量" class="headerlink" title="2. 环境变量与内置变量"></a>2. 环境变量与内置变量</h4><p>环境变量是全局可见的变量，用于配置系统环境，常见的有：</p>
<ul>
<li><p>PATH：命令搜索路径，新增路径需执行export PATH&#x3D;$PATH:&#x2F;new&#x2F;path；</p>
</li>
<li><p>HOME：当前用户主目录；</p>
</li>
<li><p>$0：脚本文件名；</p>
</li>
<li><p>$n：传递给脚本的第 n 个参数（n≥1）；</p>
</li>
<li><p>$#：参数总数；</p>
</li>
<li><p>$?：上一条命令的退出状态（0 表示成功，非 0 表示失败）。</p>
</li>
</ul>
<p>示例：接收并输出参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;脚本名：$0&quot;</span><br><span class="line">echo &quot;参数1：$1&quot;</span><br><span class="line">echo &quot;参数2：$2&quot;</span><br><span class="line">echo &quot;参数总数：$#&quot;</span><br></pre></td></tr></table></figure>

<p>执行.&#x2F;<a href="http://params.sh/">params.sh</a> first second，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脚本名：./params.sh</span><br><span class="line">参数1：first</span><br><span class="line">参数2：second</span><br><span class="line">参数总数：2</span><br></pre></td></tr></table></figure>

<h3 id="三、常用-Shell-命令与文本处理"><a href="#三、常用-Shell-命令与文本处理" class="headerlink" title="三、常用 Shell 命令与文本处理"></a>三、常用 Shell 命令与文本处理</h3><p>Shell 脚本的强大之处在于对系统命令的灵活调用，以下为高频使用的命令及示例。</p>
<h4 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h4><ul>
<li><p>ls：列出目录内容，ls -l显示详细信息；</p>
</li>
<li><p>cp：复制文件，cp src.txt dest.txt；</p>
</li>
<li><p>mv：移动 &#x2F; 重命名文件，mv old.txt new.txt；</p>
</li>
<li><p>rm：删除文件，rm -f file.txt（强制删除，无提示），rm -r dictionary(删除文件夹必须加，r是递归删除)；</p>
</li>
<li><p>mkdir&#x2F;rmdir：创建 &#x2F; 删除目录。</p>
</li>
</ul>
<h4 id="2-文本处理三剑客"><a href="#2-文本处理三剑客" class="headerlink" title="2. 文本处理三剑客"></a>2. 文本处理三剑客</h4><ul>
<li><p><strong>grep</strong>：文本搜索，grep “error” log.txt查找包含 error 的行；</p>
</li>
<li><p><strong>sed</strong>：流编辑器，sed ‘s&#x2F;old&#x2F;new&#x2F;g’ file.txt替换文件中所有 old 为 new；</p>
</li>
<li><p><strong>awk</strong>：数据处理工具，awk ‘{print $1}’ data.txt打印每行第一个字段（默认空格分隔）。</p>
</li>
</ul>
<p>示例：统计日志中错误行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">log_file=&quot;app.log&quot;</span><br><span class="line">error_count=$(grep -c &quot;ERROR&quot; $log_file)  # 使用$(...)捕获命令输出</span><br><span class="line">echo &quot;错误行数：$error_count&quot;</span><br></pre></td></tr></table></figure>

<h3 id="四、流程控制语句"><a href="#四、流程控制语句" class="headerlink" title="四、流程控制语句"></a>四、流程控制语句</h3><p>Shell 支持条件判断、循环等流程控制结构，语法与 C 语言类似但存在细节差异。</p>
<h4 id="1-条件判断（if-语句）"><a href="#1-条件判断（if-语句）" class="headerlink" title="1. 条件判断（if 语句）"></a>1. 条件判断（if 语句）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">num=10</span><br><span class="line">if [ $num -gt 5 ]; then  # [ ] 为条件表达式，与内容间需空格</span><br><span class="line">    echo &quot;$num 大于5&quot;</span><br><span class="line">elif [ $num -eq 5 ]; then</span><br><span class="line">    echo &quot;$num 等于5&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$num 小于5&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>常用比较运算符：</p>
<ul>
<li><p>数值比较：-eq（等于）、-ne（不等于）、-gt（大于）、-lt（小于）；</p>
</li>
<li><p>字符串比较：&#x3D;&#x3D;（等于）、!&#x3D;（不等于）、-z（空字符串）；</p>
</li>
<li><p>文件判断：-f（普通文件）、-d（目录）、-r（可读）。</p>
</li>
</ul>
<h4 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h4><ul>
<li><strong>for 循环</strong>：遍历列表或范围</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 遍历参数</span><br><span class="line">for arg in &quot;$@&quot;; do  # $@表示所有参数</span><br><span class="line">    echo &quot;参数：$arg&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 数值范围循环</span><br><span class="line">for i in &#123;1..5&#125;; do</span><br><span class="line">    echo &quot;计数：$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>while 循环</strong>：条件满足时执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">count=1</span><br><span class="line">while [ $count -le 3 ]; do</span><br><span class="line">    echo &quot;循环次数：$count&quot;</span><br><span class="line">    count=$((count + 1))  # 算术运算用$((...))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="五、函数定义与调用"><a href="#五、函数定义与调用" class="headerlink" title="五、函数定义与调用"></a>五、函数定义与调用</h3><p>函数用于封装重复执行的代码块，提高脚本可读性和复用性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 定义函数</span><br><span class="line">sum() &#123;</span><br><span class="line">    local a=$1  # local声明局部变量</span><br><span class="line">    local b=$2</span><br><span class="line">    echo $((a + b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 调用函数并接收返回值</span><br><span class="line">result=$(sum 3 5)</span><br><span class="line">echo &quot;3 + 5 = $result&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数定义无需指定参数类型，通过$1、$2获取参数；</p>
</li>
<li><p>函数返回值通过echo输出，调用时用$(函数名 参数)捕获。</p>
</li>
</ul>
<h3 id="六、Shell-脚本调试与优化"><a href="#六、Shell-脚本调试与优化" class="headerlink" title="六、Shell 脚本调试与优化"></a>六、Shell 脚本调试与优化</h3><h4 id="1-调试方法"><a href="#1-调试方法" class="headerlink" title="1. 调试方法"></a>1. 调试方法</h4><ul>
<li><p>执行脚本时添加-x参数：bash -x <a href="http://script.sh/">script.sh</a>，打印执行的每一条命令及参数；</p>
</li>
<li><p>在脚本中使用set -x开启调试，set +x关闭调试。</p>
</li>
</ul>
<h4 id="2-优化建议"><a href="#2-优化建议" class="headerlink" title="2. 优化建议"></a>2. 优化建议</h4><ul>
<li><p>避免使用ls解析文件名（如for file in $(ls *.txt)），直接用for file in *.txt；</p>
</li>
<li><p>处理大文件时优先使用awk或sed，减少管道操作（|）的使用；</p>
</li>
<li><p>敏感操作前添加确认提示，如read -p “确认删除？[y&#x2F;n]” -n 1 -r。</p>
</li>
</ul>
<h3 id="七、实战案例：日志清理脚本"><a href="#七、实战案例：日志清理脚本" class="headerlink" title="七、实战案例：日志清理脚本"></a>七、实战案例：日志清理脚本</h3><p>结合上述知识，编写一个自动清理指定天数前日志的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 日志清理脚本，保留最近N天的日志</span><br><span class="line"></span><br><span class="line">LOG_DIR=&quot;/var/log/myapp&quot;</span><br><span class="line">RETENTION_DAYS=7  # 保留天数</span><br><span class="line"></span><br><span class="line"># 检查日志目录是否存在</span><br><span class="line">if [ ! -d &quot;$LOG_DIR&quot; ]; then</span><br><span class="line">    echo &quot;错误：日志目录 $LOG_DIR 不存在&quot;</span><br><span class="line">    exit 1  # 非0退出表示失败</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 删除过期日志</span><br><span class="line">find &quot;$LOG_DIR&quot; -name &quot;*.log&quot; -type f -mtime +$RETENTION_DAYS -delete</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;日志清理完成，保留最近$RETENTION_DAYS天的文件&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;日志清理失败&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>Shell 编程是 Linux 系统管理和自动化任务的必备技能，本文涵盖了脚本基础、变量、流程控制、函数等核心知识点。入门阶段需重点掌握命令组合与语法细节（如空格、引号的使用），通过实际案例练习逐步提升。</p>
<p>进阶学习可关注：正则表达式在 Shell 中的应用、信号处理（trap 命令）、与其他编程语言（如 Python）的混合编程等方向。建议结合man bash手册和实际需求，深入理解 Shell 的特性与局限。</p>
<p>若有脚本编写中的具体问题，欢迎在评论区交流讨论。</p>
]]></content>
      <categories>
        <category>Shell_powershell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 零基础入门：从网页结构到内容呈现的完整指南</title>
    <url>/2025/08/11/JavaScript_HTML_CSS/HTML%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>HTML（HyperText Markup Language，超文本标记语言）是构建网页内容结构的基础语言。它不是编程语言，而是一种<strong>标记语言</strong>（Markup Language），用于描述网页的结构和内容。所有现代网站的前端都以 HTML 为核心，配合 CSS（样式）和 JavaScript（交互）共同工作。</p>
<hr>
<h2 id="一、HTML-的基本概念"><a href="#一、HTML-的基本概念" class="headerlink" title="一、HTML 的基本概念"></a>一、HTML 的基本概念</h2><h3 id="1-什么是“超文本”？"><a href="#1-什么是“超文本”？" class="headerlink" title="1. 什么是“超文本”？"></a>1. 什么是“超文本”？</h3><ul>
<li>“超文本”指包含<strong>链接</strong>的文本，用户可以点击跳转到其他页面或资源。</li>
<li>这是 Web 的核心思想：通过链接将全球文档互联。</li>
</ul>
<h3 id="2-什么是“标记”？"><a href="#2-什么是“标记”？" class="headerlink" title="2. 什么是“标记”？"></a>2. 什么是“标记”？</h3><ul>
<li>HTML 使用<strong>标签</strong>（tags）来“标记”内容的语义和结构。</li>
<li>例如：<code>&lt;h1&gt;</code> 表示一级标题，<code>&lt;p&gt;</code> 表示段落。</li>
</ul>
<hr>
<h2 id="二、HTML-文档的基本结构"><a href="#二、HTML-文档的基本结构" class="headerlink" title="二、HTML 文档的基本结构"></a>二、HTML 文档的基本结构</h2><p>一个标准的 HTML5 文档如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="各部分说明："><a href="#各部分说明：" class="headerlink" title="各部分说明："></a>各部分说明：</h3><table>
<thead>
<tr>
<th>部分</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!DOCTYPE html&gt;</code></td>
<td>声明文档类型为 HTML5（必须放在第一行）</td>
</tr>
<tr>
<td><code>&lt;html&gt;</code></td>
<td>根元素，整个 HTML 文档的容器</td>
</tr>
<tr>
<td><code>lang=&quot;zh-CN&quot;</code></td>
<td>指定页面语言，有助于 SEO 和无障碍访问</td>
</tr>
<tr>
<td><code>&lt;head&gt;</code></td>
<td>包含元数据（metadata），不直接显示在页面上</td>
</tr>
<tr>
<td><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></td>
<td>声明字符编码为 UTF-8（支持中文等多语言）</td>
</tr>
<tr>
<td><code>&lt;meta name=&quot;viewport&quot;&gt;</code></td>
<td>适配移动设备（响应式设计关键）</td>
</tr>
<tr>
<td><code>&lt;title&gt;</code></td>
<td>浏览器标签页显示的标题</td>
</tr>
<tr>
<td><code>&lt;body&gt;</code></td>
<td>页面可见内容的容器</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、HTML-标签与元素"><a href="#三、HTML-标签与元素" class="headerlink" title="三、HTML 标签与元素"></a>三、HTML 标签与元素</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><ul>
<li>大多数标签成对出现：<code>&lt;tag&gt;内容&lt;/tag&gt;</code></li>
<li>开始标签 <code>&lt;tag&gt;</code>，结束标签 <code>&lt;/tag&gt;</code></li>
<li>有些标签是自闭合的（void elements）：如 <code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, <code>&lt;hr&gt;</code></li>
</ul>
<h3 id="2-常见标签分类"><a href="#2-常见标签分类" class="headerlink" title="2. 常见标签分类"></a>2. 常见标签分类</h3><h4 id="（1）文本内容"><a href="#（1）文本内容" class="headerlink" title="（1）文本内容"></a>（1）文本内容</h4><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;h1&gt;–&lt;h6&gt;</code></td>
<td>标题（h1 最重要）</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>重要文本（默认加粗）</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>强调文本（默认斜体）</td>
</tr>
<tr>
<td><code>&lt;span&gt;</code></td>
<td>行内通用容器（无语义）</td>
</tr>
</tbody></table>
<h4 id="（2）链接与媒体"><a href="#（2）链接与媒体" class="headerlink" title="（2）链接与媒体"></a>（2）链接与媒体</h4><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;a href=&quot;...&quot;&gt;</code></td>
<td>超链接</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code></td>
<td>图片（<code>alt</code> 是无障碍必需）</td>
</tr>
<tr>
<td><code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code></td>
<td>音视频</td>
</tr>
</tbody></table>
<h4 id="（3）列表"><a href="#（3）列表" class="headerlink" title="（3）列表"></a>（3）列表</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> <span class="comment">&lt;!-- 无序列表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span> <span class="comment">&lt;!-- 有序列表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）表格"><a href="#（4）表格" class="headerlink" title="（4）表格"></a>（4）表格</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>25<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（5）表单（用户输入）"><a href="#（5）表单（用户输入）" class="headerlink" title="（5）表单（用户输入）"></a>（5）表单（用户输入）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> 男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（6）语义化结构（HTML5-新增）"><a href="#（6）语义化结构（HTML5-新增）" class="headerlink" title="（6）语义化结构（HTML5 新增）"></a>（6）语义化结构（HTML5 新增）</h4><table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;header&gt;</code></td>
<td>页眉</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>导航栏</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>主要内容</td>
</tr>
<tr>
<td><code>&lt;article&gt;</code></td>
<td>独立文章（如博客）</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>内容区块</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>侧边栏（如广告、相关链接）</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>页脚</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>语义化优势</strong>：提升 SEO、无障碍访问（屏幕阅读器友好）、代码可读性。</p>
</blockquote>
<hr>
<h2 id="四、属性（Attributes）"><a href="#四、属性（Attributes）" class="headerlink" title="四、属性（Attributes）"></a>四、属性（Attributes）</h2><p>标签可以包含<strong>属性</strong>，提供额外信息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;访问示例网站&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;photo.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;风景照片&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常见全局属性：</p>
<ul>
<li><code>id</code>：唯一标识（用于 CSS&#x2F;JS 定位）</li>
<li><code>class</code>：类别（可重复，用于样式或脚本）</li>
<li><code>style</code>：内联 CSS（不推荐大量使用）</li>
<li><code>data-*</code>：自定义数据属性（如 <code>data-user-id=&quot;123&quot;</code>）</li>
</ul>
<hr>
<h2 id="五、HTML-与-CSS-JavaScript-的关系"><a href="#五、HTML-与-CSS-JavaScript-的关系" class="headerlink" title="五、HTML 与 CSS&#x2F;JavaScript 的关系"></a>五、HTML 与 CSS&#x2F;JavaScript 的关系</h2><ul>
<li><strong>HTML</strong>：负责<strong>内容结构</strong></li>
<li><strong>CSS</strong>：负责<strong>样式表现</strong>（颜色、布局、动画）</li>
<li><strong>JavaScript</strong>：负责<strong>交互行为</strong>（点击、数据加载等）</li>
</ul>
<p>三者协同工作：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.highlight</span> &#123; <span class="attribute">background</span>: yellow; &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;text&#x27;).classList.add(&#x27;highlight&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    高亮</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、HTML5-的重要新特性"><a href="#六、HTML5-的重要新特性" class="headerlink" title="六、HTML5 的重要新特性"></a>六、HTML5 的重要新特性</h2><ol>
<li><strong>语义化标签</strong>：<code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code> 等</li>
<li><strong>多媒体原生支持</strong>：<code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code></li>
<li>表单增强：<ul>
<li>新输入类型：<code>&lt;input type=&quot;email&quot;&gt;</code>, <code>type=&quot;date&quot;</code>, <code>type=&quot;range&quot;</code></li>
<li>表单验证（<code>required</code>, <code>pattern</code>）</li>
</ul>
</li>
<li><strong>Canvas 与 SVG</strong>：图形绘制</li>
<li><strong>本地存储</strong>：<code>localStorage</code>, <code>sessionStorage</code>（虽属 JS API，但常与 HTML 配合）</li>
<li><strong>离线应用支持</strong>（通过 Service Workers，但需配合其他技术）</li>
</ol>
<hr>
<h2 id="七、最佳实践"><a href="#七、最佳实践" class="headerlink" title="七、最佳实践"></a>七、最佳实践</h2><ol>
<li><strong>始终使用 <code>&lt;!DOCTYPE html&gt;</code></strong></li>
<li><strong>指定字符编码</strong>：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></li>
<li><strong>使用语义化标签</strong>，避免滥用 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code></li>
<li><strong>为图片提供 <code>alt</code> 属性</strong>（无障碍和 SEO）</li>
<li><strong>正确嵌套标签</strong>：<code>&lt;p&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;</code> ✅，不要 <code>&lt;strong&gt;&lt;p&gt;...&lt;/p&gt;&lt;/strong&gt;</code> ❌</li>
<li><strong>关闭所有标签</strong>（HTML5 允许部分省略，但建议显式关闭）</li>
<li><strong>验证 HTML</strong>：使用 <a href="https://validator.w3.org/">W3C Validator</a></li>
</ol>
<hr>
<h2 id="八、简单示例：完整网页"><a href="#八、简单示例：完整网页" class="headerlink" title="八、简单示例：完整网页"></a>八、简单示例：完整网页</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的个人主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: Arial, sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123; <span class="attribute">margin-right</span>: <span class="number">15px</span>; &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>张三的博客<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>欢迎访问！<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是我的第一篇博客文章。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;作者头像&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span> 2025 张三<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>标记语言，描述网页结构</td>
</tr>
<tr>
<td>核心</td>
<td>标签 + 属性 + 内容</td>
</tr>
<tr>
<td>目标</td>
<td>语义清晰、结构合理、无障碍友好</td>
</tr>
<tr>
<td>演进</td>
<td>HTML5 强化语义、多媒体、表单</td>
</tr>
<tr>
<td>协同</td>
<td>与 CSS（样式）、JS（行为）共同构建现代 Web</td>
</tr>
</tbody></table>
<p>掌握 HTML 是 Web 开发的第一步。它是所有前端技术的基石，务必打好基础。</p>
]]></content>
      <categories>
        <category>JavaScript_HTML_CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 零基础入门：从样式定义到页面美化的完整指南</title>
    <url>/2025/08/10/JavaScript_HTML_CSS/CSS%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>CSS（Cascading Style Sheets，层叠样式表）是用于<strong>控制 HTML 内容外观和布局</strong>的核心 Web 技术。它将网页的<strong>结构</strong>（HTML）与<strong>表现</strong>（样式）分离，使开发者能高效地设计美观、响应式、可维护的网站。</p>
<hr>
<h2 id="一、CSS-的基本概念"><a href="#一、CSS-的基本概念" class="headerlink" title="一、CSS 的基本概念"></a>一、CSS 的基本概念</h2><h3 id="1-什么是-CSS？"><a href="#1-什么是-CSS？" class="headerlink" title="1. 什么是 CSS？"></a>1. 什么是 CSS？</h3><ul>
<li><strong>CSS 是一种样式语言</strong>，不是编程语言。</li>
<li>它通过<strong>选择器</strong>（Selector）选中 HTML 元素，并为其设置<strong>样式规则</strong>（如颜色、字体、间距、布局等）。</li>
</ul>
<h3 id="2-“层叠”（Cascading）的含义"><a href="#2-“层叠”（Cascading）的含义" class="headerlink" title="2. “层叠”（Cascading）的含义"></a>2. “层叠”（Cascading）的含义</h3><ul>
<li>多个 CSS 规则可能作用于同一个元素。</li>
<li>浏览器根据<strong>优先级规则</strong>（来源、选择器特异性、<code>!important</code> 等）决定最终应用哪条样式。</li>
<li>样式可以<strong>继承</strong>（如字体颜色从父元素传给子元素）。</li>
</ul>
<hr>
<h2 id="二、CSS-的引入方式"><a href="#二、CSS-的引入方式" class="headerlink" title="二、CSS 的引入方式"></a>二、CSS 的引入方式</h2><h3 id="1-行内样式（不推荐）"><a href="#1-行内样式（不推荐）" class="headerlink" title="1. 行内样式（不推荐）"></a>1. 行内样式（不推荐）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 16px;&quot;</span>&gt;</span>这是一段红色文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优先级最高，但难以维护，违反“结构与样式分离”原则。</li>
</ul>
<h3 id="2-内部样式表（适用于单页）"><a href="#2-内部样式表（适用于单页）" class="headerlink" title="2. 内部样式表（适用于单页）"></a>2. 内部样式表（适用于单页）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-外部样式表（推荐）"><a href="#3-外部样式表（推荐）" class="headerlink" title="3. 外部样式表（推荐）"></a>3. 外部样式表（推荐）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">/* styles.css */</span><br><span class="line">p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：复用性强、缓存友好、便于维护。</li>
</ul>
<hr>
<h2 id="三、CSS-基本语法"><a href="#三、CSS-基本语法" class="headerlink" title="三、CSS 基本语法"></a>三、CSS 基本语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">selector &#123;</span><br><span class="line">  property: value;</span><br><span class="line">  property: value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、选择器（Selectors）"><a href="#四、选择器（Selectors）" class="headerlink" title="四、选择器（Selectors）"></a>四、选择器（Selectors）</h2><p>选择器用于“选中”要样式化的 HTML 元素。</p>
<h3 id="1-基础选择器"><a href="#1-基础选择器" class="headerlink" title="1. 基础选择器"></a>1. 基础选择器</h3><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>元素选择器</td>
<td><code>p</code></td>
<td>选中所有 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>类选择器</td>
<td><code>.highlight</code></td>
<td>选中 <code>class=&quot;highlight&quot;</code> 的元素</td>
</tr>
<tr>
<td>ID 选择器</td>
<td><code>#header</code></td>
<td>选中 <code>id=&quot;header&quot;</code> 的元素（唯一）</td>
</tr>
<tr>
<td>通配符</td>
<td><code>*</code></td>
<td>选中所有元素</td>
</tr>
</tbody></table>
<h3 id="2-组合与关系选择器"><a href="#2-组合与关系选择器" class="headerlink" title="2. 组合与关系选择器"></a>2. 组合与关系选择器</h3><table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>div p</code></td>
<td>后代选择器：div 内所有 p（无论嵌套多深）</td>
</tr>
<tr>
<td><code>div &gt; p</code></td>
<td>子选择器：div 的直接子元素 p</td>
</tr>
<tr>
<td><code>h1 + p</code></td>
<td>相邻兄弟：紧跟在 h1 后的 p</td>
</tr>
<tr>
<td><code>h1 ~ p</code></td>
<td>通用兄弟：h1 之后所有同级 p</td>
</tr>
</tbody></table>
<h3 id="3-伪类与伪元素"><a href="#3-伪类与伪元素" class="headerlink" title="3. 伪类与伪元素"></a>3. 伪类与伪元素</h3><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>伪类</td>
<td><code>a:hover</code></td>
<td>鼠标悬停时的链接</td>
</tr>
<tr>
<td>伪类</td>
<td><code>p:first-child</code></td>
<td>作为第一个子元素的 p</td>
</tr>
<tr>
<td>伪元素</td>
<td><code>p::first-line</code></td>
<td>段落第一行</td>
</tr>
<tr>
<td>伪元素</td>
<td><code>::before</code>, <code>::after</code></td>
<td>在元素前后插入内容</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：伪类用单冒号（<code>:hover</code>），伪元素用双冒号（<code>::before</code>），但为兼容旧浏览器，单冒号也常被接受。</p>
</blockquote>
<h3 id="4-属性选择器"><a href="#4-属性选择器" class="headerlink" title="4. 属性选择器"></a>4. 属性选择器</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;https&quot;</span>]</span> &#123; <span class="attribute">color</span>: green; &#125; <span class="comment">/* 以 https 开头 */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、常用-CSS-属性"><a href="#五、常用-CSS-属性" class="headerlink" title="五、常用 CSS 属性"></a>五、常用 CSS 属性</h2><h3 id="1-文本与字体"><a href="#1-文本与字体" class="headerlink" title="1. 文本与字体"></a>1. 文本与字体</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;Arial&quot;</span>, sans-serif;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;      <span class="comment">/* 或 700 */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line"><span class="attribute">text-decoration</span>: underline; <span class="comment">/* 或 none（常用于链接）*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-盒模型（Box-Model）"><a href="#2-盒模型（Box-Model）" class="headerlink" title="2. 盒模型（Box Model）"></a>2. 盒模型（Box Model）</h3><p>每个元素都是一个“盒子”，由四部分组成：</p>
<ul>
<li><strong>content</strong>（内容）</li>
<li><strong>padding</strong>（内边距）</li>
<li><strong>border</strong>（边框）</li>
<li><strong>margin</strong>（外边距）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 默认 <code>width</code> 只包含 content。使用 <code>box-sizing: border-box</code> 可让 <code>width</code> 包含 padding 和 border（推荐全局设置）：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-背景"><a href="#3-背景" class="headerlink" title="3. 背景"></a>3. 背景</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;bg.jpg&quot;</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line"><span class="attribute">background-position</span>: center;</span><br><span class="line"><span class="attribute">background-size</span>: cover; <span class="comment">/* 常用：覆盖整个容器 */</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="number">#f0f0f0</span> <span class="built_in">url</span>(<span class="string">&quot;bg.jpg&quot;</span>) no-repeat center/cover;</span><br></pre></td></tr></table></figure>

<h3 id="4-布局相关"><a href="#4-布局相关" class="headerlink" title="4. 布局相关"></a>4. 布局相关</h3><ul>
<li><code>display</code>: 控制元素显示类型<ul>
<li><code>block</code>（独占一行，如 div）</li>
<li><code>inline</code>（行内，如 span）</li>
<li><code>inline-block</code>（行内但可设宽高）</li>
<li><code>flex</code>（弹性布局）</li>
<li><code>grid</code>（网格布局）</li>
<li><code>none</code>（隐藏元素）</li>
</ul>
</li>
<li><code>position</code>: 定位方式<ul>
<li><code>static</code>（默认）</li>
<li><code>relative</code>（相对自身原位置偏移）</li>
<li><code>absolute</code>（相对于最近的非 static 祖先定位）</li>
<li><code>fixed</code>（相对于视口固定）</li>
<li><code>sticky</code>（滚动时“粘”在视口某位置）</li>
</ul>
</li>
<li><code>float</code>（旧布局方式，现多用 Flex&#x2F;Grid 替代）</li>
</ul>
<hr>
<h2 id="六、现代布局技术"><a href="#六、现代布局技术" class="headerlink" title="六、现代布局技术"></a>六、现代布局技术</h2><h3 id="1-Flexbox（弹性盒子）"><a href="#1-Flexbox（弹性盒子）" class="headerlink" title="1. Flexbox（弹性盒子）"></a>1. Flexbox（弹性盒子）</h3><p>适合<strong>一维布局</strong>（行或列）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 主轴对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;     <span class="comment">/* 交叉轴对齐 */</span></span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;         <span class="comment">/* 换行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 等比伸缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-CSS-Grid（网格布局）"><a href="#2-CSS-Grid（网格布局）" class="headerlink" title="2. CSS Grid（网格布局）"></a>2. CSS Grid（网格布局）</h3><p>适合<strong>二维布局</strong>（行 + 列）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr <span class="number">1</span>fr; <span class="comment">/* 三列，比例 1:2:1 */</span></span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: span <span class="number">2</span>; <span class="comment">/* 占两列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ 推荐：简单布局用 Flex，复杂网格用 Grid。</p>
</blockquote>
<hr>
<h2 id="七、响应式设计（Responsive-Design）"><a href="#七、响应式设计（Responsive-Design）" class="headerlink" title="七、响应式设计（Responsive Design）"></a>七、响应式设计（Responsive Design）</h2><p>让网页在不同设备（手机、平板、桌面）上良好显示。</p>
<h3 id="1-视口设置（HTML-必须）"><a href="#1-视口设置（HTML-必须）" class="headerlink" title="1. 视口设置（HTML 必须）"></a>1. 视口设置（HTML 必须）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-媒体查询（Media-Queries）"><a href="#2-媒体查询（Media-Queries）" class="headerlink" title="2. 媒体查询（Media Queries）"></a>2. 媒体查询（Media Queries）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认：手机样式 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 平板及以上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123; <span class="attribute">padding</span>: <span class="number">20px</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桌面 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-移动优先（Mobile-First）"><a href="#3-移动优先（Mobile-First）" class="headerlink" title="3. 移动优先（Mobile-First）"></a>3. 移动优先（Mobile-First）</h3><p>先写手机样式，再用 <code>min-width</code> 逐步增强。</p>
<hr>
<h2 id="八、CSS-变量（自定义属性）"><a href="#八、CSS-变量（自定义属性）" class="headerlink" title="八、CSS 变量（自定义属性）"></a>八、CSS 变量（自定义属性）</h2><p>CSS 原生支持变量（CSS Custom Properties）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--primary-color</span>: <span class="number">#3498db</span>;</span><br><span class="line">  <span class="attr">--spacing</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--primary-color);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--spacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：主题切换、减少重复、动态修改（通过 JS）。</p>
<hr>
<h2 id="九、层叠与优先级（Cascading-Specificity）"><a href="#九、层叠与优先级（Cascading-Specificity）" class="headerlink" title="九、层叠与优先级（Cascading &amp; Specificity）"></a>九、层叠与优先级（Cascading &amp; Specificity）</h2><p>当多个规则冲突时，浏览器按以下顺序决定：</p>
<ol>
<li><p><strong>来源顺序</strong>：后写的覆盖先写的（同优先级下）</p>
</li>
<li><p>选择器特异性</p>
<p>（Specificity）：</p>
<ul>
<li><code>!important</code> &gt; 行内样式 &gt; ID &gt; 类&#x2F;属性&#x2F;伪类 &gt; 元素&#x2F;伪元素</li>
<li>特异性计算：<code>[内联, ID, 类, 元素]</code>，如 <code>#nav .item a</code> → <code>[0,1,1,1]</code></li>
</ul>
</li>
<li><p><strong>继承</strong>：某些属性（如 <code>color</code>, <code>font</code>）会从父元素继承</p>
</li>
</ol>
<blockquote>
<p>❗ 尽量避免 <code>!important</code>，它会破坏层叠逻辑。</p>
</blockquote>
<hr>
<h2 id="十、最佳实践"><a href="#十、最佳实践" class="headerlink" title="十、最佳实践"></a>十、最佳实践</h2><ol>
<li><strong>语义化类名</strong>：<code>.btn-primary</code> 而非 <code>.red-button</code></li>
<li><strong>使用外部 CSS 文件</strong></li>
<li><strong>全局重置或标准化样式</strong>（如 <code>normalize.css</code>）</li>
<li><strong>采用 BEM 命名法</strong>（Block__Element–Modifier）避免命名冲突</li>
<li><strong>响应式优先</strong>：移动优先 + 媒体查询</li>
<li><strong>使用 Flex&#x2F;Grid 替代 float 和 table 布局</strong></li>
<li><strong>压缩 CSS 文件</strong>（生产环境）</li>
<li><strong>合理使用 CSS 变量管理主题</strong></li>
</ol>
<hr>
<h2 id="十一、工具与扩展"><a href="#十一、工具与扩展" class="headerlink" title="十一、工具与扩展"></a>十一、工具与扩展</h2><ul>
<li><strong>预处理器</strong>：Sass、Less（支持变量、嵌套、函数等）</li>
<li><strong>PostCSS</strong>：自动加浏览器前缀（如 <code>autoprefixer</code>）</li>
<li><strong>CSS 框架</strong>：Bootstrap、Tailwind CSS（加速开发）</li>
<li><strong>开发者工具</strong>：浏览器 F12 可实时调试 CSS</li>
</ul>
<hr>
<h2 id="示例：完整-CSS-片段"><a href="#示例：完整-CSS-片段" class="headerlink" title="示例：完整 CSS 片段"></a>示例：完整 CSS 片段</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 重置部分默认样式 */</span></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--main-color</span>: <span class="number">#2c3e50</span>;</span><br><span class="line">  <span class="attr">--accent-color</span>: <span class="number">#e74c3c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--accent-color);</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>控制 HTML 的外观与布局</td>
</tr>
<tr>
<td>核心机制</td>
<td>选择器 + 属性 + 层叠规则</td>
</tr>
<tr>
<td>现代布局</td>
<td>Flexbox（一维）、Grid（二维）</td>
</tr>
<tr>
<td>响应式</td>
<td>媒体查询 + 移动优先</td>
</tr>
<tr>
<td>可维护性</td>
<td>变量、语义化命名、模块化</td>
</tr>
<tr>
<td>发展趋势</td>
<td>CSS-in-JS、Utility-First（如 Tailwind）</td>
</tr>
</tbody></table>
<p>掌握 CSS 是构建现代 Web 界面的关键。它看似简单，但深入理解盒模型、层叠、布局算法和响应式原理，才能写出高效、健壮的样式代码。</p>
]]></content>
      <categories>
        <category>JavaScript_HTML_CSS</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端三剑客：HTML、CSS 与 JavaScript 的协同之道</title>
    <url>/2025/08/12/JavaScript_HTML_CSS/HTML%E3%80%81CSS%20%E4%B8%8E%20JavaScript%20%E7%9A%84%E5%8D%8F%E5%90%8C%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>在前端开发的世界里，HTML、CSS 和 JavaScript 被称为 “前端三剑客”。它们分工明确又紧密协作，共同支撑起网页从结构搭建到视觉呈现，再到交互体验的完整生命周期。对于初学者来说，理解这三者的关系和配合方式，是迈入前端开发领域的关键一步。本文将从各自的核心功能出发，解析它们如何像精密齿轮一样协同工作，最终构建出我们日常浏览的网页应用。</p>
<h3 id="一、各司其职：前端三要素的核心定位"><a href="#一、各司其职：前端三要素的核心定位" class="headerlink" title="一、各司其职：前端三要素的核心定位"></a>一、各司其职：前端三要素的核心定位</h3><p>HTML、CSS 和 JavaScript 虽然都服务于前端，但各自承担着截然不同的角色，缺一不可。</p>
<h4 id="1-HTML：网页的-“骨架”"><a href="#1-HTML：网页的-“骨架”" class="headerlink" title="1. HTML：网页的 “骨架”"></a>1. HTML：网页的 “骨架”</h4><p>HTML（超文本标记语言）是网页的基础结构，如同建筑的钢筋骨架，定义了网页的内容和层级关系。</p>
<ul>
<li><p><strong>核心功能</strong>：通过标签（如<code>&lt;h1&gt;、&lt;p&gt;、&lt;img&gt;、&lt;div&gt;</code>）描述网页中的元素（标题、段落、图片、容器等），确定 “有什么内容” 以及 “内容的组织结构”。</p>
</li>
<li><p><strong>特点</strong>：不涉及任何样式和交互，仅负责内容的呈现逻辑。例如，<code>&lt;ul&gt;</code>标签会告诉浏览器 “这里是一个无序列表”，但不会规定列表项的颜色或点击效果。</p>
</li>
</ul>
<p>示例：一个简单的 HTML 结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;我的博客&lt;/h1&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;h2&gt;前端三剑客介绍&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;HTML负责结构，CSS负责样式，JavaScript负责交互。&lt;/p&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/main&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码仅定义了网页的基本结构，在浏览器中打开时，会显示未经美化的文字和标题。</p>
<h4 id="2-CSS：网页的-“外观”"><a href="#2-CSS：网页的-“外观”" class="headerlink" title="2. CSS：网页的 “外观”"></a>2. CSS：网页的 “外观”</h4><p>CSS（层叠样式表）负责网页的视觉呈现，如同建筑的装修设计，决定了网页的 “颜值”。</p>
<ul>
<li><p><strong>核心功能</strong>：通过选择器定位 HTML 元素，再通过样式属性（如color、font-size、background、layout）定义元素的颜色、大小、位置、布局等视觉效果，回答 “内容长什么样”。</p>
</li>
<li><p><strong>特点</strong>：完全独立于 HTML 内容，通过 “样式规则” 实现内容与表现的分离。同一份 HTML 结构，搭配不同的 CSS 可以呈现出截然不同的视觉效果。</p>
</li>
</ul>
<p>示例：为上述 HTML 添加 CSS 样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 美化标题 */</span><br><span class="line">h1 &#123;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line">    text-align: center;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 美化文章 */</span><br><span class="line">article &#123;</span><br><span class="line">    max-width: 800px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    padding: 30px;</span><br><span class="line">    background-color: white;</span><br><span class="line">    box-shadow: 0 2px 10px rgba(0,0,0,0.1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 CSS 后，网页会呈现出居中的标题、带阴影的文章卡片等美化效果。</p>
<h4 id="3-JavaScript：网页的-“行为”"><a href="#3-JavaScript：网页的-“行为”" class="headerlink" title="3. JavaScript：网页的 “行为”"></a>3. JavaScript：网页的 “行为”</h4><p>JavaScript 是一种编程语言，负责网页的交互逻辑和动态效果，如同给建筑添加电梯、门窗控制系统，让网页 “活” 起来。</p>
<ul>
<li><p><strong>核心功能</strong>：通过编程逻辑操作 HTML 和 CSS，实现动态内容更新、用户交互响应（如点击、滚动）、数据处理等功能，解决 “内容如何响应操作” 的问题。</p>
</li>
<li><p><strong>特点</strong>：可以实时修改 HTML 结构（如添加 &#x2F; 删除元素）和 CSS 样式（如动态改变颜色），让网页从静态展示变为动态交互。</p>
</li>
</ul>
<p>示例：用 JavaScript 实现交互效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给文章添加点击事件</span><br><span class="line">document.querySelector(&#x27;article&#x27;).addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">    // 点击时改变背景颜色</span><br><span class="line">    this.style.backgroundColor = &#x27;#f8f9fa&#x27;;</span><br><span class="line">    // 动态添加一段文字</span><br><span class="line">    const newP = document.createElement(&#x27;p&#x27;);</span><br><span class="line">    newP.textContent = &#x27;你点击了文章区域！&#x27;;</span><br><span class="line">    this.appendChild(newP);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>添加 JavaScript 后，点击文章区域会触发背景色变化和内容新增的交互效果。</p>
<h3 id="二、协同工作：三要素的配合机制"><a href="#二、协同工作：三要素的配合机制" class="headerlink" title="二、协同工作：三要素的配合机制"></a>二、协同工作：三要素的配合机制</h3><p>HTML、CSS 和 JavaScript 并非孤立存在，它们通过 “数据流向” 和 “操作接口” 形成紧密的协作关系，共同完成网页的渲染和交互流程。</p>
<h4 id="1-加载顺序：从结构到交互的渐进式构建"><a href="#1-加载顺序：从结构到交互的渐进式构建" class="headerlink" title="1. 加载顺序：从结构到交互的渐进式构建"></a>1. 加载顺序：从结构到交互的渐进式构建</h4><p>当浏览器加载网页时，会按照固定的顺序解析和执行三要素，确保协作的有序性：</p>
<ol>
<li><p><strong>解析 HTML</strong>：浏览器首先读取 HTML 文件，构建 DOM（文档对象模型）—— 一个以树状结构表示的网页元素关系图。DOM 是 HTML 的内存映射，后续 CSS 和 JavaScript 的操作都基于 DOM 进行。</p>
</li>
<li><p><strong>解析 CSS</strong>：在解析 HTML 的同时，浏览器会并行解析 CSS，构建 CSSOM（CSS 对象模型）—— 记录所有样式规则的结构。随后，浏览器将 DOM 和 CSSOM 结合，生成渲染树（Render Tree），确定每个元素的最终视觉样式（如位置、大小、颜色）。</p>
</li>
<li><p><strong>执行 JavaScript</strong>：JavaScript 通常在 DOM 和 CSSOM 构建到一定阶段后执行（可通过<code>&lt;script&gt;</code>标签的defer或async属性控制时机）。它可以通过 DOM API 操作 DOM（如添加元素），通过 CSSOM API 修改样式（如改变类名），从而实现动态交互。</p>
</li>
</ol>
<p>这个过程就像盖房子：先搭骨架（HTML→DOM），再刷油漆（CSS→CSSOM→渲染树），最后装电路（JavaScript→交互逻辑）。</p>
<h4 id="2-数据交互：三要素的-“通信协议”"><a href="#2-数据交互：三要素的-“通信协议”" class="headerlink" title="2. 数据交互：三要素的 “通信协议”"></a>2. 数据交互：三要素的 “通信协议”</h4><p>三要素之间通过标准化的接口进行数据交换，确保操作的一致性：</p>
<ul>
<li><p><strong>HTML 与 CSS 的交互</strong>：CSS 通过选择器 “绑定” HTML 元素。例如，h1 { color: red; }表示 “所有<code>&lt;h1&gt;</code>标签应用红色”，这种绑定基于 DOM 中的元素类型。当 HTML 结构变化（如新增<code>&lt;h1&gt;</code>），CSS 会自动应用样式，无需额外操作。</p>
</li>
<li><p><strong>HTML 与 JavaScript 的交互</strong>：JavaScript 通过 DOM API 操作 HTML。例如：</p>
</li>
<li><ul>
<li>document.getElementById(‘title’)：获取指定 ID 的 HTML 元素</li>
</ul>
</li>
<li><ul>
<li>element.innerHTML &#x3D; ‘新内容’：修改元素的内容</li>
</ul>
</li>
<li><ul>
<li>element.appendChild(newElement)：新增子元素</li>
</ul>
</li>
<li><p><strong>CSS 与 JavaScript 的交互</strong>：JavaScript 通过修改 DOM 间接影响 CSS，或直接操作样式：</p>
</li>
<li><ul>
<li>方式一：修改元素的class或id，触发 CSS 中对应选择器的样式（推荐，符合内容与样式分离原则）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 给元素添加class，触发CSS中定义的.active样式</span><br><span class="line">document.querySelector(&#x27;button&#x27;).classList.add(&#x27;active&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>方式二：直接修改元素的style属性</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 直接修改样式（不推荐，混合了逻辑与样式）</span><br><span class="line">document.querySelector(&#x27;button&#x27;).style.backgroundColor = &#x27;blue&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="3-典型场景：三要素协同的实例"><a href="#3-典型场景：三要素协同的实例" class="headerlink" title="3. 典型场景：三要素协同的实例"></a>3. 典型场景：三要素协同的实例</h4><p>以 “点击按钮切换夜间模式” 为例，看三要素如何配合：</p>
<ol>
<li><strong>HTML</strong>：定义按钮和内容容器（骨架）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;modeToggle&quot;&gt;切换夜间模式&lt;/button&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;这是一段内容&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>CSS</strong>：定义默认模式和夜间模式的样式（外观）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.content &#123; background: white; color: black; &#125;</span><br><span class="line">.dark-mode .content &#123; background: #333; color: white; &#125; /* 夜间模式样式 */</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>JavaScript</strong>：监听按钮点击，切换模式（行为）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取按钮元素</span><br><span class="line">const button = document.getElementById(&#x27;modeToggle&#x27;);</span><br><span class="line">// 点击事件：给body添加/移除dark-mode类</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    document.body.classList.toggle(&#x27;dark-mode&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>协作流程：用户点击按钮→JavaScript 触发click事件→修改body的class→CSS 中.dark-mode .content的样式生效→内容区域切换为夜间模式。整个过程中，HTML 提供结构，CSS 提供样式方案，JavaScript 提供触发逻辑，三者无缝衔接。</p>
<h3 id="三、为什么需要分离？三要素拆分的优势"><a href="#三、为什么需要分离？三要素拆分的优势" class="headerlink" title="三、为什么需要分离？三要素拆分的优势"></a>三、为什么需要分离？三要素拆分的优势</h3><p>将网页功能拆分为 HTML、CSS 和 JavaScript，并非技术限制，而是工程化的最佳实践，带来了显著的优势：</p>
<ol>
<li><p><strong>关注点分离</strong>：开发者可以专注于单一领域 ——HTML 开发者负责内容结构，CSS 开发者负责视觉设计，JavaScript 开发者负责交互逻辑，提高团队协作效率。</p>
</li>
<li><p><strong>代码复用</strong>：同一份 CSS 可以应用于多个 HTML 页面（通过外部样式表），同一段 JavaScript 可以在不同项目中复用（如表单验证逻辑）。</p>
</li>
<li><p><strong>维护性提升</strong>：修改样式无需改动 HTML 和 JavaScript，调整交互逻辑不影响结构和样式。例如，将按钮颜色从红色改为蓝色，只需修改 CSS 的background属性，无需触碰 HTML 和 JavaScript。</p>
</li>
<li><p><strong>性能优化</strong>：浏览器对三者的解析和缓存机制不同，分离后可以针对性优化。例如，CSS 和 JavaScript 文件可单独缓存，减少重复下载；JavaScript 可异步加载，避免阻塞 HTML 解析。</p>
</li>
</ol>
<p>反例：如果将样式写在 HTML 的style属性中，将交互逻辑写在onclick属性中（如<button style="color: red;" onclick="alert('hi')">按钮</button>），会导致代码混乱、复用困难，这是前端开发的大忌。</p>
<h3 id="四、总结：前端开发的-“铁三角”"><a href="#四、总结：前端开发的-“铁三角”" class="headerlink" title="四、总结：前端开发的 “铁三角”"></a>四、总结：前端开发的 “铁三角”</h3><p>HTML、CSS 和 JavaScript 如同前端开发的 “铁三角”：</p>
<ul>
<li><p>HTML 是基础，定义了网页的内容和结构，回答了 “有什么”；</p>
</li>
<li><p>CSS 是美化，决定了网页的视觉呈现，回答了 “长什么样”；</p>
</li>
<li><p>JavaScript 是灵魂，实现了网页的交互逻辑，回答了 “能做什么”。</p>
</li>
</ul>
<p>它们通过 DOM 和 CSSOM 实现数据交互，按照 “HTML→CSS→JavaScript” 的顺序协同工作，既各司其职又紧密配合，共同构建出从静态展示到动态交互的完整网页体验。</p>
<p>理解这三者的关系，不仅是学习前端开发的基础，更是写出高质量代码的前提。在实际开发中，我们应始终遵循 “结构、样式、行为分离” 的原则，让三要素在各自的领域发挥最大价值，同时通过标准化的接口实现高效协作。这就是前端开发的核心思想 —— 用分工明确的技术栈，构建出既美观又易用的网页应用。</p>
]]></content>
      <categories>
        <category>JavaScript_HTML_CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端开发</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（DP）</title>
    <url>/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><strong>动态规划（Dynamic Programming, 简称 DP）</strong> </p>
<hr>
<h2 id="🧠-一、什么是动态规划？"><a href="#🧠-一、什么是动态规划？" class="headerlink" title="🧠 一、什么是动态规划？"></a>🧠 一、什么是动态规划？</h2><p><strong>动态规划</strong> 是一种用于求解<strong>具有重叠子问题</strong>和<strong>最优子结构</strong>性质的问题的算法设计方法。它通过将原问题分解为若干子问题，<strong>先求解子问题，再利用子问题的解构造原问题的解</strong>，从而避免重复计算，提高效率。</p>
<blockquote>
<p>💡 动态规划 ≠ 递归，但常借助递归（带记忆化）或迭代实现。<br>它的本质是 <strong>“用空间换时间”</strong> —— 存储中间结果，避免重复计算。</p>
</blockquote>
<hr>
<h2 id="🔑-二、动态规划的两个核心性质"><a href="#🔑-二、动态规划的两个核心性质" class="headerlink" title="🔑 二、动态规划的两个核心性质"></a>🔑 二、动态规划的两个核心性质</h2><h3 id="1-最优子结构（Optimal-Substructure）"><a href="#1-最优子结构（Optimal-Substructure）" class="headerlink" title="1. 最优子结构（Optimal Substructure）"></a>1. <strong>最优子结构（Optimal Substructure）</strong></h3><blockquote>
<p>原问题的最优解包含子问题的最优解。</p>
</blockquote>
<p>例如：  </p>
<ul>
<li>最短路径问题中，A 到 C 的最短路径如果经过 B，那么 A→B 和 B→C 也一定是最短的。</li>
<li>股票买卖最大利润：第 i 天的最大利润依赖于前 i-1 天的状态。</li>
</ul>
<h3 id="2-重叠子问题（Overlapping-Subproblems）"><a href="#2-重叠子问题（Overlapping-Subproblems）" class="headerlink" title="2. 重叠子问题（Overlapping Subproblems）"></a>2. <strong>重叠子问题（Overlapping Subproblems）</strong></h3><blockquote>
<p>在递归求解过程中，某些子问题会被反复计算多次。</p>
</blockquote>
<p>例如：<br>斐波那契数列 <code>f(n) = f(n-1) + f(n-2)</code> 中，<code>f(3)</code> 会被 <code>f(5)</code>、<code>f(4)</code> 等多次调用。</p>
<p>✅ 动态规划通过<strong>记忆化</strong>（缓存子问题结果）来消除重复计算。</p>
<hr>
<h2 id="🛠️-三、动态规划的解题步骤（四步法）"><a href="#🛠️-三、动态规划的解题步骤（四步法）" class="headerlink" title="🛠️ 三、动态规划的解题步骤（四步法）"></a>🛠️ 三、动态规划的解题步骤（四步法）</h2><ol>
<li><strong>定义状态（State）</strong><br>明确 <code>dp[i]</code> 或 <code>dp[i][j]</code> 表示什么含义（这是最关键的一步！）。</li>
<li><strong>写出状态转移方程（Recurrence Relation）</strong><br>找出当前状态如何由之前的状态推导而来。</li>
<li><strong>确定初始条件（Base Case）</strong><br>设置边界值，如 <code>dp[0] = 0</code>、<code>dp[1] = 1</code> 等。</li>
<li><strong>确定遍历顺序 &amp; 返回结果</strong><br>是从前往后？还是从后往前？最终答案是 <code>dp[n]</code> 还是 <code>max(dp)</code>？</li>
</ol>
<hr>
<h2 id="📚-四、常见-DP-类型与经典例题"><a href="#📚-四、常见-DP-类型与经典例题" class="headerlink" title="📚 四、常见 DP 类型与经典例题"></a>📚 四、常见 DP 类型与经典例题</h2><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>经典题目</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线性 DP</strong></td>
<td>状态只与前几个状态有关</td>
<td>斐波那契、爬楼梯、打家劫舍、股票买卖</td>
</tr>
<tr>
<td><strong>区间 DP</strong></td>
<td>状态由区间 <code>[i, j]</code> 定义</td>
<td>最长回文子串、石子合并</td>
</tr>
<tr>
<td><strong>背包 DP</strong></td>
<td>有限资源下的最优选择</td>
<td>0-1 背包、完全背包、分割等和子集</td>
</tr>
<tr>
<td><strong>树形 DP</strong></td>
<td>在树结构上进行状态转移</td>
<td>树的最大独立集、二叉树打家劫舍</td>
</tr>
<tr>
<td><strong>状态机 DP</strong></td>
<td>用多个状态表示不同行为</td>
<td>股票买卖（含冷冻期、手续费）</td>
</tr>
<tr>
<td><strong>数位 DP</strong></td>
<td>按数字位进行状态设计</td>
<td>不含连续 1 的数字个数</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-五、经典例子详解"><a href="#🎯-五、经典例子详解" class="headerlink" title="🎯 五、经典例子详解"></a>🎯 五、经典例子详解</h2><h3 id="✅-例1：斐波那契数列（入门）"><a href="#✅-例1：斐波那契数列（入门）" class="headerlink" title="✅ 例1：斐波那契数列（入门）"></a>✅ 例1：斐波那契数列（入门）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归（指数时间，大量重复）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP（O(n) 时间，O(1) 空间）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="✅-例2：爬楼梯（LeetCode-70）"><a href="#✅-例2：爬楼梯（LeetCode-70）" class="headerlink" title="✅ 例2：爬楼梯（LeetCode 70）"></a>✅ 例2：爬楼梯（LeetCode 70）</h3><blockquote>
<p>每次可走 1 或 2 步，问到第 n 阶有多少种方法？</p>
</blockquote>
<ul>
<li>状态：<code>dp[i]</code> &#x3D; 到第 i 阶的方法数</li>
<li>转移：<code>dp[i] = dp[i-1] + dp[i-2]</code></li>
<li>初始：<code>dp[0]=1, dp[1]=1</code></li>
</ul>
<h3 id="✅-例3：0-1-背包问题"><a href="#✅-例3：0-1-背包问题" class="headerlink" title="✅ 例3：0-1 背包问题"></a>✅ 例3：0-1 背包问题</h3><blockquote>
<p>有 n 件物品，重量 <code>w[i]</code>，价值 <code>v[i]</code>，背包容量 W，求最大价值。</p>
</blockquote>
<ul>
<li><p>状态：<code>dp[i][j]</code> &#x3D; 前 i 件物品在容量 j 下的最大价值</p>
</li>
<li><p>转移：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">    dp[i<span class="number">-1</span>][j],               <span class="comment">// 不选第 i 件</span></span><br><span class="line">    dp[i<span class="number">-1</span>][j - w[i]] + v[i]  <span class="comment">// 选第 i 件（需 j &gt;= w[i]）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="✅-例4：最长公共子序列（LCS）"><a href="#✅-例4：最长公共子序列（LCS）" class="headerlink" title="✅ 例4：最长公共子序列（LCS）"></a>✅ 例4：最长公共子序列（LCS）</h3><blockquote>
<p>字符串 “abcde” 和 “ace” 的 LCS 是 “ace”，长度 3。</p>
</blockquote>
<ul>
<li><p>状态：<code>dp[i][j]</code> &#x3D; s1 前 i 个字符 与 s2 前 j 个字符的 LCS 长度</p>
</li>
<li><p>转移：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="⚠️-六、DP-vs-贪心-vs-分治"><a href="#⚠️-六、DP-vs-贪心-vs-分治" class="headerlink" title="⚠️ 六、DP vs 贪心 vs 分治"></a>⚠️ 六、DP vs 贪心 vs 分治</h2><table>
<thead>
<tr>
<th>方法</th>
<th>是否保证最优</th>
<th>是否有重叠子问题</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分治</strong></td>
<td>是（如果子问题独立）</td>
<td>❌ 无重叠</td>
<td>归并排序、快速排序</td>
</tr>
<tr>
<td><strong>贪心</strong></td>
<td>❌ 仅局部最优</td>
<td>❌</td>
<td>活动选择、霍夫曼编码</td>
</tr>
<tr>
<td><strong>动态规划</strong></td>
<td>✅ 全局最优</td>
<td>✅ 有重叠</td>
<td>背包、LCS、最短路径</td>
</tr>
</tbody></table>
<blockquote>
<p>贪心是 DP 的特例——当局部最优能推出全局最优时，可用贪心（如股票 I）。</p>
</blockquote>
<hr>
<h2 id="💡-七、如何判断一道题是否用-DP？"><a href="#💡-七、如何判断一道题是否用-DP？" class="headerlink" title="💡 七、如何判断一道题是否用 DP？"></a>💡 七、如何判断一道题是否用 DP？</h2><p>问自己三个问题：</p>
<ol>
<li><strong>问题是否可以分解为子问题？</strong></li>
<li><strong>子问题的最优解是否能组合成原问题的最优解？</strong>（最优子结构）</li>
<li><strong>子问题是否被重复计算？</strong>（重叠子问题）</li>
</ol>
<p>如果都回答“是”，那就考虑 DP！</p>
<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><ul>
<li><strong>动态规划 &#x3D; 状态定义 + 状态转移 + 初始条件 + 遍历顺序</strong></li>
<li>核心思想：<strong>记住已经算过的，避免重复劳动</strong></li>
<li>常见场景：最优化问题（最大&#x2F;最小&#x2F;最多&#x2F;最少）、计数问题、存在性问题</li>
<li>刷题建议：从简单线性 DP 开始（如爬楼梯、打家劫舍），再进阶到背包、区间、状态机等</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树 (Red-Black Tree)</title>
    <url>/2026/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p><strong>红黑树 (Red-Black Tree)</strong> 是计算机科学中最重要的数据结构之一，也是 C++ STL 中 <code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code> 的幕后功臣。</p>
<p>简而言之，它是一种<strong>自平衡的二叉搜索树 (Self-balancing Binary Search Tree)</strong>。</p>
<h3 id="1-为什么要发明红黑树？"><a href="#1-为什么要发明红黑树？" class="headerlink" title="1. 为什么要发明红黑树？"></a>1. 为什么要发明红黑树？</h3><p>为了解决普通二叉搜索树 (BST) 的<strong>退化问题</strong>。</p>
<ul>
<li><strong>理想情况</strong>：BST 是平衡的，查找、插入效率是 $O(\log n)$。</li>
<li><strong>最坏情况</strong>：如果你按顺序插入数据（例如 1, 2, 3, 4, 5），普通的 BST 会退化成一条<strong>链表</strong>。这时候查找效率直接掉到 $O(n)$，非常慢。</li>
</ul>
<p>红黑树通过制定一套“颜色规则”，强制树保持“大致平衡”，从而保证任何情况下的操作效率都是稳定的 $O(\log n)$。</p>
<hr>
<h3 id="2-红黑树的-5-条铁律"><a href="#2-红黑树的-5-条铁律" class="headerlink" title="2. 红黑树的 5 条铁律"></a>2. 红黑树的 5 条铁律</h3><p>红黑树的每个节点上多存了一个位 (bit) 的信息：<strong>颜色</strong>（红或黑）。</p>
<p>正是这几条看似奇怪的规则，保证了树的平衡：</p>
<ol>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li>
<li><strong>根节点</strong>：根节点必须是<strong>黑色</strong>。</li>
<li><strong>叶子节点</strong>：所有的叶子节点（NIL 节点，即空节点）都视为<strong>黑色</strong>。</li>
<li><strong>红节点限制</strong>：<strong>不能有两个红节点相连</strong>（即红节点的父节点和子节点必须是黑色）。</li>
<li><strong>黑色高度</strong>：从任意一个节点到其所有后代叶子节点的简单路径上，必须包含<strong>相同数量的黑色节点</strong>。</li>
</ol>
<hr>
<h3 id="3-为什么这能保证平衡？（核心直觉）"><a href="#3-为什么这能保证平衡？（核心直觉）" class="headerlink" title="3. 为什么这能保证平衡？（核心直觉）"></a>3. 为什么这能保证平衡？（核心直觉）</h3><p>你可能会问：<em>“这几条规则怎么就能保证树不变成链表呢？”</em></p>
<p>请结合规则 4 和规则 5 来看：</p>
<ul>
<li><strong>规则 5</strong> 保证了每条路径上的<strong>黑色</strong>节点数量是一样的（我们把这看作树的“骨架”）。</li>
<li><strong>规则 4</strong> 限制了红色节点不能连在一起，这意味着红色节点只能穿插在黑色节点之间。</li>
</ul>
<p><strong>结论：</strong> 哪怕是一条红黑相间的最长路径，其长度也<strong>不会超过</strong>全黑的最短路径的 <strong>2 倍</strong>。</p>
<ul>
<li><strong>最短路径</strong>：全黑。</li>
<li><strong>最长路径</strong>：黑-红-黑-红-黑… (红节点最多只能和黑节点一样多)。</li>
</ul>
<p>这虽然不如 AVL 树（绝对平衡）那么严格，但足以保证效率在 $O(\log n)$ 级别。</p>
<hr>
<h3 id="4-它是如何“自平衡”的？"><a href="#4-它是如何“自平衡”的？" class="headerlink" title="4. 它是如何“自平衡”的？"></a>4. 它是如何“自平衡”的？</h3><p>当你插入或删除数据时，可能会破坏上面的规则（比如插入了一个红节点，结果父节点也是红的，违反规则 4）。</p>
<p>红黑树通过以下三种手段自我修复：</p>
<ol>
<li><strong>变色 (Recoloring)</strong>：把红变黑，或把黑变红。</li>
<li><strong>左旋 (Left Rotation)</strong>：将某个节点向左“跌倒”，变成其右孩子的左孩子。</li>
<li><strong>右旋 (Right Rotation)</strong>：将某个节点向右“跌倒”，变成其左孩子的右孩子。</li>
</ol>
<blockquote>
<p><strong>比喻</strong>：想象你在玩魔方。当你改变了一块的位置（插入数据），魔方乱了（规则打破了）。你需要通过一系列特定的旋转和变色公式，让它重新符合规则。</p>
</blockquote>
<hr>
<h3 id="5-面试常考：红黑树-vs-AVL-树"><a href="#5-面试常考：红黑树-vs-AVL-树" class="headerlink" title="5. 面试常考：红黑树 vs AVL 树"></a>5. 面试常考：红黑树 vs AVL 树</h3><p>这是面试中最高频的对比问题。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>AVL 树</strong></th>
<th><strong>红黑树 (RB Tree)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>平衡程度</strong></td>
<td><strong>严格平衡</strong> (高度差不超过 1)</td>
<td><strong>非严格平衡</strong> (最长路径 &lt;&#x3D; 2倍最短路径)</td>
</tr>
<tr>
<td><strong>查找效率</strong></td>
<td>更快 (树更矮)</td>
<td>稍慢 (树稍高，但也属于 $O(\log n)$)</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除</strong></td>
<td>慢 (需要频繁旋转来维持严格平衡)</td>
<td><strong>快</strong> (旋转次数少，变色多)</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td><strong>读多写少</strong> (如字典库)</td>
<td><strong>综合性能强，读写兼顾</strong> (如 C++ STL <code>map</code>, Java <code>TreeMap</code>)</td>
</tr>
</tbody></table>
<p><strong>为什么 C++ STL 选择了红黑树？</strong></p>
<p>因为通用库不知道用户是读得多还是写得多。红黑树在插入、删除和查找之间取得了<strong>最好的折中 (Trade-off)</strong>。它的统计性能在大多数场景下都优于 AVL 树。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>红黑树</strong>是一种<strong>近似平衡</strong>的二叉搜索树。</li>
<li>它通过<strong>颜色约束</strong>确保最长路径不超过最短路径的 2 倍。</li>
<li>它是 C++ STL <code>map</code> 和 <code>set</code> 的底层实现，保证了 $O(\log n)$ 的增删查改效率。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 零基础入门：从语法到实践的完整指南</title>
    <url>/2025/08/08/JavaScript_HTML_CSS/JavaScript%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>JavaScript 是网页交互的核心语言，也是前端开发的基石，同时还能用于后端开发（Node.js）、移动应用开发等领域。对于零基础学习者来说，它语法灵活、入门门槛较低，是编程入门的理想选择。本文将从最基础的概念讲起，带你一步步走进 JavaScript 的世界。</p>
<h3 id="一、JavaScript-是什么？"><a href="#一、JavaScript-是什么？" class="headerlink" title="一、JavaScript 是什么？"></a>一、JavaScript 是什么？</h3><p>JavaScript（简称 JS）是一种<strong>轻量级的编程语言</strong>，主要用于为网页添加交互效果。与 HTML（负责结构）和 CSS（负责样式）不同，JavaScript 负责网页的 “行为”—— 比如按钮点击、表单验证、动态内容加载等。</p>
<ul>
<li><p><strong>特点</strong>：</p>
</li>
<li><ul>
<li>解释型语言：不需要编译，直接由浏览器解释执行</li>
</ul>
</li>
<li><ul>
<li>弱类型语言：变量类型可以动态变化</li>
</ul>
</li>
<li><ul>
<li>跨平台：可在所有主流浏览器和操作系统上运行</li>
</ul>
</li>
<li><ul>
<li>多范式：支持面向对象、函数式等多种编程风格</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
</li>
<li><ul>
<li>网页交互（表单验证、动画效果）</li>
</ul>
</li>
<li><ul>
<li>服务器开发（Node.js）</li>
</ul>
</li>
<li><ul>
<li>移动应用开发（React Native、Ionic）</li>
</ul>
</li>
<li><ul>
<li>桌面应用开发（Electron）</li>
</ul>
</li>
</ul>
<h3 id="二、开发环境搭建"><a href="#二、开发环境搭建" class="headerlink" title="二、开发环境搭建"></a>二、开发环境搭建</h3><p>学习 JavaScript 无需复杂的环境配置，只需以下工具：</p>
<ol>
<li><p><strong>文本编辑器</strong>：推荐 VSCode（免费、功能强大，可安装 “JavaScript and TypeScript Nightly” 插件增强支持）</p>
</li>
<li><p><strong>浏览器</strong>：推荐 Chrome 或 Firefox，它们的开发者工具（按 F12 打开）是学习 JS 的重要帮手</p>
</li>
<li><p><strong>运行方式</strong>：</p>
</li>
</ol>
<ul>
<li><ul>
<li>方式一：在 HTML 文件中嵌入 JS 代码，用浏览器打开运行</li>
</ul>
</li>
<li><ul>
<li>方式二：直接在浏览器开发者工具的 “Console” 面板中输入代码实时执行</li>
</ul>
</li>
</ul>
<h3 id="三、Hello-World！第一个程序"><a href="#三、Hello-World！第一个程序" class="headerlink" title="三、Hello World！第一个程序"></a>三、Hello World！第一个程序</h3><p>让我们从经典的 “Hello World” 开始，体验 JavaScript 的运行方式。</p>
<h4 id="1-在-HTML-中嵌入-JS"><a href="#1-在-HTML-中嵌入-JS" class="headerlink" title="1. 在 HTML 中嵌入 JS"></a>1. 在 HTML 中嵌入 JS</h4><p>创建一个index.html文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;JS入门&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 这是JavaScript代码</span><br><span class="line">        alert(&quot;Hello, World!&quot;);  // 弹出提示框</span><br><span class="line">        console.log(&quot;Hello, Console!&quot;);  // 在控制台输出</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>用浏览器打开该文件，会弹出 “Hello, World!” 的提示框，按 F12 打开控制台（Console），可看到 “Hello, Console!” 的输出。</p>
<h4 id="2-在控制台直接运行"><a href="#2-在控制台直接运行" class="headerlink" title="2. 在控制台直接运行"></a>2. 在控制台直接运行</h4><p>打开浏览器→按 F12→切换到 “Console” 面板，直接输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Hello, JavaScript!&quot;);</span><br></pre></td></tr></table></figure>

<p>按回车即可看到输出结果，这种方式适合快速测试代码片段。</p>
<h3 id="四、基础语法"><a href="#四、基础语法" class="headerlink" title="四、基础语法"></a>四、基础语法</h3><h4 id="1-变量（Variables）"><a href="#1-变量（Variables）" class="headerlink" title="1. 变量（Variables）"></a>1. 变量（Variables）</h4><p>变量用于存储数据，JavaScript 中用let、const或var声明变量（推荐使用let和const）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用let声明可修改的变量</span><br><span class="line">let age = 25;</span><br><span class="line">age = 26;  // 可以修改</span><br><span class="line"></span><br><span class="line">// 用const声明不可修改的常量（必须初始化）</span><br><span class="line">const name = &quot;Alice&quot;;</span><br><span class="line">// name = &quot;Bob&quot;;  // 错误：常量不能修改</span><br><span class="line"></span><br><span class="line">// 变量可以存储不同类型的数据</span><br><span class="line">let isStudent = true;  // 布尔值</span><br><span class="line">let height = 1.75;     // 数值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：var是旧版语法，存在作用域问题，建议优先使用let（变量）和const（常量）。</p>
</blockquote>
<h4 id="2-数据类型（Data-Types）"><a href="#2-数据类型（Data-Types）" class="headerlink" title="2. 数据类型（Data Types）"></a>2. 数据类型（Data Types）</h4><p>JavaScript 有 7 种基本数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串（文本）</td>
<td>“Hello”、’World’</td>
</tr>
<tr>
<td>Number</td>
<td>数值（整数或浮点数）</td>
<td>42、3.14</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值（真或假）</td>
<td>true、false</td>
</tr>
<tr>
<td>Null</td>
<td>表示空值</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>表示未定义（变量声明后未赋值）</td>
<td>let x;</td>
</tr>
<tr>
<td>Symbol</td>
<td>唯一标识符（ES6 新增）</td>
<td>Symbol(“id”)</td>
</tr>
<tr>
<td>BigInt</td>
<td>大整数（用于超出 Number 范围的整数）</td>
<td>123n</td>
</tr>
</tbody></table>
<p>此外，还有Object（对象）类型，用于存储复杂数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串可以用单引号或双引号</span><br><span class="line">let message = &quot;Hello&quot;;</span><br><span class="line">let language = &#x27;JavaScript&#x27;;</span><br><span class="line"></span><br><span class="line">// 数值</span><br><span class="line">let count = 100;</span><br><span class="line">let price = 99.9;</span><br><span class="line"></span><br><span class="line">// 布尔值</span><br><span class="line">let isActive = true;</span><br><span class="line">let hasError = false;</span><br><span class="line"></span><br><span class="line">// 空值和未定义</span><br><span class="line">let emptyValue = null;</span><br><span class="line">let undefinedValue;  // 声明后未赋值，值为undefined</span><br></pre></td></tr></table></figure>

<h4 id="3-运算符（Operators）"><a href="#3-运算符（Operators）" class="headerlink" title="3. 运算符（Operators）"></a>3. 运算符（Operators）</h4><p>JavaScript 支持多种运算符，用于处理数据：</p>
<ul>
<li><strong>算术运算符</strong>：+（加）、-（减）、*（乘）、&#x2F;（除）、%（取余）、++（自增）、–（自减）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = 3;</span><br><span class="line">console.log(a + b);  // 13</span><br><span class="line">console.log(a % b);  // 1（10除以3的余数）</span><br><span class="line">a++;  // 等价于a = a + 1，此时a为11</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>赋值运算符</strong>：&#x3D;、+&#x3D;、-&#x3D;等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line">x += 3;  // 等价于x = x + 3，结果为8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>比较运算符</strong>：&#x3D;&#x3D;（等于，不严格）、&#x3D;&#x3D;&#x3D;（严格等于）、!&#x3D;（不等于）、&gt;、&lt;等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(5 == &quot;5&quot;);   // true（只比较值，不比较类型）</span><br><span class="line">console.log(5 === &quot;5&quot;);  // false（严格比较，类型不同）</span><br><span class="line">console.log(10 &gt; 5);     // true</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑运算符</strong>：&amp;&amp;（与）、||（或）、!（非）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let isAdult = age &gt;= 18;</span><br><span class="line">let hasId = true;</span><br><span class="line">console.log(isAdult &amp;&amp; hasId);  // 两个条件都为真才返回真</span><br><span class="line">console.log(isAdult || hasId);   // 至少一个条件为真就返回真</span><br><span class="line">console.log(!isAdult);          // 取反</span><br></pre></td></tr></table></figure>

<h4 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h4><p>流程控制用于控制代码的执行顺序，包括条件判断和循环。</p>
<ul>
<li><strong>条件判断（if-else）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let score = 85;</span><br><span class="line">if (score &gt;= 90) &#123;</span><br><span class="line">    console.log(&quot;优秀&quot;);</span><br><span class="line">&#125; else if (score &gt;= 60) &#123;</span><br><span class="line">    console.log(&quot;及格&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;不及格&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>循环（for&#x2F;while）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// for循环：重复执行指定次数</span><br><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    console.log(&quot;循环次数：&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// while循环：条件为真时重复执行</span><br><span class="line">let num = 1;</span><br><span class="line">while (num &lt;= 3) &#123;</span><br><span class="line">    console.log(&quot;数字：&quot; + num);</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-函数（Functions）"><a href="#5-函数（Functions）" class="headerlink" title="5. 函数（Functions）"></a>5. 函数（Functions）</h4><p>函数是可重复使用的代码块，用于执行特定任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义函数</span><br><span class="line">function greet(personName) &#123;</span><br><span class="line">    return &quot;Hello, &quot; + personName + &quot;!&quot;;  // 返回结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用函数</span><br><span class="line">let greeting = greet(&quot;Bob&quot;);</span><br><span class="line">console.log(greeting);  // 输出：Hello, Bob!</span><br><span class="line"></span><br><span class="line">// 箭头函数（ES6简写形式）</span><br><span class="line">const add = (a, b) =&gt; &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(add(2, 3));  // 输出：5</span><br><span class="line"></span><br><span class="line">// 简化的箭头函数（只有一行返回语句）</span><br><span class="line">const multiply = (a, b) =&gt; a * b;</span><br><span class="line">console.log(multiply(2, 3));  // 输出：6</span><br></pre></td></tr></table></figure>

<h3 id="五、数组（Arrays）"><a href="#五、数组（Arrays）" class="headerlink" title="五、数组（Arrays）"></a>五、数组（Arrays）</h3><p>数组用于存储多个值，用方括号[]表示，元素之间用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建数组</span><br><span class="line">let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];</span><br><span class="line">let numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">// 访问数组元素（索引从0开始）</span><br><span class="line">console.log(fruits[0]);  // 输出：apple</span><br><span class="line"></span><br><span class="line">// 修改数组元素</span><br><span class="line">fruits[1] = &quot;grape&quot;;</span><br><span class="line">console.log(fruits);  // 输出：[&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]</span><br><span class="line"></span><br><span class="line">// 数组长度</span><br><span class="line">console.log(numbers.length);  // 输出：5</span><br><span class="line"></span><br><span class="line">// 常用数组方法</span><br><span class="line">fruits.push(&quot;mango&quot;);  // 添加元素到末尾</span><br><span class="line">console.log(fruits);   // [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;, &quot;mango&quot;]</span><br><span class="line"></span><br><span class="line">let firstFruit = fruits.pop();  // 移除最后一个元素并返回</span><br><span class="line">console.log(firstFruit);  // 输出：mango</span><br></pre></td></tr></table></figure>

<h3 id="六、对象（Objects）"><a href="#六、对象（Objects）" class="headerlink" title="六、对象（Objects）"></a>六、对象（Objects）</h3><p>对象用于存储键值对形式的复杂数据，用花括号{}表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建对象</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Alice&quot;,</span><br><span class="line">    age: 30,</span><br><span class="line">    isStudent: false,</span><br><span class="line">    hobbies: [&quot;reading&quot;, &quot;coding&quot;],</span><br><span class="line">    greet: function() &#123;  // 对象中的函数称为方法</span><br><span class="line">        return &quot;Hello, I&#x27;m &quot; + this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 访问对象属性</span><br><span class="line">console.log(person.name);  // 输出：Alice</span><br><span class="line">console.log(person[&quot;age&quot;]);  // 另一种访问方式，输出：30</span><br><span class="line"></span><br><span class="line">// 调用对象方法</span><br><span class="line">console.log(person.greet());  // 输出：Hello, I&#x27;m Alice</span><br><span class="line"></span><br><span class="line">// 修改属性值</span><br><span class="line">person.age = 31;</span><br><span class="line">console.log(person.age);  // 输出：31</span><br><span class="line"></span><br><span class="line">// 添加新属性</span><br><span class="line">person.city = &quot;Beijing&quot;;</span><br><span class="line">console.log(person.city);  // 输出：Beijing</span><br></pre></td></tr></table></figure>

<h3 id="七、实战案例：简单计算器"><a href="#七、实战案例：简单计算器" class="headerlink" title="七、实战案例：简单计算器"></a>七、实战案例：简单计算器</h3><p>下面通过一个简单的计算器案例，综合运用前面所学的知识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;简单计算器&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;number&quot; id=&quot;num1&quot; placeholder=&quot;输入第一个数&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;operator&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;*&quot;&gt;×&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;/&quot;&gt;÷&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;input type=&quot;number&quot; id=&quot;num2&quot; placeholder=&quot;输入第二个数&quot;&gt;</span><br><span class="line">    &lt;button onclick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;结果：&lt;span id=&quot;result&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function calculate() &#123;</span><br><span class="line">            // 获取输入值</span><br><span class="line">            const num1 = parseFloat(document.getElementById(&quot;num1&quot;).value);</span><br><span class="line">            const num2 = parseFloat(document.getElementById(&quot;num2&quot;).value);</span><br><span class="line">            const operator = document.getElementById(&quot;operator&quot;).value;</span><br><span class="line">            let result;</span><br><span class="line"></span><br><span class="line">            // 计算逻辑</span><br><span class="line">            if (operator === &quot;+&quot;) &#123;</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">            &#125; else if (operator === &quot;-&quot;) &#123;</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">            &#125; else if (operator === &quot;*&quot;) &#123;</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">            &#125; else if (operator === &quot;/&quot;) &#123;</span><br><span class="line">                // 处理除数为0的情况</span><br><span class="line">                result = num2 === 0 ? &quot;除数不能为0&quot; : num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 显示结果</span><br><span class="line">            document.getElementById(&quot;result&quot;).textContent = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这个案例实现了一个简单的计算器，包含数值输入、运算符选择、计算逻辑和结果显示，用到了变量、函数、条件判断、DOM 操作等知识。</p>
<h3 id="八、学习资源与下一步"><a href="#八、学习资源与下一步" class="headerlink" title="八、学习资源与下一步"></a>八、学习资源与下一步</h3><p>掌握基础语法后，可以继续学习以下内容：</p>
<ul>
<li><p>DOM 操作：控制网页元素的更高级方法</p>
</li>
<li><p>事件处理：响应鼠标点击、键盘输入等事件</p>
</li>
<li><p>异步编程：Promise、async&#x2F;await处理异步操作</p>
</li>
<li><p>ES6 + 新特性：解构赋值、模块、类等</p>
</li>
<li><p>框架学习：React、Vue、Angular 等前端框架</p>
</li>
</ul>
<p>推荐资源：</p>
<ul>
<li><p>MDN Web Docs（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript%EF%BC%89%EF%BC%9A%E6%9C%80%E6%9D%83%E5%A8%81%E7%9A%84">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript）：最权威的</a> JavaScript 文档</p>
</li>
<li><p><a href="https://javascript.info/">JavaScript.info</a>（<a href="https://zh.javascript.info/%EF%BC%89%EF%BC%9A%E9%80%82%E5%90%88%E9%9B%B6%E5%9F%BA%E7%A1%80%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%95%99%E7%A8%8B">https://zh.javascript.info/）：适合零基础的交互式教程</a></p>
</li>
<li><p>实践平台：CodePen、JSFiddle（在线编写和运行 JS 代码）</p>
</li>
</ul>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>JavaScript 是一门灵活且强大的编程语言，零基础学习者通过掌握变量、数据类型、运算符、函数等基础语法，就能实现简单的交互功能。本文从环境搭建到实战案例，覆盖了 JavaScript 的核心入门知识，希望能帮助你迈出编程学习的第一步。</p>
<p>学习编程的关键在于多写多练，建议结合实际案例练习语法，逐步积累经验。随着学习的深入，你会发现 JavaScript 的更多魅力，为前端开发或其他领域打下坚实基础。</p>
]]></content>
      <categories>
        <category>JavaScript_HTML_CSS</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门</title>
    <url>/2025/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/MySQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="MySQL-从入门到高级：全面用法详解与实战示例"><a href="#MySQL-从入门到高级：全面用法详解与实战示例" class="headerlink" title="MySQL 从入门到高级：全面用法详解与实战示例"></a><strong>MySQL 从入门到高级：全面用法详解与实战示例</strong></h1><hr>
<h2 id="第一部分：基础篇-Foundations"><a href="#第一部分：基础篇-Foundations" class="headerlink" title="第一部分：基础篇 (Foundations)"></a><strong>第一部分：基础篇 (Foundations)</strong></h2><h3 id="1-环境搭建与连接"><a href="#1-环境搭建与连接" class="headerlink" title="1. 环境搭建与连接"></a><strong>1. 环境搭建与连接</strong></h3><ul>
<li><strong>安装与启动：</strong> 参考入门教程的安装步骤。确保 MySQL 服务正在运行。</li>
<li><strong>连接方式：</strong><ul>
<li><strong>命令行客户端：</strong> <code>mysql -u username -p -h host -P port</code> (e.g., <code>mysql -u root -p</code>)</li>
<li><strong>图形化工具 (推荐)：</strong><ul>
<li><strong>MySQL Workbench:</strong> 官方免费工具，功能强大（设计、开发、管理、性能）。</li>
<li><strong>DBeaver:</strong> 开源通用数据库工具，支持多种数据库。</li>
<li><strong>Navicat:</strong> 商业软件，界面友好，功能丰富。</li>
</ul>
</li>
</ul>
</li>
<li><strong>基本命令：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 显示当前用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 显示当前数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 退出客户端</span></span><br><span class="line">EXIT; 或 QUIT;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-核心概念回顾"><a href="#2-核心概念回顾" class="headerlink" title="2. 核心概念回顾"></a><strong>2. 核心概念回顾</strong></h3><ul>
<li><strong>数据库 (Database):</strong> 数据容器。</li>
<li><strong>表 (Table):</strong> 二维结构，存储数据。</li>
<li><strong>行 (Row&#x2F;Record):</strong> 一条数据。</li>
<li><strong>列 (Column&#x2F;Field):</strong> 数据的属性。</li>
<li><strong>数据类型：</strong><ul>
<li><strong>数值：</strong> <code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>, <code>FLOAT</code>, <code>DOUBLE</code>, <code>DECIMAL(M,D)</code> (精确小数)。</li>
<li><strong>字符串：</strong> <code>CHAR(N)</code> (固定), <code>VARCHAR(N)</code> (可变), <code>TEXT</code> (长文本), <code>BLOB</code> (二进制)。</li>
<li><strong>日期时间：</strong> <code>DATE</code> (YYYY-MM-DD), <code>TIME</code> (HH:MM:SS), <code>DATETIME</code> (YYYY-MM-DD HH:MM:SS), <code>TIMESTAMP</code> (自动更新&#x2F;范围不同), <code>YEAR</code>。</li>
<li><strong>其他：</strong> <code>ENUM</code> (枚举), <code>SET</code> (集合), <code>JSON</code> (MySQL 5.7+)。</li>
</ul>
</li>
<li><strong>约束 (Constraints):</strong> 保证数据完整性和一致性。<ul>
<li><code>PRIMARY KEY</code>: 唯一标识，非空，一个表一个。</li>
<li><code>FOREIGN KEY</code>: 关联另一表的主键，实现参照完整性。</li>
<li><code>UNIQUE</code>: 值唯一，可为 NULL (单个 NULL 可存在)。</li>
<li><code>NOT NULL</code>: 列值不能为空。</li>
<li><code>DEFAULT value</code>: 默认值。</li>
<li><code>CHECK (condition)</code>: 值需满足条件 (MySQL 8.0.16+ 支持，早期版本语法解析但不强制)。</li>
</ul>
</li>
</ul>
<h3 id="3-数据定义语言-DDL-Data-Definition-Language"><a href="#3-数据定义语言-DDL-Data-Definition-Language" class="headerlink" title="3. 数据定义语言 (DDL - Data Definition Language)"></a><strong>3. 数据定义语言 (DDL - Data Definition Language)</strong></h3><ul>
<li><p><strong>创建数据库：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> school <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="comment">-- IF NOT EXISTS: 避免重复创建报错</span></span><br><span class="line"><span class="comment">-- CHARACTER SET utf8mb4: 支持完整 Unicode (如 emoji)</span></span><br><span class="line"><span class="comment">-- COLLATE utf8mb4_unicode_ci: 排序规则 (不区分大小写)</span></span><br><span class="line">USE school; <span class="comment">-- 使用数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> students (</span><br><span class="line">    student_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span> COMMENT <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;名&#x27;</span>,</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;姓&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    date_of_birth <span class="type">DATE</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">    enrollment_date <span class="type">DATE</span> <span class="keyword">DEFAULT</span> (<span class="built_in">CURRENT_DATE</span>) COMMENT <span class="string">&#x27;入学日期&#x27;</span>,</span><br><span class="line">    gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0.00</span> COMMENT <span class="string">&#x27;平均绩点&#x27;</span>,</span><br><span class="line">    is_active <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span> COMMENT <span class="string">&#x27;是否活跃&#x27;</span>,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"><span class="comment">-- ENGINE=InnoDB: 支持事务、外键</span></span><br><span class="line"><span class="comment">-- COMMENT: 添加注释</span></span><br><span class="line"><span class="comment">-- ON UPDATE CURRENT_TIMESTAMP: 字段更新时自动更新为当前时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改表 (ALTER TABLE):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> students <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> phone <span class="type">VARCHAR</span>(<span class="number">15</span>) AFTER last_name;</span><br><span class="line"><span class="comment">-- 在 last_name 后添加 phone 列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列 (数据类型、约束)</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> students MODIFY <span class="keyword">COLUMN</span> gpa <span class="type">DECIMAL</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 注意：修改类型可能导致数据截断或丢失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> students CHANGE <span class="keyword">COLUMN</span> phone mobile_phone <span class="type">VARCHAR</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> students <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> is_active;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> courses (</span><br><span class="line">    course_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    course_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    credits <span class="type">INT</span> <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE TABLE</span> enrollments (</span><br><span class="line">    enrollment_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    student_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    course_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    enrollment_date <span class="type">DATE</span> <span class="keyword">DEFAULT</span> (<span class="built_in">CURRENT_DATE</span>),</span><br><span class="line">    grade <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (student_id) <span class="keyword">REFERENCES</span> students(student_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (course_id) <span class="keyword">REFERENCES</span> courses(course_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- ON DELETE CASCADE: 删除学生时，自动删除其所有选课记录</span></span><br><span class="line"><span class="comment">-- ON DELETE RESTRICT: 如果有选课记录，则禁止删除课程</span></span><br><span class="line"><span class="comment">-- ON UPDATE CASCADE: 更新主键时，自动更新外键值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键约束 (需先知道约束名)</span></span><br><span class="line"><span class="comment">-- 先查看约束名: SHOW CREATE TABLE enrollments;</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> enrollments <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_student_id; <span class="comment">-- 假设约束名为 fk_student_id</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除表与数据库：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> enrollments;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> temp_db;</span><br><span class="line"><span class="comment">-- 谨慎使用！数据不可恢复</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> students; <span class="comment">-- 简要结构</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> students; <span class="comment">-- 完整的创建语句</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> students; <span class="comment">-- 查看索引</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-数据操作语言-DML-Data-Manipulation-Language"><a href="#4-数据操作语言-DML-Data-Manipulation-Language" class="headerlink" title="4. 数据操作语言 (DML - Data Manipulation Language)"></a><strong>4. 数据操作语言 (DML - Data Manipulation Language)</strong></h3><ul>
<li><p><strong>插入数据 (INSERT):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单行插入</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> students (first_name, last_name, email, date_of_birth)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;alice.smith@email.com&#x27;</span>, <span class="string">&#x27;2000-05-15&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多行插入</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> students (first_name, last_name, email, date_of_birth)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Johnson&#x27;</span>, <span class="string">&#x27;bob.johnson@email.com&#x27;</span>, <span class="string">&#x27;1999-08-20&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;Brown&#x27;</span>, <span class="string">&#x27;charlie.brown@email.com&#x27;</span>, <span class="string">&#x27;2001-03-10&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询结果 (INSERT ... SELECT)</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> backup_students (first_name, last_name, email)</span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, email <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gpa <span class="operator">&gt;</span> <span class="number">3.5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询数据 (SELECT) - 基础与进阶：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students;</span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, email <span class="keyword">FROM</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤 (WHERE)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gpa <span class="operator">&gt;=</span> <span class="number">3.0</span> <span class="keyword">AND</span> date_of_birth <span class="operator">&gt;</span> <span class="string">&#x27;1999-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> last_name <span class="keyword">IN</span> (<span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Johnson&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>; <span class="comment">-- 以A开头</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e&#x27;</span>; <span class="comment">-- 以e结尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;%li%&#x27;</span>; <span class="comment">-- 包含li</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> gpa <span class="keyword">BETWEEN</span> <span class="number">2.5</span> <span class="keyword">AND</span> <span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">-- 查找NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> email <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排序 (ORDER BY)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name <span class="keyword">ASC</span>, first_name <span class="keyword">ASC</span>; <span class="comment">-- 先按姓升序，再按名升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> gpa <span class="keyword">DESC</span> LIMIT <span class="number">5</span>; <span class="comment">-- GPA最高的前5名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重 (DISTINCT)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city <span class="keyword">FROM</span> addresses; <span class="comment">-- 假设有addresses表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制结果 (LIMIT &amp; OFFSET)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>; <span class="comment">-- 跳过前20条，取10条 (分页)</span></span><br><span class="line"><span class="comment">-- 等价于 LIMIT 20, 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新数据 (UPDATE):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> gpa <span class="operator">=</span> <span class="number">3.8</span>, updated_at <span class="operator">=</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="keyword">WHERE</span> student_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> gpa <span class="operator">=</span> gpa <span class="operator">+</span> <span class="number">0.1</span> <span class="comment">-- 所有GPA增加0.1</span></span><br><span class="line"><span class="keyword">WHERE</span> enrollment_date <span class="operator">&lt;</span> <span class="string">&#x27;2024-01-01&#x27;</span>;</span><br><span class="line"><span class="comment">-- 警告：没有WHERE会更新所有行！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除数据 (DELETE):</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> student_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> enrollment_date <span class="operator">&lt;</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">AND</span> gpa <span class="operator">&lt;</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">-- 警告：没有WHERE会删除所有行！</span></span><br><span class="line"><span class="comment">-- TRUNCATE TABLE students; -- 更快地清空表 (重置AUTO_INCREMENT计数器)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第二部分：进阶篇-Advanced"><a href="#第二部分：进阶篇-Advanced" class="headerlink" title="第二部分：进阶篇 (Advanced)"></a><strong>第二部分：进阶篇 (Advanced)</strong></h2><h3 id="5-复杂查询与连接-JOINs"><a href="#5-复杂查询与连接-JOINs" class="headerlink" title="5. 复杂查询与连接 (JOINs)"></a><strong>5. 复杂查询与连接 (JOINs)</strong></h3><ul>
<li><p><strong>内连接 (INNER JOIN):</strong> 只返回两表都有匹配的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.first_name, s.last_name, c.course_name, e.grade</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e.student_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> c.course_name <span class="operator">=</span> <span class="string">&#x27;Database Systems&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>左外连接 (LEFT JOIN):</strong> 返回左表所有行，右表无匹配则为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找出所有学生及其选课情况，包括未选课的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> s.first_name, s.last_name, c.course_name, e.grade</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e.student_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.last_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右外连接 (RIGHT JOIN):</strong> 返回右表所有行，左表无匹配则为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找出所有课程及其选课学生，包括无人选的课程</span></span><br><span class="line"><span class="keyword">SELECT</span> s.first_name, s.last_name, c.course_name</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e.student_id</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e.course_id <span class="operator">=</span> c.course_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自连接 (Self-Join):</strong> 表与自己连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设有一个员工表 employees(employee_id, name, manager_id)</span></span><br><span class="line"><span class="comment">-- 查询每个员工及其经理的姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name <span class="keyword">AS</span> employee, e2.name <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.employee_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>联合查询 (UNION):</strong> 合并多个 <code>SELECT</code> 语句的结果（自动去重）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生和教师的姓名和邮箱</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, email, <span class="string">&#x27;Student&#x27;</span> <span class="keyword">AS</span> role <span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, email, <span class="string">&#x27;Teacher&#x27;</span> <span class="keyword">AS</span> role <span class="keyword">FROM</span> teachers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name;</span><br><span class="line"><span class="comment">-- UNION ALL: 不去重，效率更高</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-聚合函数与分组-GROUP-BY"><a href="#6-聚合函数与分组-GROUP-BY" class="headerlink" title="6. 聚合函数与分组 (GROUP BY)"></a><strong>6. 聚合函数与分组 (GROUP BY)</strong></h3><ul>
<li><p><strong>聚合函数：</strong> 对一组值进行计算。</p>
<ul>
<li><code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>。</li>
</ul>
</li>
<li><p><strong>分组 (GROUP BY):</strong> 将行分组，对每组应用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按课程统计选课人数和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    c.course_name,</span><br><span class="line">    <span class="built_in">COUNT</span>(e.student_id) <span class="keyword">AS</span> enrollment_count,</span><br><span class="line">    <span class="built_in">AVG</span>(e.grade) <span class="keyword">AS</span> avg_grade</span><br><span class="line"><span class="keyword">FROM</span> courses c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> c.course_id <span class="operator">=</span> e.course_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_id, c.course_name <span class="comment">-- 通常按主键或唯一键分组</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(e.student_id) <span class="operator">&gt;</span> <span class="number">0</span>; <span class="comment">-- HAVING 过滤分组后的结果 (不能用WHERE)</span></span><br><span class="line"><span class="comment">-- HAVING avg_grade &gt; 75.0; -- 按平均分过滤</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HAVING vs WHERE:</strong></p>
<ul>
<li><code>WHERE</code>: 在分组<strong>前</strong>过滤行。</li>
<li><code>HAVING</code>: 在分组<strong>后</strong>过滤组。</li>
</ul>
</li>
</ul>
<h3 id="7-子查询-Subqueries"><a href="#7-子查询-Subqueries" class="headerlink" title="7. 子查询 (Subqueries)"></a><strong>7. 子查询 (Subqueries)</strong></h3><ul>
<li><p><strong>标量子查询：</strong> 返回单个值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找出GPA高于平均GPA的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, gpa</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> gpa <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(gpa) <span class="keyword">FROM</span> students);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>行子查询：</strong> 返回单行多列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找出与Alice Smith同一天入学的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> (first_name, last_name) <span class="operator">!=</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>) <span class="comment">-- 排除Alice自己</span></span><br><span class="line">  <span class="keyword">AND</span> enrollment_date <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> enrollment_date </span><br><span class="line">      <span class="keyword">FROM</span> students </span><br><span class="line">      <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">AND</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表子查询 (派生表)：</strong> 返回结果集，用作 <code>FROM</code> 子句中的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个课程的平均成绩，并找出高于总体平均的课程</span></span><br><span class="line"><span class="keyword">SELECT</span> course_name, avg_grade</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        c.course_name,</span><br><span class="line">        <span class="built_in">AVG</span>(e.grade) <span class="keyword">AS</span> avg_grade</span><br><span class="line">    <span class="keyword">FROM</span> courses c</span><br><span class="line">    <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> c.course_id <span class="operator">=</span> e.course_id</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> c.course_id, c.course_name</span><br><span class="line">) <span class="keyword">AS</span> course_averages</span><br><span class="line"><span class="keyword">WHERE</span> avg_grade <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(grade) <span class="keyword">FROM</span> enrollments);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>相关子查询：</strong> 子查询引用了外部查询的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找出每个学生选课中的最高分课程</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    s.first_name,</span><br><span class="line">    s.last_name,</span><br><span class="line">    c.course_name,</span><br><span class="line">    e1.grade</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">JOIN</span> enrollments e1 <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e1.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e1.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> e1.grade <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(e2.grade)</span><br><span class="line">    <span class="keyword">FROM</span> enrollments e2</span><br><span class="line">    <span class="keyword">WHERE</span> e2.student_id <span class="operator">=</span> s.student_id <span class="comment">-- 相关条件</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-索引-Indexes-性能核心"><a href="#8-索引-Indexes-性能核心" class="headerlink" title="8. 索引 (Indexes) - 性能核心"></a><strong>8. 索引 (Indexes) - 性能核心</strong></h3><ul>
<li><strong>作用：</strong> 加速数据检索，类似书籍目录。</li>
<li><strong>类型：</strong><ul>
<li><strong>普通索引 (INDEX):</strong> 最基本的索引。</li>
<li><strong>唯一索引 (UNIQUE):</strong> 值必须唯一。</li>
<li><strong>主键索引 (PRIMARY KEY):</strong> 唯一且非空，自动创建。</li>
<li><strong>全文索引 (FULLTEXT):</strong> 用于文本内容的全文搜索 (MyISAM 引擎更早支持，InnoDB 5.6+)。</li>
<li><strong>空间索引 (SPATIAL):</strong> 用于地理空间数据。</li>
</ul>
</li>
<li><strong>创建索引：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_lastname <span class="keyword">ON</span> students(last_name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> students(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建复合索引 (多列)</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> students(last_name, first_name);</span><br><span class="line"><span class="comment">-- 查询时 WHERE last_name=&#x27;Smith&#x27; OR (last_name=&#x27;Smith&#x27; AND first_name=&#x27;Alice&#x27;) 可用</span></span><br><span class="line"><span class="comment">-- WHERE first_name=&#x27;Alice&#x27; 单独使用通常无效 (最左前缀原则)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_unique_email <span class="keyword">ON</span> students(email);</span><br><span class="line"><span class="comment">-- 主键和UNIQUE约束会自动创建唯一索引</span></span><br></pre></td></tr></table></figure></li>
<li><strong>使用索引：</strong><ul>
<li><code>WHERE</code> 子句中的列。</li>
<li><code>JOIN</code> 条件中的列。</li>
<li><code>ORDER BY</code> 和 <code>GROUP BY</code> 中的列。</li>
</ul>
</li>
<li><strong>查看索引：</strong> <code>SHOW INDEX FROM students;</code></li>
<li><strong>删除索引：</strong> <code>DROP INDEX idx_lastname ON students;</code></li>
<li><strong>索引优化原则：</strong><ul>
<li><strong>选择性高：</strong> 列值分布广泛（如 <code>email</code>），避免在性别（男&#x2F;女）上建索引。</li>
<li><strong>最左前缀原则：</strong> 复合索引 <code>(col1, col2, col3)</code>，查询 <code>WHERE col1=?</code> 或 <code>WHERE col1=? AND col2=?</code> 有效；<code>WHERE col2=?</code> 通常无效。</li>
<li><strong>避免过度索引：</strong> 索引加速查询但减慢插入、更新、删除，并占用空间。</li>
<li><strong>使用 <code>EXPLAIN</code> 分析查询：</strong> 见高级篇。</li>
</ul>
</li>
</ul>
<h3 id="9-事务-Transactions"><a href="#9-事务-Transactions" class="headerlink" title="9. 事务 (Transactions)"></a><strong>9. 事务 (Transactions)</strong></h3><ul>
<li><strong>概念：</strong> 一组数据库操作，要么全部成功，要么全部失败回滚。保证数据一致性（ACID 特性）。</li>
<li><strong>ACID:</strong><ul>
<li><strong>A (Atomicity):</strong> 原子性，操作不可分割。</li>
<li><strong>C (Consistency):</strong> 一致性，事务前后数据状态一致。</li>
<li><strong>I (Isolation):</strong> 隔离性，并发事务互不干扰。</li>
<li><strong>D (Durability):</strong> 持久性，事务提交后数据永久保存。</li>
</ul>
</li>
<li><strong>事务控制语句：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION; <span class="comment">-- 或 BEGIN;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行一系列操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查是否成功</span></span><br><span class="line"><span class="comment">-- 如果都成功</span></span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 提交事务，永久生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果任一操作失败</span></span><br><span class="line"><span class="comment">-- ROLLBACK; -- 回滚事务，撤销所有操作</span></span><br></pre></td></tr></table></figure></li>
<li><strong>自动提交模式：</strong> 默认 <code>autocommit=1</code>，每个 SQL 语句都是一个独立事务。<code>SET autocommit=0;</code> 可关闭自动提交，需手动 <code>COMMIT</code>&#x2F;<code>ROLLBACK</code>。</li>
<li><strong>隔离级别 (Isolation Levels):</strong> 控制事务间的可见性。<ul>
<li><code>READ UNCOMMITTED</code> (最低): 可能读到未提交数据（脏读）。</li>
<li><code>READ COMMITTED</code>: 只能读到已提交数据（避免脏读），但可能不可重复读。</li>
<li><code>REPEATABLE READ</code> (InnoDB 默认): 保证在同一个事务中多次读取同一数据结果一致（避免脏读、不可重复读），但可能幻读。</li>
<li><code>SERIALIZABLE</code> (最高): 完全串行化，避免所有问题，但性能最低。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"><span class="comment">-- 设置会话隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-存储过程-Stored-Procedures"><a href="#10-存储过程-Stored-Procedures" class="headerlink" title="10. 存储过程 (Stored Procedures)"></a><strong>10. 存储过程 (Stored Procedures)</strong></h3><ul>
<li><strong>概念：</strong> 预编译的 SQL 代码块，存储在数据库中，可被调用。</li>
<li><strong>优点：</strong> 减少网络传输、提高性能、代码复用、增强安全性。</li>
<li><strong>创建：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span> <span class="comment">-- 更改语句结束符，避免与内部;冲突</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> GetStudentGrades(<span class="keyword">IN</span> studentId <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        s.first_name, s.last_name,</span><br><span class="line">        c.course_name, e.grade</span><br><span class="line">    <span class="keyword">FROM</span> students s</span><br><span class="line">    <span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e.student_id</span><br><span class="line">    <span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e.course_id <span class="operator">=</span> c.course_id</span><br><span class="line">    <span class="keyword">WHERE</span> s.student_id <span class="operator">=</span> studentId;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ; <span class="comment">-- 恢复结束符为;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>调用：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> GetStudentGrades(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>参数类型：</strong><ul>
<li><code>IN</code>: 输入参数（默认）。</li>
<li><code>OUT</code>: 输出参数。</li>
<li><code>INOUT</code>: 既可输入也可输出。</li>
</ul>
</li>
<li><strong>示例 (带 OUT 参数)：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> CountEnrollmentsByCourse(</span><br><span class="line">    <span class="keyword">IN</span> courseId <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> totalEnrollments <span class="type">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> totalEnrollments</span><br><span class="line">    <span class="keyword">FROM</span> enrollments</span><br><span class="line">    <span class="keyword">WHERE</span> course_id <span class="operator">=</span> courseId;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">CALL</span> CountEnrollmentsByCourse(<span class="number">101</span>, <span class="variable">@count</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@count</span>; <span class="comment">-- 查看输出值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-函数-Functions"><a href="#11-函数-Functions" class="headerlink" title="11. 函数 (Functions)"></a><strong>11. 函数 (Functions)</strong></h3><ul>
<li><strong>概念：</strong> 返回单个值的可调用代码块。</li>
<li><strong>创建：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> CalculateAge(birthDate <span class="type">DATE</span>) </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">DETERMINISTIC</span> <span class="comment">-- 声明函数是确定性的 (相同输入总得相同输出)</span></span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="comment">-- 声明函数会读取数据</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> age <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SET</span> age <span class="operator">=</span> TIMESTAMPDIFF(<span class="keyword">YEAR</span>, birthDate, CURDATE());</span><br><span class="line">    <span class="keyword">RETURN</span> age;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name, CalculateAge(date_of_birth) <span class="keyword">AS</span> age <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-触发器-Triggers"><a href="#12-触发器-Triggers" class="headerlink" title="12. 触发器 (Triggers)"></a><strong>12. 触发器 (Triggers)</strong></h3><ul>
<li><strong>概念：</strong> 在特定表上发生特定事件（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）时自动执行的代码。</li>
<li><strong>时机：</strong> <code>BEFORE</code> 或 <code>AFTER</code> 事件。</li>
<li><strong>创建：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> update_student_gpa</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> enrollments</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 当成绩更新时，重新计算该学生的GPA</span></span><br><span class="line">    <span class="keyword">DECLARE</span> new_gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(grade) <span class="keyword">INTO</span> new_gpa</span><br><span class="line">    <span class="keyword">FROM</span> enrollments</span><br><span class="line">    <span class="keyword">WHERE</span> student_id <span class="operator">=</span> NEW.student_id; <span class="comment">-- NEW代表新行</span></span><br><span class="line">    <span class="keyword">UPDATE</span> students <span class="keyword">SET</span> gpa <span class="operator">=</span> <span class="built_in">COALESCE</span>(new_gpa, <span class="number">0.00</span>)</span><br><span class="line">    <span class="keyword">WHERE</span> student_id <span class="operator">=</span> NEW.student_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 注意：此示例为简化逻辑，实际计算GPA可能更复杂，且需考虑性能。</span></span><br></pre></td></tr></table></figure></li>
<li><strong>查看触发器：</strong> <code>SHOW TRIGGERS;</code></li>
<li><strong>删除触发器：</strong> <code>DROP TRIGGER update_student_gpa;</code></li>
</ul>
<h3 id="13-视图-Views"><a href="#13-视图-Views" class="headerlink" title="13. 视图 (Views)"></a><strong>13. 视图 (Views)</strong></h3><ul>
<li><strong>概念：</strong> 虚拟表，基于一个或多个表的查询结果。</li>
<li><strong>优点：</strong> 简化复杂查询、提供数据抽象和安全性（隐藏底层表结构）、重用查询逻辑。</li>
<li><strong>创建：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> student_course_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    s.student_id, s.first_name, s.last_name,</span><br><span class="line">    c.course_id, c.course_name, e.grade, e.enrollment_date</span><br><span class="line"><span class="keyword">FROM</span> students s</span><br><span class="line"><span class="keyword">JOIN</span> enrollments e <span class="keyword">ON</span> s.student_id <span class="operator">=</span> e.student_id</span><br><span class="line"><span class="keyword">JOIN</span> courses c <span class="keyword">ON</span> e.course_id <span class="operator">=</span> c.course_id;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用：</strong> 像查询普通表一样查询视图。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_course_view <span class="keyword">WHERE</span> course_name <span class="operator">=</span> <span class="string">&#x27;Mathematics&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>更新视图：</strong> 可更新的视图有严格限制（通常只涉及单表、无聚合、无 <code>DISTINCT</code> 等）。否则为只读。</li>
<li><strong>删除视图：</strong> <code>DROP VIEW student_course_view;</code></li>
</ul>
<h3 id="14-用户与权限管理"><a href="#14-用户与权限管理" class="headerlink" title="14. 用户与权限管理"></a><strong>14. 用户与权限管理</strong></h3><ul>
<li><strong>创建用户：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;StrongPassword123!&#x27;</span>;</span><br><span class="line"><span class="comment">-- &#x27;app_user&#x27;@&#x27;%&#x27; 允许从任何主机连接 (注意安全)</span></span><br></pre></td></tr></table></figure></li>
<li><strong>授予权限：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予对 school 数据库所有表的 SELECT, INSERT, UPDATE, DELETE 权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> school.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予所有权限 (谨慎使用)</span></span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON school.* TO &#x27;admin_user&#x27;@&#x27;localhost&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li>
<li><strong>查看权限：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>撤销权限：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> school.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>删除用户：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;app_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第三部分：高级与优化篇-Advanced-Optimization"><a href="#第三部分：高级与优化篇-Advanced-Optimization" class="headerlink" title="第三部分：高级与优化篇 (Advanced &amp; Optimization)"></a><strong>第三部分：高级与优化篇 (Advanced &amp; Optimization)</strong></h2><h3 id="15-性能分析与优化-EXPLAIN"><a href="#15-性能分析与优化-EXPLAIN" class="headerlink" title="15. 性能分析与优化 (EXPLAIN)"></a><strong>15. 性能分析与优化 (EXPLAIN)</strong></h3><ul>
<li><strong><code>EXPLAIN</code> &#x2F; <code>EXPLAIN FORMAT=JSON</code>:</strong> 分析查询执行计划，是优化的基石。</li>
<li><strong>关键字段解读：</strong><ul>
<li><code>id</code>: SELECT 标识符，越大越先执行，相同则从上到下。</li>
<li><code>select_type</code>: 查询类型 (SIMPLE, PRIMARY, SUBQUERY, DERIVED, UNION)。</li>
<li><code>table</code>: 涉及的表。</li>
<li><code>partitions</code>: 匹配的分区。</li>
<li><code>type</code>: 连接类型，<strong>性能关键</strong>！<ul>
<li><code>system</code>&#x2F;<code>const</code>: 最好，通过主键或唯一索引查找。</li>
<li><code>eq_ref</code>: 唯一索引连接。</li>
<li><code>ref</code>: 非唯一索引查找。</li>
<li><code>range</code>: 索引范围扫描。</li>
<li><code>index</code>: 全索引扫描。</li>
<li><code>ALL</code>: 全表扫描 (<strong>最差，应避免</strong>)。</li>
</ul>
</li>
<li><code>possible_keys</code>: 可能使用的索引。</li>
<li><code>key</code>: 实际使用的索引。</li>
<li><code>key_len</code>: 使用的索引长度。</li>
<li><code>ref</code>: 显示索引的哪一列被使用了。</li>
<li><code>rows</code>: <strong>估算</strong>需要扫描的行数。越小越好。</li>
<li><code>filtered</code>: 按表条件过滤后剩余行的百分比。</li>
<li><code>Extra</code>: 附加信息，<strong>非常重要</strong>！<ul>
<li><code>Using index</code>: 使用了覆盖索引（索引包含所有需要的列，无需回表）。</li>
<li><code>Using where</code>: 使用了 WHERE 条件。</li>
<li><code>Using temporary</code>: 需要创建临时表（通常因 <code>GROUP BY</code> 或 <code>ORDER BY</code> 无索引）。</li>
<li><code>Using filesort</code>: 需要文件排序（<code>ORDER BY</code> 无索引），性能杀手。</li>
<li><code>Using join buffer</code>: 使用了连接缓冲区。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"><span class="comment">-- 如果 type=ALL，rows 很大，Extra 无 Using index -&gt; 需要在 last_name 上建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_lastname <span class="keyword">ON</span> students(last_name);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>; <span class="comment">-- 再次检查，type 应为 ref</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-常见优化技巧"><a href="#16-常见优化技巧" class="headerlink" title="16. 常见优化技巧"></a><strong>16. 常见优化技巧</strong></h3><ol>
<li><strong>合理使用索引：</strong> 根据查询条件创建索引，遵循最左前缀原则，避免过度索引。</li>
<li><strong>避免 <code>SELECT *</code>:</strong> 只选择需要的列，减少数据传输和内存使用。</li>
<li><strong>优化 <code>WHERE</code> 条件：</strong><ul>
<li>避免在索引列上使用函数或表达式：<code>WHERE YEAR(date_column) = 2025</code> (无法用索引) vs <code>WHERE date_column &gt;= &#39;2025-01-01&#39; AND date_column &lt; &#39;2026-01-01&#39;</code> (可用索引)。</li>
<li>避免 <code>!=</code> 或 <code>NOT IN</code> (可能导致全表扫描)。</li>
<li>使用 <code>IN</code> 代替多个 <code>OR</code>。</li>
</ul>
</li>
<li><strong>优化 <code>JOIN</code>：</strong><ul>
<li>确保 <code>JOIN</code> 条件列有索引。</li>
<li>小表驱动大表（在 <code>EXPLAIN</code> 中，小表通常先执行）。</li>
<li>避免笛卡尔积（无 <code>ON</code> 条件）。</li>
</ul>
</li>
<li><strong>优化 <code>ORDER BY</code> 和 <code>GROUP BY</code>：</strong><ul>
<li>为排序和分组的列创建索引。</li>
<li>尽量让 <code>ORDER BY</code> 的顺序与索引顺序一致。</li>
<li>减少需要排序的数据量（先用 <code>WHERE</code> 过滤）。</li>
</ul>
</li>
<li><strong>分页优化：</strong><ul>
<li>深分页 (<code>LIMIT 1000000, 10</code>) 效率低。可考虑：<ul>
<li>使用覆盖索引 + 子查询：<code>SELECT * FROM table WHERE id &gt; (SELECT id FROM table ORDER BY id LIMIT 1000000, 1) LIMIT 10;</code></li>
<li>记录上次查询的 <code>id</code> 或时间戳。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用连接池：</strong> 应用程序避免频繁创建和销毁数据库连接。</li>
<li><strong>定期分析表：</strong> <code>ANALYZE TABLE table_name;</code> 更新表的统计信息，帮助优化器生成更好计划。</li>
<li><strong>监控慢查询：</strong> 开启慢查询日志 (<code>slow_query_log=ON</code>)，分析执行时间长的 SQL。</li>
</ol>
<h3 id="17-备份与恢复"><a href="#17-备份与恢复" class="headerlink" title="17. 备份与恢复"></a><strong>17. 备份与恢复</strong></h3><ul>
<li><strong>逻辑备份 (mysqldump):</strong> 最常用。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份整个数据库</span></span><br><span class="line">mysqldump -u root -p school &gt; school_backup_20250819.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份特定表</span></span><br><span class="line">mysqldump -u root -p school students courses &gt; selected_tables.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带选项的备份 (推荐)</span></span><br><span class="line">mysqldump -u root -p --single-transaction --routines --triggers school &gt; school_backup.sql</span><br><span class="line"><span class="comment"># --single-transaction: InnoDB 一致性备份 (不锁表)</span></span><br><span class="line"><span class="comment"># --routines: 包含存储过程和函数</span></span><br><span class="line"><span class="comment"># --triggers: 包含触发器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">mysql -u root -p school &lt; school_backup_20250819.sql</span><br></pre></td></tr></table></figure></li>
<li><strong>物理备份 (Percona XtraBackup):</strong> 更高效，备份整个数据目录，支持热备份。适用于大型数据库。</li>
</ul>
<h3 id="18-JSON-支持-MySQL-5-7"><a href="#18-JSON-支持-MySQL-5-7" class="headerlink" title="18. JSON 支持 (MySQL 5.7+)"></a><strong>18. JSON 支持 (MySQL 5.7+)</strong></h3><ul>
<li><strong>JSON 数据类型：</strong> 原生支持存储 JSON 文档。</li>
<li><strong>创建表：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> user_profiles (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    profile_data JSON,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><strong>插入 JSON：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> user_profiles (user_id, profile_data)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;preferences&quot;: &#123;&quot;theme&quot;: &quot;dark&quot;, &quot;notifications&quot;: true&#125;, &quot;tags&quot;: [&quot;student&quot;, &quot;tech&quot;]&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>查询 JSON：</strong><ul>
<li><code>-&gt;</code>: 返回 JSON 字符串（带引号）。</li>
<li><code>-&gt;&gt;</code>: 返回去引号的标量值或字符串。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取整个JSON</span></span><br><span class="line"><span class="keyword">SELECT</span> profile_data <span class="keyword">FROM</span> user_profiles <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取特定字段</span></span><br><span class="line"><span class="keyword">SELECT</span> profile_data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> name <span class="keyword">FROM</span> user_profiles <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- &quot;Alice&quot;</span></span><br><span class="line"><span class="keyword">SELECT</span> profile_data<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> name <span class="keyword">FROM</span> user_profiles <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询嵌套字段</span></span><br><span class="line"><span class="keyword">SELECT</span> profile_data<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;$.preferences.theme&#x27;</span> <span class="keyword">AS</span> theme <span class="keyword">FROM</span> user_profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数组元素</span></span><br><span class="line"><span class="keyword">SELECT</span> profile_data<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;$.tags[0]&#x27;</span> <span class="keyword">AS</span> first_tag <span class="keyword">FROM</span> user_profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 JSON 函数</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_EXTRACT(profile_data, <span class="string">&#x27;$.preferences.notifications&#x27;</span>) <span class="keyword">FROM</span> user_profiles;</span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS(profile_data, <span class="string">&#x27;&quot;tech&quot;&#x27;</span>, <span class="string">&#x27;$.tags&#x27;</span>) <span class="keyword">FROM</span> user_profiles; <span class="comment">-- 检查tags数组是否包含&quot;tech&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>更新 JSON：</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_profiles</span><br><span class="line"><span class="keyword">SET</span> profile_data <span class="operator">=</span> JSON_SET(profile_data, <span class="string">&#x27;$.preferences.theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>恭喜你走完了 MySQL 从入门到高级的旅程！你已经掌握了从基础的增删改查到复杂的连接、事务、存储过程、性能优化等核心技能。记住，数据库知识需要不断实践和深化。</p>
<p><strong>持续学习的方向：</strong></p>
<ul>
<li><strong>深入 InnoDB 引擎：</strong> 了解其架构（Buffer Pool, Redo Log, Undo Log）、行锁、间隙锁、MVCC (多版本并发控制)。</li>
<li><strong>高可用与复制：</strong> 主从复制 (Master-Slave Replication)、组复制 (Group Replication)、InnoDB Cluster。</li>
<li><strong>分库分表：</strong> 应对海量数据和高并发。</li>
<li><strong>监控与调优：</strong> 使用 Performance Schema, sys schema, 监控工具 (如 Prometheus + Grafana)。</li>
<li><strong>云数据库：</strong> 了解 AWS RDS, Azure Database for MySQL, Google Cloud SQL, 阿里云 RDS 等云服务。</li>
</ul>
<p><strong>学习资源推荐：</strong></p>
<ul>
<li><strong>官方文档：</strong> <a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a> (最权威)</li>
<li><strong>书籍：</strong><ul>
<li>《高性能 MySQL》(High Performance MySQL)</li>
<li>《MySQL 技术内幕：InnoDB 存储引擎》</li>
</ul>
</li>
<li><strong>在线课程：</strong> Coursera, Udemy, edX 等平台上的 MySQL 课程。</li>
</ul>
<p>保持好奇心，不断探索，你将成为一名出色的数据库使用者或管理员！祝你学习顺利，应用成功！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索（DFS）与广度优先搜索（BFS）</title>
    <url>/2025/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/</url>
    <content><![CDATA[<p>深度优先搜索（DFS）和广度优先搜索（BFS）是两种常用的图遍历算法，在数据结构、算法设计及实际应用中有着广泛的用途。本文将深入解析这两种算法的核心思想、实现方式、优缺点及典型应用场景。</p>
<h3 id="一、算法基本概念"><a href="#一、算法基本概念" class="headerlink" title="一、算法基本概念"></a>一、算法基本概念</h3><h4 id="1-深度优先搜索（DFS）"><a href="#1-深度优先搜索（DFS）" class="headerlink" title="1. 深度优先搜索（DFS）"></a>1. 深度优先搜索（DFS）</h4><p>深度优先搜索是一种沿着图的深度优先遍历图的节点的算法。它的核心思想是：<strong>从起始节点出发，尽可能深地探索分支，当无法继续前进时，回溯到上一节点，选择其他未探索的分支继续探索</strong>，直到所有节点都被访问过。</p>
<p>可以形象地理解为 “不撞南墙不回头”，优先深入探索一条路径，而非横向扩展。</p>
<h4 id="2-广度优先搜索（BFS）"><a href="#2-广度优先搜索（BFS）" class="headerlink" title="2. 广度优先搜索（BFS）"></a>2. 广度优先搜索（BFS）</h4><p>广度优先搜索则是一种按层次逐层遍历图的节点的算法。其核心思想是：<strong>从起始节点出发，先访问该节点的所有邻接节点（第一层），再依次访问每个邻接节点的邻接节点（第二层），以此类推，直到所有节点都被访问过</strong>。</p>
<p>类似于 “水波扩散”，从起点开始，由近及远地遍历所有节点。</p>
<h3 id="二、算法实现方式"><a href="#二、算法实现方式" class="headerlink" title="二、算法实现方式"></a>二、算法实现方式</h3><h4 id="1-DFS-的实现"><a href="#1-DFS-的实现" class="headerlink" title="1. DFS 的实现"></a>1. DFS 的实现</h4><p>DFS 通常可以通过<strong>递归</strong>或<strong>栈（Stack）</strong> 来实现：</p>
<ul>
<li><p><strong>递归实现</strong>：利用函数调用栈的特性，递归访问每个未被访问的邻接节点。</p>
</li>
<li><p><strong>栈实现</strong>：手动维护一个栈，将待访问节点入栈，弹出节点并访问其未被访问的邻接节点，入栈顺序可控制遍历方向。</p>
</li>
</ul>
<p><strong>示例代码（递归实现无向图 DFS）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表存储图</span><br><span class="line">vector&lt;bool&gt; visited;    // 标记节点是否被访问</span><br><span class="line"></span><br><span class="line">// 从节点u开始DFS</span><br><span class="line">void dfs(int u) &#123;</span><br><span class="line">    visited[u] = true;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; &quot; &quot;; // 访问节点u</span><br><span class="line">    // 遍历所有邻接节点</span><br><span class="line">    for (int v : adj[u]) &#123;</span><br><span class="line">        if (!visited[v]) &#123;</span><br><span class="line">            dfs(v); // 递归访问未被访问的邻接节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5, m = 5; // 5个节点，5条边</span><br><span class="line">    adj.resize(n);</span><br><span class="line">    visited.resize(n, false);</span><br><span class="line">    // 构建无向图</span><br><span class="line">    adj[0].push_back(1);</span><br><span class="line">    adj[1].push_back(0);</span><br><span class="line">    adj[0].push_back(2);</span><br><span class="line">    adj[2].push_back(0);</span><br><span class="line">    adj[1].push_back(3);</span><br><span class="line">    adj[3].push_back(1);</span><br><span class="line">    adj[1].push_back(4);</span><br><span class="line">    adj[4].push_back(1);</span><br><span class="line">    adj[2].push_back(4);</span><br><span class="line">    adj[4].push_back(2);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;DFS遍历结果：&quot;;</span><br><span class="line">    dfs(0); // 从节点0开始DFS</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果（可能因邻接表顺序不同而略有差异）：0 1 3 4 2</p>
<h4 id="2-BFS-的实现"><a href="#2-BFS-的实现" class="headerlink" title="2. BFS 的实现"></a>2. BFS 的实现</h4><p>BFS 通常通过<strong>队列（Queue）</strong> 来实现：</p>
<ul>
<li><p>初始化队列，将起始节点入队并标记为已访问。</p>
</li>
<li><p>循环弹出队首节点，访问其所有未被访问的邻接节点，标记为已访问并入队。</p>
</li>
<li><p>重复上述过程，直到队列为空。</p>
</li>
</ul>
<p><strong>示例代码（BFS 遍历无向图）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; adj;</span><br><span class="line">vector&lt;bool&gt; visited;</span><br><span class="line"></span><br><span class="line">// 从节点u开始BFS</span><br><span class="line">void bfs(int u) &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    visited[u] = true;</span><br><span class="line">    cout &lt;&lt; &quot;BFS遍历结果：&quot;;</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; &quot; &quot;; // 访问节点v</span><br><span class="line">        // 遍历所有邻接节点</span><br><span class="line">        for (int w : adj[v]) &#123;</span><br><span class="line">            if (!visited[w]) &#123;</span><br><span class="line">                visited[w] = true;</span><br><span class="line">                q.push(w); // 未访问的邻接节点入队</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 图结构与DFS示例相同</span><br><span class="line">    int n = 5, m = 5;</span><br><span class="line">    adj.resize(n);</span><br><span class="line">    visited.resize(n, false);</span><br><span class="line">    adj[0].push_back(1);</span><br><span class="line">    adj[1].push_back(0);</span><br><span class="line">    adj[0].push_back(2);</span><br><span class="line">    adj[2].push_back(0);</span><br><span class="line">    adj[1].push_back(3);</span><br><span class="line">    adj[3].push_back(1);</span><br><span class="line">    adj[1].push_back(4);</span><br><span class="line">    adj[4].push_back(1);</span><br><span class="line">    adj[2].push_back(4);</span><br><span class="line">    adj[4].push_back(2);</span><br><span class="line">    </span><br><span class="line">    bfs(0); // 从节点0开始BFS</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：BFS遍历结果：0 1 2 3 4</p>
<h3 id="三、算法优缺点及适用场景"><a href="#三、算法优缺点及适用场景" class="headerlink" title="三、算法优缺点及适用场景"></a>三、算法优缺点及适用场景</h3><h4 id="1-DFS-的优缺点与适用场景"><a href="#1-DFS-的优缺点与适用场景" class="headerlink" title="1. DFS 的优缺点与适用场景"></a>1. DFS 的优缺点与适用场景</h4><ul>
<li><p><strong>优点</strong>：</p>
</li>
<li><ul>
<li>内存占用相对较少（递归深度较小时）。</li>
</ul>
</li>
<li><ul>
<li>适合解决 “路径存在性”“连通性”“拓扑排序” 等问题。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
</li>
<li><ul>
<li>可能陷入深层路径，无法找到最短路径（在无权图中）。</li>
</ul>
</li>
<li><ul>
<li>递归实现可能因深度过大导致栈溢出。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
</li>
<li><ul>
<li>迷宫求解（寻找一条可行路径）。</li>
</ul>
</li>
<li><ul>
<li>拓扑排序（有向无环图）。</li>
</ul>
</li>
<li><ul>
<li>连通分量查找。</li>
</ul>
</li>
</ul>
<h4 id="2-BFS-的优缺点与适用场景"><a href="#2-BFS-的优缺点与适用场景" class="headerlink" title="2. BFS 的优缺点与适用场景"></a>2. BFS 的优缺点与适用场景</h4><ul>
<li><p><strong>优点</strong>：</p>
</li>
<li><ul>
<li>在无权图中，能找到从起始节点到目标节点的<strong>最短路径</strong>（边数最少）。</li>
</ul>
</li>
<li><ul>
<li>按层次遍历，适合 “层次相关” 问题。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
</li>
<li><ul>
<li>内存占用较大（需要存储大量待访问节点）。</li>
</ul>
</li>
<li><ul>
<li>不适合深度较大的图（可能导致队列过大）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
</li>
<li><ul>
<li>最短路径问题（无权图）。</li>
</ul>
</li>
<li><ul>
<li>层次遍历（如二叉树的层序遍历）。</li>
</ul>
</li>
<li><ul>
<li>社交网络中的 “一度好友”“二度好友” 查找。</li>
</ul>
</li>
</ul>
<h3 id="四、算法对比总结"><a href="#四、算法对比总结" class="headerlink" title="四、算法对比总结"></a>四、算法对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>DFS</th>
<th>BFS</th>
</tr>
</thead>
<tbody><tr>
<td>遍历方式</td>
<td>深度优先，回溯探索</td>
<td>广度优先，层次扩展</td>
</tr>
<tr>
<td>实现工具</td>
<td>递归 &#x2F; 栈</td>
<td>队列</td>
</tr>
<tr>
<td>最短路径（无权图）</td>
<td>不保证</td>
<td>保证</td>
</tr>
<tr>
<td>内存占用</td>
<td>通常较少（取决于深度）</td>
<td>通常较多（取决于广度）</td>
</tr>
<tr>
<td>典型应用</td>
<td>拓扑排序、连通分量</td>
<td>最短路径、层次遍历</td>
</tr>
</tbody></table>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>DFS 和 BFS 是两种基础且重要的搜索算法，各有其适用场景。理解它们的核心思想、实现方式及优缺点，能帮助我们在解决实际问题时选择合适的算法。</p>
<p>在实际开发中，两种算法也常结合使用（如 “双向 BFS” 优化搜索效率）。掌握这两种算法，是深入学习更复杂算法（如 A * 搜索、回溯法）的基础。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>算法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>串口通信读取数据遇到0x0A停止读取数据</title>
    <url>/2025/07/24/%E5%85%B6%E4%BB%96/ViRead%E9%81%87%E5%88%B00A%E7%BB%93%E6%9D%9F%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96/</url>
    <content><![CDATA[<h1 id="串口通信读取数据遇到0x0A停止读取数据"><a href="#串口通信读取数据遇到0x0A停止读取数据" class="headerlink" title="串口通信读取数据遇到0x0A停止读取数据"></a>串口通信读取数据遇到0x0A停止读取数据</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在使用labwindowscvi串口通信使用ViRead函数读取数据的时候遇到0x0A函数会自动结束，后续数据无法读取。</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>0x0A即1010，ASCII码10，代表换行\n</p>
<p>而在labwindows中：</p>
<p><strong>终止符（Termination Character）属性</strong>：</p>
<ul>
<li>VISA库默认启用了终止符检测（通过属性 <code>VI_ATTR_TERMCHAR_EN</code>）。</li>
<li>默认终止符通常是 <code>0x0A</code>（即<code>\n</code>，换行符）。</li>
<li>当<code>viread</code>检测到终止符时，会立即结束读取（即使未达到请求的字节数）。<br><strong>串口&#x2F;仪器通信协议</strong>：<br> 许多仪器（如串口设备、网络仪器）使用<code>\n</code>作为消息结束符。VISA为实现标准化通信，默认启用此行为。</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h4 id="方法1：禁用终止符检测"><a href="#方法1：禁用终止符检测" class="headerlink" title="方法1：禁用终止符检测"></a>方法1：<strong>禁用终止符检测</strong></h4><p>在打开会话后，添加以下代码禁用终止符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(viSession, VI_ATTR_TERMCHAR_EN, VI_FALSE);  // 关闭终止符检测</span><br></pre></td></tr></table></figure>

<p>此后，<code>viread</code>会严格按请求的字节数读取（或等待超时），不再因<code>0x0A</code>提前结束。</p>
<hr>
<h4 id="方法2：修改终止符"><a href="#方法2：修改终止符" class="headerlink" title="方法2：修改终止符"></a>方法2：<strong>修改终止符</strong></h4><p>如果仍需终止符，但需避免<code>0x0A</code>的影响，可修改为其他字符（如<code>0x00</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(viSession, VI_ATTR_TERMCHAR, 0x00);  // 设置终止符为0x00</span><br><span class="line">viSetAttribute(viSession, VI_ATTR_TERMCHAR_EN, VI_TRUE);  // 保持启用终止符</span><br></pre></td></tr></table></figure>





<h2 id="上述为理论解决方法，但是实际中禁用终止符检测后仍然会停止。遂加入如下代码即可正常读取数据，遇到0x0A不再截断："><a href="#上述为理论解决方法，但是实际中禁用终止符检测后仍然会停止。遂加入如下代码即可正常读取数据，遇到0x0A不再截断：" class="headerlink" title="上述为理论解决方法，但是实际中禁用终止符检测后仍然会停止。遂加入如下代码即可正常读取数据，遇到0x0A不再截断："></a>上述为理论解决方法，但是实际中禁用终止符检测后仍然会停止。遂加入如下代码即可正常读取数据，遇到0x0A不再截断：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(Ivi_IOSession(vi),VI_ATTR_TERMCHAR_EN,VI_FALSE);//关闭终止符检测</span><br><span class="line">viSetAttribute(Ivi_IOSession(vi),VI_ATTR_ASRL_END_OUT,VI_ASRL_END_NONE);</span><br><span class="line">viSetAttribute(Ivi_IOSession(vi),VI_ATTR_ASRL_END_IN,VI_ASRL_END_NONE);</span><br></pre></td></tr></table></figure>

<h3 id="1-VI-ATTR-TERMCHAR-EN-终止符启用属性"><a href="#1-VI-ATTR-TERMCHAR-EN-终止符启用属性" class="headerlink" title="1. VI_ATTR_TERMCHAR_EN - 终止符启用属性"></a>1. <code>VI_ATTR_TERMCHAR_EN</code> - 终止符启用属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(vi, VI_ATTR_TERMCHAR_EN, VI_FALSE);</span><br></pre></td></tr></table></figure>

<h4 id="作用机制："><a href="#作用机制：" class="headerlink" title="作用机制："></a>作用机制：</h4><ul>
<li><strong>核心功能</strong>：禁用VISA的终止符检测机制</li>
<li><strong>默认行为</strong>：VISA默认启用终止符检测（VI_TRUE），0x0A(LF)是预设终止符</li>
<li><strong>工作方式</strong>：<ul>
<li>当启用时，<code>viRead</code>会扫描每个收到的字节</li>
<li>遇到预设终止符（默认0x0A）时立即返回</li>
<li>返回状态为<code>VI_SUCCESS_TERM_CHAR</code>（而不是VI_SUCCESS）</li>
</ul>
</li>
</ul>
<h4 id="关键影响："><a href="#关键影响：" class="headerlink" title="关键影响："></a>关键影响：</h4><ul>
<li><strong>解决问题</strong>：防止读取操作在0x0A处提前终止</li>
<li><strong>数据完整性</strong>：确保完整接收包含0x0A的二进制数据流</li>
<li><strong>行为变化</strong>：<ul>
<li>读取操作不再因特定字符提前结束</li>
<li>必须依赖超时或指定字节数来结束读取</li>
</ul>
</li>
</ul>
<h3 id="2-VI-ATTR-ASRL-END-OUT-串行输出结束模式"><a href="#2-VI-ATTR-ASRL-END-OUT-串行输出结束模式" class="headerlink" title="2. VI_ATTR_ASRL_END_OUT - 串行输出结束模式"></a>2. <code>VI_ATTR_ASRL_END_OUT</code> - 串行输出结束模式</h3><p>c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(vi, VI_ATTR_ASRL_END_OUT, VI_ASRL_END_NONE);</span><br></pre></td></tr></table></figure>

<h4 id="作用机制：-1"><a href="#作用机制：-1" class="headerlink" title="作用机制："></a>作用机制：</h4><ul>
<li><p><strong>核心功能</strong>：控制写入操作如何结束</p>
</li>
<li><p><strong>选项解析</strong>：</p>
<table>
<thead>
<tr>
<th align="left">选项值</th>
<th align="left">常量</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">VI_ASRL_END_NONE</td>
<td align="left">无特殊结束处理</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">VI_ASRL_END_LAST_BIT</td>
<td align="left">保持最后一位电平</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">VI_ASRL_END_TERMCHAR</td>
<td align="left">自动附加终止符</td>
</tr>
</tbody></table>
</li>
<li><p><strong>默认行为</strong>：VI_ASRL_END_TERMCHAR（自动附加终止符）</p>
</li>
</ul>
<h4 id="关键影响：-1"><a href="#关键影响：-1" class="headerlink" title="关键影响："></a>关键影响：</h4><ul>
<li><strong>解决问题</strong>：防止写入时自动附加0x0A终止符</li>
<li><strong>数据纯净度</strong>：确保发送的数据不被修改</li>
<li><strong>设备兼容性</strong>：避免向设备发送意外终止符</li>
</ul>
<h3 id="3-VI-ATTR-ASRL-END-IN-串行输入结束模式"><a href="#3-VI-ATTR-ASRL-END-IN-串行输入结束模式" class="headerlink" title="3. VI_ATTR_ASRL_END_IN - 串行输入结束模式"></a>3. <code>VI_ATTR_ASRL_END_IN</code> - 串行输入结束模式</h3><p>c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viSetAttribute(vi, VI_ATTR_ASRL_END_IN, VI_ASRL_END_NONE);</span><br></pre></td></tr></table></figure>

<h4 id="作用机制：-2"><a href="#作用机制：-2" class="headerlink" title="作用机制："></a>作用机制：</h4><ul>
<li><p><strong>核心功能</strong>：控制读取操作如何结束</p>
</li>
<li><p><strong>选项解析</strong>：</p>
<table>
<thead>
<tr>
<th align="left">选项值</th>
<th align="left">常量</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">VI_ASRL_END_NONE</td>
<td align="left">无特殊结束条件</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">VI_ASRL_END_LAST_BIT</td>
<td align="left">检测停止位结束</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">VI_ASRL_END_TERMCHAR</td>
<td align="left">检测终止符结束</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">VI_ASRL_END_BREAK</td>
<td align="left">检测BREAK信号结束</td>
</tr>
</tbody></table>
</li>
<li><p><strong>默认行为</strong>：VI_ASRL_END_TERMCHAR（检测终止符结束）</p>
</li>
</ul>
<h4 id="关键影响：-2"><a href="#关键影响：-2" class="headerlink" title="关键影响："></a>关键影响：</h4><ul>
<li><strong>核心解决方案</strong>：完全禁用基于字符的读取结束机制</li>
<li><strong>读取行为</strong>：<ul>
<li>不再检查任何终止符（包括0x0A）</li>
<li>读取操作仅由以下条件结束：<ul>
<li>达到请求的字节数</li>
<li>超时发生</li>
<li>硬件错误</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据完整性</strong>：确保包含0x0A的二进制数据被完整读取</li>
</ul>
<h3 id="配置综合效果"><a href="#配置综合效果" class="headerlink" title="配置综合效果"></a>配置综合效果</h3><table>
<thead>
<tr>
<th align="left">配置前</th>
<th align="left">配置后</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读取在0x0A处停止</td>
<td align="left">完整读取所有字节</td>
</tr>
<tr>
<td align="left">自动附加终止符</td>
<td align="left">原始数据发送</td>
</tr>
<tr>
<td align="left">基于字符的读取结束</td>
<td align="left">基于长度&#x2F;超时的读取结束</td>
</tr>
</tbody></table>
<h1 id="附录：ASCII-码表及解析"><a href="#附录：ASCII-码表及解析" class="headerlink" title="附录：ASCII 码表及解析"></a>附录：ASCII 码表及解析</h1><blockquote>
<p>标准 ASCII（American Standard Code for Information Interchange）共 128 个码位（0–127），使用 7 bit 表示。<br>下面按十进制、十六进制、二进制、字符、名称&#x2F;功能 5 个维度列出，并补充控制字符的语义解析。</p>
</blockquote>
<h2 id="1-控制字符（0–31-127）"><a href="#1-控制字符（0–31-127）" class="headerlink" title="1. 控制字符（0–31 &amp; 127）"></a>1. 控制字符（0–31 &amp; 127）</h2><table>
<thead>
<tr>
<th align="right">Dec</th>
<th align="right">Hex</th>
<th>Bin</th>
<th>Abbr</th>
<th>名称 &#x2F; 功能解析</th>
</tr>
</thead>
<tbody><tr>
<td align="right">0</td>
<td align="right">00</td>
<td>00000000</td>
<td>NUL</td>
<td>Null（空字符，字符串结束符 C 风格 ‘\0’）</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">01</td>
<td>00000001</td>
<td>SOH</td>
<td>Start of Heading（报文标题开始）</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">02</td>
<td>00000010</td>
<td>STX</td>
<td>Start of Text（报文正文开始）</td>
</tr>
<tr>
<td align="right">3</td>
<td align="right">03</td>
<td>00000011</td>
<td>ETX</td>
<td>End of Text（报文正文结束）</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">04</td>
<td>00000100</td>
<td>EOT</td>
<td>End of Transmission（传输结束，Ctrl-D）</td>
</tr>
<tr>
<td align="right">5</td>
<td align="right">05</td>
<td>00000101</td>
<td>ENQ</td>
<td>Enquiry（询问，请求远程站应答）</td>
</tr>
<tr>
<td align="right">6</td>
<td align="right">06</td>
<td>00000110</td>
<td>ACK</td>
<td>Acknowledge（肯定应答）</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">07</td>
<td>00000111</td>
<td>BEL</td>
<td>Bell（响铃，’\a’）</td>
</tr>
<tr>
<td align="right">8</td>
<td align="right">08</td>
<td>00001000</td>
<td>BS</td>
<td>Backspace（退格，’\b’）</td>
</tr>
<tr>
<td align="right">9</td>
<td align="right">09</td>
<td>00001001</td>
<td>HT</td>
<td>Horizontal Tab（水平制表，’\t’）</td>
</tr>
<tr>
<td align="right">10</td>
<td align="right">0A</td>
<td>00001010</td>
<td>LF</td>
<td>Line Feed（换行，’\n’，Unix 新行）</td>
</tr>
<tr>
<td align="right">11</td>
<td align="right">0B</td>
<td>00001011</td>
<td>VT</td>
<td>Vertical Tab（垂直制表，’\v’）</td>
</tr>
<tr>
<td align="right">12</td>
<td align="right">0C</td>
<td>00001100</td>
<td>FF</td>
<td>Form Feed（换页，’\f’）</td>
</tr>
<tr>
<td align="right">13</td>
<td align="right">0D</td>
<td>00001101</td>
<td>CR</td>
<td>Carriage Return（回车，’\r’，Win 新行 CR LF）</td>
</tr>
<tr>
<td align="right">14</td>
<td align="right">0E</td>
<td>00001110</td>
<td>SO</td>
<td>Shift Out（转义字符集）</td>
</tr>
<tr>
<td align="right">15</td>
<td align="right">0F</td>
<td>00001111</td>
<td>SI</td>
<td>Shift In（恢复默认字符集）</td>
</tr>
<tr>
<td align="right">16</td>
<td align="right">10</td>
<td>00010000</td>
<td>DLE</td>
<td>Data Link Escape（数据链路转义）</td>
</tr>
<tr>
<td align="right">17</td>
<td align="right">11</td>
<td>00010001</td>
<td>DC1</td>
<td>Device Control 1（XON，Ctrl-Q）</td>
</tr>
<tr>
<td align="right">18</td>
<td align="right">12</td>
<td>00010010</td>
<td>DC2</td>
<td>Device Control 2</td>
</tr>
<tr>
<td align="right">19</td>
<td align="right">13</td>
<td>00010011</td>
<td>DC3</td>
<td>Device Control 3（XOFF，Ctrl-S）</td>
</tr>
<tr>
<td align="right">20</td>
<td align="right">14</td>
<td>00010100</td>
<td>DC4</td>
<td>Device Control 4</td>
</tr>
<tr>
<td align="right">21</td>
<td align="right">15</td>
<td>00010101</td>
<td>NAK</td>
<td>Negative Acknowledge（否定应答）</td>
</tr>
<tr>
<td align="right">22</td>
<td align="right">16</td>
<td>00010110</td>
<td>SYN</td>
<td>Synchronous Idle（同步空闲）</td>
</tr>
<tr>
<td align="right">23</td>
<td align="right">17</td>
<td>00010111</td>
<td>ETB</td>
<td>End of Transmission Block（块传输结束）</td>
</tr>
<tr>
<td align="right">24</td>
<td align="right">18</td>
<td>00011000</td>
<td>CAN</td>
<td>Cancel（作废）</td>
</tr>
<tr>
<td align="right">25</td>
<td align="right">19</td>
<td>00011001</td>
<td>EM</td>
<td>End of Medium（介质结束）</td>
</tr>
<tr>
<td align="right">26</td>
<td align="right">1A</td>
<td>00011010</td>
<td>SUB</td>
<td>Substitute（替换，Ctrl-Z 传统 EOF）</td>
</tr>
<tr>
<td align="right">27</td>
<td align="right">1B</td>
<td>00011011</td>
<td>ESC</td>
<td>Escape（转义序列开始，ANSI 控制码前缀）</td>
</tr>
<tr>
<td align="right">28</td>
<td align="right">1C</td>
<td>00011100</td>
<td>FS</td>
<td>File Separator</td>
</tr>
<tr>
<td align="right">29</td>
<td align="right">1D</td>
<td>00011101</td>
<td>GS</td>
<td>Group Separator</td>
</tr>
<tr>
<td align="right">30</td>
<td align="right">1E</td>
<td>00011110</td>
<td>RS</td>
<td>Record Separator</td>
</tr>
<tr>
<td align="right">31</td>
<td align="right">1F</td>
<td>00011111</td>
<td>US</td>
<td>Unit Separator</td>
</tr>
<tr>
<td align="right">127</td>
<td align="right">7F</td>
<td>01111111</td>
<td>DEL</td>
<td>Delete（删除，填充字节）</td>
</tr>
</tbody></table>
<h2 id="2-可打印字符（32–126）"><a href="#2-可打印字符（32–126）" class="headerlink" title="2. 可打印字符（32–126）"></a>2. 可打印字符（32–126）</h2><table>
<thead>
<tr>
<th align="right">Dec</th>
<th align="right">Hex</th>
<th>Bin</th>
<th>Char</th>
<th align="right">Dec</th>
<th align="right">Hex</th>
<th>Bin</th>
<th>Char</th>
</tr>
</thead>
<tbody><tr>
<td align="right">32</td>
<td align="right">20</td>
<td>00100000</td>
<td>␠ (space)</td>
<td align="right">80</td>
<td align="right">50</td>
<td>01010000</td>
<td>P</td>
</tr>
<tr>
<td align="right">33</td>
<td align="right">21</td>
<td>00100001</td>
<td>!</td>
<td align="right">81</td>
<td align="right">51</td>
<td>01010001</td>
<td>Q</td>
</tr>
<tr>
<td align="right">34</td>
<td align="right">22</td>
<td>00100010</td>
<td>“</td>
<td align="right">82</td>
<td align="right">52</td>
<td>01010010</td>
<td>R</td>
</tr>
<tr>
<td align="right">35</td>
<td align="right">23</td>
<td>00100011</td>
<td>#</td>
<td align="right">83</td>
<td align="right">53</td>
<td>01010011</td>
<td>S</td>
</tr>
<tr>
<td align="right">36</td>
<td align="right">24</td>
<td>00100100</td>
<td>$</td>
<td align="right">84</td>
<td align="right">54</td>
<td>01010100</td>
<td>T</td>
</tr>
<tr>
<td align="right">37</td>
<td align="right">25</td>
<td>00100101</td>
<td>%</td>
<td align="right">85</td>
<td align="right">55</td>
<td>01010101</td>
<td>U</td>
</tr>
<tr>
<td align="right">38</td>
<td align="right">26</td>
<td>00100110</td>
<td>&amp;</td>
<td align="right">86</td>
<td align="right">56</td>
<td>01010110</td>
<td>V</td>
</tr>
<tr>
<td align="right">39</td>
<td align="right">27</td>
<td>00100111</td>
<td>‘</td>
<td align="right">87</td>
<td align="right">57</td>
<td>01010111</td>
<td>W</td>
</tr>
<tr>
<td align="right">40</td>
<td align="right">28</td>
<td>00101000</td>
<td>(</td>
<td align="right">88</td>
<td align="right">58</td>
<td>01011000</td>
<td>X</td>
</tr>
<tr>
<td align="right">41</td>
<td align="right">29</td>
<td>00101001</td>
<td>)</td>
<td align="right">89</td>
<td align="right">59</td>
<td>01011001</td>
<td>Y</td>
</tr>
<tr>
<td align="right">42</td>
<td align="right">2A</td>
<td>00101010</td>
<td>*</td>
<td align="right">90</td>
<td align="right">5A</td>
<td>01011010</td>
<td>Z</td>
</tr>
<tr>
<td align="right">43</td>
<td align="right">2B</td>
<td>00101011</td>
<td>+</td>
<td align="right">91</td>
<td align="right">5B</td>
<td>01011011</td>
<td>[</td>
</tr>
<tr>
<td align="right">44</td>
<td align="right">2C</td>
<td>00101100</td>
<td>,</td>
<td align="right">92</td>
<td align="right">5C</td>
<td>01011100</td>
<td>\</td>
</tr>
<tr>
<td align="right">45</td>
<td align="right">2D</td>
<td>00101101</td>
<td>-</td>
<td align="right">93</td>
<td align="right">5D</td>
<td>01011101</td>
<td>]</td>
</tr>
<tr>
<td align="right">46</td>
<td align="right">2E</td>
<td>00101110</td>
<td>.</td>
<td align="right">94</td>
<td align="right">5E</td>
<td>01011110</td>
<td>^</td>
</tr>
<tr>
<td align="right">47</td>
<td align="right">2F</td>
<td>00101111</td>
<td>&#x2F;</td>
<td align="right">95</td>
<td align="right">5F</td>
<td>01011111</td>
<td>_</td>
</tr>
<tr>
<td align="right">48</td>
<td align="right">30</td>
<td>00110000</td>
<td>0</td>
<td align="right">96</td>
<td align="right">60</td>
<td>01100000</td>
<td>&#96;</td>
</tr>
<tr>
<td align="right">49</td>
<td align="right">31</td>
<td>00110001</td>
<td>1</td>
<td align="right">97</td>
<td align="right">61</td>
<td>01100001</td>
<td>a</td>
</tr>
<tr>
<td align="right">50</td>
<td align="right">32</td>
<td>00110010</td>
<td>2</td>
<td align="right">98</td>
<td align="right">62</td>
<td>01100010</td>
<td>b</td>
</tr>
<tr>
<td align="right">51</td>
<td align="right">33</td>
<td>00110011</td>
<td>3</td>
<td align="right">99</td>
<td align="right">63</td>
<td>01100011</td>
<td>c</td>
</tr>
<tr>
<td align="right">52</td>
<td align="right">34</td>
<td>00110100</td>
<td>4</td>
<td align="right">100</td>
<td align="right">64</td>
<td>01100100</td>
<td>d</td>
</tr>
<tr>
<td align="right">53</td>
<td align="right">35</td>
<td>00110101</td>
<td>5</td>
<td align="right">101</td>
<td align="right">65</td>
<td>01100101</td>
<td>e</td>
</tr>
<tr>
<td align="right">54</td>
<td align="right">36</td>
<td>00110110</td>
<td>6</td>
<td align="right">102</td>
<td align="right">66</td>
<td>01100110</td>
<td>f</td>
</tr>
<tr>
<td align="right">55</td>
<td align="right">37</td>
<td>00110111</td>
<td>7</td>
<td align="right">103</td>
<td align="right">67</td>
<td>01100111</td>
<td>g</td>
</tr>
<tr>
<td align="right">56</td>
<td align="right">38</td>
<td>00111000</td>
<td>8</td>
<td align="right">104</td>
<td align="right">68</td>
<td>01101000</td>
<td>h</td>
</tr>
<tr>
<td align="right">57</td>
<td align="right">39</td>
<td>00111001</td>
<td>9</td>
<td align="right">105</td>
<td align="right">69</td>
<td>01101001</td>
<td>i</td>
</tr>
<tr>
<td align="right">58</td>
<td align="right">3A</td>
<td>00111010</td>
<td>:</td>
<td align="right">106</td>
<td align="right">6A</td>
<td>01101010</td>
<td>j</td>
</tr>
<tr>
<td align="right">59</td>
<td align="right">3B</td>
<td>00111011</td>
<td>;</td>
<td align="right">107</td>
<td align="right">6B</td>
<td>01101011</td>
<td>k</td>
</tr>
<tr>
<td align="right">60</td>
<td align="right">3C</td>
<td>00111100</td>
<td>&lt;</td>
<td align="right">108</td>
<td align="right">6C</td>
<td>01101100</td>
<td>l</td>
</tr>
<tr>
<td align="right">61</td>
<td align="right">3D</td>
<td>00111101</td>
<td>&#x3D;</td>
<td align="right">109</td>
<td align="right">6D</td>
<td>01101101</td>
<td>m</td>
</tr>
<tr>
<td align="right">62</td>
<td align="right">3E</td>
<td>00111110</td>
<td>&gt;</td>
<td align="right">110</td>
<td align="right">6E</td>
<td>01101110</td>
<td>n</td>
</tr>
<tr>
<td align="right">63</td>
<td align="right">3F</td>
<td>00111111</td>
<td>?</td>
<td align="right">111</td>
<td align="right">6F</td>
<td>01101111</td>
<td>o</td>
</tr>
<tr>
<td align="right">64</td>
<td align="right">40</td>
<td>01000000</td>
<td>@</td>
<td align="right">112</td>
<td align="right">70</td>
<td>01110000</td>
<td>p</td>
</tr>
<tr>
<td align="right">65</td>
<td align="right">41</td>
<td>01000001</td>
<td>A</td>
<td align="right">113</td>
<td align="right">71</td>
<td>01110001</td>
<td>q</td>
</tr>
<tr>
<td align="right">66</td>
<td align="right">42</td>
<td>01000010</td>
<td>B</td>
<td align="right">114</td>
<td align="right">72</td>
<td>01110010</td>
<td>r</td>
</tr>
<tr>
<td align="right">67</td>
<td align="right">43</td>
<td>01000011</td>
<td>C</td>
<td align="right">115</td>
<td align="right">73</td>
<td>01110011</td>
<td>s</td>
</tr>
<tr>
<td align="right">68</td>
<td align="right">44</td>
<td>01000100</td>
<td>D</td>
<td align="right">116</td>
<td align="right">74</td>
<td>01110100</td>
<td>t</td>
</tr>
<tr>
<td align="right">69</td>
<td align="right">45</td>
<td>01000101</td>
<td>E</td>
<td align="right">117</td>
<td align="right">75</td>
<td>01110101</td>
<td>u</td>
</tr>
<tr>
<td align="right">70</td>
<td align="right">46</td>
<td>01000110</td>
<td>F</td>
<td align="right">118</td>
<td align="right">76</td>
<td>01110110</td>
<td>v</td>
</tr>
<tr>
<td align="right">71</td>
<td align="right">47</td>
<td>01000111</td>
<td>G</td>
<td align="right">119</td>
<td align="right">77</td>
<td>01110111</td>
<td>w</td>
</tr>
<tr>
<td align="right">72</td>
<td align="right">48</td>
<td>01001000</td>
<td>H</td>
<td align="right">120</td>
<td align="right">78</td>
<td>01111000</td>
<td>x</td>
</tr>
<tr>
<td align="right">73</td>
<td align="right">49</td>
<td>01001001</td>
<td>I</td>
<td align="right">121</td>
<td align="right">79</td>
<td>01111001</td>
<td>y</td>
</tr>
<tr>
<td align="right">74</td>
<td align="right">4A</td>
<td>01001010</td>
<td>J</td>
<td align="right">122</td>
<td align="right">7A</td>
<td>01111010</td>
<td>z</td>
</tr>
<tr>
<td align="right">75</td>
<td align="right">4B</td>
<td>01001011</td>
<td>K</td>
<td align="right">123</td>
<td align="right">7B</td>
<td>01111011</td>
<td>{</td>
</tr>
<tr>
<td align="right">76</td>
<td align="right">4C</td>
<td>01001100</td>
<td>L</td>
<td align="right">124</td>
<td align="right">7C</td>
<td>01111100</td>
<td>|</td>
</tr>
<tr>
<td align="right">77</td>
<td align="right">4D</td>
<td>01001101</td>
<td>M</td>
<td align="right">125</td>
<td align="right">7D</td>
<td>01111101</td>
<td>}</td>
</tr>
<tr>
<td align="right">78</td>
<td align="right">4E</td>
<td>01001110</td>
<td>N</td>
<td align="right">126</td>
<td align="right">7E</td>
<td>01111110</td>
<td>~</td>
</tr>
</tbody></table>
<h2 id="3-使用小贴士"><a href="#3-使用小贴士" class="headerlink" title="3. 使用小贴士"></a>3. 使用小贴士</h2><ol>
<li>C&#x2F;C++&#x2F;Java 字符串转义：<code>\n</code>(10)、<code>\r</code>(13)、<code>\t</code>(9)、<code>\0</code>(0) 等。  </li>
<li>终端颜色&#x2F;光标控制序列由 ESC(27) 引导，如 <code>ESC[31m</code> 红色。  </li>
<li>常见快捷键：Ctrl-C(3) ETX 中断，Ctrl-D(4) EOT 文件结束，Ctrl-Z(26) SUB 暂停。  </li>
<li>扩展 ASCII（ISO-8859-1、Windows-1252 等）利用 8 bit 编码 128–255，但已超出标准 ASCII 范围。</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>串口通信</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>16位数据两字节交换顺序</title>
    <url>/2025/07/24/%E5%85%B6%E4%BB%96/16%E4%BD%8D%E6%95%B0%E6%8D%AE%E5%89%8D%E5%90%8E%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82%E4%BA%92%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在使用串口通过labwindows&#x2F;cvi的ViRead函数接受数据的时候遇到接受的16位数据是相反的，比如发送0x010F会收到0x0F01.</p>
<h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>在使用LabWindows&#x2F;CVI的<code>ViRead</code>函数时遇到数据字节顺序相反的问题（如发送<code>0x010F</code>收到<code>0x0F01</code>），这是由于<strong>主机与设备的字节序（Endianness）不一致</strong>导致的。以下是原因和解决方案：</p>
<ol>
<li><strong>字节序差异</strong>：<ul>
<li><strong>大端序（Big-Endian）</strong>：高位字节在前（如 <code>0x01</code> 在前，<code>0x0F</code> 在后）。</li>
<li><strong>小端序（Little-Endian）</strong>：低位字节在前（如 <code>0x0F</code> 在前，<code>0x01</code> 在后）。</li>
<li>主机（x86&#x2F;x64 CPU）通常使用<strong>小端序</strong>，而许多仪器设备（如串口设备、网络协议）可能采用<strong>大端序</strong>。</li>
</ul>
</li>
<li><strong>数据处理方式</strong>：<ul>
<li>当仪器以大端序发送数据 <code>0x010F</code>（字节流 <code>0x01, 0x0F</code>）时，主机用小端序解读会将其解释为 <code>0x0F01</code>。</li>
</ul>
</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0;i&lt;DataCount;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data16[i] = (data16[i]&lt;&lt;8 | data16[i] &gt;&gt;8);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上for循环即可将收到的16位数据的两个字节顺序交换，发送0x010F保存的数据也为0x010F。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>字节交换</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客撰写教程</title>
    <url>/2025/07/18/%E5%85%B6%E4%BB%96/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%92%B0%E5%86%99%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>阅读本文预计 5 分钟，你将学会：</p>
<ol>
<li>用一条命令新建文章  </li>
<li>正确填写 Front-matter（标题、标签、分类等）  </li>
<li>用 Markdown 写出排版漂亮的正文  </li>
<li>本地预览与一键部署到 GitHub Pages</li>
</ol>
</blockquote>
<h2 id="1-新建文章（2-种方式）"><a href="#1-新建文章（2-种方式）" class="headerlink" title="1. 新建文章（2 种方式）"></a>1. 新建文章（2 种方式）</h2><h3 id="1-1-CLI-创建（推荐）"><a href="#1-1-CLI-创建（推荐）" class="headerlink" title="1.1 CLI 创建（推荐）"></a>1.1 CLI 创建（推荐）</h3><p>在项目根目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件自动生成在 <code>source/_posts/文章标题.md</code></li>
<li>标题中的空格会被替换成 <code>-</code>，文件名更友好</li>
</ul>
<h3 id="1-2-手动创建"><a href="#1-2-手动创建" class="headerlink" title="1.2 手动创建"></a>1.2 手动创建</h3><p>直接在 <code>source/_posts/</code> 目录下新建 <code>.md</code> 文件，文件名即 URL slug，需自己补全 Front-matter。</p>
<hr>
<h2 id="2-Front-matter-万能模板"><a href="#2-Front-matter-万能模板" class="headerlink" title="2. Front-matter 万能模板"></a>2. Front-matter 万能模板</h2><p>把下面模板复制到文章最顶部（<code>---</code> 之间），按需增删字段即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;          <span class="comment"># 文章标题（必填）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-07-18 11:30:00</span>   <span class="comment"># 发布时间</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2025-07-18 12:00:00</span><span class="comment"># 更新时间（可选）</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Hexo</span>,<span class="string">Markdown</span>]       <span class="comment"># 标签（数组或单行）</span></span><br><span class="line"><span class="attr">categories:</span> [<span class="string">其他</span>]</span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Hexo,</span> <span class="string">博客,</span> <span class="string">教程</span>   <span class="comment"># SEO 关键词（可选）</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">一段简洁摘要</span>     <span class="comment"># 用于首页/SEO/社交媒体卡片</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span>                   <span class="comment"># 是否开启目录（部分主题）</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/images/cover.jpg</span>    <span class="comment"># 文章封面（可选）</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span>               <span class="comment"># 开启数学公式（可选）</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span>              <span class="comment"># 是否开启评论</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">/custom-url/</span>     <span class="comment"># 自定义链接（可选）</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul>
<li>单行写法：<code>tags: [Hexo, 教程]</code>  </li>
<li>多分类层级：<code>categories: [父类, 子类]</code>  </li>
<li>避免特殊字符：<code>description: &quot;带冒号:需引号&quot;</code></li>
<li>显示部分内容：在需要截断处插入代码<code>&lt;!-- more --&gt;</code></li>
</ul>
<hr>
<h2 id="3-用-Markdown-写出漂亮正文"><a href="#3-用-Markdown-写出漂亮正文" class="headerlink" title="3. 用 Markdown 写出漂亮正文"></a>3. 用 Markdown 写出漂亮正文</h2><h3 id="3-1-常用语法速查"><a href="#3-1-常用语法速查" class="headerlink" title="3.1 常用语法速查"></a>3.1 常用语法速查</h3><table>
<thead>
<tr>
<th>效果</th>
<th>写法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>标题</td>
<td><code>#</code> ~ <code>######</code></td>
<td><code>## 二级标题</code></td>
</tr>
<tr>
<td>加粗</td>
<td><code>**文本**</code></td>
<td><strong>加粗</strong></td>
</tr>
<tr>
<td>斜体</td>
<td><code>*文本*</code></td>
<td><em>斜体</em></td>
</tr>
<tr>
<td>引用</td>
<td><code>&gt; </code></td>
<td>&gt; 这是一段引用</td>
</tr>
<tr>
<td>代码</td>
<td>行内 <code>\``code</code>`&#96;</td>
<td><code>print(&quot;hello&quot;)</code></td>
</tr>
<tr>
<td>代码块</td>
<td><code> ```语言</code></td>
<td><code>python ... </code></td>
</tr>
<tr>
<td>列表</td>
<td><code>-</code> 或 <code>1.</code></td>
<td>- 苹果<br>- 香蕉</td>
</tr>
<tr>
<td>链接</td>
<td><code>[文字](url)</code></td>
<td><a href="https://hexo.io/">Hexo 官网</a></td>
</tr>
<tr>
<td>图片</td>
<td><code>![alt](url)</code></td>
<td><img src="/images/logo.png" alt="Logo"></td>
</tr>
<tr>
<td>表格</td>
<td>见下方</td>
<td></td>
</tr>
<tr>
<td>注脚</td>
<td><code>[^1]</code> + <code>[^1]: 说明</code></td>
<td>注脚示例<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%84%9A%E8%AF%B4%E6%98%8E%E3%80%82">^1</a></td>
</tr>
</tbody></table>
<h3 id="3-2-表格示例"><a href="#3-2-表格示例" class="headerlink" title="3.2 表格示例"></a>3.2 表格示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 快捷键 | 作用 |</span><br><span class="line">|---|---|</span><br><span class="line">| <span class="code">`hexo s`</span> | 本地预览 |</span><br><span class="line">| <span class="code">`hexo d`</span> | 一键部署 |</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-本地预览与调试"><a href="#4-本地预览与调试" class="headerlink" title="4. 本地预览与调试"></a>4. 本地预览与调试</h2><ol>
<li>启动本地服务器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li>浏览器打开 <code>http://localhost:4000</code> 实时查看效果  </li>
<li>修改文章后保存，页面会自动热重载（Hexo 5.x+ 支持）</li>
</ol>
<hr>
<h2 id="5-部署到-GitHub-Pages"><a href="#5-部署到-GitHub-Pages" class="headerlink" title="5. 部署到 GitHub Pages"></a>5. 部署到 GitHub Pages</h2><h3 id="三连命令"><a href="#三连命令" class="headerlink" title="三连命令"></a>三连命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="comment"># 清除缓存</span></span><br><span class="line">hexo g       <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo d       <span class="comment"># 部署到 GitHub</span></span><br></pre></td></tr></table></figure>



<hr>
<p>至此，你已掌握 Hexo 文章撰写 → 预览 → 部署的完整闭环。Happy blogging!</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows右键新建添加md文件</title>
    <url>/2025/07/22/%E5%85%B6%E4%BB%96/Win11%E5%8F%B3%E9%94%AE%E6%B7%BB%E5%8A%A0md%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="Win11右键新建添加md文件"><a href="#Win11右键新建添加md文件" class="headerlink" title="Win11右键新建添加md文件"></a>Win11右键新建添加md文件</h4><h5 id="1-在任意位置（最好是Typora）的安装目录下新建TXT文件"><a href="#1-在任意位置（最好是Typora）的安装目录下新建TXT文件" class="headerlink" title="1.在任意位置（最好是Typora）的安装目录下新建TXT文件"></a>1.在任意位置（最好是Typora）的安装目录下新建TXT文件</h5><h5 id="2-在TXT文件中插入以下代码并保存："><a href="#2-在TXT文件中插入以下代码并保存：" class="headerlink" title="2.在TXT文件中插入以下代码并保存："></a>2.在TXT文件中插入以下代码并保存：</h5><hr>
<pre><code>Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\.md]
@=&quot;Typora.md&quot;
&quot;Content Type&quot;=&quot;text/markdown&quot;
&quot;PerceivedType&quot;=&quot;text&quot;

[HKEY_CLASSES_ROOT\.md\ShellNew]
&quot;NullFile&quot;=&quot;&quot;
</code></pre>
<hr>
<h5 id="3-将TXT文件后缀改为-reg"><a href="#3-将TXT文件后缀改为-reg" class="headerlink" title="3.将TXT文件后缀改为.reg"></a>3.将TXT文件后缀改为.reg</h5><h5 id="4-双击运行-reg文件"><a href="#4-双击运行-reg文件" class="headerlink" title="4.双击运行.reg文件"></a>4.双击运行.reg文件</h5><h5 id="5-打开文件资源管理器，使用Ctrl-shift-Esc打开任务管理器，选择文件管理右键重新启动。（很重要）"><a href="#5-打开文件资源管理器，使用Ctrl-shift-Esc打开任务管理器，选择文件管理右键重新启动。（很重要）" class="headerlink" title="5.打开文件资源管理器，使用Ctrl+shift+Esc打开任务管理器，选择文件管理右键重新启动。（很重要）"></a>5.打开文件资源管理器，使用Ctrl+shift+Esc打开任务管理器，选择文件管理右键重新启动。（很重要）</h5>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>md文件</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2025/07/17/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>欢迎来到我的小小自留地！<br>敲下这篇文字的时候，窗外的知了刚刚唱到第三遍，而我终于把博客的域名解析折腾完毕。于是就有了你正在看的这篇——<strong>既当作开站宣言，也当作技术笔记，更当作写给未来自己的一张明信片</strong>。</p>
<span id="more"></span>

<hr>
<h2 id="为什么开博客？"><a href="#为什么开博客？" class="headerlink" title="为什么开博客？"></a>为什么开博客？</h2><table>
<thead>
<tr>
<th>理由</th>
<th>一句话解释</th>
</tr>
</thead>
<tbody><tr>
<td>记录</td>
<td>好记性不如烂键盘</td>
</tr>
<tr>
<td>分享</td>
<td>一人踩坑不如众人填坑</td>
</tr>
<tr>
<td>复盘</td>
<td>让成长有迹可循</td>
</tr>
<tr>
<td>交友</td>
<td>评论区蹲一个同频的你</td>
</tr>
</tbody></table>
<hr>
<h2 id="我会写什么？"><a href="#我会写什么？" class="headerlink" title="我会写什么？"></a>我会写什么？</h2><ul>
<li>📓 <strong>学习笔记</strong>：算法、前端、Python、随笔</li>
<li>🛠️ <strong>踩坑实录</strong>：环境配置、Bug 修复、工具推荐</li>
<li>🌱 <strong>生活碎碎念</strong>：阅读、摄影、咖啡、猫</li>
<li>🗂️ <strong>月度&#x2F;年度总结</strong>：把时间切片，再重新拼成故事</li>
</ul>
<hr>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">博客框架：Hexo</span><br><span class="line">主题：NexT</span><br><span class="line">部署：GitHub Pages</span><br><span class="line">评论：Utterances</span><br><span class="line">写作：Typora + VS Code</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="彩蛋环节"><a href="#彩蛋环节" class="headerlink" title="彩蛋环节"></a>彩蛋环节</h2><p>如果你读到这里，送你三句话：</p>
<ol>
<li>“种一棵树最好的时间是十年前，其次是现在。”</li>
<li>“写博客最难的是第一行，其次是第二行。”</li>
<li>“看到这里的人，祝你今天也有好事发生。”</li>
</ol>
<hr>
<h2 id="保持联系"><a href="#保持联系" class="headerlink" title="保持联系"></a>保持联系</h2><ul>
<li>📧 邮箱：<a href="mailto:&#x79;&#x61;&#x6e;&#120;&#x69;&#97;&#x6f;&#x61;&#x6e;&#x34;&#50;&#x39;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;">yanxiaoan429@163.com</a>  </li>
<li>🐙 GitHub：<a href="https://github.com/yanxianan">github.com&#x2F;yanxianan</a></li>
</ul>
<blockquote>
<p><strong>评论区见！</strong><br>期待你的第一条留言，让这篇处女作不再孤独。</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>一些术语</title>
    <url>/2025/09/11/%E5%85%B6%E4%BB%96/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="异构组合："><a href="#异构组合：" class="headerlink" title="异构组合："></a>异构组合：</h2><p>“<strong>异构组合</strong>”是一个在计算机、电子工程、系统架构等领域中常见的术语，它的核心含义是：</p>
<blockquote>
<p><strong>由不同类型（不同架构、不同技术、不同功能）的组件组合在一起，协同工作，形成一个完整的系统。</strong></p>
</blockquote>
<h2 id="RFDC："><a href="#RFDC：" class="headerlink" title="RFDC："></a>RFDC：</h2><p><strong>RFDC</strong> 是 <strong>Radio Frequency Data Converter</strong> 的缩写，中文意思是 <strong>射频数据转换器</strong>。</p>
<p>它是现代高性能通信系统、雷达、5G 基站、软件定义无线电（SDR）、测试测量设备等领域中的<strong>核心芯片技术</strong>，能够直接对<strong>射频（RF）信号</strong>进行高速模数（ADC）或数模（DAC）转换，<strong>跳过传统中频处理环节</strong>，实现更高效、更灵活的信号处理。</p>
<hr>
<p>一、RFDC 是什么？</p>
<p>🔹 定义：</p>
<p>RFDC 是一种<strong>高带宽、高采样率的数据转换器</strong>（ADC 或 DAC），可以直接处理 <strong>GHz 级别的射频频率信号</strong>，无需像传统系统那样先将信号下变频到中频（IF）再进行数字化。</p>
<ul>
<li><strong>RFDC ADC</strong>：将模拟射频信号直接转换为数字信号（A&#x2F;D 转换）</li>
<li><strong>RFDC DAC</strong>：将数字信号直接生成射频信号（D&#x2F;A 转换）</li>
</ul>
<blockquote>
<p>✅ 简单说：它是一个“<strong>能直接处理射频信号的高速 ADC&#x2F;DAC</strong>”。</p>
</blockquote>
<h2 id="软件无线电理念："><a href="#软件无线电理念：" class="headerlink" title="软件无线电理念："></a>软件无线电理念：</h2><p>“<strong>软件无线电</strong>”（Software Defined Radio，简称 <strong>SDR</strong>）的核心理念可以用一句话概括：</p>
<blockquote>
<p><strong>尽可能用软件来实现无线电系统的功能，而不是依赖固定的硬件电路。</strong></p>
</blockquote>
<h3 id="软件无线电的五大核心理念"><a href="#软件无线电的五大核心理念" class="headerlink" title="软件无线电的五大核心理念"></a>软件无线电的五大核心理念</h3><table>
<thead>
<tr>
<th>理念</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>1. <strong>硬件通用化</strong></td>
<td align="center">使用宽频带天线、宽带射频前端、高速 ADC&#x2F;DAC，支持多种频率和带宽。</td>
</tr>
<tr>
<td>2. <strong>功能软件化</strong></td>
<td align="center">所有信号处理（调制、解调、滤波、编码）由软件或可编程逻辑（FPGA）实现。</td>
</tr>
<tr>
<td>3. <strong>可重构性</strong></td>
<td align="center">设备功能可通过软件更新动态改变，无需更换硬件。</td>
</tr>
<tr>
<td>4. <strong>开放性与可编程性</strong></td>
<td align="center">提供 API 或开发环境，允许用户自定义通信协议。</td>
</tr>
<tr>
<td>5. <strong>多模多频兼容</strong></td>
<td align="center">一台设备支持多种通信标准（如 GSM、LTE、Wi-Fi、LoRa）。</td>
</tr>
</tbody></table>
<h2 id="功能解耦："><a href="#功能解耦：" class="headerlink" title="功能解耦："></a>功能解耦：</h2><p>“<strong>功能解耦</strong>”（Functional Decoupling）是一个在 <strong>软件工程、系统架构、硬件设计、通信系统</strong> 等领域广泛使用的概念，它的核心思想是：</p>
<blockquote>
<p><strong>将原本紧密关联、互相依赖的功能模块拆分开来，使它们可以独立开发、维护和升级，降低系统复杂性。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title>防晕车指南</title>
    <url>/2025/08/21/%E5%85%B6%E4%BB%96/%E6%99%95%E8%BD%A6%E9%A2%84%E9%98%B2/</url>
    <content><![CDATA[<h3 id="🚗-一、乘车前的物理准备"><a href="#🚗-一、乘车前的物理准备" class="headerlink" title="🚗 一、乘车前的物理准备"></a>🚗 一、乘车前的物理准备</h3><ol>
<li><strong>保证充足睡眠</strong><ul>
<li>疲劳会降低前庭系统的稳定性，更容易晕车。出发前一晚睡好，避免熬夜。</li>
</ul>
</li>
<li><strong>适度进食，避免空腹或过饱</strong><ul>
<li>空腹时胃酸刺激易引发恶心；过饱则消化负担加重。</li>
<li>✅ 建议：上车前1小时吃点<strong>清淡食物</strong>，如苏打饼干、香蕉、全麦面包。</li>
</ul>
</li>
<li><strong>进行简单前庭激活练习（5分钟）</strong><ul>
<li>坐在椅子上，缓慢左右转头（10次）、上下点头（10次）。</li>
<li>轻微屈膝站立，闭眼保持平衡10秒，重复3次。</li>
<li>目的：提前“唤醒”内耳平衡系统，增强适应能力。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🚌-二、乘车中的物理缓解技巧（关键！）"><a href="#🚌-二、乘车中的物理缓解技巧（关键！）" class="headerlink" title="🚌 二、乘车中的物理缓解技巧（关键！）"></a>🚌 二、乘车中的物理缓解技巧（关键！）</h3><h4 id="1-优化座位与视线（最重要）"><a href="#1-优化座位与视线（最重要）" class="headerlink" title="1. 优化座位与视线（最重要）"></a>1. <strong>优化座位与视线（最重要）</strong></h4><table>
<thead>
<tr>
<th>交通工具</th>
<th>推荐位置</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>汽车&#x2F;网约车</td>
<td><strong>副驾驶座</strong></td>
<td>视野最开阔，能提前看到道路变化，大脑预判运动</td>
</tr>
<tr>
<td>大巴车</td>
<td><strong>前排靠窗</strong></td>
<td>减少左右摇晃感，可看向远处地平线</td>
</tr>
<tr>
<td>火车</td>
<td><strong>前进方向的前排</strong></td>
<td>视觉与运动方向一致</td>
</tr>
<tr>
<td>飞机</td>
<td><strong>机翼附近靠窗</strong></td>
<td>颠簸最小，可观察地面或云层移动</td>
</tr>
<tr>
<td>轮船</td>
<td><strong>船中部靠近水面层</strong></td>
<td>摇晃幅度最小</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>视线技巧</strong>：</p>
<ul>
<li>眼睛看向<strong>远处静止的物体</strong>（如地平线、远山），帮助大脑判断真实运动状态。</li>
<li>❌ 避免低头看手机、书、平板（视觉输入与身体感觉冲突，极易诱发晕车）。</li>
</ul>
</blockquote>
<h4 id="2-控制头部与身体姿势"><a href="#2-控制头部与身体姿势" class="headerlink" title="2. 控制头部与身体姿势"></a>2. <strong>控制头部与身体姿势</strong></h4><ul>
<li><strong>头部靠稳</strong>：使用头枕或靠垫，减少头部晃动，减轻前庭刺激。</li>
<li><strong>坐姿端正</strong>：背部贴紧椅背，避免身体左右摇摆。</li>
<li><strong>闭眼休息</strong>：如果无法看远处，闭眼可减少视觉混乱信息输入。</li>
</ul>
<h4 id="3-调节呼吸与放松身体"><a href="#3-调节呼吸与放松身体" class="headerlink" title="3. 调节呼吸与放松身体"></a>3. <strong>调节呼吸与放松身体</strong></h4><ul>
<li><p>深呼吸法</p>
<p>（4-7-8呼吸）：</p>
<ul>
<li>吸气4秒 → 屏气7秒 → 缓慢呼气8秒</li>
<li>重复5-10次，可激活副交感神经，缓解紧张和恶心。</li>
</ul>
</li>
<li><p><strong>肌肉放松</strong>：从脚趾开始，逐步放松小腿、大腿、腹部、肩膀，减少身体紧张带来的不适。</p>
</li>
</ul>
<h4 id="4-改善车内环境"><a href="#4-改善车内环境" class="headerlink" title="4. 改善车内环境"></a>4. <strong>改善车内环境</strong></h4><ul>
<li><strong>通风换气</strong>：立即打开车窗或空调外循环，保持空气新鲜，避免闷热和异味（如汽油味、香水味）。</li>
<li><strong>降低视觉干扰</strong>：避免看车内快速移动的物体（如路边疾驰的树木、车内晃动的挂件）。</li>
<li><strong>控制温度</strong>：过热易引发头晕，保持凉爽舒适。</li>
</ul>
<h4 id="5-物理刺激穴位（经临床验证有效）"><a href="#5-物理刺激穴位（经临床验证有效）" class="headerlink" title="5. 物理刺激穴位（经临床验证有效）"></a>5. <strong>物理刺激穴位（经临床验证有效）</strong></h4><ul>
<li>按压内关穴（P6穴）：<ul>
<li>位置：手腕内侧，距腕横纹约三指宽，两筋之间。</li>
<li>方法：用拇指用力按压，每侧持续1-2分钟，可缓解恶心。</li>
<li>工具：可佩戴<strong>晕车手环</strong>（如Sea-Band），持续施压。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🧘-三、长期物理训练方法（改善体质）"><a href="#🧘-三、长期物理训练方法（改善体质）" class="headerlink" title="🧘 三、长期物理训练方法（改善体质）"></a>🧘 三、长期物理训练方法（改善体质）</h3><ol>
<li><strong>前庭功能训练</strong><ul>
<li>每天做：转头练习、闭眼单脚站立、走直线、原地缓慢旋转后突然停止并保持平衡。</li>
<li>目的：增强内耳前庭系统的适应性和稳定性。</li>
</ul>
</li>
<li><strong>核心肌群与平衡训练</strong><ul>
<li>练习瑜伽、太极、普拉提、平衡板训练。</li>
<li>身体控制力越强，对颠簸的耐受性越高。</li>
</ul>
</li>
<li><strong>视觉-前庭协调训练</strong><ul>
<li>追踪移动手指（在眼前左右移动）。</li>
<li>在移动的车上练习看远处固定点，逐步延长适应时间。</li>
</ul>
</li>
<li><strong>渐进式暴露法</strong><ul>
<li>从短途、平稳的车程开始，逐步增加时间和颠簸程度，让身体慢慢“脱敏”。</li>
</ul>
</li>
</ol>
<h2 id="四、食物本身具有物理刺激或挥发性成分，能通过嗅觉、味觉或胃部作用缓解不适："><a href="#四、食物本身具有物理刺激或挥发性成分，能通过嗅觉、味觉或胃部作用缓解不适：" class="headerlink" title="四、食物本身具有物理刺激或挥发性成分，能通过嗅觉、味觉或胃部作用缓解不适："></a>四、食物本身具有<strong>物理刺激或挥发性成分</strong>，能通过嗅觉、味觉或胃部作用缓解不适：</h2><ol>
<li><strong>含姜片或嚼姜糖</strong><ul>
<li>姜含有姜辣素，能温和刺激胃部血液循环，抑制恶心感。</li>
<li>✅ 方法：乘车前30分钟含一片 candied ginger（糖姜），或喝一小杯姜茶。</li>
<li>⚠️ 注意：避免空腹吃太辣的鲜姜，可能刺激胃。</li>
</ul>
</li>
<li><strong>柠檬片或橙皮</strong><ul>
<li>清新的柑橘类香气能掩盖汽油味、提神醒脑，抑制呕吐反射。</li>
<li>✅ 方法：带一片柠檬含在嘴里，或闻橙皮散发的清香。</li>
</ul>
</li>
<li><strong>苏打饼干或干面包</strong><ul>
<li>物理作用：吸收胃酸，防止空腹时胃酸刺激引发恶心。</li>
<li>✅ 方法：上车前吃1-2块，缓慢咀嚼。</li>
</ul>
</li>
<li><strong>薄荷糖或风油精</strong><ul>
<li>薄荷醇能通过鼻腔刺激三叉神经，产生清凉感，分散大脑对恶心信号的关注。</li>
<li>✅ 方法：含薄荷糖，或在太阳穴、口罩内侧涂少量风油精（注意别过敏）。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>晕车</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过修改注册表关闭Windows更新（Windows 10/11）</title>
    <url>/2025/08/22/%E5%85%B6%E4%BB%96/%E7%94%B5%E8%84%91%E6%B0%B8%E4%B9%85%E5%85%B3%E9%97%ADWindows%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<hr>
<h1 id="如何通过修改注册表关闭Windows更新（Windows-10-11）"><a href="#如何通过修改注册表关闭Windows更新（Windows-10-11）" class="headerlink" title="如何通过修改注册表关闭Windows更新（Windows 10&#x2F;11）"></a>如何通过修改注册表关闭Windows更新（Windows 10&#x2F;11）</h1><hr>
<h2 id="一、操作步骤"><a href="#一、操作步骤" class="headerlink" title="一、操作步骤"></a>一、操作步骤</h2><h3 id="步骤1：打开注册表编辑器"><a href="#步骤1：打开注册表编辑器" class="headerlink" title="步骤1：打开注册表编辑器"></a>步骤1：打开注册表编辑器</h3><ol>
<li>按下 <code>Win + R</code> 键，打开“运行”窗口。</li>
<li>输入 <code>regedit</code>，然后按 “确定”。</li>
<li>·如果弹出用户账户控制（UAC）提示，点击“是”继续。</li>
</ol>
<hr>
<h3 id="步骤2：定位Windows更新相关注册表项"><a href="#步骤2：定位Windows更新相关注册表项" class="headerlink" title="步骤2：定位Windows更新相关注册表项"></a>步骤2：定位Windows更新相关注册表项</h3><p>在注册表编辑器中，导航到以下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="步骤3：创建或修改注册表值"><a href="#步骤3：创建或修改注册表值" class="headerlink" title="步骤3：创建或修改注册表值"></a>步骤3：创建或修改注册表值</h3><p>在 <code>Settings</code> 项中，右键右侧空白区域，选择“新建” → “DWORD (32位) 值”，将其命名为	<code>FlightSettingsMaxPauseDays</code></p>
<hr>
<h3 id="步骤4：编辑注册表值"><a href="#步骤4：编辑注册表值" class="headerlink" title="步骤4：编辑注册表值"></a>步骤4：编辑注册表值</h3><p>双击刚才新建的<code>FlightSettingsMaxPauseDays</code>项，将其值填为36500，选择十进制，点击确定。</p>
<hr>
<h3 id="步骤5：设置暂停更新"><a href="#步骤5：设置暂停更新" class="headerlink" title="步骤5：设置暂停更新"></a>步骤5：设置暂停更新</h3><p>在设置中找到Windows更新选项，点击其中的暂停更新，在下拉框中选择可以选择的最大值即可。</p>
<hr>
<h2 id="三、恢复Windows更新的方法"><a href="#三、恢复Windows更新的方法" class="headerlink" title="三、恢复Windows更新的方法"></a>三、恢复Windows更新的方法</h2><p>如果你想重新启用更新：</p>
<p>在设置中选择继续更新即可。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Windows暂停更新</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 环境下 Makefile、CMake 和 xmake 的使用</title>
    <url>/2025/08/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/vscode%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84Makefile%E3%80%81Cmake%E3%80%81Xmake%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>VSCode 作为一款轻量且强大的代码编辑器，凭借丰富的插件生态，成为 C&#x2F;C++ 开发的热门选择。结合 Makefile、CMake 或 xmake 等构建工具，可实现高效的项目编译与管理。本文将分步讲解在 VSCode 中配置这三种工具的完整流程，帮助你快速搭建便捷的 C&#x2F;C++ 开发环境。</p>
<h3 id="一、前期准备：VSCode-基础配置"><a href="#一、前期准备：VSCode-基础配置" class="headerlink" title="一、前期准备：VSCode 基础配置"></a>一、前期准备：VSCode 基础配置</h3><p>在开始之前，需先完成 VSCode 的基础环境配置，确保支持 C&#x2F;C++ 语法高亮、智能提示和调试功能。</p>
<h4 id="1-安装必要插件"><a href="#1-安装必要插件" class="headerlink" title="1. 安装必要插件"></a>1. 安装必要插件</h4><p>打开 VSCode，进入左侧「扩展」面板，搜索并安装以下插件：</p>
<ul>
<li><p><strong>C&#x2F;C++</strong>（微软官方插件）：提供语法高亮、代码补全、调试等核心功能</p>
</li>
<li><p><strong>CMake Tools</strong>：支持 CMake 项目的配置与编译（若使用 CMake）</p>
</li>
<li><p><strong>Code Runner</strong>（可选）：快速运行单个源文件，适合简单测试</p>
</li>
</ul>
<h4 id="2-配置编译器"><a href="#2-配置编译器" class="headerlink" title="2. 配置编译器"></a>2. 配置编译器</h4><ul>
<li><p><strong>Windows</strong>：安装 MinGW 或 MSVC。推荐 MinGW，下载后将bin目录（如C:\MinGW\bin）添加到系统环境变量Path。</p>
</li>
<li><p><strong>Linux&#x2F;macOS</strong>：通常自带 GCC&#x2F;G++，若未安装，执行sudo apt install gcc g++（Linux）或brew install gcc（macOS）。</p>
</li>
</ul>
<p>验证编译器是否生效：打开 VSCode 终端（Ctrl+<code>），输入gcc --version或g++ --version</code>，显示版本信息则配置成功。</p>
<h3 id="二、在-VSCode-中使用-Makefile-编译"><a href="#二、在-VSCode-中使用-Makefile-编译" class="headerlink" title="二、在 VSCode 中使用 Makefile 编译"></a>二、在 VSCode 中使用 Makefile 编译</h3><p>Makefile 通过定义规则实现编译自动化，适合中小型项目。以下是在 VSCode 中的使用流程：</p>
<h4 id="1-创建项目结构"><a href="#1-创建项目结构" class="headerlink" title="1. 创建项目结构"></a>1. 创建项目结构</h4><p>新建文件夹（如makefile_demo），在 VSCode 中打开，工程根目录下有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makefile_demo/</span><br><span class="line">.vscode</span><br><span class="line">src/...cpp</span><br><span class="line">include/...h</span><br><span class="line">Makefile</span><br></pre></td></tr></table></figure>

<ul>
<li><p>src：包含所有源文件</p>
</li>
<li><p>include：包含所有头文件</p>
</li>
<li><p>Makefile：Makefile编译规则</p>
</li>
</ul>
<h4 id="2-编写-Makefile"><a href="#2-编写-Makefile" class="headerlink" title="2. 编写 Makefile"></a>2. 编写 Makefile</h4><p>编写Makefile（注意首字母大写），内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定编译器、最终目标名</span><br><span class="line">CXX         := g++</span><br><span class="line">TARGET      := main</span><br><span class="line">SRC_DIR     := src</span><br><span class="line">INC_DIR     := include</span><br><span class="line">BUILD       := build</span><br><span class="line"></span><br><span class="line"># 自动找所有 .cpp</span><br><span class="line">SOURCES  	:= $(wildcard $(SRC_DIR)/*.cpp)</span><br><span class="line">OBJECTS  	:= $(SOURCES:$(SRC_DIR)/%.cpp=$(BUILD)/%.o)</span><br><span class="line"></span><br><span class="line"># 编译参数</span><br><span class="line">CXXFLAGS 	:= -std=c++17 -Wall -I$(INC_DIR)</span><br><span class="line"></span><br><span class="line"># 默认目标</span><br><span class="line">$(TARGET): $(OBJECTS)</span><br><span class="line">	$(CXX) $^ -o $@</span><br><span class="line"></span><br><span class="line"># 把 .o 放到 build 目录</span><br><span class="line">$(BUILD)/%.o: $(SRC_DIR)/%.cpp | $(BUILD)</span><br><span class="line">	$(CXX) $(CXXFLAGS) -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD):</span><br><span class="line">	mkdir -p $(BUILD)</span><br><span class="line"></span><br><span class="line"># 清理</span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(BUILD) $(TARGET)</span><br></pre></td></tr></table></figure>

<h4 id="3-编译与运行"><a href="#3-编译与运行" class="headerlink" title="3. 编译与运行"></a>3. 编译与运行</h4><ul>
<li><p>打开 VSCode 终端，输入make，自动执行编译，生成可执行文件main（Windows 为main.exe）</p>
</li>
<li><p>运行程序：输入.&#x2F;main</p>
</li>
<li><p>清理产物：输入make clean删除生成的文件</p>
</li>
</ul>
<h3 id="三、在-VSCode-中使用-CMake-编译"><a href="#三、在-VSCode-中使用-CMake-编译" class="headerlink" title="三、在 VSCode 中使用 CMake 编译"></a>三、在 VSCode 中使用 CMake 编译</h3><p>CMake 通过CMakeLists.txt生成构建文件，适合跨平台和大型项目，结合CMake Tools插件可实现可视化操作。</p>
<h4 id="1-创建项目结构-1"><a href="#1-创建项目结构-1" class="headerlink" title="1. 创建项目结构"></a>1. 创建项目结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_demo/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   ├── func.cpp</span><br><span class="line">│   └── ....cpp</span><br><span class="line">├── include/</span><br><span class="line">│   ├── func.h</span><br><span class="line">│   └── ....h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>源文件内容与 Makefile 示例相同，仅将Makefile改为CMakeLists.txt。</p>
<h4 id="2-编写-CMakeLists-txt"><a href="#2-编写-CMakeLists-txt" class="headerlink" title="2. 编写 CMakeLists.txt"></a>2. 编写 CMakeLists.txt</h4><p>在项目根目录创建CMakeLists.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line">project(cmake_demo)</span><br><span class="line"></span><br><span class="line">set(CMAKE_C_STANDARD 11)</span><br><span class="line"></span><br><span class="line"># 添加头文件目录</span><br><span class="line">include_directories(include)</span><br><span class="line"></span><br><span class="line"># 收集源文件</span><br><span class="line">file(GLOB SRCS &quot;src/*.c&quot;)</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">add_executable(app $&#123;SRCS&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-配置与编译"><a href="#3-配置与编译" class="headerlink" title="3. 配置与编译"></a>3. 配置与编译</h4><ol>
<li><p>安装CMake Tools插件后，状态栏会显示「No active kit」，点击选择编译器（如GCC 9.4.0）</p>
</li>
<li><p>点击状态栏「Configure」按钮（或按Ctrl+Shift+P输入「CMake: Configure」），自动生成构建文件（默认在build目录）</p>
</li>
<li><p>点击状态栏「Build」按钮（或输入「CMake: Build」），完成编译</p>
</li>
<li><p>运行程序：在终端进入build目录，执行.&#x2F;app</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 进入工程根目录</span><br><span class="line">cd .../cmake_demo   # Windows</span><br><span class="line"># Linux/macOS 直接 cd 路径</span><br><span class="line"></span><br><span class="line"># 2. 生成构建系统（仅第一次或修改 CMakeLists.txt 时）</span><br><span class="line">cmake -B build          # 会在当前目录新建 build/ 文件夹</span><br><span class="line"># 如果想指定生成器（可选）：</span><br><span class="line"># cmake -B build -G &quot;MinGW Makefiles&quot;   # Windows MinGW</span><br><span class="line"># cmake -B build -G &quot;Unix Makefiles&quot;    # Linux/macOS</span><br><span class="line"></span><br><span class="line"># 3. 编译</span><br><span class="line">cmake --build build     # 相当于进入 build 再 make / msbuild</span><br><span class="line"></span><br><span class="line"># 4. 运行</span><br><span class="line"># Windows MinGW：</span><br><span class="line">./build/Debug/app.exe</span><br><span class="line"># Linux/macOS：</span><br><span class="line">./build/app</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -B build &amp;&amp; cmake --build build &amp;&amp; ./build/app</span><br></pre></td></tr></table></figure>



<h3 id="四、在-VSCode-中使用-xmake-编译"><a href="#四、在-VSCode-中使用-xmake-编译" class="headerlink" title="四、在 VSCode 中使用 xmake 编译"></a>四、在 VSCode 中使用 xmake 编译</h3><p>xmake 是一款现代化构建工具，语法简洁且集成包管理，在 VSCode 中可通过终端或插件操作。</p>
<h4 id="1-安装-xmake"><a href="#1-安装-xmake" class="headerlink" title="1. 安装 xmake"></a>1. 安装 xmake</h4><p>完成Xmake的安装，确保终端中xmake –version可正常运行。</p>
<h4 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h4><ol>
<li>打开 VSCode 终端，进入项目目录，执行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake create -l cpp xmake_demo</span><br><span class="line">cd xmake_demo</span><br></pre></td></tr></table></figure>
<p>或者使用vscode直接打开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code xmake_demo</span><br></pre></td></tr></table></figure>

<ol>
<li>自动生成的目录结构：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake_demo/</span><br><span class="line">├── src/</span><br><span class="line">│   └── main.c</span><br><span class="line">└── xmake.lua</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-xmake-lua"><a href="#3-配置-xmake-lua" class="headerlink" title="3. 配置 xmake.lua"></a>3. 配置 xmake.lua</h4><p>编辑项目根目录的xmake.lua：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(&quot;xmake_demo&quot;)</span><br><span class="line">    set_kind(&quot;binary&quot;)</span><br><span class="line">    add_files(&quot;src/*.c&quot;)</span><br><span class="line">    add_includedirs(&quot;src&quot;)  -- 头文件在src目录</span><br></pre></td></tr></table></figure>

<h4 id="4-编译与运行"><a href="#4-编译与运行" class="headerlink" title="4. 编译与运行"></a>4. 编译与运行</h4><ul>
<li><p>终端输入xmake或者xmake build进行编译</p>
</li>
<li><p>输入xmake run运行程序</p>
</li>
<li><p>输入xmake clean清理产物</p>
</li>
</ul>
<h4 id="5-1可能存在的问题1（可直接看3的解决方法）"><a href="#5-1可能存在的问题1（可直接看3的解决方法）" class="headerlink" title="5.1可能存在的问题1（可直接看3的解决方法）"></a>5.1可能存在的问题1（可直接看3的解决方法）</h4><p>笔者在配置Xmake的过程中遇到了以下问题：<br>在运行xmake的时候xmake总是找不到正确的g++地址而默认找到的是git下的MinGW导致出现错误error: cannot get program for cxx</p>
<p>解决方法：手动设置 <code>toolchain</code> 工具链路径</p>
<p>你可以在你的项目根目录添加或编辑 <code>.xmake.lua</code>，显式指定正确的 <code>g++</code> 路径，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_toolchains(&quot;mytoolchain&quot;)</span><br><span class="line"></span><br><span class="line">toolchain(&quot;mytoolchain&quot;)</span><br><span class="line">    set_kind(&quot;standalone&quot;)</span><br><span class="line">    set_toolset(&quot;cxx&quot;, &quot;D:/applications/MinGW/bin/g++.exe&quot;)</span><br><span class="line">    set_toolset(&quot;cc&quot;,  &quot;D:/applications/MinGW/bin/gcc.exe&quot;)</span><br><span class="line">    set_toolset(&quot;ld&quot;,  &quot;D:/applications/MinGW/bin/g++.exe&quot;)</span><br><span class="line">    set_toolset(&quot;ar&quot;,  &quot;D:/applications/MinGW/bin/ar.exe&quot;)</span><br><span class="line">toolchain_end()</span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake f -p mingw --toolchain=mytoolchain</span><br><span class="line">xmake build</span><br></pre></td></tr></table></figure>

<p>程序就可以被正确地编译和运行了。</p>
<h4 id="5-2可能存在的问题2（可直接看3的解决方法）"><a href="#5-2可能存在的问题2（可直接看3的解决方法）" class="headerlink" title="5.2可能存在的问题2（可直接看3的解决方法）"></a>5.2可能存在的问题2（可直接看3的解决方法）</h4><p>由于笔者之前在vscode使用的是git bash，考虑到它在寻找编译器的时候会优先寻找git目录下的文件结果git下刚好有MinGW64会导致xmake将错误的MinGW配置导致错误</p>
<p>之后笔者使用Windows自带的powershell运行xmake，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake f -p windows -a x86_64 --toolchain=mingw --mingw=D:\applications_peizhi\MinGW\MinGW</span><br></pre></td></tr></table></figure>

<p>后面的路径为自己的MinGW安装路径，最终xmake也可以正常编译并运行了。</p>
<h4 id="5-3可能存在的问题3"><a href="#5-3可能存在的问题3" class="headerlink" title="5.3可能存在的问题3"></a>5.3可能存在的问题3</h4><p>如果上述还无法解决问题（笔者也是），主要是设置完当前项目编译确实没有问题，但是新建项目之后仍然 会遇到同样的问题，可以输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmake g --menu</span><br></pre></td></tr></table></figure>

<p>配置xmake的全局设置</p>
<p>在弹出的configure选项中找到MinGW Configure输入你所在的MinGW地址，笔者为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\applications_peizhi\MinGW\MinGW</span><br></pre></td></tr></table></figure>

<p>然后保存即可。</p>
<p>完成上述配置之后新建项目也是可以正常编译的。</p>
<p>之后使用git bash等终端也是可以正常编译的。</p>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>在 VSCode 中使用 Makefile、CMake 或 xmake 编译 C&#x2F;C++ 项目，核心是通过配置文件定义编译规则，并结合终端或插件执行操作。Makefile 适合简单场景，CMake 擅长跨平台大型项目，xmake 则以简洁语法和集成功能见长。</p>
<p>根据项目需求选择合适的工具，配合 VSCode 的插件生态，可大幅提升开发效率。熟练掌握后，还可探索工具的高级功能（如 xmake 的包管理、CMake 的多目标构建），进一步优化开发流程。</p>
]]></content>
      <categories>
        <category>工具使用与环境配置</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Makefile</tag>
        <tag>CMake</tag>
        <tag>xmake</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode检测到include错误请更新includePath</title>
    <url>/2025/08/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%A7%A3%E5%86%B3vscode%E6%A3%80%E6%B5%8B%E5%88%B0include%E9%94%99%E8%AF%AF%E8%AF%B7%E6%9B%B4%E6%96%B0includePath/</url>
    <content><![CDATA[<h1 id="解决vscode检测到-include-错误请更新-includePath问题"><a href="#解决vscode检测到-include-错误请更新-includePath问题" class="headerlink" title="解决vscode检测到 #include 错误请更新 includePath问题"></a>解决vscode检测到 <code>#include</code> 错误请更新 includePath问题</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在 VSCode 中遇到提示：</p>
<blockquote>
<p>“检测到 <code>#include</code> 错误。请更新 <code>includePath</code>。已为此翻译单元——。”</p>
</blockquote>
<p>说明 VSCode 的 <strong>C&#x2F;C++ 插件无法识别某些头文件的路径</strong>，即 <code>#include</code> 的文件找不到。这种情况常见于 C&#x2F;C++ 工程未正确配置包含路径（include path）。</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>需要 <strong>手动配置 <code>includePath</code></strong>，具体步骤如下：</p>
<p>1.打开你的项目文件夹。</p>
<p>2.在左侧资源管理器中点击 <code>.vscode</code> 文件夹（如果没有，请新建）。</p>
<p>3.找到或创建 <code>c_cpp_properties.json</code> 文件。</p>
<p>4.配置样例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Win64&quot;, // 取决于你使用的系统</span><br><span class="line">      &quot;includePath&quot;: [</span><br><span class="line">        &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">        &quot;C:/MinGW/include&quot;,               </span><br><span class="line">        &quot;C:/MinGW/lib/gcc/mingw32/9.2.0/include&quot;, </span><br><span class="line">        &quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30133/include&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;defines&quot;: [],</span><br><span class="line">      &quot;compilerPath&quot;: &quot;C:/MinGW/bin/g++.exe&quot;, // 你的编译器路径</span><br><span class="line">      &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">      &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">      &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot; // 根据系统选择</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键配置内容为其中以下几行的内容：（仅做示例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:/MinGW/include&quot;,               </span><br><span class="line">&quot;C:/MinGW/lib/gcc/mingw32/9.2.0/include&quot;, </span><br><span class="line">&quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30133/include&quot;</span><br></pre></td></tr></table></figure>

<p>而你如何得到这几行的内容呢，打开vscode终端输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -v -E -x c -</span><br></pre></td></tr></table></figure>

<p>可以看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br><span class="line"> D:/applications_peizhi/MinGW/MinGW/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/include</span><br><span class="line"> D:/applications_peizhi/MinGW/MinGW/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/include-fixed</span><br><span class="line"> D:/applications_peizhi/MinGW/MinGW/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure>

<p>复制其中三行地址到上面的<code>c_cpp_properties.json</code>文件中,按照上述配置案例完善格式（地址前后加“ ”以及地址间加英文逗号），关闭vscode重新打开即可。</p>
]]></content>
      <categories>
        <category>工具使用与环境配置</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile的自动化变量</title>
    <url>/2025/07/21/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Makefile%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Makefile的自动化变量"><a href="#Makefile的自动化变量" class="headerlink" title="Makefile的自动化变量"></a>Makefile的自动化变量</h1><p>自动化变量是 Make 工具提供的一组特殊变量，它们的值在规则执行时根据当前规则所涉及的**目标（Target）<strong>和</strong>先决条件（Prerequisites）**自动确定。它们极大地简化了 Makefile 的编写，使得规则更加通用和简洁，避免了重复书写文件名。</p>
<p>理解自动化变量是编写高效、可维护 Makefile 的关键。</p>
<hr>
<h3 id="核心自动化变量"><a href="#核心自动化变量" class="headerlink" title="核心自动化变量"></a><strong>核心自动化变量</strong></h3><p>以下是 Make 中最常用和最重要的自动化变量：</p>
<ol>
<li><p><strong><code>$@</code> (Dollar-At)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>规则中的目标文件名（Target）</strong>。</li>
<li><strong>行为</strong>：<ul>
<li>如果规则有多个目标，<code>$@</code> 代表的是<strong>触发此规则执行的那个目标</strong>。在模式规则中，这通常是与模式匹配的那个目标。</li>
<li>它会包含目标文件的完整路径（如果目标名中包含目录）。</li>
</ul>
</li>
<li><strong>用途</strong>：最常用于指定编译或链接的输出文件名。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：将 main.c 编译成 main.o</span></span><br><span class="line"><span class="section">main.o: main.c main.h</span></span><br><span class="line">	gcc -c main.c -o <span class="variable">$@</span>  <span class="comment"># $@ 展开为 &quot;main.o&quot;</span></span><br></pre></td></tr></table></figure>
这等价于 <code>gcc -c main.c -o main.o</code>。</li>
</ul>
</li>
<li><p><strong><code>$&lt;</code> (Dollar-Less-Than)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>规则中的第一个先决条件（Prerequisite）</strong>。</li>
<li><strong>行为</strong>：只取列表中的第一个文件名。</li>
<li><strong>用途</strong>：当你明确知道只需要第一个依赖文件时使用，例如在编译单个源文件生成目标文件时。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：将 .c 文件编译成同名的 .o 文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  <span class="comment"># $&lt; 是 %.c 匹配的源文件 (如 main.c), $@ 是 %.o 匹配的目标文件 (如 main.o)</span></span><br></pre></td></tr></table></figure>
如果有 <code>main.o: main.c utils.h defs.h</code>，<code>$&lt;</code> 仍然是 <code>main.c</code>。</li>
</ul>
</li>
<li><p><strong><code>$^</code> (Dollar-Caret)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>规则中所有的先决条件（Prerequisites），以空格分隔，且会自动去重</strong>。</li>
<li><strong>行为</strong>：列出所有依赖文件，重复的文件名只出现一次。</li>
<li><strong>用途</strong>：当需要将所有依赖文件都作为参数传递给命令时非常有用，比如链接多个目标文件生成可执行文件，或者将所有依赖头文件传递给某些工具。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：链接多个 .o 文件生成可执行文件</span></span><br><span class="line"><span class="section">program: main.o utils.o math.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span>  <span class="comment"># $^ 展开为 &quot;main.o utils.o math.o&quot;, $@ 是 &quot;program&quot;</span></span><br></pre></td></tr></table></figure>
如果 <code>main.o</code> 被多个规则依赖，<code>$^</code> 仍只列出一次。</li>
</ul>
</li>
<li><p><strong><code>$+</code> (Dollar-Plus)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>规则中所有的先决条件（Prerequisites），以空格分隔，但不会去重</strong>。</li>
<li><strong>行为</strong>：与 <code>$^</code> 类似，但保留了重复的文件名。</li>
<li><strong>用途</strong>：非常罕见。只有在依赖列表中文件名的<strong>顺序和重复</strong>对命令有特定意义时才需要使用。绝大多数情况下 <code>$^</code> 更合适。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设依赖顺序和重复很重要（极少见）</span></span><br><span class="line"><span class="section">target: dep1 dep2 dep1 dep3</span></span><br><span class="line">	some_command <span class="variable">$+</span>  <span class="comment"># $+ 展开为 &quot;dep1 dep2 dep1 dep3&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>$?</code> (Dollar-Question-Mark)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>比目标文件更新（更晚修改）的所有先决条件</strong>。</li>
<li><strong>行为</strong>：Make 会比较目标文件和每个先决条件的修改时间，只列出那些时间戳比目标文件新的依赖。</li>
<li><strong>用途</strong>：用于增量构建，只处理那些发生变化的依赖。常用于归档（<code>ar</code>）操作，只将更新的 <code>.o</code> 文件添加到静态库中。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：只将更新的 .o 文件添加到静态库 libmylib.a</span></span><br><span class="line"><span class="section">libmylib.a: file1.o file2.o file3.o</span></span><br><span class="line">	ar r libmylib.a <span class="variable">$?</span>  <span class="comment"># $? 只包含那些比 libmylib.a 新的 .o 文件</span></span><br></pre></td></tr></table></figure>
如果 <code>file2.o</code> 刚被修改过，而 <code>file1.o</code> 和 <code>file3.o</code> 没变，<code>$?</code> 就是 <code>file2.o</code>。</li>
</ul>
</li>
<li><p><strong><code>$*</code> (Dollar-Star)</strong></p>
<ul>
<li><strong>含义</strong>：代表<strong>模式规则中匹配的目标模式部分</strong>。</li>
<li><strong>行为</strong>：<strong>仅在模式规则（Pattern Rules）中有效</strong>。它代表 <code>%</code> 所匹配的那部分字符串。</li>
<li><strong>用途</strong>：在需要将模式匹配的部分作为文件名（不带扩展名）使用时。使用较少，且容易与 <code>$(basename ...)</code> 混淆。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：将 .txt 文件复制到 .bak 文件，并在同目录下创建一个 .log 文件</span></span><br><span class="line"><span class="section">%.bak: %.txt</span></span><br><span class="line">	cp <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line">	touch <span class="variable">$*</span>.log  <span class="comment"># $* 代表 % 匹配的部分 (如 &quot;report&quot; 匹配 &quot;report.txt&quot; -&gt; &quot;report.bak&quot;)</span></span><br></pre></td></tr></table></figure>
如果目标是 <code>report.bak</code>，<code>$*</code> 就是 <code>report</code>。<code>$*.log</code> 变成 <code>report.log</code>。</li>
<li><strong>注意</strong>：<code>$*</code> 的行为在静态模式规则和双后缀规则中更复杂，有时不可靠，现代 Makefile 中更推荐使用 <code>$(basename $@)</code> 或 <code>$(basename $&lt;)</code>。</li>
</ul>
</li>
<li><p><strong><code>$%</code> (Dollar-Percent)</strong></p>
<ul>
<li><strong>含义</strong>：当目标是<strong>归档成员（Archive Member）<strong>时，代表</strong>归档成员的名字</strong>。</li>
<li><strong>行为</strong>：仅在目标是 <code>archive(member)</code> 格式时有效。</li>
<li><strong>用途</strong>：专门用于处理静态库（<code>.a</code> 文件）中的单个成员。</li>
<li><strong>示例</strong>：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 规则：将 main.o 更新到 libmylib.a 库中</span></span><br><span class="line"><span class="section">libmylib.a(main.o): main.o</span></span><br><span class="line">	ar r <span class="variable">$@</span> <span class="variable">$&lt;</span>  <span class="comment"># $@ 是 &quot;libmylib.a(main.o)&quot;, $% 是 &quot;main.o&quot;</span></span><br></pre></td></tr></table></figure>
在这个规则中，<code>$%</code> 等于 <code>main.o</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a><strong>总结与最佳实践</strong></h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">含义</th>
<th align="left">最常用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>$@</code></strong></td>
<td align="left">目标文件名</td>
<td align="left">几乎所有规则的输出文件</td>
</tr>
<tr>
<td align="left"><strong><code>$&lt;</code></strong></td>
<td align="left">第一个先决条件</td>
<td align="left">编译单个源文件 (<code>%.c -&gt; %.o</code>)</td>
</tr>
<tr>
<td align="left"><strong><code>$^</code></strong></td>
<td align="left">所有先决条件 (去重)</td>
<td align="left">链接多个 <code>.o</code> 文件生成可执行文件</td>
</tr>
<tr>
<td align="left"><strong><code>$?</code></strong></td>
<td align="left">更新的先决条件</td>
<td align="left">增量更新静态库 (<code>ar r</code>)</td>
</tr>
<tr>
<td align="left"><strong><code>$*</code></strong></td>
<td align="left">模式匹配部分</td>
<td align="left">模式规则中提取基础名 (较少用，<code>$(basename)</code> 更佳)</td>
</tr>
<tr>
<td align="left"><strong><code>$+</code></strong></td>
<td align="left">所有先决条件 (不去重)</td>
<td align="left">极其罕见</td>
</tr>
<tr>
<td align="left"><strong><code>$%</code></strong></td>
<td align="left">归档成员名</td>
<td align="left">操作静态库成员</td>
</tr>
</tbody></table>
<p><strong>最佳实践建议：</strong></p>
<ol>
<li><strong>优先使用 <code>$@</code>, <code>$&lt;</code>, <code>$^</code></strong>：这三个是绝对的核心，覆盖了 90% 以上的场景。</li>
<li><strong>链接时用 <code>$^</code></strong>：链接器通常需要所有目标文件，<code>$^</code> 能确保所有依赖都被包含且不重复。</li>
<li><strong>编译时用 <code>$&lt;</code></strong>：编译单个源文件时，输入就是第一个（通常也是唯一一个）<code>.c</code> 文件。</li>
<li><strong>避免 <code>$*</code></strong>：除非你明确知道自己在做什么且需要它，否则优先使用 <code>$(basename $@)</code> 或 <code>$(dir $@)</code> 等更清晰的函数。</li>
<li><strong>理解 <code>$?</code> 的增量优势</strong>：在管理大型静态库时，<code>$?</code> 可以显著加快构建速度，因为它只处理变化的文件。</li>
<li><strong>注意变量作用域</strong>：自动化变量的值是在<strong>执行规则命令时</strong>才确定的，所以它们只能在规则的命令行中使用。</li>
</ol>
<p>掌握这些自动化变量，你就能写出简洁、高效且易于维护的 Makefile 了。</p>
]]></content>
      <categories>
        <category>工具使用与环境配置</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>编译</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CPSR和SPSR</title>
    <url>/2025/12/12/%E6%B1%87%E7%BC%96/CPSR%E3%80%81SPSR%E3%80%81MSR%E5%92%8CMRS/</url>
    <content><![CDATA[<p>在 ARM 架构的汇编语言中，<strong>MSR</strong>、<strong>MRS</strong>、<strong>CPSR</strong> 和 <strong>SPSR</strong> 是与处理器状态寄存器密切相关的指令和寄存器。它们主要用于控制和读取处理器的工作模式、中断使能状态、条件标志等关键信息。</p>
<p>下面分别详细讲解：</p>
<hr>
<h2 id="1-CPSR（Current-Program-Status-Register）"><a href="#1-CPSR（Current-Program-Status-Register）" class="headerlink" title="1. CPSR（Current Program Status Register）"></a>1. CPSR（Current Program Status Register）</h2><p><strong>当前程序状态寄存器（CPSR）</strong> 是 ARM 处理器中的一个 32 位寄存器，它保存了当前处理器的状态信息，包括：</p>
<ul>
<li><strong>条件标志位（N, Z, C, V）</strong>：<ul>
<li>N（Negative）：结果为负</li>
<li>Z（Zero）：结果为零</li>
<li>C（Carry）：进位&#x2F;借位</li>
<li>V（Overflow）：溢出</li>
</ul>
</li>
<li><strong>中断禁止位</strong>：<ul>
<li>I：禁止 IRQ 中断（1 &#x3D; 禁止）</li>
<li>F：禁止 FIQ 中断（1 &#x3D; 禁止）</li>
</ul>
</li>
<li><strong>处理器工作模式（Mode bits [4:0]）</strong>：<ul>
<li>如用户模式（User）、系统模式（System）、IRQ 模式、FIQ 模式、管理模式（Supervisor）等</li>
</ul>
</li>
<li><strong>其他控制位</strong>：如 Thumb 状态位（T）、Jazelle 位（J）等（视具体架构而定）</li>
</ul>
<blockquote>
<p>注意：并非所有模式下都可以修改 CPSR 的全部字段。例如，在用户模式下不能修改模式位或中断禁止位。</p>
</blockquote>
<hr>
<h2 id="2-SPSR（Saved-Program-Status-Register）"><a href="#2-SPSR（Saved-Program-Status-Register）" class="headerlink" title="2. SPSR（Saved Program Status Register）"></a>2. SPSR（Saved Program Status Register）</h2><p><strong>保存的程序状态寄存器（SPSR）</strong> 存在于除用户模式和系统模式之外的所有特权模式中（如 IRQ、FIQ、Supervisor、Abort、Undefined）。</p>
<ul>
<li>当处理器从一个模式切换到另一个异常模式时（如发生中断），<strong>当前的 CPSR 会被自动保存到新进入模式的 SPSR 中</strong>。</li>
<li>异常处理完成后，可以通过将 SPSR 恢复到 CPSR 来返回原来的执行状态。</li>
</ul>
<blockquote>
<p>举例：当发生 IRQ 中断时，处理器进入 IRQ 模式，并将原来的 CPSR 值保存到 SPSR_irq 中。</p>
</blockquote>
<hr>
<h2 id="3-MRS（Move-to-Register-from-Status-register）"><a href="#3-MRS（Move-to-Register-from-Status-register）" class="headerlink" title="3. MRS（Move to Register from Status register）"></a>3. MRS（Move to Register from Status register）</h2><p><strong>MRS 指令用于将状态寄存器（CPSR 或 SPSR）的内容读取到通用寄存器中</strong>。</p>
<p>语法：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MRS</span> &lt;Rd&gt;, <span class="keyword">CPSR</span>   <span class="comment">; 将 CPSR 的值读入 Rd</span></span><br><span class="line"><span class="keyword">MRS</span> &lt;Rd&gt;, SPSR   <span class="comment">; 将当前模式的 SPSR 的值读入 Rd</span></span><br></pre></td></tr></table></figure>

<p>用途：</p>
<ul>
<li>读取当前状态（如判断是否处于某种模式）</li>
<li>保存当前状态以便后续恢复（常用于异常处理前）</li>
</ul>
<p>示例：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, <span class="keyword">CPSR</span>     <span class="comment">; 读取 CPSR 到 R0</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-MSR（Move-to-Status-register-from-Register）"><a href="#4-MSR（Move-to-Status-register-from-Register）" class="headerlink" title="4. MSR（Move to Status register from Register）"></a>4. MSR（Move to Status register from Register）</h2><p><strong>MSR 指令用于将通用寄存器或立即数的值写入状态寄存器（CPSR 或 SPSR）</strong>。</p>
<p>语法（两种形式）：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MSR</span> CPSR_flg, &lt;Rm<span class="title">|#imm&gt;   ; 只更新标志位（N, Z, C, V）和控制位（I, F, T）</span></span><br><span class="line"><span class="title">MSR CPSR_cxsf, &lt;Rm|</span><span class="symbol">#imm</span>&gt;  <span class="comment">; 更新控制位（c）、扩展位（x）、状态位（s）、标志位（f）</span></span><br><span class="line"><span class="keyword">MSR</span> CPSR, &lt;Rm<span class="title">|#imm&gt;       ; 更新整个 CPSR（需特权模式）</span></span><br><span class="line"><span class="title">MSR SPSR, &lt;Rm|</span><span class="symbol">#imm</span>&gt;       <span class="comment">; 写入当前模式的 SPSR</span></span><br></pre></td></tr></table></figure>

<p>其中后缀含义（ARM 架构）：</p>
<ul>
<li><strong>_c</strong>：控制字段（[7:0]，包括 I&#x2F;F&#x2F;T&#x2F;M[4:0]）</li>
<li><strong>_x</strong>：扩展字段（某些架构保留）</li>
<li><strong>_s</strong>：状态字段（[19:16]，如 J,T 等）</li>
<li><strong>_f</strong>：标志字段（[31:28]，即 NZCV）</li>
</ul>
<p>常见用法：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MSR</span> <span class="built_in">CPSR_c</span>, <span class="built_in">R0</span>    <span class="comment">; 仅更新控制位（如切换模式、开关中断）</span></span><br><span class="line"><span class="keyword">MSR</span> <span class="built_in">CPSR_f</span>, <span class="number">#0x20000000</span>  <span class="comment">; 设置 Z 标志位（假设该值对应 Z=1）</span></span><br></pre></td></tr></table></figure>

<p>⚠️ 注意：在用户模式下，只能通过 MSR 修改标志位（_f），不能修改控制位（如中断禁止位或模式位）。</p>
<hr>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><h3 id="1-关闭-开启中断"><a href="#1-关闭-开启中断" class="headerlink" title="1. 关闭&#x2F;开启中断"></a>1. 关闭&#x2F;开启中断</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, <span class="keyword">CPSR</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x80</span>      <span class="comment">; 设置 I 位（禁止 IRQ）</span></span><br><span class="line"><span class="keyword">MSR</span> <span class="built_in">CPSR_c</span>, <span class="built_in">R0</span></span><br></pre></td></tr></table></figure>

<h3 id="2-切换处理器模式（需在特权模式下）"><a href="#2-切换处理器模式（需在特权模式下）" class="headerlink" title="2. 切换处理器模式（需在特权模式下）"></a>2. 切换处理器模式（需在特权模式下）</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, <span class="keyword">CPSR</span></span><br><span class="line"><span class="keyword">BIC</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x1F</span>      <span class="comment">; 清除模式位</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="number">#0x12</span>      <span class="comment">; 设置为 IRQ 模式 (0b10010)</span></span><br><span class="line"><span class="keyword">MSR</span> <span class="built_in">CPSR_c</span>, <span class="built_in">R0</span></span><br></pre></td></tr></table></figure>

<h3 id="3-异常返回（恢复-CPSR）"><a href="#3-异常返回（恢复-CPSR）" class="headerlink" title="3. 异常返回（恢复 CPSR）"></a>3. 异常返回（恢复 CPSR）</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOVS</span> <span class="built_in">PC</span>, <span class="built_in">LR</span>            <span class="comment">; 同时将 SPSR 恢复到 CPSR（仅在异常返回时有效）</span></span><br><span class="line"><span class="comment">; 或者显式：</span></span><br><span class="line"><span class="keyword">MRS</span> <span class="built_in">R0</span>, SPSR</span><br><span class="line"><span class="keyword">MSR</span> CPSR, <span class="built_in">R0</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">PC</span>, <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPSR</strong></td>
<td>寄存器</td>
<td>当前程序状态寄存器，反映处理器当前状态</td>
</tr>
<tr>
<td><strong>SPSR</strong></td>
<td>寄存器</td>
<td>异常发生时保存 CPSR 的副本，每个异常模式有自己的 SPSR</td>
</tr>
<tr>
<td><strong>MRS</strong></td>
<td>指令</td>
<td>从 CPSR&#x2F;SPSR 读取到通用寄存器</td>
</tr>
<tr>
<td><strong>MSR</strong></td>
<td>指令</td>
<td>从通用寄存器&#x2F;立即数写入 CPSR&#x2F;SPSR</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>⚠️ 注意：在 ARMv8（AArch64）架构中，CPSR 被拆分为多个系统寄存器（如 PSTATE、DAIF、NZCV 等），MRS&#x2F;MSR 仍然存在但语义不同。上述内容主要适用于 <strong>ARMv7 及更早的 AArch32 模式</strong>。</p>
</blockquote>
<p>如果你使用的是 Cortex-M 系列（如 Cortex-M3&#x2F;M4），则没有 CPSR&#x2F;SPSR 的完整概念，而是使用 <strong>xPSR</strong>（Program Status Register）并通过类似方式访问。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>架构</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile与CMake入门指南：从手动构建到自动化编译</title>
    <url>/2025/08/04/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Makefile%E4%B8%8Ecmake%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>在C&#x2F;C++开发中，随着项目规模扩大，手动输入编译命令会变得繁琐且容易出错。Makefile和CMake作为两款主流的构建工具，能够自动化处理编译流程，提高开发效率。本文将从基础入手，带你认识这两款工具的核心功能与使用方法，理解它们在项目构建中的角色与价值。</p>
<span id="more"></span>

<h3 id="一、构建工具的核心价值"><a href="#一、构建工具的核心价值" class="headerlink" title="一、构建工具的核心价值"></a>一、构建工具的核心价值</h3><p>在小型项目中，我们通常使用<code>gcc main.c -o app</code>这样的命令手动编译程序。但当项目包含多个源文件、依赖库和编译选项时，手动编译会面临以下问题：</p>
<ul>
<li>重复输入冗长的命令，效率低下</li>
<li>每次修改都重新编译所有文件，浪费时间</li>
<li>不同平台（Windows&#x2F;Linux&#x2F;macOS）的编译命令存在差异</li>
</ul>
<p>构建工具通过<strong>定义源文件依赖关系</strong>和<strong>编译规则</strong>，解决了这些问题：</p>
<ul>
<li>只重新编译修改过的文件（增量编译）</li>
<li>集中管理编译选项，保持一致性</li>
<li>自动化处理复杂的依赖关系</li>
</ul>
<p>Makefile和CMake正是为此而生的工具，其中Makefile是编译规则的描述文件，而CMake则是生成Makefile（或其他构建文件）的跨平台工具。</p>
<h3 id="二、Makefile入门"><a href="#二、Makefile入门" class="headerlink" title="二、Makefile入门"></a>二、Makefile入门</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>Makefile是一个文本文件，定义了一系列规则，用于指定如何编译和链接程序。每条规则包含三部分：</p>
<ul>
<li><strong>目标（Target）</strong>：通常是要生成的文件名（可执行文件、目标文件等）</li>
<li><strong>依赖（Prerequisites）</strong>：生成目标所需的文件（源文件、其他目标文件等）</li>
<li><strong>命令（Commands）</strong>：从依赖生成目标的操作（编译命令等）</li>
</ul>
<p>基本格式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 依赖</span></span><br><span class="line">    命令1</span><br><span class="line">    命令2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：命令前必须使用Tab键缩进，不能用空格</p>
</blockquote>
<h4 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a>2. 简单示例</h4><p>假设项目有两个文件：<code>main.c</code>和<code>func.c</code>，对应头文件<code>func.h</code>。</p>
<p><code>main.c</code>内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print_hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func.c</code>内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, Makefile!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义可执行文件名称</span></span><br><span class="line"><span class="section">app: main.o func.o</span></span><br><span class="line">    gcc main.o func.o -o app  <span class="comment"># 链接目标文件生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译main.c生成main.o</span></span><br><span class="line"><span class="section">main.o: main.c func.h</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译func.c生成func.o</span></span><br><span class="line"><span class="section">func.o: func.c func.h</span></span><br><span class="line">    gcc -c func.c -o func.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义clean目标（无依赖），用于清理生成文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f app *.o</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<ul>
<li>终端执行<code>make</code>：自动执行第一条规则，生成可执行文件<code>app</code></li>
<li>执行<code>make clean</code>：执行<code>clean</code>规则，删除生成的文件</li>
<li>修改<code>func.c</code>后再次执行<code>make</code>：只会重新编译<code>func.o</code>和链接，实现增量编译</li>
</ul>
<h4 id="3-变量与简化"><a href="#3-变量与简化" class="headerlink" title="3. 变量与简化"></a>3. 变量与简化</h4><p>为避免重复书写编译命令和文件名，Makefile支持变量定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc          <span class="comment"># 编译器</span></span><br><span class="line">CFLAGS = -Wall    <span class="comment"># 编译选项（开启所有警告）</span></span><br><span class="line">TARGET = app      <span class="comment"># 目标文件名</span></span><br><span class="line">OBJS = main.o func.o  <span class="comment"># 目标文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c func.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">func.o: func.c func.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c func.c -o func.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>

<p>Makefile还提供了自动推导规则（如<code>.c.o</code>规则），可进一步简化：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line">TARGET = app</span><br><span class="line">OBJS = main.o func.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span>  <span class="comment"># $^表示所有依赖，$@表示目标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动推导：%.o依赖%.c，无需手动编写每个.o的规则</span></span><br><span class="line"><span class="section">%.o: %.c func.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  <span class="comment"># $&lt;表示第一个依赖</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-CMake语法示例："><a href="#4-CMake语法示例：" class="headerlink" title="4.CMake语法示例："></a>4.CMake语法示例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目包含main.cpp,factorial.cpp,printhello.cpp和function.h文件</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新建文件夹</span><br><span class="line">mkdir learn_makefile</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.cpp文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;functions.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printhello();</span><br><span class="line">    cout &lt;&lt; &quot;This is main:&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The factorial of 5 is: &quot; &lt;&lt; factorial(5) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//factorial.cpp文件</span><br><span class="line">#include &quot;functions.h&quot;</span><br><span class="line"></span><br><span class="line">int factorial(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n == 1)</span><br><span class="line">            return 1;</span><br><span class="line">    else</span><br><span class="line">            return n * factorial(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//printhello.cpp文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;functions.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printhello()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//function.h文件</span><br><span class="line">#ifndef _FUNCTIONS_H_</span><br><span class="line">#define _FUNCTIONS_H_</span><br><span class="line">void printhello();</span><br><span class="line">int factorial(int n);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h5 id="4-1普通编译方式"><a href="#4-1普通编译方式" class="headerlink" title="4.1普通编译方式"></a>4.1普通编译方式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd learn_makefile</span><br><span class="line">g++ main.cpp factorial.cpp printhello.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<h5 id="4-2-Version1"><a href="#4-2-Version1" class="headerlink" title="4.2 Version1"></a>4.2 Version1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VERSION 1</span><br><span class="line"></span><br><span class="line"># hello为生成的可执行文件，依赖于后面的三个.cpp文件</span><br><span class="line"></span><br><span class="line"># g++前面加一个TAB的空格</span><br><span class="line"></span><br><span class="line">hello: main.cpp printhello.cpp factorial.cpp</span><br><span class="line">	g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd learn_makefile</span><br><span class="line">make</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>

<h5 id="4-3-Version2"><a href="#4-3-Version2" class="headerlink" title="4.3 Version2"></a>4.3 Version2</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VERSION 2</span><br><span class="line"></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"># make时执行g++ 先找TARGET，TARGET不存在找OBJ，OBJ不存在，编译三个.cpp文件生成.o文件</span><br><span class="line"></span><br><span class="line"># 然后再编译OBJ文件，生成可执行文件hello</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) -o $(TARGET) $(OBJ)</span><br><span class="line"></span><br><span class="line"># main.o这样来的，编译main.cpp生成</span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line">	$(CXX) -c main.cpp</span><br><span class="line">printhello.o: printhello.cpp</span><br><span class="line">	$(CXX) -c printhello.cpp</span><br><span class="line">factorial.o: factorial.cpp</span><br><span class="line">	$(CXX) -c factorial.cpp</span><br></pre></td></tr></table></figure>



<h5 id="4-4-Version3"><a href="#4-4-Version3" class="headerlink" title="4.4 Version3"></a>4.4 Version3</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VERSION 3</span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"> </span><br><span class="line"># 编译选项，显示所有的warning</span><br><span class="line">CXXLAGS = -c -Wall</span><br><span class="line"> </span><br><span class="line"># $@表示的就是冒号前面的TARGET，$^表示的是冒号后OBJ的全部.o依赖文件</span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) -o $@ $^</span><br><span class="line"> </span><br><span class="line"># $&lt;表示指向%.cpp依赖的第一个，但是这里依赖只有一个</span><br><span class="line"># $@表示指向%.o</span><br><span class="line">%.o: %.cpp</span><br><span class="line">	$(CXX) $(CXXLAGS) $&lt; -o $@</span><br><span class="line"> </span><br><span class="line"># 为了防止文件夹中存在一个文件叫clean</span><br><span class="line">.PHONY: clean</span><br><span class="line"> </span><br><span class="line"># -f表示强制删除，此处表示删除所有的.o文件和TARGET文件</span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>



<h5 id="4-5-Version4"><a href="#4-5-Version4" class="headerlink" title="4.5 Version4"></a>4.5 Version4</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VERSION 4</span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line"># 所有当前目录的.cpp文件都放在SRC里面</span><br><span class="line">SRC = $(wildcard *.cpp)</span><br><span class="line"># 把SRC里面的.cpp文件替换为.o文件</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o,$(SRC))</span><br><span class="line"> </span><br><span class="line">CXXLAGS = -c -Wall</span><br><span class="line"> </span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) -o $@ $^</span><br><span class="line"> </span><br><span class="line">%.o: %.cpp</span><br><span class="line">	$(CXX) $(CXXLAGS) $&lt; -o $@</span><br><span class="line"> </span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>



<h3 id="三、CMake入门"><a href="#三、CMake入门" class="headerlink" title="三、CMake入门"></a>三、CMake入门</h3><h4 id="1-为什么需要CMake？"><a href="#1-为什么需要CMake？" class="headerlink" title="1. 为什么需要CMake？"></a>1. 为什么需要CMake？</h4><p>Makefile虽然强大，但存在以下局限：</p>
<ul>
<li>语法复杂，编写大型项目的Makefile难度高</li>
<li>不跨平台，Windows上需要MinGW或Cygwin支持</li>
<li>不同编译器的适配需要手动处理</li>
</ul>
<p>CMake通过<strong>生成平台无关的配置文件</strong>（如Makefile、Visual Studio项目文件）解决了这些问题。开发者只需编写一份<code>CMakeLists.txt</code>，CMake就能根据目标平台生成对应的构建文件。</p>
<h4 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h4><p>CMake的配置文件名为<code>CMakeLists.txt</code>，基本语法规则：</p>
<ul>
<li>命令不区分大小写，但通常使用大写</li>
<li>变量使用<code>$&#123;变量名&#125;</code>引用</li>
<li>注释以<code>#</code>开头</li>
</ul>
<p>核心命令：</p>
<ul>
<li><code>cmake_minimum_required(VERSION 版本)</code>：指定CMake最低版本</li>
<li><code>project(项目名)</code>：定义项目名称</li>
<li><code>add_executable(可执行文件名 源文件列表)</code>：指定生成的可执行文件及源文件</li>
<li><code>target_include_directories(目标 路径)</code>：添加头文件搜索路径</li>
<li><code>target_link_libraries(目标 库文件)</code>：链接库文件</li>
</ul>
<h4 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h4><p>针对上述相同的项目，<code>CMakeLists.txt</code>内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)  <span class="comment"># 最低CMake版本要求</span></span><br><span class="line"><span class="keyword">project</span>(hello_project)                <span class="comment"># 项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C标准版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件：目标名为app，源文件为main.c和func.c</span></span><br><span class="line"><span class="keyword">add_executable</span>(app main.c func.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：添加编译选项</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(app PRIVATE -Wall)</span><br></pre></td></tr></table></figure>

<p>使用方法（命令行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建构建目录并进入（推荐out-of-source build，避免污染源文件）</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成Makefile（Unix-like系统）或Visual Studio项目（Windows）</span></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译项目（相当于make）</span></span><br><span class="line">cmake --build .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行可执行文件</span></span><br><span class="line">./app  <span class="comment"># Linux/macOS</span></span><br><span class="line">app.exe  <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure>

<h4 id="4-处理多目录项目"><a href="#4-处理多目录项目" class="headerlink" title="4. 处理多目录项目"></a>4. 处理多目录项目</h4><p>对于包含多个源文件目录的项目，CMake的组织方式更清晰。假设项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   └── func.c</span><br><span class="line">├── include/</span><br><span class="line">│   └── func.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>对应的<code>CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(hello_project)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收集src目录下的所有.c文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCES <span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="四、Makefile与CMake的对比"><a href="#四、Makefile与CMake的对比" class="headerlink" title="四、Makefile与CMake的对比"></a>四、Makefile与CMake的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Makefile</th>
<th>CMake</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>构建脚本（直接执行）</td>
<td>构建系统生成器（间接生成构建脚本）</td>
</tr>
<tr>
<td>跨平台性</td>
<td>差（主要用于Unix-like系统）</td>
<td>好（支持Windows&#x2F;Linux&#x2F;macOS等）</td>
</tr>
<tr>
<td>语法复杂度</td>
<td>高（需要掌握自动变量、模式规则等）</td>
<td>低（命令简洁，易于学习）</td>
</tr>
<tr>
<td>大型项目支持</td>
<td>较难维护</td>
<td>支持良好（通过<code>add_subdirectory</code>管理子模块）</td>
</tr>
<tr>
<td>适用场景</td>
<td>小型项目、单一平台</td>
<td>中大型项目、跨平台开发</td>
</tr>
</tbody></table>
<h3 id="五、实际应用建议"><a href="#五、实际应用建议" class="headerlink" title="五、实际应用建议"></a>五、实际应用建议</h3><ol>
<li><strong>小型单一平台项目</strong>：直接使用Makefile，简单直观</li>
<li><strong>跨平台项目或团队协作</strong>：优先选择CMake，减少平台适配成本</li>
<li><strong>学习路径</strong>：先理解Makefile的工作原理，再学习CMake的使用，有助于理解构建流程</li>
<li><strong>最佳实践</strong>：<ul>
<li>始终使用<code>out-of-source build</code>（单独的构建目录），避免污染源文件</li>
<li>合理组织项目结构，将源文件和头文件分离</li>
<li>为常用操作（如清理、安装）定义清晰的目标&#x2F;命令</li>
</ul>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>Makefile和CMake是C&#x2F;C++开发中不可或缺的构建工具。Makefile作为经典的构建脚本，直接定义编译规则，适合小型项目和单一平台；CMake作为更高层次的工具，通过生成平台无关的配置文件，解决了跨平台构建的难题，更适合中大型项目。</p>
<p>掌握这两款工具，不仅能显著提高编译效率，更能帮助开发者理解项目的构建流程和依赖管理。无论是手动编写Makefile，还是使用CMake进行跨平台开发，核心目标都是实现构建过程的自动化与规范化，让开发者能更专注于代码逻辑本身。</p>
]]></content>
      <categories>
        <category>工具使用与环境配置</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>CMake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>xmake 入门指南</title>
    <url>/2025/08/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/xmake/</url>
    <content><![CDATA[<p>在 C&#x2F;C++ 开发领域，构建工具的选择直接影响开发效率。除了经典的 Makefile 和 CMake，xmake 作为一款新兴的现代化构建工具，凭借其简洁的语法、强大的跨平台能力和丰富的功能，逐渐受到开发者的青睐。本文将带你走进 xmake 的世界，从入门到熟练使用，感受它带来的便捷与高效。</p>
<h3 id="一、xmake-的优势与特点"><a href="#一、xmake-的优势与特点" class="headerlink" title="一、xmake 的优势与特点"></a>一、xmake 的优势与特点</h3><p>xmake 是一个基于 Lua 的跨平台构建工具，专注于 C&#x2F;C++ 项目的构建与管理，相比传统工具，它具有以下显著优势：</p>
<ol>
<li><p><strong>简洁直观的语法</strong>：采用 Lua 脚本作为配置语言，语法简洁易懂，比 Makefile 的复杂规则和 CMake 的冗余配置更易于上手和维护。</p>
</li>
<li><p><strong>强大的跨平台支持</strong>：无缝支持 Windows、Linux、macOS、Android、iOS 等多种操作系统，无需编写平台特定的适配代码。</p>
</li>
<li><p><strong>自动依赖管理</strong>：能够自动检测源文件依赖关系，实现增量编译，大大缩短编译时间。</p>
</li>
<li><p><strong>丰富的内置功能</strong>：集成了包管理、测试框架、调试支持等功能，一站式解决项目构建中的各种需求。</p>
</li>
<li><p><strong>与主流工具兼容</strong>：可以生成 Makefile、Visual Studio 项目、Xcode 项目等，方便与现有开发流程集成。</p>
</li>
</ol>
<h3 id="二、xmake-的安装"><a href="#二、xmake-的安装" class="headerlink" title="二、xmake 的安装"></a>二、xmake 的安装</h3><p>xmake 的安装过程简单快捷，支持多种安装方式，适用于不同的操作系统。</p>
<h4 id="1-Windows-系统"><a href="#1-Windows-系统" class="headerlink" title="1. Windows 系统"></a>1. Windows 系统</h4><ul>
<li><p><strong>使用 Chocolatey</strong>：如果已经安装了 Chocolatey 包管理器，只需在命令行中执行choco install xmake即可。</p>
</li>
<li><p><strong>手动安装</strong>：从 xmake 的官方 GitHub 仓库（<a href="https://github.com/xmake-io/xmake/releases%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84">https://github.com/xmake-io/xmake/releases）下载最新的</a> Windows 安装包（.exe 文件），双击运行并按照提示完成安装。</p>
</li>
</ul>
<h4 id="2-Linux-系统"><a href="#2-Linux-系统" class="headerlink" title="2. Linux 系统"></a>2. Linux 系统</h4><ul>
<li><p><strong>使用包管理器</strong>：对于 Ubuntu&#x2F;Debian 系统，可执行sudo apt install xmake；对于 Fedora 系统，可执行sudo dnf install xmake。</p>
</li>
<li><p><strong>脚本安装</strong>：在终端中执行bash &lt;(curl -fsSL <a href="https://xmake.io/shget.text)%EF%BC%8C%E8%AF%A5%E8%84%9A%E6%9C%AC%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85%E9%80%82%E5%90%88%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84">https://xmake.io/shget.text)，该脚本会自动下载并安装适合当前系统的</a> xmake 版本。</p>
</li>
</ul>
<h4 id="3-macOS-系统"><a href="#3-macOS-系统" class="headerlink" title="3. macOS 系统"></a>3. macOS 系统</h4><ul>
<li><strong>使用 Homebrew</strong>：执行brew install xmake即可完成安装。</li>
</ul>
<p>安装完成后，在命令行中输入xmake –version，如果能显示出 xmake 的版本信息，说明安装成功。</p>
<h3 id="三、xmake-的基本使用"><a href="#三、xmake-的基本使用" class="headerlink" title="三、xmake 的基本使用"></a>三、xmake 的基本使用</h3><h4 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h4><p>在命令行中进入项目所在的目录，执行以下命令初始化一个 xmake 项目：</p>
<p>xmake create -l c myproject</p>
<p>其中，-l c指定项目语言为 C 语言，myproject是项目名称。执行后，会在当前目录下创建一个名为myproject的文件夹，里面包含了 xmake 的配置文件xmake.lua和基本的源文件结构。</p>
<p>进入项目目录：cd myproject</p>
<h4 id="2-配置项目"><a href="#2-配置项目" class="headerlink" title="2. 配置项目"></a>2. 配置项目</h4><p>xmake 项目的配置主要通过xmake.lua文件实现。打开该文件，初始内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(&quot;myproject&quot;)</span><br><span class="line">    set_kind(&quot;binary&quot;)</span><br><span class="line">    add_files(&quot;src/*.c&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>target(“myproject”)：定义一个名为myproject的目标。</p>
</li>
<li><p>set_kind(“binary”)：指定目标类型为可执行文件。</p>
</li>
<li><p>add_files(“src&#x2F;*.c”)：添加源文件，这里表示添加src目录下所有的.c文件。</p>
</li>
</ul>
<p>如果需要添加头文件搜索路径、链接库等，可以在xmake.lua中进行配置。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(&quot;myproject&quot;)</span><br><span class="line">    set_kind(&quot;binary&quot;)</span><br><span class="line">    add_files(&quot;src/*.c&quot;)</span><br><span class="line">    add_includedirs(&quot;include&quot;)  -- 添加头文件搜索目录</span><br><span class="line">    add_links(&quot;m&quot;)  -- 链接数学库</span><br></pre></td></tr></table></figure>

<h4 id="3-构建项目"><a href="#3-构建项目" class="headerlink" title="3. 构建项目"></a>3. 构建项目</h4><p>配置完成后，执行xmake命令即可开始构建项目。xmake 会自动检测源文件的变化，只编译修改过的文件，实现增量编译。</p>
<p>如果需要重新构建整个项目，可以执行xmake -r。</p>
<h4 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4. 运行程序"></a>4. 运行程序</h4><p>项目构建成功后，执行xmake run命令可以运行生成的可执行文件。如果需要传递命令行参数，可以在xmake run后添加参数，例如xmake run – arg1 arg2。</p>
<h4 id="5-清理构建产物"><a href="#5-清理构建产物" class="headerlink" title="5. 清理构建产物"></a>5. 清理构建产物</h4><p>执行xmake clean命令可以清理构建过程中生成的目标文件、可执行文件等中间产物。如果需要彻底清理，包括配置缓存等，可以执行xmake clean -a。</p>
<h3 id="四、xmake-的进阶用法"><a href="#四、xmake-的进阶用法" class="headerlink" title="四、xmake 的进阶用法"></a>四、xmake 的进阶用法</h3><h4 id="1-多目标构建"><a href="#1-多目标构建" class="headerlink" title="1. 多目标构建"></a>1. 多目标构建</h4><p>xmake 支持在一个项目中定义多个目标，例如同时构建可执行文件和静态库。在xmake.lua中可以这样配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 定义可执行文件目标</span><br><span class="line">target(&quot;app&quot;)</span><br><span class="line">    set_kind(&quot;binary&quot;)</span><br><span class="line">    add_files(&quot;src/main.c&quot;)</span><br><span class="line">    add_deps(&quot;mylib&quot;)  -- 依赖静态库目标</span><br><span class="line"></span><br><span class="line">-- 定义静态库目标</span><br><span class="line">target(&quot;mylib&quot;)</span><br><span class="line">    set_kind(&quot;static&quot;)</span><br><span class="line">    add_files(&quot;src/lib/*.c&quot;)</span><br></pre></td></tr></table></figure>

<p>执行xmake会同时构建这两个目标，执行xmake build app可以只构建app目标。</p>
<h4 id="2-包管理"><a href="#2-包管理" class="headerlink" title="2. 包管理"></a>2. 包管理</h4><p>xmake 内置了包管理功能，可以方便地引入第三方库。例如，要引入zlib库，可以在xmake.lua中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(&quot;myapp&quot;)</span><br><span class="line">    set_kind(&quot;binary&quot;)</span><br><span class="line">    add_files(&quot;src/*.c&quot;)</span><br><span class="line">    add_requires(&quot;zlib&quot;)  -- 声明依赖zlib</span><br><span class="line">    add_packages(&quot;zlib&quot;)  -- 链接zlib库</span><br></pre></td></tr></table></figure>

<p>执行xmake时，xmake 会自动下载并编译zlib库，并将其链接到目标程序中。</p>
<h4 id="3-构建模式切换"><a href="#3-构建模式切换" class="headerlink" title="3. 构建模式切换"></a>3. 构建模式切换</h4><p>xmake 支持多种构建模式，如调试模式（debug）和发布模式（release）。默认情况下为调试模式，执行xmake f -m release可以切换到发布模式，然后执行xmake进行构建。其中f是config的缩写，用于配置构建选项。</p>
<h4 id="4-生成-IDE-项目"><a href="#4-生成-IDE-项目" class="headerlink" title="4. 生成 IDE 项目"></a>4. 生成 IDE 项目</h4><p>xmake 可以生成主流 IDE 的项目文件，方便在 IDE 中进行开发。例如，生成 Visual Studio 项目：xmake project -k vs2022；生成 Xcode 项目：xmake project -k xcode。</p>
<h3 id="五、xmake-与其他构建工具的对比"><a href="#五、xmake-与其他构建工具的对比" class="headerlink" title="五、xmake 与其他构建工具的对比"></a>五、xmake 与其他构建工具的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>xmake</th>
<th>Makefile</th>
<th>CMake</th>
</tr>
</thead>
<tbody><tr>
<td>配置语法</td>
<td>Lua 脚本，简洁灵活</td>
<td>自定义规则，复杂</td>
<td>专用语法，较冗余</td>
</tr>
<tr>
<td>跨平台性</td>
<td>优秀，原生支持多平台</td>
<td>较差，需额外适配</td>
<td>良好，生成平台特定文件</td>
</tr>
<tr>
<td>学习曲线</td>
<td>平缓，易于上手</td>
<td>陡峭，规则复杂</td>
<td>中等，需掌握大量命令</td>
</tr>
<tr>
<td>包管理</td>
<td>内置支持</td>
<td>无，需手动处理</td>
<td>需配合外部包管理器</td>
</tr>
<tr>
<td>增量编译</td>
<td>自动支持</td>
<td>需手动定义依赖</td>
<td>自动支持</td>
</tr>
</tbody></table>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>xmake 作为一款现代化的 C&#x2F;C++ 构建工具，以其简洁的语法、强大的功能和出色的跨平台性，为开发者提供了高效便捷的项目构建体验。无论是小型项目的快速构建，还是大型复杂项目的管理，xmake 都能胜任。</p>
<p>通过本文的介绍，相信你已经对 xmake 有了基本的了解，并能进行简单的项目构建。在实际使用中，还可以深入探索 xmake 的更多高级功能，如自定义任务、远程构建等，让它更好地服务于你的开发工作。</p>
<p>如果你正在寻找一款易于学习、功能强大的构建工具，不妨尝试一下 xmake，它可能会给你带来意想不到的惊喜。</p>
]]></content>
      <categories>
        <category>工具使用与环境配置</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>xmake</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title>解析ELF可执行文件</title>
    <url>/2025/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/ARM32%E4%B8%8A%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E5%BA%95%E9%95%BF%E5%95%A5%E6%A0%B7/</url>
    <content><![CDATA[<p>当我们编译 C&#x2F;C++ 程序生成可执行文件后，双击运行即可得到结果，但很少有人深究这个二进制文件内部到底长什么样。实际上，可执行文件并非一堆杂乱无章的 0 和 1，而是按照严格格式组织的结构化数据。在 Linux 系统中，最常见的可执行文件格式是 ELF（Executable and Linkable Format），而readelf命令则是剖析 ELF 文件的利器。本文将通过readelf的各种参数，逐层揭开可执行文件的神秘面纱，带你看清它的 “内部器官”—— 各个段（Section）的真实面貌。</p>
<h3 id="一、准备工作：生成并认识目标文件"><a href="#一、准备工作：生成并认识目标文件" class="headerlink" title="一、准备工作：生成并认识目标文件"></a>一、准备工作：生成并认识目标文件</h3><p>在开始分析前，我们需要一个简单的可执行文件作为研究对象。编写如下 C 程序（demo.c）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">int global_var = 10;</span><br><span class="line">int global_uninit_var;</span><br><span class="line"></span><br><span class="line">// 函数</span><br><span class="line">void print_msg() &#123;</span><br><span class="line">    const char* msg = &quot;Hello, ELF!&quot;;  // 字符串常量</span><br><span class="line">    printf(&quot;%s\n&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int local_var = 20;  // 局部变量</span><br><span class="line">    print_msg();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用gcc编译生成可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc demo.c -o demo  # 生成ELF格式的可执行文件demo</span><br></pre></td></tr></table></figure>

<p>接下来，我们将通过readelf命令分析demo文件的结构。readelf是 GNU binutils 工具集中的一员，专门用于读取 ELF 格式文件的信息，支持多种参数查看不同维度的内容。</p>
<h3 id="二、ELF-文件的整体结构概览"><a href="#二、ELF-文件的整体结构概览" class="headerlink" title="二、ELF 文件的整体结构概览"></a>二、ELF 文件的整体结构概览</h3><p>首先用readelf -h查看 ELF 文件的头部信息，了解文件的基本属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -h demo</span><br></pre></td></tr></table></figure>

<p>输出结果（精简版）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x400430</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          6240 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br></pre></td></tr></table></figure>

<p>头部信息揭示了关键信息：</p>
<ul>
<li><p><strong>Class</strong>: 64 位 ELF 文件（对应 x86_64 架构）</p>
</li>
<li><p><strong>Type</strong>: 可执行文件（EXEC）</p>
</li>
<li><p><strong>Entry point address</strong>: 程序入口地址（0x400430，即main函数附近的代码起始位置）</p>
</li>
<li><p><strong>Section headers</strong>: 段表信息（共 31 个段，段表起始位置在文件偏移 6240 字节）</p>
</li>
</ul>
<p>ELF 文件的整体结构可分为三部分：</p>
<ol>
<li><p><strong>ELF 头部</strong>：如上述信息，描述文件的基本属性</p>
</li>
<li><p><strong>段表（Section Headers）</strong>：记录所有段的元信息（名称、类型、大小、偏移量等）</p>
</li>
<li><p><strong>段数据</strong>：各个段的实际内容（代码、数据、符号表等）</p>
</li>
</ol>
<p>接下来，我们通过readelf -S查看所有段的列表，这是分析的基础：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -S demo</span><br></pre></td></tr></table></figure>

<p>输出结果中会列出 31 个段（因编译器版本可能略有差异），每个段有名称、类型、地址、偏移量、大小等属性。其中最关键的段包括：</p>
<ul>
<li><p>代码相关：.text（代码段）、.plt（过程链接表）</p>
</li>
<li><p>数据相关：.data（已初始化数据段）、.bss（未初始化数据段）、.rodata（只读数据段）</p>
</li>
<li><p>符号相关：.symtab（符号表）、.strtab（字符串表）、.dynsym（动态符号表）</p>
</li>
</ul>
<h3 id="三、代码段：程序的-“行动指令”"><a href="#三、代码段：程序的-“行动指令”" class="headerlink" title="三、代码段：程序的 “行动指令”"></a>三、代码段：程序的 “行动指令”</h3><p>代码段（.text）是可执行文件中最核心的段之一，存放程序的机器指令（二进制形式的代码）。通过readelf -x .text可查看其十六进制内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -x .text demo</span><br></pre></td></tr></table></figure>

<p>输出结果（精简版）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex dump of section &#x27;.text&#x27;:</span><br><span class="line">  0x00400430 554889e5 4883ec20 897dfc8b 45fc83f8  UH..H.. ...]..E...</span><br><span class="line">  0x00400440 00741e8b 05d60b20 008b0083 c8ff4889  .t..... ......H.</span><br><span class="line">  ...（省略部分内容）</span><br></pre></td></tr></table></figure>

<p>这些十六进制数值是 CPU 可直接执行的机器码。结合objdump -d demo（反汇编）可将其转换为汇编指令，对应我们编写的main和print_msg函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d demo | grep -A 20 &quot;&lt;main&gt;&quot;  # 查看main函数的汇编</span><br></pre></td></tr></table></figure>

<p>.text段的特点：</p>
<ul>
<li><p><strong>只读</strong>：防止程序运行时意外修改指令（内存保护机制）</p>
</li>
<li><p><strong>可执行</strong>：CPU 可直接从该段读取并执行指令</p>
</li>
<li><p><strong>位置无关</strong>（部分情况下）：动态链接时可加载到任意内存地址</p>
</li>
</ul>
<h3 id="四、数据段：程序的-“记忆仓库”"><a href="#四、数据段：程序的-“记忆仓库”" class="headerlink" title="四、数据段：程序的 “记忆仓库”"></a>四、数据段：程序的 “记忆仓库”</h3><p>数据段用于存放程序中的变量，根据初始化状态分为.data、.bss和.rodata三个关键段。</p>
<h4 id="1-data：已初始化的全局-静态变量"><a href="#1-data：已初始化的全局-静态变量" class="headerlink" title="1. .data：已初始化的全局 &#x2F; 静态变量"></a>1. .data：已初始化的全局 &#x2F; 静态变量</h4><p>我们在程序中定义了int global_var &#x3D; 10;（已初始化全局变量），其值存放在.data段。通过readelf -x .data查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -x .data demo</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex dump of section &#x27;.data&#x27;:</span><br><span class="line">  0x00601028 0a000000 00000000                 ........</span><br></pre></td></tr></table></figure>

<ul>
<li><p>0x00601028是global_var的内存地址</p>
</li>
<li><p>0a000000是十六进制的10（小端存储，低字节在前）</p>
</li>
<li><p>后续的00000000可能是其他已初始化变量的占位符</p>
</li>
</ul>
<h4 id="2-bss：未初始化的全局-静态变量"><a href="#2-bss：未初始化的全局-静态变量" class="headerlink" title="2. .bss：未初始化的全局 &#x2F; 静态变量"></a>2. .bss：未初始化的全局 &#x2F; 静态变量</h4><p>未初始化的全局变量（如global_uninit_var）或初始值为 0 的变量存放在.bss段。与.data不同，.bss段在文件中不占用实际空间（仅记录大小），程序加载时由操作系统分配内存并初始化为 0。</p>
<p>通过readelf -S查看.bss段的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[25] .bss              NOBITS          00601030 001030 000008 00  WA  0   0  8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>NOBITS：表示该段无实际数据（仅占内存，不占文件空间）</p>
</li>
<li><p>Size为000008（8 字节）：global_uninit_var是 int 类型（4 字节），可能还有其他未初始化变量</p>
</li>
</ul>
<h4 id="3-rodata：只读数据"><a href="#3-rodata：只读数据" class="headerlink" title="3. .rodata：只读数据"></a>3. .rodata：只读数据</h4><p>字符串常量（如”Hello, ELF!”）和const修饰的全局变量存放在.rodata段，该段只读不可修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -x .rodata demo</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex dump of section &#x27;.rodata&#x27;:</span><br><span class="line">  0x004005f8 01000200 48656c6c 6f2c2045 4c462100  ....Hello, ELF!.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>48656c6c6f2c20454c4621对应 ASCII 码的”Hello, ELF!”</p>
</li>
<li><p>末尾的00是字符串结束符\0</p>
</li>
</ul>
<p>.rodata段的只读特性由内存页保护机制保证，试图修改会触发段错误（Segmentation fault）。</p>
<h3 id="五、符号表：程序的-“身份档案”"><a href="#五、符号表：程序的-“身份档案”" class="headerlink" title="五、符号表：程序的 “身份档案”"></a>五、符号表：程序的 “身份档案”</h3><p>符号表（.symtab）记录了程序中所有符号（变量名、函数名）的信息，包括符号类型、地址、大小等。通过readelf -s查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -s demo | grep -E &quot;global_var|main|print_msg&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果（精简版）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58: 0000000000601028     4 OBJECT  GLOBAL DEFAULT   25 global_var</span><br><span class="line">65: 0000000000400526    28 FUNC    GLOBAL DEFAULT   14 print_msg</span><br><span class="line">66: 0000000000400430    43 FUNC    GLOBAL DEFAULT   14 main</span><br><span class="line">67: 0000000000601030     4 OBJECT  GLOBAL DEFAULT   25 global_uninit_var</span><br></pre></td></tr></table></figure>

<p>各字段含义：</p>
<ul>
<li><p><strong>Value</strong>：符号的内存地址（如global_var在0x601028）</p>
</li>
<li><p><strong>Size</strong>：符号大小（global_var是 int 类型，占 4 字节）</p>
</li>
<li><p><strong>Type</strong>：符号类型（OBJECT表示变量，FUNC表示函数）</p>
</li>
<li><p><strong>Ndx</strong>：所在段的索引（25对应.bss段，14对应.text段）</p>
</li>
</ul>
<p>符号表的作用：</p>
<ul>
<li><p>编译链接阶段：确保函数和变量的引用正确解析</p>
</li>
<li><p>调试阶段：gdb通过符号表将内存地址映射为变量名 &#x2F; 函数名</p>
</li>
<li><p>动态链接：动态加载器通过符号表定位共享库中的函数</p>
</li>
</ul>
<h3 id="六、其他重要段：程序的-“辅助器官”"><a href="#六、其他重要段：程序的-“辅助器官”" class="headerlink" title="六、其他重要段：程序的 “辅助器官”"></a>六、其他重要段：程序的 “辅助器官”</h3><p>除了核心的代码段和数据段，ELF 文件还有多个辅助段，负责程序的加载、链接和调试。</p>
<h4 id="1-plt与-got：动态链接的-“桥梁”"><a href="#1-plt与-got：动态链接的-“桥梁”" class="headerlink" title="1. .plt与.got：动态链接的 “桥梁”"></a>1. .plt与.got：动态链接的 “桥梁”</h4><p>当程序使用动态链接库（如printf来自libc）时，.plt（Procedure Linkage Table，过程链接表）和.got（Global Offset Table，全局偏移表）负责在运行时找到共享库函数的实际地址。</p>
<ul>
<li><p>.plt：存放跳转指令，首次调用共享库函数时触发动态链接器解析地址</p>
</li>
<li><p>.got：存放已解析的共享库函数地址，后续调用直接使用，避免重复解析</p>
</li>
</ul>
<p>通过readelf -x .plt可查看.plt段的内容，其中包含指向.got的跳转指令。</p>
<h4 id="2-shstrtab与-strtab：字符串表"><a href="#2-shstrtab与-strtab：字符串表" class="headerlink" title="2. .shstrtab与.strtab：字符串表"></a>2. .shstrtab与.strtab：字符串表</h4><ul>
<li><p>.shstrtab（Section Header String Table）：存放段表中所有段的名称（如.text、.data）</p>
</li>
<li><p>.strtab（String Table）：存放符号表中符号的名称（如函数名、变量名）</p>
</li>
</ul>
<p>通过readelf -p .shstrtab demo可查看段名称字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -p .shstrtab demo</span><br></pre></td></tr></table></figure>

<p>输出结果中包含所有段的名称，如[  11]  .text、[  17]  .rodata等。</p>
<h3 id="七、程序头表：告诉操作系统如何加载"><a href="#七、程序头表：告诉操作系统如何加载" class="headerlink" title="七、程序头表：告诉操作系统如何加载"></a>七、程序头表：告诉操作系统如何加载</h3><p>程序头表（Program Headers）描述了 ELF 文件如何被操作系统加载到内存，通过readelf -l查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf -l demo</span><br></pre></td></tr></table></figure>

<p>输出结果中的 “Segment”（段，与 Section 不同）表示内存加载单元，例如：</p>
<ul>
<li><p><strong>LOAD</strong>类型的 Segment：将文件中的部分内容加载到内存，包含.text、.data等 Section</p>
</li>
<li><p><strong>Dynamic</strong>类型的 Segment：存放动态链接信息</p>
</li>
</ul>
<p>每个 Segment 有VirtAddr（内存地址）、PhysAddr（物理地址）、FileSiz（文件中大小）、MemSiz（内存中大小）等属性，操作系统根据这些信息分配内存并加载数据。</p>
<h3 id="八、总结：可执行文件的-“解剖图”"><a href="#八、总结：可执行文件的-“解剖图”" class="headerlink" title="八、总结：可执行文件的 “解剖图”"></a>八、总结：可执行文件的 “解剖图”</h3><p>通过readelf的各种命令，我们可以清晰看到 ELF 可执行文件的内部结构：</p>
<table>
<thead>
<tr>
<th>段名称</th>
<th>功能</th>
<th>关键特性</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>存放机器指令</td>
<td>只读、可执行</td>
</tr>
<tr>
<td>.data</td>
<td>存放已初始化全局 &#x2F; 静态变量</td>
<td>可读写、占文件空间</td>
</tr>
<tr>
<td>.bss</td>
<td>存放未初始化全局 &#x2F; 静态变量</td>
<td>可读写、不占文件空间</td>
</tr>
<tr>
<td>.rodata</td>
<td>存放只读数据（字符串常量等）</td>
<td>只读</td>
</tr>
<tr>
<td>.symtab</td>
<td>记录符号信息（变量 &#x2F; 函数名）</td>
<td>调试和链接的基础</td>
</tr>
<tr>
<td>.plt&#x2F;.got</td>
<td>动态链接时定位共享库函数</td>
<td>实现延迟绑定</td>
</tr>
</tbody></table>
<p>这些段按照 ELF 格式的规则有序组织，共同构成了可执行文件的 “躯体”。操作系统加载程序时，根据程序头表将各段映射到内存的相应位置，CPU 从.text段的入口地址开始执行指令，通过符号表和动态链接机制调用外部函数，通过数据段读写变量 —— 整个过程如同一个精密的机器在运转。</p>
<p>理解可执行文件的结构，不仅能帮助我们排查链接错误、优化程序性能，更能深入理解程序从源码到运行的完整生命周期。readelf作为剖析工具，为我们打开了一扇窥探二进制世界的窗口，让看似神秘的可执行文件变得清晰可见。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>可执行文件</tag>
        <tag>readelf</tag>
        <tag>ELF 格式</tag>
      </tags>
  </entry>
  <entry>
    <title>LAN 通信详解：从原理到实践的局域网技术指南</title>
    <url>/2025/09/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/LAN%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>在数字化时代，局域网（LAN，Local Area Network）是连接设备、实现数据交互的基础 —— 从家庭中的路由器连接电脑与智能设备，到工业场景中 PLC 与传感器的通信，再到数据中心内服务器的集群交互，都依赖 LAN 通信技术。本文将从 LAN 通信的核心原理入手，拆解关键技术、协议栈及典型应用，同时分享嵌入式场景下 LAN 通信的调试技巧，帮你全面掌握局域网通信的底层逻辑与实践方法。</p>
<h2 id="一、LAN-通信基础：什么是局域网？"><a href="#一、LAN-通信基础：什么是局域网？" class="headerlink" title="一、LAN 通信基础：什么是局域网？"></a>一、LAN 通信基础：什么是局域网？</h2><p>LAN（局域网）是指在<strong>有限地理范围</strong>（如一栋楼、一个办公室、一个家庭）内，将多台设备（计算机、嵌入式设备、打印机等）通过物理介质（网线、WiFi）连接形成的网络。其核心特点是：</p>
<ul>
<li><p><strong>地理范围小</strong>：通常覆盖范围不超过几公里，区别于广域网（WAN，如互联网）；</p>
</li>
<li><p><strong>传输速率高</strong>：主流以太网速率已达 100Mbps、1Gbps，甚至 10Gbps，满足高频数据交互需求；</p>
</li>
<li><p><strong>延迟低</strong>：设备间通信延迟通常在毫秒级，适合实时性要求高的场景（如工业控制、游戏）；</p>
</li>
<li><p><strong>成本低</strong>：硬件（交换机、网线）价格亲民，部署维护简单。</p>
</li>
</ul>
<p>常见的 LAN 通信介质分为两类：</p>
<ol>
<li><p><strong>有线介质</strong>：以以太网网线（CAT5&#x2F;CAT6）为代表，传输稳定、抗干扰能力强，适合工业控制、服务器集群等对可靠性要求高的场景；</p>
</li>
<li><p><strong>无线介质</strong>：以 WiFi（802.11 系列协议）为代表，无需布线、灵活性高，适合家庭、办公场景中的移动设备（手机、笔记本）。</p>
</li>
</ol>
<h2 id="二、LAN-通信的核心技术：协议栈与关键协议"><a href="#二、LAN-通信的核心技术：协议栈与关键协议" class="headerlink" title="二、LAN 通信的核心技术：协议栈与关键协议"></a>二、LAN 通信的核心技术：协议栈与关键协议</h2><p>LAN 通信的正常运行依赖 “分层协议栈”—— 不同层级负责不同功能，从物理层的信号传输到应用层的业务数据交互，形成完整的通信链路。最常用的是<strong>TCP&#x2F;IP 协议栈</strong>（与 OSI 七层模型对应），在 LAN 场景中核心涉及以下层级：</p>
<h3 id="1-物理层：信号的-“传输载体”"><a href="#1-物理层：信号的-“传输载体”" class="headerlink" title="1. 物理层：信号的 “传输载体”"></a>1. 物理层：信号的 “传输载体”</h3><p>物理层是 LAN 通信的 “硬件基础”，负责将数字信号转换为物理介质可传输的电信号 &#x2F; 光信号，定义介质类型、接口标准、传输速率等。</p>
<ul>
<li><p><strong>有线 LAN（以太网）</strong>：</p>
</li>
<li><ul>
<li>接口：RJ45 水晶头（常见于网卡、交换机）；</li>
</ul>
</li>
<li><ul>
<li>信号：差分信号（抗干扰），如 100Mbps 以太网采用曼彻斯特编码，1Gbps 及以上采用 4B&#x2F;5B 编码；</li>
</ul>
</li>
<li><ul>
<li>传输距离：CAT5 网线单段最大传输距离 100 米，超过需通过交换机中继。</li>
</ul>
</li>
<li><p><strong>无线 LAN（WiFi）</strong>：</p>
</li>
<li><ul>
<li>频段：2.4GHz（覆盖广、速率低，最高 300Mbps）、5GHz（速率高、覆盖窄，最高数 Gbps）；</li>
</ul>
</li>
<li><ul>
<li>调制方式：OFDM（正交频分复用），通过多子载波并行传输提升速率。</li>
</ul>
</li>
</ul>
<h3 id="2-数据链路层：设备的-“身份识别”-与-“帧传输”"><a href="#2-数据链路层：设备的-“身份识别”-与-“帧传输”" class="headerlink" title="2. 数据链路层：设备的 “身份识别” 与 “帧传输”"></a>2. 数据链路层：设备的 “身份识别” 与 “帧传输”</h3><p>数据链路层负责将物理层的信号封装为 “数据帧”，实现局域网内设备的精准通信，核心协议是<strong>以太网协议（Ethernet）</strong> 和<strong>ARP 协议</strong>。</p>
<h4 id="（1）以太网帧：LAN-通信的-“数据包裹”"><a href="#（1）以太网帧：LAN-通信的-“数据包裹”" class="headerlink" title="（1）以太网帧：LAN 通信的 “数据包裹”"></a>（1）以太网帧：LAN 通信的 “数据包裹”</h4><p>以太网帧是 LAN 内数据传输的基本单位，结构如下（简化版）：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（字节）</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>目的 MAC 地址</td>
<td>6</td>
<td>接收设备的物理地址（唯一标识）</td>
</tr>
<tr>
<td>源 MAC 地址</td>
<td>6</td>
<td>发送设备的物理地址</td>
</tr>
<tr>
<td>类型 &#x2F; 长度</td>
<td>2</td>
<td>标识上层协议（如 0x0800 表示 IP 协议）</td>
</tr>
<tr>
<td>数据</td>
<td>46-1500</td>
<td>上层协议数据（如 IP 数据包）</td>
</tr>
<tr>
<td>FCS</td>
<td>4</td>
<td>校验和（检测帧传输是否出错）</td>
</tr>
</tbody></table>
<p><strong>关键概念：MAC 地址</strong></p>
<p>MAC 地址是设备网卡的物理地址，由 48 位二进制数组成（如00:1A:2B:3C:4D:5E），前 24 位为厂商代码（由 IEEE 分配），后 24 位为厂商自定义编号，确保全球唯一 —— 这是 LAN 内设备 “身份识别” 的核心，交换机通过 MAC 地址表实现 “帧转发”。</p>
<h4 id="（2）ARP-协议：从-IP-地址到-MAC-地址的-“翻译官”"><a href="#（2）ARP-协议：从-IP-地址到-MAC-地址的-“翻译官”" class="headerlink" title="（2）ARP 协议：从 IP 地址到 MAC 地址的 “翻译官”"></a>（2）ARP 协议：从 IP 地址到 MAC 地址的 “翻译官”</h4><p>LAN 内通信时，设备通常已知目标设备的 IP 地址（如 <a href="http://192.168.1.10/">192.168.1.10</a>），但需要 MAC 地址才能封装以太网帧 ——ARP 协议（地址解析协议）负责实现 “IP 地址→MAC 地址” 的映射。</p>
<ul>
<li><strong>工作流程</strong>：</li>
</ul>
<ol>
<li><ol>
<li>发送设备（如 IP：<a href="http://192.168.1.20/">192.168.1.20</a>）广播 ARP 请求帧：“谁是 <a href="http://192.168.1.10/">192.168.1.10</a>？请回复你的 MAC 地址”；</li>
</ol>
</li>
<li><ol>
<li>局域网内所有设备接收请求，仅目标设备（<a href="http://192.168.1.10/">192.168.1.10</a>）回复 ARP 响应帧，包含自身 MAC 地址；</li>
</ol>
</li>
<li><ol>
<li>发送设备将 “IP→MAC” 映射存入 ARP 缓存表，后续通信直接使用该映射，无需重复广播。</li>
</ol>
</li>
</ol>
<p><strong>实例：查看 ARP 缓存表</strong></p>
<p>在 Linux&#x2F;Windows 终端中，可通过命令查看 ARP 缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Linux系统</span><br><span class="line">arp -a</span><br><span class="line"># 输出示例：? (192.168.1.10) at 00:1a:2b:3c:4d:5e [ether] on eth0</span><br><span class="line"></span><br><span class="line"># Windows系统</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure>

<h3 id="3-网络层：LAN-内的-“路由与转发”"><a href="#3-网络层：LAN-内的-“路由与转发”" class="headerlink" title="3. 网络层：LAN 内的 “路由与转发”"></a>3. 网络层：LAN 内的 “路由与转发”</h3><p>网络层负责实现 LAN 内设备的 IP 地址管理与数据包路由，核心协议是<strong>IP 协议（IPv4&#x2F;IPv6）</strong>。</p>
<ul>
<li><p><strong>IP 地址</strong>：LAN 内设备的逻辑地址（如 <a href="http://192.168.1.20/">192.168.1.20</a>），由 “网络段 + 主机段” 组成，通过子网掩码（如 <a href="http://255.255.255.0/">255.255.255.0</a>）区分；</p>
</li>
<li><p><strong>LAN 内路由</strong>：若设备在同一子网（如 <a href="http://192.168.1.20/">192.168.1.20</a> 和 <a href="http://192.168.1.10/">192.168.1.10</a>，子网掩码 <a href="http://255.255.255.0/">255.255.255.0</a>），数据包直接通过数据链路层传输；若跨子网，则需通过路由器转发（但 LAN 场景多为同一子网，路由需求较少）。</p>
</li>
</ul>
<h3 id="4-传输层：数据的-“可靠-快速传输”"><a href="#4-传输层：数据的-“可靠-快速传输”" class="headerlink" title="4. 传输层：数据的 “可靠 &#x2F; 快速传输”"></a>4. 传输层：数据的 “可靠 &#x2F; 快速传输”</h3><p>传输层负责为应用层提供端到端的通信服务，LAN 场景中最常用的是<strong>TCP 协议</strong>和<strong>UDP 协议</strong>：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接、可靠传输（重传、流量控制）、有序</td>
<td>文件传输（FTP）、数据交互（HTTP）、工业控制</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接、不可靠、高速传输</td>
<td>实时视频（RTSP）、传感器数据（MQTT）、广播</td>
</tr>
</tbody></table>
<p><strong>实例：LAN 内 TCP 通信流程</strong></p>
<ol>
<li><p>客户端（如 <a href="http://192.168.1.20:8080/">192.168.1.20:8080</a>）向服务器（<a href="http://192.168.1.10/">192.168.1.10:80</a>）发起 TCP 三次握手，建立连接；</p>
</li>
<li><p>客户端发送数据（如 HTTP 请求），TCP 通过序号、确认号确保数据有序且不丢失；</p>
</li>
<li><p>服务器处理请求后返回响应数据，TCP 通过滑动窗口实现流量控制，避免发送过快导致接收端溢出；</p>
</li>
<li><p>通信结束后，双方发起 TCP 四次挥手，释放连接。</p>
</li>
</ol>
<h2 id="三、LAN-通信的典型应用场景"><a href="#三、LAN-通信的典型应用场景" class="headerlink" title="三、LAN 通信的典型应用场景"></a>三、LAN 通信的典型应用场景</h2><p>LAN 通信广泛应用于家庭、办公、工业等领域，不同场景的技术选型与配置重点不同：</p>
<h3 id="1-家庭-LAN：WiFi-以太网混合组网"><a href="#1-家庭-LAN：WiFi-以太网混合组网" class="headerlink" title="1. 家庭 LAN：WiFi + 以太网混合组网"></a>1. 家庭 LAN：WiFi + 以太网混合组网</h3><p>家庭场景中，通常以<strong>无线路由器</strong>为核心，构建 “有线 + 无线” 混合 LAN：</p>
<ul>
<li><p>有线连接：路由器 LAN 口通过网线连接台式机、智能电视（传输稳定，适合大流量场景）；</p>
</li>
<li><p>无线连接：手机、笔记本、智能家居（如扫地机器人、摄像头）通过 WiFi 连接路由器；</p>
</li>
<li><p>核心配置：路由器分配 LAN 内 IP 地址（如 <a href="http://192.168.3.0/24">192.168.3.0&#x2F;24</a> 网段），所有设备在同一子网，可互相访问（如手机访问台式机共享文件夹）。</p>
</li>
</ul>
<h3 id="2-工业-LAN：高可靠、低延迟的工业以太网"><a href="#2-工业-LAN：高可靠、低延迟的工业以太网" class="headerlink" title="2. 工业 LAN：高可靠、低延迟的工业以太网"></a>2. 工业 LAN：高可靠、低延迟的工业以太网</h3><p>工业场景对 LAN 通信的 “可靠性”“实时性” 要求极高（如生产线控制、设备监控），通常采用<strong>工业以太网</strong>技术：</p>
<ul>
<li><p>协议：在标准以太网基础上优化，如 Profinet、EtherNet&#x2F;IP，支持实时数据传输（延迟 &lt; 1ms）；</p>
</li>
<li><p>拓扑：采用环网拓扑（如冗余环），某一段网线故障时，数据可通过备用路径传输，避免网络中断；</p>
</li>
<li><p>硬件：工业级交换机、网线（抗电磁干扰、耐高低温），适应工厂恶劣环境。</p>
</li>
</ul>
<h3 id="3-嵌入式-LAN：设备的-“联网能力”-实现"><a href="#3-嵌入式-LAN：设备的-“联网能力”-实现" class="headerlink" title="3. 嵌入式 LAN：设备的 “联网能力” 实现"></a>3. 嵌入式 LAN：设备的 “联网能力” 实现</h3><p>嵌入式设备（如 PLC、传感器、智能硬件）通过 LAN 通信接入网络，通常需要以下步骤：</p>
<ol>
<li><p><strong>硬件选型</strong>：集成以太网控制器（如 ENC28J60、W5500）或 WiFi 模块（如 ESP8266、ESP32）；</p>
</li>
<li><p><strong>驱动开发</strong>：在嵌入式系统（如 Linux、RT-Thread）中编写网卡驱动，实现数据链路层通信；</p>
</li>
<li><p><strong>协议栈移植</strong>：移植 LwIP（轻量级 TCP&#x2F;IP 协议栈），支持 IP、TCP、UDP 等协议；</p>
</li>
<li><p><strong>应用开发</strong>：基于 Socket 编程实现业务逻辑，如通过 TCP 与上位机通信，或通过 UDP 发送传感器数据。</p>
</li>
</ol>
<p><strong>实例：嵌入式设备 LAN 通信代码片段（LwIP+UDP）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;lwip/socket.h&quot;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEST_IP &quot;192.168.1.100&quot;  // 目标设备IP</span><br><span class="line">#define DEST_PORT 8888           // 目标端口</span><br><span class="line"></span><br><span class="line">void udp_send_data(const char* data, int len) &#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in dest_addr;</span><br><span class="line"></span><br><span class="line">    // 创建UDP socket</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if (sockfd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Socket create failed!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置目标地址</span><br><span class="line">    memset(&amp;dest_addr, 0, sizeof(dest_addr));</span><br><span class="line">    dest_addr.sin_family = AF_INET;</span><br><span class="line">    dest_addr.sin_port = htons(DEST_PORT);</span><br><span class="line">    inet_aton(DEST_IP, &amp;dest_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    // 发送数据</span><br><span class="line">    sendto(sockfd, data, len, 0, (struct sockaddr*)&amp;dest_addr, sizeof(dest_addr));</span><br><span class="line">    printf(&quot;Send data: %s\n&quot;, data);</span><br><span class="line"></span><br><span class="line">    // 关闭socket</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、LAN-通信调试：常见问题与排查方法"><a href="#四、LAN-通信调试：常见问题与排查方法" class="headerlink" title="四、LAN 通信调试：常见问题与排查方法"></a>四、LAN 通信调试：常见问题与排查方法</h2><p>在 LAN 通信开发中，常遇到 “设备无法联网”“数据传输丢包”“延迟过高” 等问题，以下是实用的调试工具与排查流程：</p>
<h3 id="1-基础连通性排查：ping-命令"><a href="#1-基础连通性排查：ping-命令" class="headerlink" title="1. 基础连通性排查：ping 命令"></a>1. 基础连通性排查：ping 命令</h3><p>ping是 LAN 通信调试的 “第一工具”，通过 ICMP 协议测试设备间的连通性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 测试与192.168.1.10的连通性（Linux/Windows通用）</span><br><span class="line">ping 192.168.1.10</span><br><span class="line"></span><br><span class="line"># 关键输出解读：</span><br><span class="line"># &quot;64 bytes from 192.168.1.10: icmp_seq=1 ttl=64 time=0.500 ms&quot;：连通正常，延迟0.5ms；</span><br><span class="line"># &quot;Request timeout for icmp_seq=1&quot;：超时，设备未响应（可能IP错误、防火墙拦截、设备离线）；</span><br><span class="line"># &quot;Destination host unreachable&quot;：目标不可达（可能子网掩码错误、路由配置问题）。</span><br></pre></td></tr></table></figure>

<h3 id="2-端口通信排查：telnet-netcat"><a href="#2-端口通信排查：telnet-netcat" class="headerlink" title="2. 端口通信排查：telnet&#x2F;netcat"></a>2. 端口通信排查：telnet&#x2F;netcat</h3><p>若应用层使用 TCP 协议，可通过telnet或nc（netcat）测试端口是否开放、能否建立连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方法1：telnet测试192.168.1.10的8080端口</span><br><span class="line">telnet 192.168.1.10 8080</span><br><span class="line"># 成功：显示&quot;Connected to 192.168.1.10&quot;；失败：显示&quot;Connection refused&quot;（端口未开放）</span><br><span class="line"></span><br><span class="line"># 方法2：nc测试UDP端口（-u表示UDP）</span><br><span class="line">nc -u 192.168.1.10 8888</span><br><span class="line"># 输入数据并回车，若目标设备能接收，则通信正常</span><br></pre></td></tr></table></figure>

<h3 id="3-数据包分析：Wireshark-抓包"><a href="#3-数据包分析：Wireshark-抓包" class="headerlink" title="3. 数据包分析：Wireshark 抓包"></a>3. 数据包分析：Wireshark 抓包</h3><p>Wireshark 是 LAN 通信的 “显微镜”，可捕获局域网内的数据包，分析协议交互过程，定位丢包、协议错误等问题：</p>
<ul>
<li><strong>操作步骤</strong>：</li>
</ul>
<ol>
<li><ol>
<li>打开 Wireshark，选择 LAN 网卡（如 eth0、WiFi）；</li>
</ol>
</li>
<li><ol>
<li>设置过滤条件（如ip.addr &#x3D;&#x3D; <a href="http://192.168.1.20/">192.168.1.20</a>，仅显示目标设备的数据包）；</li>
</ol>
</li>
<li><ol>
<li>触发通信（如发送数据），Wireshark 捕获数据包；</li>
</ol>
</li>
<li><ol>
<li>分析数据包：查看以太网帧、IP 包、TCP&#x2F;UDP 段的结构，判断是否存在帧丢失、校验错误、协议字段异常。</li>
</ol>
</li>
</ol>
<p><strong>常见问题定位</strong>：</p>
<ul>
<li><p>若仅能捕获 ARP 请求，无 ARP 响应：可能目标设备 IP 错误、MAC 地址冲突；</p>
</li>
<li><p>若 TCP 三次握手失败（仅 SYN 包，无 SYN+ACK 包）：可能目标设备端口未监听、防火墙拦截；</p>
</li>
<li><p>若数据包存在大量重传（TCP Dup ACK）：可能网线接触不良、信号干扰导致丢包。</p>
</li>
</ul>
<h3 id="4-工业-LAN-特殊排查：环网冗余测试"><a href="#4-工业-LAN-特殊排查：环网冗余测试" class="headerlink" title="4. 工业 LAN 特殊排查：环网冗余测试"></a>4. 工业 LAN 特殊排查：环网冗余测试</h3><p>工业环网场景中，需测试 “冗余切换” 功能：</p>
<ol>
<li><p>正常状态下，通过 Wireshark 查看数据包传输路径；</p>
</li>
<li><p>断开环网中某一段网线，观察设备是否能在 100ms 内切换到备用路径；</p>
</li>
<li><p>检查切换后的数据是否连续，无丢失或重复（可通过应用层数据序号验证）。</p>
</li>
</ol>
<h2 id="五、LAN-通信的发展趋势"><a href="#五、LAN-通信的发展趋势" class="headerlink" title="五、LAN 通信的发展趋势"></a>五、LAN 通信的发展趋势</h2><p>随着物联网、工业 4.0 的推进，LAN 通信正朝着以下方向发展：</p>
<ol>
<li><p><strong>更高速率</strong>：从 1Gbps 以太网向 10Gbps、25Gbps 升级，满足高清视频、大数据传输需求；</p>
</li>
<li><p><strong>更低延迟</strong>：工业以太网延迟逐步降至微秒级（如 Time-Sensitive Networking，TSN 协议），支持实时控制场景；</p>
</li>
<li><p><strong>无线化</strong>：WiFi 6&#x2F;6E、5G-Advanced 技术在 LAN 场景中的应用增加，实现 “有线级可靠性” 的无线通信；</p>
</li>
<li><p><strong>智能化</strong>：LAN 设备（交换机、路由器）集成 AI 功能，支持自动故障诊断、流量优化、安全防护（如入侵检测）。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LAN 通信是连接设备的 “基础纽带”，从物理层的信号传输到应用层的业务交互，每一层都有明确的协议与技术支撑。无论是家庭场景的 WiFi 组网、工业场景的实时控制，还是嵌入式设备的联网实现，理解 LAN 通信的原理、掌握调试方法都是关键。</p>
<p>对于嵌入式工程师而言，需重点关注 “硬件驱动→协议栈移植→应用开发” 的全流程，结合ping、Wireshark 等工具排查问题；对于普通用户或运维人员，需熟悉 LAN 的基本配置与连通性测试，确保网络稳定运行。随着技术的发展，LAN 通信将持续进化，为更复杂的场景提供高效、可靠的连接能力。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LAN 通信，局域网，以太网，TCP/IP</tag>
        <tag>嵌入式网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC通信协议</title>
    <url>/2025/09/23/%E5%B5%8C%E5%85%A5%E5%BC%8F/IIC%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="IIC-通信协议基础与嵌入式应用"><a href="#IIC-通信协议基础与嵌入式应用" class="headerlink" title="IIC 通信协议基础与嵌入式应用"></a>IIC 通信协议基础与嵌入式应用</h1><h2 id="一、IIC-协议简介"><a href="#一、IIC-协议简介" class="headerlink" title="一、IIC 协议简介"></a>一、IIC 协议简介</h2><p>IIC（Inter-Integrated Circuit，集成电路间总线）是由飞利浦（Philips）公司于 1982 年推出的同步串行通信协议，专为短距离、低速的芯片间数据传输设计。其核心优势在于<strong>仅需两根信号线</strong>即可实现多设备间的双向通信，大幅简化了嵌入式系统的硬件接线（无需片选线），广泛应用于传感器（温湿度、光照）、EEPROM（存储芯片）、LCD 控制器、ADC&#x2F;DAC 等外设与 MCU 的通信场景。</p>
<p>IIC 协议的核心特征的：</p>
<ol>
<li><p><strong>双线制</strong>：仅需 SDA（Serial Data，串行数据线）和 SCL（Serial Clock，串行时钟线）两根信号线，均为双向传输</p>
</li>
<li><p><strong>多主从架构</strong>：总线可挂载多个主设备（如 MCU）和多个从设备（如传感器），通过地址区分不同从设备</p>
</li>
<li><p><strong>同步通信</strong>：通过 SCL 提供时钟同步，数据传输速率可灵活调整（标准模式 100kHz、快速模式 400kHz、高速模式 3.4MHz）</p>
</li>
<li><p><strong>开漏输出</strong>：SDA 和 SCL 均采用开漏输出设计，需外接上拉电阻（通常 4.7kΩ~10kΩ）至电源，实现 “线与” 逻辑（多设备同时拉低时总线为低，均释放时为高）</p>
</li>
</ol>
<h2 id="二、IIC-协议核心特性"><a href="#二、IIC-协议核心特性" class="headerlink" title="二、IIC 协议核心特性"></a>二、IIC 协议核心特性</h2><h3 id="（一）物理层规范"><a href="#（一）物理层规范" class="headerlink" title="（一）物理层规范"></a>（一）物理层规范</h3><p>IIC 的物理层定义了总线的硬件连接与电平标准，是协议正常工作的基础：</p>
<table>
<thead>
<tr>
<th>信号线</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>SDA</td>
<td>双向串行数据线，用于传输 8 位数据（MSB 先传），数据在 SCL 高电平时保持稳定</td>
</tr>
<tr>
<td>SCL</td>
<td>双向串行时钟线，由主设备生成，用于同步 SDA 上的数据传输，控制数据采样时机</td>
</tr>
<tr>
<td>上拉电阻</td>
<td>必须外接，确保 SDA&#x2F;SCL 在无设备驱动时处于高电平，阻值根据传输速率选择（100kHz 用 4.7kΩ）</td>
</tr>
<tr>
<td>总线拓扑</td>
<td>所有设备的 SDA&#x2F;SCL 分别共接，主设备负责发起通信、生成时钟，从设备被动响应</td>
</tr>
</tbody></table>
<p><strong>电平标准</strong>：</p>
<ul>
<li><p>高电平（VIH）：通常为 2.7V~5V（兼容 3.3V&#x2F;5V 系统，需注意设备电平匹配）</p>
</li>
<li><p>低电平（VIL）：通常≤0.8V（开漏输出通过拉低总线实现低电平，释放总线后由上拉电阻拉回高电平）</p>
</li>
</ul>
<h3 id="（二）通信拓扑结构"><a href="#（二）通信拓扑结构" class="headerlink" title="（二）通信拓扑结构"></a>（二）通信拓扑结构</h3><p>IIC 总线采用 “主从” 通信模式，支持多主设备共存（需避免总线冲突），典型拓扑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          +5V/3.3V</span><br><span class="line">            |</span><br><span class="line">            R（上拉电阻）</span><br><span class="line">            |</span><br><span class="line">SDA: 主设备1（MCU）&lt;--&gt; 主设备2（FPGA）&lt;--&gt; 从设备1（SHT30）&lt;--&gt; 从设备2（AT24C02）</span><br><span class="line">            |              |                |                |</span><br><span class="line">SCL: 主设备1（MCU）&lt;--&gt; 主设备2（FPGA）&lt;--&gt; 从设备1（SHT30）&lt;--&gt; 从设备2（AT24C02）</span><br><span class="line">            |              |                |                |</span><br><span class="line">          GND             GND              GND              GND</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>主设备</strong>：发起通信（生成起始 &#x2F; 停止条件）、控制时钟频率、决定通信对象（从设备地址）</p>
</li>
<li><p><strong>从设备</strong>：拥有唯一地址，仅在被主设备寻址后才响应数据传输</p>
</li>
<li><p><strong>多主冲突处理</strong>：当两个主设备同时发起通信时，通过 “时钟同步” 和 “数据仲裁” 避免冲突（检测到总线电平与自身输出不一致时，主动放弃主设备身份）</p>
</li>
</ul>
<h2 id="三、IIC-协议通信时序（核心）"><a href="#三、IIC-协议通信时序（核心）" class="headerlink" title="三、IIC 协议通信时序（核心）"></a>三、IIC 协议通信时序（核心）</h2><p>IIC 的通信过程由<strong>起始条件</strong>、<strong>地址传输</strong>、<strong>数据传输</strong>、<strong>应答信号</strong>、<strong>停止条件</strong>5 个关键环节组成，时序的正确性直接决定通信是否成功。</p>
<h3 id="（一）关键时序定义"><a href="#（一）关键时序定义" class="headerlink" title="（一）关键时序定义"></a>（一）关键时序定义</h3><h4 id="1-起始条件（S）：通信开始标志"><a href="#1-起始条件（S）：通信开始标志" class="headerlink" title="1. 起始条件（S）：通信开始标志"></a>1. 起始条件（S）：通信开始标志</h4><ul>
<li><p>时序要求：SCL 保持高电平时，SDA 从高电平跳转为低电平（下降沿触发）</p>
</li>
<li><p>作用：告知总线上所有从设备 “即将开始通信”，从设备开始监听 SDA 上的地址信息</p>
</li>
<li><p>时序示意图（文字描述）：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCL: 1 1 1 1 1 1 1 1  # 高电平期间</span><br><span class="line">SDA: 1 1 1 0 0 0 0 0  # 下降沿触发起始条件</span><br><span class="line">         ↑</span><br><span class="line">       起始点</span><br></pre></td></tr></table></figure>

<h4 id="2-停止条件（P）：通信结束标志"><a href="#2-停止条件（P）：通信结束标志" class="headerlink" title="2. 停止条件（P）：通信结束标志"></a>2. 停止条件（P）：通信结束标志</h4><ul>
<li><p>时序要求：SCL 保持高电平时，SDA 从低电平跳转为高电平（上升沿触发）</p>
</li>
<li><p>作用：告知总线上所有从设备 “通信结束”，从设备恢复待机状态</p>
</li>
<li><p>时序示意图（文字描述）：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCL: 1 1 1 1 1 1 1 1  # 高电平期间</span><br><span class="line">SDA: 0 0 0 0 1 1 1 1  # 上升沿触发停止条件</span><br><span class="line">         ↑</span><br><span class="line">       停止点</span><br></pre></td></tr></table></figure>

<h4 id="3-数据传输时序"><a href="#3-数据传输时序" class="headerlink" title="3. 数据传输时序"></a>3. 数据传输时序</h4><ul>
<li><p>时序要求：<strong>SCL 低电平时 SDA 可变化</strong>（准备数据），<strong>SCL 高电平时 SDA 必须稳定</strong>（从设备采样数据）</p>
</li>
<li><p>数据格式：每次传输 1 字节（8 位），按 “高位（MSB）在前，低位（LSB）在后” 的顺序传输</p>
</li>
<li><p>时序示意图（文字描述，以传输字节 0x53 为例）：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCL: 0 1 0 1 0 1 0 1 0  # 高低电平交替，共9个时钟（8位数据+1位应答）</span><br><span class="line">SDA: 0 0 1 1 0 0 1 1 A  # 0x53的二进制为01010011，A为应答位</span><br><span class="line">      （bit7）     （bit0）</span><br></pre></td></tr></table></figure>

<h4 id="4-应答信号（ACK-NACK）：数据接收确认"><a href="#4-应答信号（ACK-NACK）：数据接收确认" class="headerlink" title="4. 应答信号（ACK&#x2F;NACK）：数据接收确认"></a>4. 应答信号（ACK&#x2F;NACK）：数据接收确认</h4><ul>
<li><p>时序位置：每传输 1 字节（8 位）后，紧跟 1 位应答位（第 9 个 SCL 时钟）</p>
</li>
<li><p>应答规则：</p>
</li>
<li><ul>
<li><strong>ACK（应答）</strong>：接收方（主设备 &#x2F; 从设备）在第 9 个 SCL 高电平时，将 SDA 拉为低电平，表示 “已成功接收数据”</li>
</ul>
</li>
<li><ul>
<li><strong>NACK（非应答）</strong>：接收方在第 9 个 SCL 高电平时，释放 SDA（由上拉电阻拉为高电平），表示 “未接收数据” 或 “数据接收完成”</li>
</ul>
</li>
<li><p>常见场景：</p>
</li>
<li><ul>
<li>主设备发送地址 &#x2F; 数据后，由从设备发送 ACK</li>
</ul>
</li>
<li><ul>
<li>主设备接收从设备数据后，由主设备发送 ACK（需继续接收）或 NACK（接收结束）</li>
</ul>
</li>
</ul>
<h3 id="（二）完整通信流程示例（主设备读从设备数据）"><a href="#（二）完整通信流程示例（主设备读从设备数据）" class="headerlink" title="（二）完整通信流程示例（主设备读从设备数据）"></a>（二）完整通信流程示例（主设备读从设备数据）</h3><p>以 “STM32（主设备）读取 SHT30 温湿度传感器（从设备）” 为例，完整时序步骤如下：</p>
<ol>
<li><p>主设备发送<strong>起始条件（S）</strong>，总线进入忙状态</p>
</li>
<li><p>主设备发送<strong>从设备写地址（8 位）</strong>：SHT30 的 7 位地址为 0x44，写操作时第 8 位为 0 → 完整地址 0x88</p>
</li>
<li><p>从设备接收地址后，发送<strong>ACK</strong>（SDA 拉低），表示 “地址匹配，准备接收指令”</p>
</li>
<li><p>主设备发送<strong>寄存器地址（8 位）</strong>：如 SHT30 的 “单次测量指令” 0x2C06（分两字节发送：0x2C、0x06），每字节后从设备回复 ACK</p>
</li>
<li><p>主设备发送<strong>重复起始条件（Sr）</strong>：无需发送停止条件，直接发起新的起始（用于切换 “写” 到 “读” 操作）</p>
</li>
<li><p>主设备发送<strong>从设备读地址（8 位）</strong>：SHT30 的 7 位地址 0x44，读操作时第 8 位为 1 → 完整地址 0x89</p>
</li>
<li><p>从设备接收读地址后，发送<strong>ACK</strong>，表示 “准备发送数据”</p>
</li>
<li><p>从设备发送<strong>温湿度数据（共 6 字节）</strong>：每字节后主设备回复 ACK（前 5 字节），第 6 字节后主设备回复 NACK（数据接收完成）</p>
</li>
<li><p>主设备发送<strong>停止条件（P）</strong>，总线恢复空闲状态</p>
</li>
</ol>
<h2 id="四、IIC-协议地址机制"><a href="#四、IIC-协议地址机制" class="headerlink" title="四、IIC 协议地址机制"></a>四、IIC 协议地址机制</h2><p>IIC 通过 “从设备地址” 区分总线上的不同设备，地址长度分为<strong>7 位地址</strong>（最常用）和<strong>10 位地址</strong>（用于设备数量多的场景），其中 7 位地址占比超过 90%。</p>
<h3 id="（一）7-位地址格式"><a href="#（一）7-位地址格式" class="headerlink" title="（一）7 位地址格式"></a>（一）7 位地址格式</h3><p>7 位地址是 IIC 的标准地址格式，共包含 8 位（7 位地址 + 1 位读写位），结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit7 bit6 bit5 bit4 bit3 bit2 bit1 | bit0</span><br><span class="line">  7位从设备地址                    | 读写位（R/W）</span><br><span class="line">                                   | 0=写操作，1=读操作</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>固定地址</strong>：部分从设备的 7 位地址固定（如 SHT30 为 0x44&#x2F;0x45，AT24C02 为 0xA0~0xA7）</p>
</li>
<li><p><strong>可编程地址</strong>：部分从设备通过引脚（如 A0&#x2F;A1&#x2F;A2）配置地址的低 3 位，实现多设备共存（如 AT24C02 的 A0&#x2F;A1&#x2F;A2 引脚接 GND 或 VCC，可生成 8 个不同地址）</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li><p>AT24C02（EEPROM）的 A0&#x3D;A1&#x3D;A2&#x3D;GND → 7 位地址为 0x50 → 写地址 0xA0（0x50&lt;&lt;1 | 0），读地址 0xA1（0x50&lt;&lt;1 | 1）</p>
</li>
<li><p>SHT30（温湿度传感器）的 ADDR 引脚接 GND → 7 位地址 0x44 → 写地址 0x88，读地址 0x89</p>
</li>
</ul>
<h3 id="（二）广播地址"><a href="#（二）广播地址" class="headerlink" title="（二）广播地址"></a>（二）广播地址</h3><p>IIC 协议定义了<strong>0x00（7 位地址）</strong> 为广播地址，主设备发送该地址时，总线上所有从设备都会响应（仅支持写操作），常用于 “批量复位所有从设备” 等场景。</p>
<h2 id="五、嵌入式应用示例（STM32-HAL-库）"><a href="#五、嵌入式应用示例（STM32-HAL-库）" class="headerlink" title="五、嵌入式应用示例（STM32 HAL 库）"></a>五、嵌入式应用示例（STM32 HAL 库）</h2><p>以 “STM32F103 通过 IIC 读取 AT24C02（EEPROM）数据” 为例，展示 IIC 协议的实际代码实现（基于 STM32 HAL 库）。</p>
<h3 id="（一）硬件连接"><a href="#（一）硬件连接" class="headerlink" title="（一）硬件连接"></a>（一）硬件连接</h3><table>
<thead>
<tr>
<th>STM32 引脚</th>
<th>功能</th>
<th>AT24C02 引脚</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>PB6</td>
<td>I2C1_SCL</td>
<td>SCL</td>
<td>时钟线</td>
</tr>
<tr>
<td>PB7</td>
<td>I2C1_SDA</td>
<td>SDA</td>
<td>数据线</td>
</tr>
<tr>
<td>3.3V</td>
<td>电源</td>
<td>VCC</td>
<td>电源</td>
</tr>
<tr>
<td>GND</td>
<td>地</td>
<td>GND</td>
<td>地</td>
</tr>
<tr>
<td>GND</td>
<td>地址配置</td>
<td>A0&#x2F;A1&#x2F;A2</td>
<td>地址引脚</td>
</tr>
</tbody></table>
<h3 id="（二）代码实现"><a href="#（二）代码实现" class="headerlink" title="（二）代码实现"></a>（二）代码实现</h3><h4 id="1-IIC-外设初始化（HAL-库）"><a href="#1-IIC-外设初始化（HAL-库）" class="headerlink" title="1. IIC 外设初始化（HAL 库）"></a>1. IIC 外设初始化（HAL 库）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f1xx_hal.h&quot;</span><br><span class="line"></span><br><span class="line">I2C_HandleTypeDef hi2c1;  // IIC句柄</span><br><span class="line"></span><br><span class="line">// IIC初始化函数（标准模式100kHz）</span><br><span class="line">void MX_I2C1_Init(void) &#123;</span><br><span class="line">  hi2c1.Instance = I2C1;</span><br><span class="line">  hi2c1.Init.ClockSpeed = 100000;  // 时钟频率100kHz（标准模式）</span><br><span class="line">  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;  // 占空比1:2</span><br><span class="line">  hi2c1.Init.OwnAddress1 = 0;  // 主设备无需设置自身地址</span><br><span class="line">  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;  // 7位地址模式</span><br><span class="line">  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;</span><br><span class="line">  hi2c1.Init.OwnAddress2 = 0;</span><br><span class="line">  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;</span><br><span class="line">  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;</span><br><span class="line">  if (HAL_I2C_Init(&amp;hi2c1) != HAL_OK) &#123;</span><br><span class="line">    Error_Handler();  // 初始化失败处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// GPIO初始化（IIC引脚配置为开漏、上拉）</span><br><span class="line">void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle) &#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;;</span><br><span class="line">  if (i2cHandle-&gt;Instance == I2C1) &#123;</span><br><span class="line">    __HAL_RCC_GPIOB_CLK_ENABLE();  // 使能GPIOB时钟</span><br><span class="line">    __HAL_RCC_I2C1_CLK_ENABLE();   // 使能I2C1时钟</span><br><span class="line"></span><br><span class="line">    // PB6（SCL）配置</span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_6;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;  // 复用开漏输出</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_PULLUP;      // 上拉</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    // PB7（SDA）配置</span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_7;</span><br><span class="line">    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-AT24C02-读写函数"><a href="#2-AT24C02-读写函数" class="headerlink" title="2. AT24C02 读写函数"></a>2. AT24C02 读写函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define AT24C02_ADDR_WRITE 0xA0  // AT24C02写地址</span><br><span class="line">#define AT24C02_ADDR_READ  0xA1  // AT24C02读地址</span><br><span class="line"></span><br><span class="line">// 向AT24C02指定地址写入1字节数据</span><br><span class="line">HAL_StatusTypeDef AT24C02_WriteByte(uint8_t addr, uint8_t data) &#123;</span><br><span class="line">  return HAL_I2C_Mem_Write(&amp;hi2c1,          // IIC句柄</span><br><span class="line">                           AT24C02_ADDR_WRITE,  // 从设备写地址</span><br><span class="line">                           addr,             // EEPROM内部地址</span><br><span class="line">                           I2C_MEMADD_SIZE_8BIT,  // 内部地址长度（8位）</span><br><span class="line">                           &amp;data,            // 待写数据</span><br><span class="line">                           1,                // 数据长度</span><br><span class="line">                           100);             // 超时时间（ms）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从AT24C02指定地址读取1字节数据</span><br><span class="line">HAL_StatusTypeDef AT24C02_ReadByte(uint8_t addr, uint8_t* data) &#123;</span><br><span class="line">  return HAL_I2C_Mem_Read(&amp;hi2c1,           // IIC句柄</span><br><span class="line">                          AT24C02_ADDR_READ,   // 从设备读地址</span><br><span class="line">                          addr,             // EEPROM内部地址</span><br><span class="line">                          I2C_MEMADD_SIZE_8BIT,  // 内部地址长度（8位）</span><br><span class="line">                          data,             // 接收数据缓存</span><br><span class="line">                          1,                // 数据长度</span><br><span class="line">                          100);             // 超时时间（ms）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-主函数调用示例"><a href="#3-主函数调用示例" class="headerlink" title="3. 主函数调用示例"></a>3. 主函数调用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">  HAL_Init();  // HAL库初始化</span><br><span class="line">  SystemClock_Config();  // 系统时钟配置</span><br><span class="line">  MX_I2C1_Init();        // IIC初始化</span><br><span class="line"></span><br><span class="line">  uint8_t write_data = 0x5A;  // 待写入数据</span><br><span class="line">  uint8_t read_data = 0;       // 读取到的数据</span><br><span class="line"></span><br><span class="line">  // 1. 向AT24C02地址0x00写入0x5A</span><br><span class="line">  if (AT24C02_WriteByte(0x00, write_data) == HAL_OK) &#123;</span><br><span class="line">    HAL_Delay(5);  // EEPROM写入需要时间，延迟等待</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 从AT24C02地址0x00读取数据</span><br><span class="line">  if (AT24C02_ReadByte(0x00, &amp;read_data) == HAL_OK) &#123;</span><br><span class="line">    // 读取成功，read_data应为0x5A</span><br><span class="line">    if (read_data == write_data) &#123;</span><br><span class="line">      // 通信成功，可添加LED指示或串口打印</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line">    // 主循环</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、IIC-常见问题与调试技巧"><a href="#六、IIC-常见问题与调试技巧" class="headerlink" title="六、IIC 常见问题与调试技巧"></a>六、IIC 常见问题与调试技巧</h2><h3 id="（一）常见问题及解决方案"><a href="#（一）常见问题及解决方案" class="headerlink" title="（一）常见问题及解决方案"></a>（一）常见问题及解决方案</h3><table>
<thead>
<tr>
<th>问题现象</th>
<th>可能原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>通信无响应（HAL 返回 ERROR）</td>
<td>1. 上拉电阻缺失 &#x2F; 阻值错误2. 从设备地址错误3. 引脚连接错误</td>
<td>1. 检查 SDA&#x2F;SCL 是否接 4.7kΩ~10kΩ 上拉电阻2. 确认从设备地址及读写位3. 核对引脚（SDA&#x2F;SCL 勿接反）</td>
</tr>
<tr>
<td>数据读取错误</td>
<td>1. 时序不匹配（时钟频率过高）2. 未等待 EEPROM 写入完成3. 电平不兼容（3.3V&#x2F;5V 混接）</td>
<td>1. 降低 IIC 时钟频率（从 100kHz 开始测试）2. EEPROM 写入后延迟 5~10ms3. 使用电平转换芯片（如 TXS0108）</td>
</tr>
<tr>
<td>多设备共存时冲突</td>
<td>1. 从设备地址重复2. 多主设备同时发起通信</td>
<td>1. 通过 A0&#x2F;A1&#x2F;A2 引脚配置不同地址2. 避免多主设备同时操作总线，增加冲突检测逻辑</td>
</tr>
</tbody></table>
<h3 id="（二）调试工具推荐"><a href="#（二）调试工具推荐" class="headerlink" title="（二）调试工具推荐"></a>（二）调试工具推荐</h3><ol>
<li><p><strong>逻辑分析仪</strong>：抓取 SDA&#x2F;SCL 的实际波形，对比标准时序（如起始 &#x2F; 停止条件、数据采样时机），快速定位时序错误（推荐工具：DSLogic、Saleae）</p>
</li>
<li><p><strong>示波器</strong>：测量 SDA&#x2F;SCL 的电平是否正常（高电平是否≥2.7V，低电平是否≤0.8V），检查上拉电阻是否生效</p>
</li>
<li><p><strong>串口打印</strong>：在代码中添加调试信息（如 “发送起始条件”“接收 ACK”），通过串口助手观察通信流程，定位哪一步出错</p>
</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>IIC 协议凭借 “双线制、多主从、低功耗” 的优势，成为嵌入式系统中芯片间通信的主流选择。掌握其核心时序（起始 &#x2F; 停止条件、应答机制）和地址规则，是实现稳定通信的关键。本文通过 STM32 HAL 库示例，展示了 IIC 在实际项目中的应用，同时提供了常见问题的调试思路，可满足大多数中小型嵌入式项目的需求。</p>
<p>进阶学习方向：</p>
<ol>
<li><p>多主设备通信（冲突检测与仲裁）</p>
</li>
<li><p>IIC 高速模式（Fast-mode Plus，1MHz）与超高速模式（HS-mode，3.4MHz）</p>
</li>
<li><p>IIC 总线扩展（通过 I2C Hub 芯片增加挂载设备数量）</p>
</li>
<li><p>软件模拟 IIC（无需依赖硬件 IIC 外设，灵活性更高）</p>
</li>
</ol>
<p>合理运用 IIC 协议，可大幅简化嵌入式系统的硬件设计，提升开发效率，是嵌入式工程师必备的通信协议技能之一。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>通信协议</tag>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统常用命令大全</title>
    <url>/2025/09/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux系统的强大之处在于其丰富的命令行工具，无论是日常操作、系统管理还是开发调试，命令行都能提供高效的解决方案。本文精选了Linux系统中最常用的命令，从基础的文件操作到复杂的系统监控，每个命令都配有实际场景的使用例子，帮助你快速掌握Linux命令行技能。</p>
<h3 id="一、文件与目录操作命令"><a href="#一、文件与目录操作命令" class="headerlink" title="一、文件与目录操作命令"></a>一、文件与目录操作命令</h3><h4 id="1-ls：列出目录内容"><a href="#1-ls：列出目录内容" class="headerlink" title="1. ls：列出目录内容"></a>1. <code>ls</code>：列出目录内容</h4><p><strong>功能</strong>：查看当前目录或指定目录下的文件和子目录。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-l</code>：以长格式显示（权限、所有者、大小、修改时间等）</li>
<li><code>-a</code>：显示所有文件（包括隐藏文件，以<code>.</code>开头的文件）</li>
<li><code>-h</code>：以人类可读的单位显示文件大小（如K、M、G）</li>
<li><code>-t</code>：按修改时间排序（最新的在前）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录所有文件（包括隐藏文件）的详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -la</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出/var/log目录下的文件，按大小排序（从大到小）</span></span><br><span class="line"><span class="built_in">ls</span> -lhS /var/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只列出当前目录下的子目录</span></span><br><span class="line"><span class="built_in">ls</span> -d */</span><br></pre></td></tr></table></figure>

<h4 id="2-cd：切换目录"><a href="#2-cd：切换目录" class="headerlink" title="2. cd：切换目录"></a>2. <code>cd</code>：切换目录</h4><p><strong>功能</strong>：切换当前工作目录。</p>
<p><strong>特殊路径</strong>：</p>
<ul>
<li><code>~</code>：当前用户的家目录</li>
<li><code>.</code>：当前目录</li>
<li><code>..</code>：上一级目录</li>
<li><code>-</code>：上一次所在的目录</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到用户家目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换回上一次所在的目录</span></span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<h4 id="3-pwd：显示当前目录路径"><a href="#3-pwd：显示当前目录路径" class="headerlink" title="3. pwd：显示当前目录路径"></a>3. <code>pwd</code>：显示当前目录路径</h4><p><strong>功能</strong>：打印当前工作目录的绝对路径。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前所在目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 输出：/home/user/documents</span></span><br></pre></td></tr></table></figure>

<h4 id="4-mkdir：创建目录"><a href="#4-mkdir：创建目录" class="headerlink" title="4. mkdir：创建目录"></a>4. <code>mkdir</code>：创建目录</h4><p><strong>功能</strong>：创建新的目录。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-p</code>：递归创建目录（若父目录不存在则自动创建）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录创建单个目录</span></span><br><span class="line"><span class="built_in">mkdir</span> projects</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建多级目录（如创建a/b/c，即使a和b不存在）</span></span><br><span class="line"><span class="built_in">mkdir</span> -p a/b/c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个目录</span></span><br><span class="line"><span class="built_in">mkdir</span> docs images downloads</span><br></pre></td></tr></table></figure>

<h4 id="5-rm：删除文件或目录"><a href="#5-rm：删除文件或目录" class="headerlink" title="5. rm：删除文件或目录"></a>5. <code>rm</code>：删除文件或目录</h4><p><strong>功能</strong>：删除指定的文件或目录（危险操作，谨慎使用）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-f</code>：强制删除（不提示确认）</li>
<li><code>-r</code>：递归删除目录及其内容</li>
<li><code>-i</code>：删除前提示确认</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除单个文件（会提示确认）</span></span><br><span class="line"><span class="built_in">rm</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除多个文件</span></span><br><span class="line"><span class="built_in">rm</span> -f temp1.txt temp2.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除目录及其所有内容（危险！）</span></span><br><span class="line"><span class="built_in">rm</span> -rf old_projects/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录前逐一确认</span></span><br><span class="line"><span class="built_in">rm</span> -ri data/</span><br></pre></td></tr></table></figure>

<h4 id="6-cp：复制文件或目录"><a href="#6-cp：复制文件或目录" class="headerlink" title="6. cp：复制文件或目录"></a>6. <code>cp</code>：复制文件或目录</h4><p><strong>功能</strong>：复制文件或目录到指定位置。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-i</code>：若目标文件存在，提示是否覆盖</li>
<li><code>-r</code>：递归复制目录及其内容</li>
<li><code>-v</code>：显示复制过程</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制文件到指定目录</span></span><br><span class="line"><span class="built_in">cp</span> report.pdf ~/documents/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件并改名</span></span><br><span class="line"><span class="built_in">cp</span> image.jpg backup_image.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归复制目录到目标位置</span></span><br><span class="line"><span class="built_in">cp</span> -r projects/ /backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制多个文件到目录</span></span><br><span class="line"><span class="built_in">cp</span> *.txt ~/text_files/</span><br></pre></td></tr></table></figure>

<h4 id="7-mv：移动或重命名文件-目录"><a href="#7-mv：移动或重命名文件-目录" class="headerlink" title="7. mv：移动或重命名文件&#x2F;目录"></a>7. <code>mv</code>：移动或重命名文件&#x2F;目录</h4><p><strong>功能</strong>：移动文件&#x2F;目录到新位置，或重命名文件&#x2F;目录。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> oldname.txt newname.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件到目录</span></span><br><span class="line"><span class="built_in">mv</span> document.pdf ~/archive/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动多个文件到目录</span></span><br><span class="line"><span class="built_in">mv</span> *.<span class="built_in">log</span> /var/log/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名目录</span></span><br><span class="line"><span class="built_in">mv</span> photos/ vacation_photos/</span><br></pre></td></tr></table></figure>

<h4 id="8-find：查找文件或目录"><a href="#8-find：查找文件或目录" class="headerlink" title="8. find：查找文件或目录"></a>8. <code>find</code>：查找文件或目录</h4><p><strong>功能</strong>：在指定目录下按名称、类型、大小等条件查找文件。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-name</code>：按文件名查找（支持通配符<code>*</code>和<code>?</code>）</li>
<li><code>-type</code>：按类型查找（<code>f</code>为文件，<code>d</code>为目录）</li>
<li><code>-size</code>：按大小查找（<code>+10M</code>表示大于10M，<code>-1k</code>表示小于1k）</li>
<li><code>-mtime</code>：按修改时间查找（<code>-7</code>表示7天内修改的）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录及子目录查找所有.txt文件</span></span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/var目录查找最近3天内修改的.log文件</span></span><br><span class="line">find /var -name <span class="string">&quot;*.log&quot;</span> -mtime -3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找系统中大于100M的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -size +100M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找/home目录下所有名为docs的目录</span></span><br><span class="line">find /home -<span class="built_in">type</span> d -name <span class="string">&quot;docs&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-grep：文本搜索工具"><a href="#9-grep：文本搜索工具" class="headerlink" title="9. grep：文本搜索工具"></a>9. <code>grep</code>：文本搜索工具</h4><p><strong>功能</strong>：在文件中搜索匹配指定模式的文本行。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-i</code>：忽略大小写</li>
<li><code>-n</code>：显示匹配行的行号</li>
<li><code>-r</code>：递归搜索目录下的所有文件</li>
<li><code>-v</code>：显示不匹配的行</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在file.txt中查找包含&quot;error&quot;的行（忽略大小写）</span></span><br><span class="line">grep -i <span class="string">&quot;error&quot;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录所有.php文件中查找&quot;function&quot;并显示行号</span></span><br><span class="line">grep -rn <span class="string">&quot;function&quot;</span> *.php</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找/var/log/syslog中不包含&quot;INFO&quot;的行</span></span><br><span class="line">grep -v <span class="string">&quot;INFO&quot;</span> /var/log/syslog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包含&quot;user&quot;且紧接着&quot;name&quot;的行（使用正则表达式）</span></span><br><span class="line">grep -E <span class="string">&quot;user.*name&quot;</span> data.txt</span><br></pre></td></tr></table></figure>


<h3 id="二、文件内容操作命令"><a href="#二、文件内容操作命令" class="headerlink" title="二、文件内容操作命令"></a>二、文件内容操作命令</h3><h4 id="1-cat：查看文件内容"><a href="#1-cat：查看文件内容" class="headerlink" title="1. cat：查看文件内容"></a>1. <code>cat</code>：查看文件内容</h4><p><strong>功能</strong>：连接并打印文件内容（适合查看小型文件）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-n</code>：显示行号</li>
<li><code>-b</code>：只对非空行显示行号</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="built_in">cat</span> readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件内容并带行号</span></span><br><span class="line"><span class="built_in">cat</span> -n config.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并多个文件内容到新文件</span></span><br><span class="line"><span class="built_in">cat</span> part1.txt part2.txt &gt; combined.txt</span><br></pre></td></tr></table></figure>

<h4 id="2-less-more：分页查看文件内容"><a href="#2-less-more：分页查看文件内容" class="headerlink" title="2. less&#x2F;more：分页查看文件内容"></a>2. <code>less</code>&#x2F;<code>more</code>：分页查看文件内容</h4><p><strong>功能</strong>：分页显示大型文件内容（<code>less</code>功能更强大，支持上下滚动和搜索）。</p>
<p><strong>常用操作（<code>less</code>中）</strong>：</p>
<ul>
<li><code>空格键</code>：翻页</li>
<li><code>b</code>：向上翻页</li>
<li><code>/关键词</code>：向下搜索关键词</li>
<li><code>q</code>：退出</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分页查看大型日志文件</span></span><br><span class="line">less /var/log/syslog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在查看过程中搜索&quot;error&quot;</span></span><br><span class="line"><span class="comment"># 输入 /error 然后按回车，按n查看下一个匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="3-head-tail：查看文件开头-结尾内容"><a href="#3-head-tail：查看文件开头-结尾内容" class="headerlink" title="3. head&#x2F;tail：查看文件开头&#x2F;结尾内容"></a>3. <code>head</code>&#x2F;<code>tail</code>：查看文件开头&#x2F;结尾内容</h4><p><strong>功能</strong>：</p>
<ul>
<li><code>head</code>：显示文件开头的几行（默认10行）</li>
<li><code>tail</code>：显示文件结尾的几行（默认10行）</li>
</ul>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-n</code>：指定显示的行数</li>
<li><code>-f</code>：实时跟踪文件新增内容（常用于监控日志）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件前5行</span></span><br><span class="line"><span class="built_in">head</span> -n 5 access.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件最后20行</span></span><br><span class="line"><span class="built_in">tail</span> -n 20 error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时监控日志文件新增内容（按Ctrl+C退出）</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/apache2/access.log</span><br></pre></td></tr></table></figure>

<h4 id="4-wc：统计文件内容"><a href="#4-wc：统计文件内容" class="headerlink" title="4. wc：统计文件内容"></a>4. <code>wc</code>：统计文件内容</h4><p><strong>功能</strong>：统计文件的行数、单词数、字节数。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-l</code>：只统计行数</li>
<li><code>-w</code>：只统计单词数</li>
<li><code>-c</code>：只统计字节数</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计文件的行数、单词数、字节数</span></span><br><span class="line"><span class="built_in">wc</span> document.txt</span><br><span class="line"><span class="comment"># 输出：  150   850  12500 document.txt（行数 单词数 字节数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计当前目录下所有.txt文件的总行数</span></span><br><span class="line"><span class="built_in">wc</span> -l *.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计一个目录下的文件总数（通过管道结合ls）</span></span><br><span class="line"><span class="built_in">ls</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>


<h3 id="三、系统管理命令"><a href="#三、系统管理命令" class="headerlink" title="三、系统管理命令"></a>三、系统管理命令</h3><h4 id="1-top-htop：查看系统进程和资源占用"><a href="#1-top-htop：查看系统进程和资源占用" class="headerlink" title="1. top&#x2F;htop：查看系统进程和资源占用"></a>1. <code>top</code>&#x2F;<code>htop</code>：查看系统进程和资源占用</h4><p><strong>功能</strong>：实时显示系统进程的CPU、内存占用情况（<code>htop</code>是<code>top</code>的增强版，界面更友好）。</p>
<p><strong>常用操作（<code>top</code>中）</strong>：</p>
<ul>
<li><code>P</code>：按CPU使用率排序</li>
<li><code>M</code>：按内存使用率排序</li>
<li><code>k</code>：终止指定进程（输入进程ID）</li>
<li><code>q</code>：退出</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动top监控</span></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装并启动htop（部分系统需先安装）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install htop  <span class="comment"># Debian/Ubuntu</span></span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<h4 id="2-ps：查看进程状态"><a href="#2-ps：查看进程状态" class="headerlink" title="2. ps：查看进程状态"></a>2. <code>ps</code>：查看进程状态</h4><p><strong>功能</strong>：显示当前系统的进程快照（静态查看）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>aux</code>：显示所有用户的所有进程（最常用组合）</li>
<li><code>-ef</code>：显示进程的详细信息（包括父进程ID）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看系统中所有进程（常用）</span></span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找特定进程（如nginx）</span></span><br><span class="line">ps aux | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进程树（父子关系）</span></span><br><span class="line">ps -ef --forest</span><br></pre></td></tr></table></figure>

<h4 id="3-kill-pkill：终止进程"><a href="#3-kill-pkill：终止进程" class="headerlink" title="3. kill&#x2F;pkill：终止进程"></a>3. <code>kill</code>&#x2F;<code>pkill</code>：终止进程</h4><p><strong>功能</strong>：向进程发送信号（默认是终止信号）。</p>
<p><strong>常用信号</strong>：</p>
<ul>
<li><code>15</code>（SIGTERM）：正常终止（默认）</li>
<li><code>9</code>（SIGKILL）：强制终止（无法被进程捕获）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过进程ID终止进程（先通过ps找到PID）</span></span><br><span class="line"><span class="built_in">kill</span> 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制终止进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过进程名终止进程（更方便）</span></span><br><span class="line">pkill nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制终止所有包含&quot;python&quot;的进程</span></span><br><span class="line">pkill -9 python</span><br></pre></td></tr></table></figure>

<h4 id="4-df-du：查看磁盘空间"><a href="#4-df-du：查看磁盘空间" class="headerlink" title="4. df&#x2F;du：查看磁盘空间"></a>4. <code>df</code>&#x2F;<code>du</code>：查看磁盘空间</h4><p><strong>功能</strong>：</p>
<ul>
<li><code>df</code>：显示磁盘分区的使用情况</li>
<li><code>du</code>：显示文件或目录的磁盘占用情况</li>
</ul>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-h</code>：以人类可读的单位显示（K、M、G）</li>
<li><code>-s</code>：<code>du</code>专用，显示总大小（不显示子目录详情）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有磁盘分区的使用情况</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录的总大小</span></span><br><span class="line"><span class="built_in">du</span> -sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下各子目录的大小（按大小排序）</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1 | <span class="built_in">sort</span> -hr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/var目录的磁盘占用</span></span><br><span class="line"><span class="built_in">du</span> -sh /var</span><br></pre></td></tr></table></figure>

<h4 id="5-free：查看内存使用情况"><a href="#5-free：查看内存使用情况" class="headerlink" title="5. free：查看内存使用情况"></a>5. <code>free</code>：查看内存使用情况</h4><p><strong>功能</strong>：显示系统内存（物理内存和交换分区）的使用情况。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-h</code>：以人类可读的单位显示</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内存使用情况</span></span><br><span class="line">free -h</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment">#              total        used        free      shared  buff/cache   available</span></span><br><span class="line"><span class="comment"># Mem:           15G        8.2G        2.1G        512M        5.2G        7.0G</span></span><br><span class="line"><span class="comment"># Swap:          2.0G        512M        1.5G</span></span><br></pre></td></tr></table></figure>


<h3 id="四、用户与权限管理命令"><a href="#四、用户与权限管理命令" class="headerlink" title="四、用户与权限管理命令"></a>四、用户与权限管理命令</h3><h4 id="1-sudo：以超级用户权限执行命令"><a href="#1-sudo：以超级用户权限执行命令" class="headerlink" title="1. sudo：以超级用户权限执行命令"></a>1. <code>sudo</code>：以超级用户权限执行命令</h4><p><strong>功能</strong>：允许普通用户以root权限执行指定命令（需在<code>sudoers</code>文件中配置权限）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以root权限安装软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑系统配置文件（通常需要root权限）</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到root用户（需输入当前用户密码）</span></span><br><span class="line"><span class="built_in">sudo</span> su -</span><br></pre></td></tr></table></figure>

<h4 id="2-chmod：修改文件权限"><a href="#2-chmod：修改文件权限" class="headerlink" title="2. chmod：修改文件权限"></a>2. <code>chmod</code>：修改文件权限</h4><p><strong>功能</strong>：改变文件或目录的访问权限（读<code>r</code>、写<code>w</code>、执行<code>x</code>）。</p>
<p><strong>权限表示方式</strong>：</p>
<ul>
<li>符号表示：<code>u</code>（所有者）、<code>g</code>（所属组）、<code>o</code>（其他用户）；<code>+</code>（添加）、<code>-</code>（移除）、<code>=</code>（设置）</li>
<li>数字表示：<code>r=4</code>、<code>w=2</code>、<code>x=1</code>，三者之和表示权限（如<code>755</code>表示<code>rwxr-xr-x</code>）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给文件所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> u+x script.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除其他用户的写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o-w data.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件权限为所有者可读可写可执行，同组和其他用户可读可执行（755）</span></span><br><span class="line"><span class="built_in">chmod</span> 755 program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归设置目录及其内容的权限（所有者可读可写，同组和其他用户只读）</span></span><br><span class="line"><span class="built_in">chmod</span> -R 644 documents/</span><br></pre></td></tr></table></figure>

<h4 id="3-chown：修改文件所有者"><a href="#3-chown：修改文件所有者" class="headerlink" title="3. chown：修改文件所有者"></a>3. <code>chown</code>：修改文件所有者</h4><p><strong>功能</strong>：改变文件或目录的所有者和所属组。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将file.txt的所有者改为user1</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> user1 file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录web/的所有者改为user1，所属组改为group1</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> user1:group1 web/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改目录及其内容的所有者和所属组</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R www-data:www-data /var/www/html/</span><br></pre></td></tr></table></figure>


<h3 id="五、网络相关命令"><a href="#五、网络相关命令" class="headerlink" title="五、网络相关命令"></a>五、网络相关命令</h3><h4 id="1-ping：测试网络连接"><a href="#1-ping：测试网络连接" class="headerlink" title="1. ping：测试网络连接"></a>1. <code>ping</code>：测试网络连接</h4><p><strong>功能</strong>：向目标主机发送ICMP请求，检查网络连通性。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-c</code>：指定发送包的数量</li>
<li><code>-i</code>：指定发送间隔（秒）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试与百度的连接（发送4个包）</span></span><br><span class="line">ping -c 4 baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试与局域网内主机的连接</span></span><br><span class="line">ping 192.168.1.1</span><br></pre></td></tr></table></figure>

<h4 id="2-ifconfig-ip：查看网络接口信息"><a href="#2-ifconfig-ip：查看网络接口信息" class="headerlink" title="2. ifconfig&#x2F;ip：查看网络接口信息"></a>2. <code>ifconfig</code>&#x2F;<code>ip</code>：查看网络接口信息</h4><p><strong>功能</strong>：显示或配置网络接口（<code>ip</code>是新一代工具，逐步替代<code>ifconfig</code>）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有网络接口信息（旧方式）</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有网络接口信息（新方式，推荐）</span></span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用或禁用网络接口（需root权限）</span></span><br><span class="line"><span class="built_in">sudo</span> ifconfig eth0 up   <span class="comment"># 启用eth0</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down  <span class="comment"># 禁用eth0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-netstat-ss：查看网络连接"><a href="#3-netstat-ss：查看网络连接" class="headerlink" title="3. netstat&#x2F;ss：查看网络连接"></a>3. <code>netstat</code>&#x2F;<code>ss</code>：查看网络连接</h4><p><strong>功能</strong>：显示网络连接、路由表、端口监听等信息（<code>ss</code>是<code>netstat</code>的替代工具，性能更好）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有监听端口（包括TCP和UDP）</span></span><br><span class="line">netstat -tuln</span><br><span class="line">ss -tuln</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已建立的TCP连接</span></span><br><span class="line">netstat -tuan</span><br><span class="line">ss -tuan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找占用80端口的进程</span></span><br><span class="line">netstat -tulnp | grep :80</span><br><span class="line">ss -tulnp | grep :80</span><br></pre></td></tr></table></figure>

<h4 id="4-curl-wget：下载文件或测试HTTP请求"><a href="#4-curl-wget：下载文件或测试HTTP请求" class="headerlink" title="4. curl&#x2F;wget：下载文件或测试HTTP请求"></a>4. <code>curl</code>&#x2F;<code>wget</code>：下载文件或测试HTTP请求</h4><p><strong>功能</strong>：</p>
<ul>
<li><code>curl</code>：发送HTTP请求，支持多种协议，适合测试API</li>
<li><code>wget</code>：下载文件，支持断点续传</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用curl获取网页内容</span></span><br><span class="line">curl https://example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用curl发送POST请求</span></span><br><span class="line">curl -X POST -d <span class="string">&quot;name=test&quot;</span> https://api.example.com/submit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用wget下载文件</span></span><br><span class="line">wget https://example.com/file.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断点续传下载</span></span><br><span class="line">wget -c https://example.com/large_file.iso</span><br></pre></td></tr></table></figure>


<h3 id="六、压缩与解压命令"><a href="#六、压缩与解压命令" class="headerlink" title="六、压缩与解压命令"></a>六、压缩与解压命令</h3><h4 id="1-tar：打包与压缩文件"><a href="#1-tar：打包与压缩文件" class="headerlink" title="1. tar：打包与压缩文件"></a>1. <code>tar</code>：打包与压缩文件</h4><p><strong>功能</strong>：打包多个文件为一个归档文件，可结合gzip或bzip2进行压缩。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-c</code>：创建归档</li>
<li><code>-x</code>：解压归档</li>
<li><code>-v</code>：显示过程</li>
<li><code>-f</code>：指定归档文件名</li>
<li><code>-z</code>：用gzip压缩&#x2F;解压（.tar.gz）</li>
<li><code>-j</code>：用bzip2压缩&#x2F;解压（.tar.bz2）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打包并压缩目录（gzip格式）</span></span><br><span class="line">tar -czvf documents.tar.gz documents/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar.gz文件</span></span><br><span class="line">tar -xzvf documents.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包并压缩目录（bzip2格式）</span></span><br><span class="line">tar -cjvf images.tar.bz2 images/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar.bz2文件到指定目录</span></span><br><span class="line">tar -xjvf images.tar.bz2 -C /tmp/</span><br></pre></td></tr></table></figure>

<h4 id="2-zip-unzip：ZIP格式压缩-解压"><a href="#2-zip-unzip：ZIP格式压缩-解压" class="headerlink" title="2. zip&#x2F;unzip：ZIP格式压缩&#x2F;解压"></a>2. <code>zip</code>&#x2F;<code>unzip</code>：ZIP格式压缩&#x2F;解压</h4><p><strong>功能</strong>：处理ZIP格式的压缩文件（Windows系统常用格式，跨平台兼容性强，适合与Windows设备交互或压缩单个文件）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-r</code>：递归压缩目录及其子目录内容（压缩目录时必须添加）</li>
<li><code>-q</code>：静默压缩&#x2F;解压（不显示过程信息）</li>
<li><code>-l</code>：查看压缩包内文件列表（不解压）</li>
<li><code>-d</code>：指定解压目标目录</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩多个文件和目录为ZIP包（递归处理目录docs/和photos/）</span></span><br><span class="line">zip -r backup_20250911.zip docs/ photos/ report.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静默压缩（不显示压缩过程）</span></span><br><span class="line">zip -qr silent_backup.zip important_data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ZIP包内的文件列表（大小、修改时间等）</span></span><br><span class="line">unzip -l backup_20250911.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压ZIP包到指定目录（如/tmp/backup/，目录不存在会自动创建）</span></span><br><span class="line">unzip backup_20250911.zip -d /tmp/backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只解压ZIP包中的某个特定文件（如report.txt）</span></span><br><span class="line">unzip backup_20250911.zip report.txt -d /tmp/</span><br></pre></td></tr></table></figure>


<h3 id="七、其他实用命令（嵌入式开发高频场景补充）"><a href="#七、其他实用命令（嵌入式开发高频场景补充）" class="headerlink" title="七、其他实用命令（嵌入式开发高频场景补充）"></a>七、其他实用命令（嵌入式开发高频场景补充）</h3><h4 id="1-history：查看与复用命令历史"><a href="#1-history：查看与复用命令历史" class="headerlink" title="1. history：查看与复用命令历史"></a>1. <code>history</code>：查看与复用命令历史</h4><p><strong>功能</strong>：显示当前用户执行过的命令历史，支持快速复用历史命令（嵌入式开发中频繁执行编译、烧录命令时尤其高效）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li>直接输入<code>history</code>：显示所有历史命令（默认保存1000条，可通过<code>HISTSIZE</code>环境变量修改）</li>
<li><code>history N</code>：显示最近N条命令</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看最近15条命令历史（快速找到之前的编译命令）</span></span><br><span class="line"><span class="built_in">history</span> 15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包含&quot;make&quot;的历史命令（嵌入式编译常用）</span></span><br><span class="line"><span class="built_in">history</span> | grep <span class="string">&quot;make&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复执行历史中第89条命令（假设第89条是交叉编译命令）</span></span><br><span class="line">!89</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复执行上一条命令（如刚执行完烧录，想再验证一次）</span></span><br><span class="line">!!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除所有命令历史（避免敏感命令泄露，如密码或设备IP）</span></span><br><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure>

<h4 id="2-man-help：获取命令帮助"><a href="#2-man-help：获取命令帮助" class="headerlink" title="2. man&#x2F;--help：获取命令帮助"></a>2. <code>man</code>&#x2F;<code>--help</code>：获取命令帮助</h4><p><strong>功能</strong>：<code>man</code>是Linux系统自带的“离线手册”，提供命令的详细参数说明和使用场景；<code>--help</code>则是快速查看命令核心参数（适合临时记忆模糊时快速查阅）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看tar命令的完整手册（包括参数详解、示例）</span></span><br><span class="line">man tar</span><br><span class="line"><span class="comment"># 手册内操作：按&quot;/关键词&quot;搜索（如搜索&quot;-z&quot;），按&quot;q&quot;退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看find命令的手册，并跳转到&quot;-name&quot;参数说明（通过章节定位）</span></span><br><span class="line">man find  <span class="comment"># 进入后输入 /-name 按回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速查看cp命令的核心参数（无需打开完整手册）</span></span><br><span class="line"><span class="built_in">cp</span> --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看交叉编译工具链的gcc版本及帮助（嵌入式开发常用）</span></span><br><span class="line">arm-linux-gnueabihf-gcc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h4 id="3-sudo进阶：权限与执行控制"><a href="#3-sudo进阶：权限与执行控制" class="headerlink" title="3. sudo进阶：权限与执行控制"></a>3. <code>sudo</code>进阶：权限与执行控制</h4><p><strong>功能</strong>：除了基础的“提权执行”，<code>sudo</code>还支持限制用户执行特定命令、保留环境变量等（嵌入式开发中多用户协作或避免误操作时常用）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以root权限执行命令，并保留当前用户的环境变量（如交叉编译的PATH）</span></span><br><span class="line"><span class="built_in">sudo</span> -E make -j4 zImage  <span class="comment"># -E 保留环境变量，避免因权限切换导致工具链路径丢失</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到root用户，但使用当前用户的Shell配置（如.bashrc中的环境变量）</span></span><br><span class="line"><span class="built_in">sudo</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前用户可执行的sudo命令列表（确认是否有权限执行烧录、修改系统配置）</span></span><br><span class="line"><span class="built_in">sudo</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时以其他用户（如开发板测试用户test）执行命令</span></span><br><span class="line"><span class="built_in">sudo</span> -u <span class="built_in">test</span> scp rootfs.img <span class="built_in">test</span>@192.168.1.100:/home/test/</span><br></pre></td></tr></table></figure>

<h4 id="4-scp：跨设备文件传输（嵌入式开发必备）"><a href="#4-scp：跨设备文件传输（嵌入式开发必备）" class="headerlink" title="4. scp：跨设备文件传输（嵌入式开发必备）"></a>4. <code>scp</code>：跨设备文件传输（嵌入式开发必备）</h4><p><strong>功能</strong>：基于SSH协议在本地主机与远程设备（如开发板、服务器）之间传输文件（嵌入式开发中常用于传输内核镜像、根文件系统）。</p>
<p><strong>常用参数</strong>：</p>
<ul>
<li><code>-r</code>：递归传输目录</li>
<li><code>-P</code>：指定远程设备的SSH端口（默认22，若开发板修改过端口需指定）</li>
<li><code>-q</code>：静默传输（不显示进度）</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地→开发板：传输编译好的内核镜像到开发板的/tmp目录（开发板IP：192.168.1.100）</span></span><br><span class="line">scp <span class="built_in">arch</span>/arm/boot/zImage root@192.168.1.100:/tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地→开发板：递归传输根文件系统目录到开发板</span></span><br><span class="line">scp -r ~/rootfs/ root@192.168.1.100:/mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板→本地：从开发板下载日志文件到本地的logs目录</span></span><br><span class="line">scp root@192.168.1.100:/var/log/messages ~/logs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定SSH端口传输（如开发板SSH端口改为2222）</span></span><br><span class="line">scp -P 2222 exynos4412-tiny4412.dtb root@192.168.1.100:/boot/</span><br></pre></td></tr></table></figure>

<h4 id="5-watch：实时监控命令输出"><a href="#5-watch：实时监控命令输出" class="headerlink" title="5. watch：实时监控命令输出"></a>5. <code>watch</code>：实时监控命令输出</h4><p><strong>功能</strong>：周期性执行指定命令并显示输出，适合实时监控文件变化、系统资源或编译进度（嵌入式开发中监控日志、磁盘占用时常用）。</p>
<p><strong>实例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每2秒查看一次当前目录下的文件大小变化（监控编译产物生成）</span></span><br><span class="line">watch -n 2 <span class="string">&quot;ls -lh arch/arm/boot/zImage&quot;</span>  <span class="comment"># -n 2 表示每2秒执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时监控开发板的内存使用情况（通过SSH远程执行free命令）</span></span><br><span class="line">watch -n 1 <span class="string">&quot;ssh root@192.168.1.100 free -h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控日志文件的新增内容（结合tail命令，比单独用tail -f更灵活）</span></span><br><span class="line">watch -d <span class="string">&quot;tail -n 10 /var/log/embedded_dev.log&quot;</span>  <span class="comment"># -d 高亮显示变化的内容</span></span><br></pre></td></tr></table></figure>


<h3 id="八、嵌入式开发场景命令组合示例"><a href="#八、嵌入式开发场景命令组合示例" class="headerlink" title="八、嵌入式开发场景命令组合示例"></a>八、嵌入式开发场景命令组合示例</h3><p>Linux命令的核心效率在于“组合使用”，通过管道（<code>|</code>）、重定向（<code>&gt;</code>&#x2F;<code>&gt;&gt;</code>）将多个命令串联，解决复杂场景需求（以下为嵌入式开发高频组合）。</p>
<h4 id="1-查找并删除过期编译产物"><a href="#1-查找并删除过期编译产物" class="headerlink" title="1. 查找并删除过期编译产物"></a>1. 查找并删除过期编译产物</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录及子目录下30天前的.o文件（编译中间产物）并删除</span></span><br><span class="line">find . -name <span class="string">&quot;*.o&quot;</span> -mtime +30 -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;</span><br><span class="line"><span class="comment"># 解释：-exec 执行后续命令，&#123;&#125; 代表找到的每个文件，\; 结束exec命令</span></span><br></pre></td></tr></table></figure>

<h4 id="2-统计内核源码目录下的C文件数量"><a href="#2-统计内核源码目录下的C文件数量" class="headerlink" title="2. 统计内核源码目录下的C文件数量"></a>2. 统计内核源码目录下的C文件数量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归查找所有.c文件，统计总行数（评估代码量）</span></span><br><span class="line">find linux-5.15.71/ -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">type</span> f | xargs <span class="built_in">cat</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 解释：xargs 将find的结果作为cat的输入，批量读取文件内容后用wc -l统计</span></span><br></pre></td></tr></table></figure>

<h4 id="3-筛选开发板串口日志中的错误信息"><a href="#3-筛选开发板串口日志中的错误信息" class="headerlink" title="3. 筛选开发板串口日志中的错误信息"></a>3. 筛选开发板串口日志中的错误信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从串口日志文件中筛选包含&quot;error&quot;或&quot;fail&quot;的行，并保存到error.log</span></span><br><span class="line"><span class="built_in">cat</span> serial_log.txt | grep -iE <span class="string">&quot;error|fail&quot;</span> &gt; error.log</span><br><span class="line"><span class="comment"># 解释：-i 忽略大小写，-E 支持正则表达式（| 表示“或”），&gt; 重定向输出到文件</span></span><br></pre></td></tr></table></figure>

<h4 id="4-批量重命名开发板设备树文件"><a href="#4-批量重命名开发板设备树文件" class="headerlink" title="4. 批量重命名开发板设备树文件"></a>4. 批量重命名开发板设备树文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将目录下所有.dts文件重命名为&quot;board_xxx.dts&quot;（如exynos4412.dts→board_exynos4412.dts）</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.dts; <span class="keyword">do</span> <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;board_<span class="variable">$&#123;file&#125;</span>&quot;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 解释：for循环遍历所有.dts文件，$&#123;file&#125; 保留原文件名，拼接前缀后重命名</span></span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文整理的命令覆盖了Linux系统基础操作与嵌入式开发高频场景，从文件管理、系统监控到跨设备交互，每个命令均结合嵌入式开发实际需求补充了实例。对于嵌入式工程师而言，命令行的核心价值在于“高效自动化”——通过熟练组合命令、编写简单脚本（如编译烧录一键脚本），可大幅减少重复操作，提升开发效率。</p>
<p>建议在实际开发中逐步积累“命令组合模板”（如日志筛选、文件传输），遇到陌生命令时优先通过<code>man</code>或<code>--help</code>查阅官方说明，避免因参数错误导致数据丢失或设备异常（尤其是<code>rm -rf</code>、<code>dd</code>等高危命令）。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>MCU 入门</title>
    <url>/2025/07/21/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>如果你拆开过智能手表、电饭煲或者玩具车，可能会在里面发现一个不起眼的小芯片 —— 别小看它，那很可能就是整个设备的 “神经中枢”，学名 MCU。今天咱们就来聊聊这个小个子里藏着的大能量，看看它是如何在各种电子设备里 “发号施令” 的。</p>
<h3 id="一、MCU-是啥？先给它起个-“接地气”-的外号"><a href="#一、MCU-是啥？先给它起个-“接地气”-的外号" class="headerlink" title="一、MCU 是啥？先给它起个 “接地气” 的外号"></a>一、MCU 是啥？先给它起个 “接地气” 的外号</h3><p>MCU 的全称是 Microcontroller Unit，翻译过来叫微控制器。但圈内人更爱叫它 “单片机”，因为它把 CPU、内存、IO 口、定时器这些 “过日子的家伙什” 全塞在一块小小的芯片里了，就像一个迷你版的计算机，五脏俱全却身材小巧。</p>
<p>打个比方，如果把 PC 机比作豪华别墅（功能强、占地大、耗电多），那 MCU 就是胶囊旅馆里的单间 —— 麻雀虽小，该有的都有，而且特别省地方、省电费，完美适配各种小型电子设备。</p>
<h3 id="二、MCU-凭啥这么-“受欢迎”？看看它的硬核优势"><a href="#二、MCU-凭啥这么-“受欢迎”？看看它的硬核优势" class="headerlink" title="二、MCU 凭啥这么 “受欢迎”？看看它的硬核优势"></a>二、MCU 凭啥这么 “受欢迎”？看看它的硬核优势</h3><p>MCU 能在嵌入式领域叱咤风云，可不是靠颜值（毕竟芯片长得都差不多），而是靠实实在在的本事：</p>
<ul>
<li><p><strong>体型迷你</strong>：指甲盖大小的芯片就能包办一堆活儿，特别适合塞在智能手环、蓝牙耳机这类 “寸土寸金” 的设备里。</p>
</li>
<li><p><strong>耗电感人</strong>：有些 MCU 待机时的功耗能低到微安级，一节纽扣电池就能让它跑上几年，这要是换个 PC 机，怕是得插着充电宝才能出门。</p>
</li>
<li><p><strong>价格亲民</strong>：普通 MCU 几块钱就能买到，批量采购甚至能论毛算，对于成本敏感的消费电子来说，简直是 “性价比之王”。</p>
</li>
<li><p><strong>上手不难</strong>：相比动辄上 G 主频的处理器，MCU 的性能虽然温柔，但配套的开发工具和资料特别多，新手也能快速入门。</p>
</li>
</ul>
<h3 id="三、常见的-MCU-“门派”，看看你认识几个？"><a href="#三、常见的-MCU-“门派”，看看你认识几个？" class="headerlink" title="三、常见的 MCU “门派”，看看你认识几个？"></a>三、常见的 MCU “门派”，看看你认识几个？</h3><p>就像手机有苹果、安卓阵营，MCU 也有不少 “门派”，各有各的看家本领：</p>
<ul>
<li><p><strong>STM32（意法半导体）</strong>：江湖人称 “单片机中的战斗机”，性能强、外设全，从入门级到高端型号一应俱全，是很多工程师的 “初恋”。缺点嘛，就是近几年价格有点 “飘”，偶尔还会缺货，让人又爱又恨。</p>
</li>
<li><p><strong>ATmega 系列（ATMEL，已被 Microchip 收购）</strong>：Arduino 开发板的常客，以简单易上手闻名，特别适合新手练手。就像学驾照时的教练车，虽然不豪华，但足够靠谱。</p>
</li>
<li><p><strong>PIC 系列（Microchip）</strong>：老牌 MCU，稳定性没话说，在工业控制领域很受欢迎，就像一位严谨的老工程师，做事一丝不苟。</p>
</li>
<li><p><strong>MSP430（德州仪器）</strong>：以超低功耗著称，在电池供电的便携设备里出镜率很高，堪称 “省电小能手”。</p>
</li>
</ul>
<h3 id="四、MCU-藏在哪些地方？其实你每天都在和它打交道"><a href="#四、MCU-藏在哪些地方？其实你每天都在和它打交道" class="headerlink" title="四、MCU 藏在哪些地方？其实你每天都在和它打交道"></a>四、MCU 藏在哪些地方？其实你每天都在和它打交道</h3><p>别以为 MCU 只存在于实验室里，其实它早就渗透到我们生活的方方面面：</p>
<ul>
<li><p><strong>智能家居</strong>：电饭煲里的 MCU 控制加热温度和时间，让米饭不糊锅；扫地机器人的 MCU 规划清扫路线，避免 “原地打转”。</p>
</li>
<li><p><strong>穿戴设备</strong>：智能手表的 MCU 负责采集心率、计步，还得控制屏幕亮灭，堪称 “贴身小管家”。</p>
</li>
<li><p><strong>汽车电子</strong>：车窗升降、雨刮器摆动、安全气囊触发，背后都有 MCU 在默默工作，保障行车安全。</p>
</li>
<li><p><strong>玩具领域</strong>：遥控汽车的转向、发声，机器人玩具的动作协调，全靠 MCU 发号施令，让玩具 “活” 起来。</p>
</li>
</ul>
<h3 id="五、想玩-MCU？入门其实没那么难"><a href="#五、想玩-MCU？入门其实没那么难" class="headerlink" title="五、想玩 MCU？入门其实没那么难"></a>五、想玩 MCU？入门其实没那么难</h3><p>如果你也想亲手摆弄一下 MCU，其实门槛并不高：</p>
<ol>
<li><p><strong>选块开发板</strong>：新手推荐 Arduino Uno（用的是 ATmega328P）或者 STM32F103C8T6（俗称 “蓝胖子”），价格便宜，资料丰富。</p>
</li>
<li><p><strong>装上开发工具</strong>：STM32 用 Keil MDK 或 STM32CubeIDE，Arduino 直接用官方 IDE，傻瓜式操作，不用费劲配置环境。</p>
</li>
<li><p><strong>写段小程序</strong>：从点亮一个 LED 灯开始，逐步尝试读取传感器、控制电机，就像搭积木一样，慢慢解锁新技能。</p>
</li>
</ol>
<h3 id="六、总结：小个子有大能量"><a href="#六、总结：小个子有大能量" class="headerlink" title="六、总结：小个子有大能量"></a>六、总结：小个子有大能量</h3><p>MCU 虽然没有 PC 机的算力，也没有手机芯片的酷炫，但它用自己的小巧、省电、亲民，在嵌入式世界里占据了不可替代的地位。从家里的小家电到工厂的自动化设备，从医疗仪器到航天器材，到处都有它忙碌的身影。</p>
<p>如果你对电子制作感兴趣，不妨从一块 MCU 开发板开始，亲手打造属于自己的小玩意 —— 毕竟，能让一堆零件听从指挥动起来，那种成就感可是买现成产品比不了的。</p>
<p>你用过哪些 MCU？或者有什么好玩的 DIY 作品？欢迎在评论区分享你的故事～</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MCU</tag>
        <tag>嵌入式</tag>
        <tag>微控制器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用操作（实时更新）</title>
    <url>/2025/07/26/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Ubuntu常用操作"><a href="#Ubuntu常用操作" class="headerlink" title="Ubuntu常用操作"></a>Ubuntu常用操作</h1><h2 id="一、系统相关"><a href="#一、系统相关" class="headerlink" title="一、系统相关"></a>一、系统相关</h2><h3 id="查看Ubuntu系统版本："><a href="#查看Ubuntu系统版本：" class="headerlink" title="查看Ubuntu系统版本："></a>查看Ubuntu系统版本：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>

<p>这个文件包含了操作系统识别数据，是系统和应用程序查看 OS 版本的标准方式之一，输出将包括多行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;20.04.2 LTS (Focal Fossa)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 20.04.2 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;20.04&quot;</span><br><span class="line">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br></pre></td></tr></table></figure>





<h2 id="二、文件操作"><a href="#二、文件操作" class="headerlink" title="二、文件操作"></a>二、文件操作</h2><h3 id="1、文件的权限信息"><a href="#1、文件的权限信息" class="headerlink" title="1、文件的权限信息"></a>1、文件的权限信息</h3><p>使用 LL 指令显示文件信息，第一列的第一个字符表示文件的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d：文件夹</span><br><span class="line">-：普通文件</span><br><span class="line">l：软链接（类似Windows的快捷方式）</span><br><span class="line">b：块设备文件（例如硬盘、光驱等）</span><br><span class="line">p：管道文件</span><br><span class="line">c：字符设备文件（例如屏幕等串口设备）</span><br><span class="line">s：套接口文件</span><br></pre></td></tr></table></figure>

<p>对于文件来说权限是用来限制用户对自己的操作的，而文件自己一般只有三个操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读（read）：具有读取文件内容的权限。</span><br><span class="line">写（write）： 具有修改文件内容的权限。</span><br><span class="line">执行（execute）：具有执行文件的权限。</span><br></pre></td></tr></table></figure>
<p>这个比较好理解，但是要注意对于一个目录文件来说又有点不一样了，虽然有也是同样的三个操作，但是效果不一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读（read）：查看目录下的文件列表的权限。</span><br><span class="line">写（write）： 具有删除移动目录内文件和创建文件的权限 。</span><br><span class="line">执行（execute）：具有进入目录的权限。</span><br></pre></td></tr></table></figure>

<p>对于一个文件来说能访问它的用户大致分为三种： 拥有者(owner)、所属组(group)、其他(other)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拥有者(owner)：文件和文件目录的所有者。</span><br><span class="line">所属组(group)：文件和文件目录的所有者所在的组的用户。</span><br><span class="line">其它用户(other)：不属于上面的两个。</span><br></pre></td></tr></table></figure>

<p>由于权限是可以限制人也可以限制文件的，所以修改文件的访问权限，要么修改用户的权限，要么修改文件的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令：chmod   设置文件的访问权限。</span><br><span class="line"></span><br><span class="line">+：增加权限</span><br><span class="line">-：取消权限</span><br><span class="line">u：拥有者 </span><br><span class="line">g：拥有者同组用</span><br><span class="line">o：其它用户</span><br><span class="line">a：所有用户</span><br></pre></td></tr></table></figure>

<p> 使用 ll命令的第三列和四列就是文件的拥有者和所属组，而不属于这两个的就是other。</p>
<h3 id="2-vim命令"><a href="#2-vim命令" class="headerlink" title="2.vim命令"></a>2.vim命令</h3><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><h3 id="1、时间不正确"><a href="#1、时间不正确" class="headerlink" title="1、时间不正确"></a>1、时间不正确</h3><p>安装完ubuntu后，ubuntu显示的时间不对，和网络的时间对不上。</p>
<p>一般来说，显示时间不正确的情况就两种情况，第一：是系统设置的时区不对；第二：时区是正确的，但是系统本身的时间不对。</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure>

<p>该命令会把我们系统的时间还有时区显示出来，我们是属于东八区，应该显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tue, 22 Jul 2025 17:00:16 +0800</span><br></pre></td></tr></table></figure>

<p>如果时区正确，则为第二种情况，否则为第一种情况。</p>
<h4 id="第一种情况解决办法（系统时区不正确）"><a href="#第一种情况解决办法（系统时区不正确）" class="headerlink" title="第一种情况解决办法（系统时区不正确）"></a>第一种情况解决办法（系统时区不正确）</h4><p>运行 tzselect 工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tzselect</span><br></pre></td></tr></table></figure>

<p>运行这个工具之后，会有文本的简单交互。在这里我们选择亚洲 Asia ，确认之后选择中国 China ，最后选择北京 Beijing ，最后再选择 YES 确认即可。</p>
<p>然后复制文件到 &#x2F;etc&#x2F;localtime 目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure>

<p>再次输入 date -R 命令查看就可以发现时区已经改为了东八区了。</p>
<p>Log out 再Log in时间即可正确显示。</p>
<h4 id="第二种情况解决办法（系统本身时间不正确）"><a href="#第二种情况解决办法（系统本身时间不正确）" class="headerlink" title="第二种情况解决办法（系统本身时间不正确）"></a>第二种情况解决办法（系统本身时间不正确）</h4><p>安装ntpdate工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br></pre></td></tr></table></figure>

<p>同步系统时间与网络时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>

<p>做完上面两步之后，时间即可显示正常。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>MCU 深度解析</title>
    <url>/2025/07/21/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>微控制器（MCU）作为嵌入式系统的核心组件，承担着控制、数据处理与外设交互等关键功能。与通用处理器不同，MCU 以专用性、低功耗和高集成度为显著特征，广泛应用于工业控制、消费电子、汽车电子等领域。本文将从技术底层出发，系统阐述 MCU 的架构组成、性能指标、指令集差异及外设接口设计，为深入理解和应用 MCU 提供理论基础。</p>
<h3 id="一、MCU-的核心架构组成"><a href="#一、MCU-的核心架构组成" class="headerlink" title="一、MCU 的核心架构组成"></a>一、MCU 的核心架构组成</h3><p>MCU 的架构设计围绕 “专用控制” 需求展开，其核心组成可分为运算核心、存储系统、外设模块及总线结构四部分，各模块通过内部总线实现数据交互。</p>
<h4 id="1-运算核心（CPU）"><a href="#1-运算核心（CPU）" class="headerlink" title="1. 运算核心（CPU）"></a>1. 运算核心（CPU）</h4><p>MCU 的 CPU 多基于精简指令集（RISC）架构，如 ARM Cortex-M 系列、MIPS M-Class 等，部分低端型号采用专用架构（如 8051 内核）。与复杂指令集（CISC）相比，RISC 架构具有以下特点：</p>
<ul>
<li><p>指令长度固定（通常为 16 位或 32 位），执行周期可预测，有利于实时控制；</p>
</li>
<li><p>寄存器数量较多（如 Cortex-M4 含 31 个通用寄存器），减少内存访问次数；</p>
</li>
<li><p>硬件乘法器、除法器等专用运算单元集成化，支持单周期乘法操作，提升数值处理效率。</p>
</li>
</ul>
<p>以 STM32F4 系列为例，其搭载的 Cortex-M4 内核支持浮点运算单元（FPU），可直接处理 32 位 IEEE 754 格式浮点数，适用于需要高精度控制的场景（如电机伺服系统）。</p>
<h4 id="2-存储系统"><a href="#2-存储系统" class="headerlink" title="2. 存储系统"></a>2. 存储系统</h4><p>MCU 的存储系统采用 “哈佛架构”，即程序存储器与数据存储器物理分离，通过不同总线访问，提升指令执行效率。</p>
<ul>
<li><p><strong>程序存储器</strong>：以 Flash 为主，用于固化程序代码，容量范围从 KB 级（如 ATmega328P 的 32KB）到 MB 级（如 STM32H743 的 2MB），部分型号支持在线编程（ISP）和在应用编程（IAP），便于固件升级。</p>
</li>
<li><p><strong>数据存储器</strong>：包括 SRAM（用于运行时数据存储）和寄存器文件，SRAM 容量通常为 Flash 的 1&#x2F;4~1&#x2F;2，部分高端型号通过内存管理单元（MMU）支持外部扩展存储。</p>
</li>
</ul>
<h4 id="3-外设模块"><a href="#3-外设模块" class="headerlink" title="3. 外设模块"></a>3. 外设模块</h4><p>外设模块是 MCU 实现专用控制功能的关键，不同型号的外设配置差异较大，主要包括：</p>
<ul>
<li><p><strong>通用输入输出（GPIO）</strong>：支持推挽、开漏、上拉 &#x2F; 下拉等多种工作模式，部分引脚可复用为专用功能（如 SPI、UART），引脚驱动能力通常为 2~20mA，满足中小功率外设驱动需求。</p>
</li>
<li><p><strong>定时器 &#x2F; 计数器</strong>：包括基本定时器（用于定时中断）、通用定时器（支持 PWM 输出、输入捕获）和高级定时器（如 STM32 的 TIM1，支持死区控制和互补输出，适用于电机驱动）。</p>
</li>
<li><p><strong>通信接口</strong>：</p>
</li>
<li><ul>
<li>同步接口：SPI（最高速率可达 42MHz）、I²C（支持 100kHz&#x2F;400kHz&#x2F;3.4MHz 速率等级）；</li>
</ul>
</li>
<li><ul>
<li>异步接口：UART（支持硬件流控）、LIN（适用于汽车低速率通信）；</li>
</ul>
</li>
<li><ul>
<li>高速接口：USB（多为 USB 2.0 Full-Speed）、Ethernet（部分高端型号集成 MAC 层）。</li>
</ul>
</li>
<li><p><strong>模拟外设</strong>：ADC（分辨率 8<del>16 位，转换速率可达数 MSPS）、DAC（8</del>12 位）及比较器，用于模拟信号采集与转换。</p>
</li>
</ul>
<h4 id="4-总线结构"><a href="#4-总线结构" class="headerlink" title="4. 总线结构"></a>4. 总线结构</h4><p>MCU 内部总线采用分层设计，以 STM32 为例，其总线架构包括：</p>
<ul>
<li><p>指令总线（I-Code）与数据总线（D-Code）：连接 CPU 与 Flash、SRAM，保障指令与数据的并行访问；</p>
</li>
<li><p>系统总线（AHB）：连接高带宽外设（如 DMA、定时器），最高频率可达系统时钟的 1&#x2F;1；</p>
</li>
<li><p>外设总线（APB）：分为 APB1（低速，最高 36MHz）和 APB2（高速，最高 72MHz），连接 UART、SPI 等外设。</p>
</li>
</ul>
<h3 id="二、MCU-的关键性能指标"><a href="#二、MCU-的关键性能指标" class="headerlink" title="二、MCU 的关键性能指标"></a>二、MCU 的关键性能指标</h3><p>评估 MCU 的技术特性需关注以下核心参数，这些参数直接决定其适用场景：</p>
<h4 id="1-时钟频率与运算能力"><a href="#1-时钟频率与运算能力" class="headerlink" title="1. 时钟频率与运算能力"></a>1. 时钟频率与运算能力</h4><ul>
<li><p>时钟频率：主流 MCU 的核心频率范围为 8MHz（低端 8 位 MCU）至 600MHz（高端 32 位 MCU，如 STM32H7），频率越高，单周期指令执行速度越快，但功耗随之增加。</p>
</li>
<li><p>DMIPS&#x2F;MHz：用于衡量 CPU 的整数运算能力，Cortex-M0 + 约为 0.9 DMIPS&#x2F;MHz，Cortex-M7 可达 3.25 DMIPS&#x2F;MHz，该指标越高，数据处理效率越强。</p>
</li>
</ul>
<h4 id="2-功耗特性"><a href="#2-功耗特性" class="headerlink" title="2. 功耗特性"></a>2. 功耗特性</h4><p>MCU 的功耗通常以 “工作模式” 和 “待机模式” 区分：</p>
<ul>
<li><p>工作模式：电流消耗与时钟频率正相关，如 32 位 MCU 在 72MHz 频率下约为 10~30mA；</p>
</li>
<li><p>低功耗模式：通过关闭部分模块实现功耗优化，如 STM32 的 Stop 模式电流可低至 10μA，Standby 模式仅 0.5μA，适用于电池供电设备。</p>
</li>
</ul>
<h4 id="3-温度与可靠性"><a href="#3-温度与可靠性" class="headerlink" title="3. 温度与可靠性"></a>3. 温度与可靠性</h4><ul>
<li><p>工业级 MCU（如 STM32F103 工业级）支持 - 40℃<del>85℃工作温度，汽车级型号（如 S32K 系列）可扩展至 - 40℃</del>125℃，满足极端环境需求；</p>
</li>
<li><p>抗干扰性能通过 ESD（静电放电）、EFT（电快速瞬变脉冲群）测试衡量，工业级产品通常支持 ±8kV 接触放电防护。</p>
</li>
</ul>
<h3 id="三、主流-MCU-架构对比"><a href="#三、主流-MCU-架构对比" class="headerlink" title="三、主流 MCU 架构对比"></a>三、主流 MCU 架构对比</h3><p>不同厂商的 MCU 基于差异化架构形成技术壁垒，以下为三类典型架构的特性分析：</p>
<table>
<thead>
<tr>
<th>架构类型</th>
<th>代表产品</th>
<th>优势领域</th>
<th>技术特点</th>
</tr>
</thead>
<tbody><tr>
<td>8051 兼容架构</td>
<td>STC89C52</td>
<td>低端控制、成本敏感场景</td>
<td>8 位数据总线，指令集简单，开发工具成熟</td>
</tr>
<tr>
<td>ARM Cortex-M</td>
<td>STM32、NRF52 系列</td>
<td>中高端嵌入式、无线连接</td>
<td>32 位架构，支持嵌套向量中断控制器（NVIC），中断响应时间 &lt; 12 个时钟周期</td>
</tr>
<tr>
<td>MSP430 架构</td>
<td>MSP430F5 系列</td>
<td>超低功耗场景（如医疗设备）</td>
<td>16 位 RISC，支持 5 种低功耗模式，待机电流 &lt; 1μA</td>
</tr>
</tbody></table>
<p>其中，ARM Cortex-M 系列通过架构版本迭代覆盖不同需求：</p>
<ul>
<li><p>Cortex-M0+&#x2F;M0：面向低成本、低功耗场景，如家电控制；</p>
</li>
<li><p>Cortex-M3&#x2F;M4：平衡性能与功耗，适用于工业传感器、电机控制；</p>
</li>
<li><p>Cortex-M7&#x2F;M85：高性能型号，支持浮点运算和 DSP 指令，用于高端汽车电子。</p>
</li>
</ul>
<h3 id="四、MCU-的外设接口设计要点"><a href="#四、MCU-的外设接口设计要点" class="headerlink" title="四、MCU 的外设接口设计要点"></a>四、MCU 的外设接口设计要点</h3><p>外设接口的合理配置是 MCU 应用开发的关键，以下为典型接口的设计规范：</p>
<h4 id="1-GPIO-接口"><a href="#1-GPIO-接口" class="headerlink" title="1. GPIO 接口"></a>1. GPIO 接口</h4><ul>
<li><p>输出模式：驱动感性负载（如继电器）时需并联续流二极管，避免反向电压损坏引脚；</p>
</li>
<li><p>输入模式：采集模拟信号时需配置为浮空输入，数字信号则建议启用内部上拉电阻，减少外部电路复杂度。</p>
</li>
</ul>
<h4 id="2-通信接口"><a href="#2-通信接口" class="headerlink" title="2. 通信接口"></a>2. 通信接口</h4><ul>
<li><p>SPI：多设备连接时需通过片选（CS）引脚区分，布线时应缩短时钟线（SCK）长度，避免信号干扰；</p>
</li>
<li><p>I²C：总线上挂载的设备数量受电容限制（通常≤400pF），长距离传输需添加总线缓冲器；</p>
</li>
<li><p>UART：需匹配波特率误差（≤3%），异步通信时建议使用硬件流控（RTS&#x2F;CTS）防止数据溢出。</p>
</li>
</ul>
<h4 id="3-中断系统"><a href="#3-中断系统" class="headerlink" title="3. 中断系统"></a>3. 中断系统</h4><p>MCU 的中断响应机制直接影响实时性，设计时需注意：</p>
<ul>
<li><p>中断优先级：通过 NVIC 配置抢占优先级和子优先级，确保关键事件（如故障保护）优先响应；</p>
</li>
<li><p>中断服务程序（ISR）：应尽量缩短执行时间，避免占用过多 CPU 资源，复杂处理需通过消息队列异步执行。</p>
</li>
</ul>
<h3 id="五、MCU-的开发与调试"><a href="#五、MCU-的开发与调试" class="headerlink" title="五、MCU 的开发与调试"></a>五、MCU 的开发与调试</h3><p>专业 MCU 开发需掌握以下工具链与技术流程：</p>
<h4 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1. 开发环境"></a>1. 开发环境</h4><ul>
<li><p>集成开发环境（IDE）：STM32CubeIDE（基于 Eclipse）、IAR Embedded Workbench、Keil MDK，支持代码编辑、编译与调试；</p>
</li>
<li><p>编译器：GCC（开源）、ARMCC（商用），需根据目标架构选择，如 Cortex-M 系列推荐使用 ARMCC 6，优化效果更佳。</p>
</li>
</ul>
<h4 id="2-调试工具"><a href="#2-调试工具" class="headerlink" title="2. 调试工具"></a>2. 调试工具</h4><ul>
<li><p>JTAG&#x2F;SWD 接口：通过调试器（如 ST-Link、J-Link）实现程序下载与断点调试，SWD 接口仅需 2 根线（CLK、DIO），适合空间受限的场景；</p>
</li>
<li><p>仿真器功能：支持查看寄存器状态、内存数据及外设配置，部分高端工具可实时监控功耗变化。</p>
</li>
</ul>
<h4 id="3-开发流程"><a href="#3-开发流程" class="headerlink" title="3. 开发流程"></a>3. 开发流程</h4><ol>
<li><p>需求分析：根据控制对象确定 MCU 的性能、外设与功耗需求；</p>
</li>
<li><p>硬件选型：参考 Datasheet 中的电气参数，完成原理图设计（需预留调试接口）；</p>
</li>
<li><p>固件开发：基于 HAL 库或 LL 库编写驱动程序，实现外设初始化与控制逻辑；</p>
</li>
<li><p>测试验证：通过示波器、逻辑分析仪验证时序正确性，进行高低温环境测试。</p>
</li>
</ol>
<h3 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h3><p>MCU 的技术发展呈现 “高性能与低功耗并存” 的趋势，32 位 MCU 已成为市场主流，同时 AI 加速单元、无线通信模块的集成（如 BLE 5.0、LoRa）使 MCU 向 “智能边缘节点” 演进。深入理解 MCU 的架构原理与性能特性，是实现高效嵌入式系统设计的基础，开发者需结合具体应用场景，在算力、功耗与成本之间找到最优平衡。</p>
<p>对于进阶学习者，建议通过实际项目（如电机闭环控制、传感器数据采集）实践本文所述技术要点，同时关注厂商提供的参考设计（Reference Design），快速掌握工程化应用技巧。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MCU</tag>
        <tag>微控制器</tag>
        <tag>嵌入式系统</tag>
        <tag>处理器架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU 深度解析</title>
    <url>/2025/07/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/MMU%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>内存管理单元（MMU）是现代处理器的核心组件之一，承担着虚拟地址到物理地址的转换、内存访问权限控制及缓存管理等关键功能。它是操作系统实现虚拟内存、进程隔离和内存保护的硬件基础，从嵌入式设备到服务器 CPU 均有广泛应用。本文将从底层原理出发，全面解析 MMU 的工作机制、核心结构及实际应用场景。</p>
<h3 id="一、MMU-的核心功能与作用"><a href="#一、MMU-的核心功能与作用" class="headerlink" title="一、MMU 的核心功能与作用"></a>一、MMU 的核心功能与作用</h3><p>MMU 位于 CPU 与物理内存之间，是衔接软件需求与硬件资源的关键枢纽，其核心功能可概括为以下三点：</p>
<h4 id="1-虚拟地址到物理地址的转换"><a href="#1-虚拟地址到物理地址的转换" class="headerlink" title="1. 虚拟地址到物理地址的转换"></a>1. 虚拟地址到物理地址的转换</h4><p>现代操作系统普遍采用虚拟内存技术，进程访问的内存地址（虚拟地址）并非直接对应物理内存地址。MMU 通过硬件电路将虚拟地址映射到物理地址，使进程无需关心实际内存位置，简化了内存管理复杂度。例如，两个进程可使用相同的虚拟地址（如0x00400000），但 MMU 会将其映射到物理内存的不同区域，实现进程地址空间隔离。</p>
<h4 id="2-内存访问权限控制"><a href="#2-内存访问权限控制" class="headerlink" title="2. 内存访问权限控制"></a>2. 内存访问权限控制</h4><p>MMU 通过页表项中的权限位（如可读、可写、可执行）对内存访问进行管控，防止非法操作。例如：</p>
<ul>
<li><p>只读数据段（如常量）被标记为 “不可写”，避免程序意外修改；</p>
</li>
<li><p>用户态进程访问内核态内存时，MMU 会触发异常（如 ARM 的 Data Abort），阻止越权访问。</p>
</li>
</ul>
<h4 id="3-辅助缓存管理"><a href="#3-辅助缓存管理" class="headerlink" title="3. 辅助缓存管理"></a>3. 辅助缓存管理</h4><p>MMU 与 CPU 缓存（L1&#x2F;L2 Cache）协同工作，通过页表项中的缓存策略位（如 ARM 的 C、B 位）配置内存区域的缓存行为：</p>
<ul>
<li><p>可缓存（Cacheable）：数据可存入缓存，提升访问速度；</p>
</li>
<li><p>不可缓存（Non-cacheable）：适用于外设寄存器等需要实时访问的地址；</p>
</li>
<li><p>写回（Write-back）&#x2F; 写透（Write-through）：控制缓存数据同步到物理内存的策略。</p>
</li>
</ul>
<h3 id="二、地址转换的核心：页表结构与工作流程"><a href="#二、地址转换的核心：页表结构与工作流程" class="headerlink" title="二、地址转换的核心：页表结构与工作流程"></a>二、地址转换的核心：页表结构与工作流程</h3><p>虚拟地址到物理地址的转换是 MMU 最核心的功能，其实现依赖于页表（Page Table）这一数据结构，转换过程可分为 “页表查询” 和 “地址拼接” 两个阶段。</p>
<h4 id="1-分页机制基础"><a href="#1-分页机制基础" class="headerlink" title="1. 分页机制基础"></a>1. 分页机制基础</h4><p>MMU 将虚拟地址和物理地址划分为固定大小的 “页（Page）”，常见页大小为 4KB、16KB、64KB 或 2MB。例如，4KB 页意味着虚拟地址空间被分为2^32 &#x2F; 2^12 &#x3D; 1M个页（32 位系统）。</p>
<ul>
<li><p><strong>虚拟页号（VPN）</strong>：虚拟地址中用于索引页表的部分；</p>
</li>
<li><p><strong>页内偏移（Offset）</strong>：虚拟地址中表示页内位置的部分，转换时直接映射到物理地址的页内偏移；</p>
</li>
<li><p><strong>物理页号（PPN）</strong>：物理地址中对应页框的编号，由页表查询获得。</p>
</li>
</ul>
<p>以 32 位虚拟地址和 4KB 页为例，地址结构为：[VPN（20位）][Offset（12位）]，其中 20 位 VPN 用于定位页表项，12 位 Offset 确定页内具体字节。</p>
<h4 id="2-多级页表结构"><a href="#2-多级页表结构" class="headerlink" title="2. 多级页表结构"></a>2. 多级页表结构</h4><p>单级页表在 32 位系统中需占用 4MB 内存（1M页表项 × 4字节&#x2F;项），64 位系统中更是难以实现。因此，现代 MMU 普遍采用多级页表（如二级、三级），通过 “分级索引” 减少内存占用。</p>
<p>以 ARMv7-A 的二级页表为例：</p>
<ul>
<li><p><strong>一级页表（L1 Page Table）</strong>：每个表项对应 1MB 内存区域，包含 “二级页表基地址” 或 “大页（Section）直接映射” 信息；</p>
</li>
<li><p><strong>二级页表（L2 Page Table）</strong>：每个表项对应 4KB 小页，存储物理页号和权限信息。</p>
</li>
</ul>
<p>32 位虚拟地址的拆分如下：</p>
<ul>
<li><p>高 12 位：一级页表索引（用于查找 L1 表项）；</p>
</li>
<li><p>中间 8 位：二级页表索引（用于查找 L2 表项）；</p>
</li>
<li><p>低 12 位：页内偏移（直接映射）。</p>
</li>
</ul>
<h4 id="3-地址转换流程"><a href="#3-地址转换流程" class="headerlink" title="3. 地址转换流程"></a>3. 地址转换流程</h4><p>以 4KB 页的二级页表转换为例，步骤如下：</p>
<ol>
<li><p>CPU 生成虚拟地址（VA），MMU 从中提取一级索引、二级索引和页内偏移；</p>
</li>
<li><p>MMU 通过 “页表基地址寄存器（TTBR，Translation Table Base Register）” 获取一级页表的物理基地址；</p>
</li>
<li><p>用一级索引访问一级页表，得到二级页表的物理基地址（若为大页映射，则直接获取物理页号）；</p>
</li>
<li><p>用二级索引访问二级页表，获取物理页号（PPN）；</p>
</li>
<li><p>将 PPN 与页内偏移拼接，生成物理地址（PA）。</p>
</li>
</ol>
<h3 id="三、加速地址转换：TLB-的作用与工作机制"><a href="#三、加速地址转换：TLB-的作用与工作机制" class="headerlink" title="三、加速地址转换：TLB 的作用与工作机制"></a>三、加速地址转换：TLB 的作用与工作机制</h3><p>页表存储在物理内存中，若每次地址转换都访问内存，会显著降低效率（内存访问延迟约为 CPU 周期的 100 倍以上）。为此，MMU 内置了 “转换后备缓冲器（TLB，Translation Lookaside Buffer）”—— 一种高速缓存，用于存储近期使用的页表项。</p>
<h4 id="1-TLB-的工作原理"><a href="#1-TLB-的工作原理" class="headerlink" title="1. TLB 的工作原理"></a>1. TLB 的工作原理</h4><ul>
<li><p><strong>命中（TLB Hit）</strong>：虚拟地址对应的页表项已在 TLB 中，直接使用缓存的物理页号和权限信息，无需访问内存页表，转换延迟仅需几个 CPU 周期；</p>
</li>
<li><p><strong>未命中（TLB Miss）</strong>：TLB 中无对应页表项，MMU 需执行 “页表遍历”（访问内存中的页表）获取页表项，并更新 TLB，此过程会产生数十至数百个 CPU 周期的延迟。</p>
</li>
</ul>
<h4 id="2-TLB-的分类与特性"><a href="#2-TLB-的分类与特性" class="headerlink" title="2. TLB 的分类与特性"></a>2. TLB 的分类与特性</h4><ul>
<li><p><strong>指令 TLB（ITLB）</strong>：专门缓存指令页的转换信息，与 CPU 的指令缓存配合；</p>
</li>
<li><p><strong>数据 TLB（DTLB）</strong>：缓存数据页的转换信息，与数据缓存配合；</p>
</li>
<li><p><strong>统一 TLB（UTLB）</strong>：同时缓存指令和数据的转换信息，常见于低功耗处理器。</p>
</li>
</ul>
<p>TLB 容量通常较小（如 ARM Cortex-A53 的 ITLB&#x2F;DTLB 各 64 项），但通过 “局部性原理”（程序倾向于访问最近使用的地址）仍能达到较高的命中率（通常 &gt; 90%）。</p>
<h3 id="四、不同架构下的-MMU-实现差异"><a href="#四、不同架构下的-MMU-实现差异" class="headerlink" title="四、不同架构下的 MMU 实现差异"></a>四、不同架构下的 MMU 实现差异</h3><p>MMU 的核心功能一致，但在具体实现上，ARM、x86 等架构存在细节差异，以下为两类主流架构的对比：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ARM 架构（如 Cortex-A 系列）</th>
<th>x86 架构（如 Intel x86_64）</th>
</tr>
</thead>
<tbody><tr>
<td>页表级数</td>
<td>支持二级（ARMv7）、三级（ARMv8-A）页表</td>
<td>四级页表（x86_64，CR3 寄存器指向 PML4 表）</td>
</tr>
<tr>
<td>页大小支持</td>
<td>4KB、16KB、64KB、1MB、2MB、1GB</td>
<td>4KB、2MB、1GB</td>
</tr>
<tr>
<td>权限控制</td>
<td>基于域（Domain）和页表项 AP 位</td>
<td>基于页表项的 R&#x2F;W、U&#x2F;S 位（用户 &#x2F; 超级用户）</td>
</tr>
<tr>
<td>异常处理</td>
<td>未命中或权限错误触发 Data Abort&#x2F;Pre-fetch Abort</td>
<td>触发页错误（Page Fault），通过 CR2 寄存器传递故障地址</td>
</tr>
<tr>
<td>TLB 管理</td>
<td>软件管理（需显式指令刷新，如 TLBI）</td>
<td>硬件自动管理（部分指令可触发刷新，如 INVLPG）</td>
</tr>
</tbody></table>
<p>以 ARMv8-A（64 位）为例，其三级页表支持 4KB 页的 64 位地址转换，虚拟地址拆分如下：</p>
<ul>
<li><p>第 0 级索引（9 位）：指向 PUD（Page Upper Directory）表项；</p>
</li>
<li><p>第 1 级索引（9 位）：指向 PMD（Page Middle Directory）表项；</p>
</li>
<li><p>第 2 级索引（9 位）：指向 PTE（Page Table Entry）表项；</p>
</li>
<li><p>页内偏移（12 位）：4KB 页对应的偏移量。</p>
</li>
</ul>
<h3 id="五、MMU-的使能与初始化（以嵌入式系统为例）"><a href="#五、MMU-的使能与初始化（以嵌入式系统为例）" class="headerlink" title="五、MMU 的使能与初始化（以嵌入式系统为例）"></a>五、MMU 的使能与初始化（以嵌入式系统为例）</h3><p>在嵌入式系统中，MMU 默认处于禁用状态（复位后），需通过软件初始化才能启用，步骤如下：</p>
<h4 id="1-页表创建"><a href="#1-页表创建" class="headerlink" title="1. 页表创建"></a>1. 页表创建</h4><p>在物理内存中分配连续区域作为页表（如 ARMv7 中一级页表需 16KB，0x10000 ~ 0x13FFF），并根据内存布局填充页表项：</p>
<ul>
<li><p>内核代码段：标记为 “可执行、可读、内核态可写”；</p>
</li>
<li><p>外设寄存器区域：标记为 “不可缓存、不可执行、读写权限按需配置”；</p>
</li>
<li><p>用户空间：标记为 “用户态可访问”。</p>
</li>
</ul>
<h4 id="2-配置页表基地址寄存器"><a href="#2-配置页表基地址寄存器" class="headerlink" title="2. 配置页表基地址寄存器"></a>2. 配置页表基地址寄存器</h4><p>将页表的物理基地址写入 MMU 的页表基地址寄存器（如 ARM 的 TTBR0&#x2F;TTBR1，x86 的 CR3）。</p>
<h4 id="3-使能-MMU"><a href="#3-使能-MMU" class="headerlink" title="3. 使能 MMU"></a>3. 使能 MMU</h4><p>通过处理器控制寄存器开启 MMU 功能：</p>
<ul>
<li><p>ARM：设置 SCTLR 寄存器的 M 位（bit 0）为 1；</p>
</li>
<li><p>x86：设置 CR0 寄存器的 PG 位（bit 31）为 1。</p>
</li>
</ul>
<p>使能后，CPU 发出的所有虚拟地址均会经过 MMU 转换，未映射的地址访问会触发异常。</p>
<h3 id="六、MMU-在操作系统中的典型应用"><a href="#六、MMU-在操作系统中的典型应用" class="headerlink" title="六、MMU 在操作系统中的典型应用"></a>六、MMU 在操作系统中的典型应用</h3><p>操作系统通过 MMU 实现多项核心功能，以下为三个典型场景：</p>
<h4 id="1-进程地址空间隔离"><a href="#1-进程地址空间隔离" class="headerlink" title="1. 进程地址空间隔离"></a>1. 进程地址空间隔离</h4><p>每个进程拥有独立的页表（或页表子集），操作系统通过切换页表基地址寄存器（如进程上下文切换时更新 TTBR0），使不同进程的虚拟地址映射到物理内存的不同区域，确保进程间互不干扰。</p>
<h4 id="2-内存分配与换页（Swap）"><a href="#2-内存分配与换页（Swap）" class="headerlink" title="2. 内存分配与换页（Swap）"></a>2. 内存分配与换页（Swap）</h4><p>当物理内存不足时，操作系统可将不常用的页（通过 MMU 标记为 “无效”）写入磁盘（Swap 分区），释放物理内存；当进程再次访问该页时，MMU 触发 “缺页异常”，操作系统将磁盘数据读回物理内存并更新页表，实现 “内存扩容” 的假象。</p>
<h4 id="3-内存映射文件（mmap）"><a href="#3-内存映射文件（mmap）" class="headerlink" title="3. 内存映射文件（mmap）"></a>3. 内存映射文件（mmap）</h4><p>通过 MMU 将文件内容直接映射到进程虚拟地址空间，进程访问虚拟地址时，MMU 自动完成文件数据与物理内存的同步，避免了传统 read&#x2F;write 系统调用的数据拷贝开销，提升 IO 效率。</p>
<h3 id="七、总结与学习建议"><a href="#七、总结与学习建议" class="headerlink" title="七、总结与学习建议"></a>七、总结与学习建议</h3><p>MMU 是连接软件与硬件内存的桥梁，其设计直接影响系统的安全性、效率和灵活性。理解 MMU 的工作原理，不仅有助于深入掌握操作系统内存管理机制，也是嵌入式开发中调试内存相关问题（如总线错误、缓存一致性）的基础。</p>
<p>学习 MMU 可从以下步骤入手：</p>
<ol>
<li><p>掌握分页机制和页表结构，通过手动计算虚拟地址到物理地址的转换过程加深理解；</p>
</li>
<li><p>结合具体架构（如 ARM Cortex-A 系列）的技术手册，分析页表项格式和 TLB 操作指令；</p>
</li>
<li><p>在嵌入式开发板（如树莓派）上实践 MMU 初始化，观察使能前后的地址访问差异。</p>
</li>
</ol>
<p>MMU 的细节虽复杂，但核心逻辑围绕 “虚拟地址转换” 和 “内存保护” 展开，抓住这两条主线，就能逐步揭开其神秘面纱。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>MMU</tag>
        <tag>内存管理</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC/G++ 基础使用</title>
    <url>/2025/07/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/gccg++%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="GCC-G-的基础使用"><a href="#GCC-G-的基础使用" class="headerlink" title="GCC&#x2F;G++ 的基础使用"></a>GCC&#x2F;G++ 的基础使用</h1><h2 id="一、GCC-简介"><a href="#一、GCC-简介" class="headerlink" title="一、GCC 简介"></a>一、GCC 简介</h2><p>GCC（GNU Compiler Collection，GNU 编译器套件）是由 GNU 开发的开源编程语言编译器，最初仅支持 C 语言，后逐步扩展至 C++、Objective-C、Fortran、Java、Ada 和 Go 等多种语言，同时包含这些语言的库（如 C++ 的 libstdc++、Java 的 libgcj 等）。它是跨平台开发的核心工具之一，广泛应用于 Linux、Unix 及 Windows（通过 MinGW 等工具链）环境。</p>
<p>程序编译的核心目标是将人类可读的源代码（如 C&#x2F;C++ 代码）转化为计算机可直接执行的机器代码，这一过程主要分为<strong>预处理、编译、汇编、链接</strong>四个阶段，每个阶段都有明确的任务和输出结果。</p>
<h2 id="二、程序编译的四个阶段"><a href="#二、程序编译的四个阶段" class="headerlink" title="二、程序编译的四个阶段"></a>二、程序编译的四个阶段</h2><h3 id="（一）预处理阶段：宏替换与文本转换"><a href="#（一）预处理阶段：宏替换与文本转换" class="headerlink" title="（一）预处理阶段：宏替换与文本转换"></a>（一）预处理阶段：宏替换与文本转换</h3><p>预处理是编译流程的第一步，主要对源代码中的特殊指令和符号进行处理，生成无宏定义、无条件编译指令的中间文件。具体处理内容包括：</p>
<ol>
<li><p><strong>宏定义替换</strong>：将#define定义的宏在代码中展开（如#define PI 3.14会替换所有PI为 3.14）。</p>
</li>
<li><p><strong>文件包含处理</strong>：解析#include指令，将指定的头文件内容插入到当前文件中（如#include &lt;stdio.h&gt;会插入标准输入输出库的声明）。</p>
</li>
<li><p><strong>条件编译处理</strong>：根据#ifdef、#ifndef、#if等指令选择性保留代码（如调试时保留日志打印，发布时移除）。</p>
</li>
<li><p><strong>特殊符号替换</strong>：将__LINE__（当前行号）、<strong>FILE</strong>（当前文件名）等特殊符号替换为实际值。</p>
</li>
</ol>
<p><strong>示例</strong>：</p>
<p>创建test.c文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MAX 100</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;File: %s, Line: %d\n&quot;, __FILE__, __LINE__);</span><br><span class="line">    printf(&quot;MAX = %d\n&quot;, MAX);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预处理命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>生成的test.i文件已展开宏定义和头文件，仅保留 C 语言关键字和变量。</p>
<h3 id="（二）编译阶段：生成汇编代码"><a href="#（二）编译阶段：生成汇编代码" class="headerlink" title="（二）编译阶段：生成汇编代码"></a>（二）编译阶段：生成汇编代码</h3><p>编译阶段会对预处理后的文件（.i）进行语法检查，确认无误后将其转换为汇编语言代码（.s）。此阶段会检测代码规范性（如变量未定义、函数参数不匹配等），并优化代码逻辑。</p>
<p><strong>常用命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S test.i -o test.s  # 从预处理文件生成汇编代码</span><br><span class="line"># 或直接从源文件编译（自动包含预处理）</span><br><span class="line">gcc -S test.c -o test.s</span><br></pre></td></tr></table></figure>

<p><strong>关键选项</strong>：</p>
<ul>
<li><p>-Wall：显示所有警告信息（如未使用的变量、类型不匹配），帮助排查潜在问题。</p>
</li>
<li><p>-O（大写字母 O）：开启优化（如-O1、-O2、-O3，优化级别越高，编译时间越长，生成的代码更高效）。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<p>添加警告检查并优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S -Wall -O2 test.c -o test.s</span><br></pre></td></tr></table></figure>

<h3 id="（三）汇编阶段：生成二进制目标文件"><a href="#（三）汇编阶段：生成二进制目标文件" class="headerlink" title="（三）汇编阶段：生成二进制目标文件"></a>（三）汇编阶段：生成二进制目标文件</h3><p>汇编阶段将汇编代码（.s）转换为机器可识别的二进制目标文件（.o或.obj）。目标文件包含函数和变量的二进制指令，但尚未解决外部引用（如调用其他文件的函数）。</p>
<p><strong>命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c test.s -o test.o  # 从汇编文件生成目标文件</span><br><span class="line"># 或直接从源文件生成（自动包含预处理、编译）</span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>目标文件无法直接执行，可通过objdump工具查看其内容（如机器指令）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d test.o  # 反汇编目标文件</span><br></pre></td></tr></table></figure>

<h3 id="（四）链接阶段：生成可执行文件或库"><a href="#（四）链接阶段：生成可执行文件或库" class="headerlink" title="（四）链接阶段：生成可执行文件或库"></a>（四）链接阶段：生成可执行文件或库</h3><p>链接阶段将多个目标文件（.o）及所需的库文件组合，解决外部引用问题，最终生成可执行文件或库文件。链接分为<strong>静态链接</strong>和<strong>动态链接</strong>两种方式。</p>
<h4 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h4><ul>
<li><p><strong>原理</strong>：将库函数的代码直接拷贝到可执行文件中。</p>
</li>
<li><p><strong>优点</strong>：可执行文件独立运行，不依赖外部库。</p>
</li>
<li><p><strong>缺点</strong>：文件体积大，库更新后需重新编译程序。</p>
</li>
</ul>
<h4 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h4><ul>
<li><p><strong>原理</strong>：仅在可执行文件中记录库的引用，运行时动态加载库文件。</p>
</li>
<li><p><strong>优点</strong>：文件体积小，库更新后无需重新编译程序。</p>
</li>
<li><p><strong>缺点</strong>：依赖系统中存在对应的动态库，否则无法运行。</p>
</li>
</ul>
<p><strong>命令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test  # 链接目标文件生成可执行文件（默认动态链接）</span><br><span class="line"># 直接从源文件生成可执行文件（自动完成四阶段）</span><br><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

<p><strong>查看动态依赖</strong>：</p>
<p>使用ldd命令查看可执行文件依赖的动态库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldd test  # 显示test依赖的动态库路径</span><br></pre></td></tr></table></figure>

<h2 id="三、常用-GCC-选项总结"><a href="#三、常用-GCC-选项总结" class="headerlink" title="三、常用 GCC 选项总结"></a>三、常用 GCC 选项总结</h2><table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-E</td>
<td>仅执行预处理，生成.i文件</td>
</tr>
<tr>
<td>-S</td>
<td>执行预处理和编译，生成.s文件</td>
</tr>
<tr>
<td>-c</td>
<td>执行预处理、编译、汇编，生成.o文件</td>
</tr>
<tr>
<td>-o <file></td>
<td>指定输出文件名称</td>
</tr>
<tr>
<td>-Wall</td>
<td>显示所有警告信息</td>
</tr>
<tr>
<td>-O<level></td>
<td>开启优化（level为 1-3，0 表示关闭）</td>
</tr>
<tr>
<td>-I<dir></td>
<td>指定头文件搜索路径（如-I.&#x2F;include）</td>
</tr>
<tr>
<td>-L<dir></td>
<td>指定库文件搜索路径（如-L.&#x2F;lib）</td>
</tr>
<tr>
<td>-l<lib></td>
<td>链接指定的库（如-lm链接数学库libm.so）</td>
</tr>
<tr>
<td>-static</td>
<td>强制使用静态链接</td>
</tr>
</tbody></table>
<h2 id="四、多文件编译示例"><a href="#四、多文件编译示例" class="headerlink" title="四、多文件编译示例"></a>四、多文件编译示例</h2><p>假设项目包含main.c和func.c两个文件：</p>
<ul>
<li><p>func.c：定义函数add(int a, int b)</p>
</li>
<li><p>main.c：调用add函数</p>
</li>
</ul>
<h4 id="步骤-1：分别生成目标文件"><a href="#步骤-1：分别生成目标文件" class="headerlink" title="步骤 1：分别生成目标文件"></a>步骤 1：分别生成目标文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c func.c -o func.o</span><br><span class="line">gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>

<h4 id="步骤-2：链接生成可执行文件"><a href="#步骤-2：链接生成可执行文件" class="headerlink" title="步骤 2：链接生成可执行文件"></a>步骤 2：链接生成可执行文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.o func.o -o main</span><br></pre></td></tr></table></figure>

<p>直接编译多文件（简化步骤）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c func.c -o main</span><br></pre></td></tr></table></figure>

<h2 id="五、库的创建与使用"><a href="#五、库的创建与使用" class="headerlink" title="五、库的创建与使用"></a>五、库的创建与使用</h2><h3 id="1-静态库（-a）"><a href="#1-静态库（-a）" class="headerlink" title="1. 静态库（.a）"></a>1. 静态库（.a）</h3><ul>
<li><strong>创建</strong>：将多个目标文件打包为静态库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar rcs libmath.a add.o sub.o  # 将add.o、sub.o打包为libmath.a</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用</strong>：链接静态库（-l后省略lib前缀和.a后缀）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.o -L. -lmath -o main  # -L. 指定当前目录为库搜索路径</span><br></pre></td></tr></table></figure>

<h3 id="2-动态库（-so）"><a href="#2-动态库（-so）" class="headerlink" title="2. 动态库（.so）"></a>2. 动态库（.so）</h3><ul>
<li><strong>创建</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared add.o sub.o -o libmath.so  # -fPIC 生成位置无关代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用</strong>：与静态库类似，默认优先链接动态库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.o -L. -lmath -o main</span><br></pre></td></tr></table></figure>

<p>运行时需确保动态库可被找到（可将库路径添加到LD_LIBRARY_PATH）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.  # 临时添加当前目录到库路径</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>GCC 是开发 C&#x2F;C++ 程序的核心工具，其编译过程分为预处理、编译、汇编、链接四个阶段。通过掌握各阶段的命令和选项，可灵活控制编译流程，优化程序性能。实际开发中，需根据需求选择静态链接或动态链接，并合理使用库文件管理代码复用。</p>
<p>掌握本文介绍的基础命令和技巧后，可进一步探索更高级的功能（如调试、交叉编译等），提升开发效率。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下的交叉编译实战</title>
    <url>/2025/08/14/%E5%B5%8C%E5%85%A5%E5%BC%8F/Ubuntu%E4%B8%8B%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>arm-linux-gcc交叉编译工具链的安装：</p>
<p>首先更新软件列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>安装 <strong>ARM 32 位 hard-float</strong> 工具链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure>

<p>安装 <strong>ARM 64 位 (AArch64)</strong> 工具链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>验证是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v      <span class="comment"># 32 位</span></span><br><span class="line">aarch64-linux-gnu-gcc -v        <span class="comment"># 64 位</span></span><br></pre></td></tr></table></figure>

<p>能看到 gcc version 即成功</p>
<p>卸载<strong>ARM 32 位 hard-float</strong> 工具链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt remove gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure>

<p>卸载 <strong>ARM 64 位 (AArch64)</strong> 工具链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt remove gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p><strong>查看本机硬件 CPU 架构&#x2F;指令集</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -m</span><br></pre></td></tr></table></figure>

<p><code>uname -m</code> 是 <strong>“查看本机硬件 CPU 架构&#x2F;指令集”</strong> 的最简命令。<br>它把内核检测到的 <strong>机器硬件名称</strong> 原样打印出来，不做任何转换。<br>常见返回值一览（按出现频率排序）</p>
<table>
<thead>
<tr>
<th align="left">返回值示例</th>
<th align="left">含义</th>
<th align="left">常见场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x86_64</code> &#x2F; <code>amd64</code></td>
<td align="left">64 位 Intel&#x2F;AMD PC、服务器、笔记本、虚拟机</td>
<td align="left">绝大多数桌面&#x2F;服务器 Linux</td>
</tr>
<tr>
<td align="left"><code>aarch64</code></td>
<td align="left">64 位 ARMv8-A（AArch64）</td>
<td align="left">树莓派 3&#x2F;4&#x2F;5、RK3399、苹果 M 系列、安卓手机刷 Linux</td>
</tr>
<tr>
<td align="left"><code>armv7l</code></td>
<td align="left">32 位 ARMv7（Little-endian）</td>
<td align="left">树莓派 2 早期版、某些嵌入式板、老手机</td>
</tr>
<tr>
<td align="left"><code>armv6l</code></td>
<td align="left">32 位 ARMv6</td>
<td align="left">树莓派 1&#x2F;Zero、旧款路由器</td>
</tr>
<tr>
<td align="left"><code>i686</code> &#x2F; <code>i386</code></td>
<td align="left">32 位 x86</td>
<td align="left">老旧 PC、极小容器镜像</td>
</tr>
<tr>
<td align="left"><code>mips</code> &#x2F; <code>mips64</code></td>
<td align="left">MIPS32 &#x2F; MIPS64</td>
<td align="left">路由器、龙芯</td>
</tr>
<tr>
<td align="left"><code>ppc64le</code></td>
<td align="left">64 位 PowerPC Little-endian</td>
<td align="left">IBM POWER 服务器、OpenPOWER</td>
</tr>
<tr>
<td align="left"><code>s390x</code></td>
<td align="left">IBM z&#x2F;Architecture</td>
<td align="left">大型机、LinuxONE</td>
</tr>
<tr>
<td align="left"><code>riscv64</code></td>
<td align="left">64 位 RISC-V</td>
<td align="left">新兴开发板、SiFive</td>
</tr>
</tbody></table>
<p>────────────────<br>与 <code>uname -a</code> 的区别</p>
<ul>
<li><code>-m</code> 只看“硬件架构”；</li>
<li><code>-a</code> 会把内核名称、节点名、内核版本、架构等全部打出来，内容更长。</li>
<li><code>uname -m</code> 返回的就是 <strong>“CPU 身份证”</strong>；看到 <code>x86_64</code> 就是 PC，<code>aarch64</code> 就是 ARM64 板。</li>
</ul>
<p>对程序进行交叉编译：</p>
<p>本机64位可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello.x64          <span class="comment"># 默认就是 x86_64</span></span><br></pre></td></tr></table></figure>

<p>查看可执行文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file hello.x64</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.x64: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1234f2d2c59244aae4b4a8cc4015da1ee68ba2dd, not stripped</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hello.x64</span><br></pre></td></tr></table></figure>

<p>可以正常运行</p>
<p>ARM32位可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello.arm32   <span class="comment"># ARM32</span></span><br></pre></td></tr></table></figure>

<p>查看可执行文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file hello.x64</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.arm32: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=71501e52207455e36f5e2df3ca9beef3229858f8, not stripped</span><br></pre></td></tr></table></figure>

<p>运行<code>./hello.arm32</code>会显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/lib/ld-linux-armhf.so.3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>ARM64位可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc   hello.c -o hello.arm64   <span class="comment"># ARM64</span></span><br></pre></td></tr></table></figure>

<p>查看可执行文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file hello.x64</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.arm64: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=1e9a9503efe79366a8c4f51bba5d20cc65f9a7fe, not stripped</span><br></pre></td></tr></table></figure>

<p>运行<code>./hello.arm64</code>会显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/lib/ld-linux-aarch64.so.1: No such file or directory</span><br></pre></td></tr></table></figure>

<p>只想运行单个可执行文件可以使用QEMU 的user-mode，如果交叉编译的程序依赖很多系统库，就需要启动一个虚拟机镜像运行。</p>
<p>常用的 QEMU user-mode 运行器：</p>
<table>
<thead>
<tr>
<th>目标架构</th>
<th>QEMU 命令</th>
</tr>
</thead>
<tbody><tr>
<td>x86_64</td>
<td>qemu-x86_64</td>
</tr>
<tr>
<td>arm</td>
<td>qemu-arm</td>
</tr>
<tr>
<td>aarch64</td>
<td>qemu-aarch64</td>
</tr>
<tr>
<td>riscv64</td>
<td>qemu-riscv64</td>
</tr>
<tr>
<td>mips</td>
<td>qemu-mips</td>
</tr>
</tbody></table>
<p>这种方式只模拟用户空间，不需要虚拟机系统，速度比系统仿真快。</p>
<p>上述交叉编译默认的是动态链接，无法通过QEMU user-mode直接运行，若想要通过QEMU user-mode直接运行，可以选择静态链接的交叉编译，具体方式是编译的时候加<code>-static</code></p>
<p>即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc hello.c -static -o hello.x64   </span><br><span class="line">arm-linux-gnueabihf-gcc hello.c -static -o hello.arm32</span><br><span class="line">aarch64-linux-gnu-gcc   hello.c -static -o hello.arm64 </span><br></pre></td></tr></table></figure>

<p>此时使用file查看可以看到可执行文件变成了静态链接的方式（以hello.arm32为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.arm32: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=daf059fd2211eccfde2c445552f5442b724bbe70, not stripped</span><br></pre></td></tr></table></figure>

<p>然后再使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-arm ./hello.arm32</span><br></pre></td></tr></table></figure>

<p>可以看到程序正常运行。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试技巧</title>
    <url>/2025/07/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="GCC-G-调试技巧指南"><a href="#GCC-G-调试技巧指南" class="headerlink" title="GCC&#x2F;G++ 调试技巧指南"></a>GCC&#x2F;G++ 调试技巧指南</h1><p>在程序开发过程中，调试是定位和解决问题的关键环节。GCC&#x2F;G++ 配合 GDB（GNU 调试器）提供了强大的调试能力，能够帮助开发者追踪程序执行流程、查看变量状态、分析内存问题等。本文将详细介绍基于 GCC&#x2F;G++ 和 GDB 的调试技巧，涵盖从编译准备到高级调试的全流程。</p>
<h2 id="一、调试前的编译准备"><a href="#一、调试前的编译准备" class="headerlink" title="一、调试前的编译准备"></a>一、调试前的编译准备</h2><p>要使用 GDB 调试程序，需在编译阶段生成包含调试信息的可执行文件。GCC&#x2F;G++ 通过 -g 选项添加调试信息（如变量名、行号、函数信息等），常用的调试级别如下：</p>
<ul>
<li><p>-g：生成基本调试信息（推荐默认使用）。</p>
</li>
<li><p>-g3：包含更多调试信息（如宏定义、注释等），适合复杂项目。</p>
</li>
<li><p>-ggdb：生成 GDB 专用的调试信息，优化调试体验。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<p>编译包含调试信息的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test  # 基本调试信息</span><br><span class="line">g++ -g3 main.cpp func.cpp -o main  # 高级调试信息（多文件）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：调试时建议关闭代码优化（如 -O0，默认不优化），避免优化导致的代码逻辑与源码不一致（如变量被优化掉、循环展开等）。若需同时优化和调试，可使用 -Og 选项（专为调试设计的轻度优化）。</p>
</blockquote>
<h2 id="二、GDB-基本操作流程"><a href="#二、GDB-基本操作流程" class="headerlink" title="二、GDB 基本操作流程"></a>二、GDB 基本操作流程</h2><h3 id="1-启动-GDB"><a href="#1-启动-GDB" class="headerlink" title="1. 启动 GDB"></a>1. 启动 GDB</h3><p>在终端中通过以下命令启动 GDB 并加载可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./test  # 直接启动并加载test</span><br><span class="line">gdb -args ./test arg1 arg2  # 带命令行参数启动（arg1、arg2为程序参数）</span><br></pre></td></tr></table></figure>

<p>启动后进入 GDB 交互界面，提示符为 (gdb)，可输入调试命令。</p>
<h3 id="2-常用基础命令"><a href="#2-常用基础命令" class="headerlink" title="2. 常用基础命令"></a>2. 常用基础命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>简化形式</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>启动程序（可带参数，如 run arg1）</td>
<td>r</td>
</tr>
<tr>
<td>quit</td>
<td>退出 GDB</td>
<td>q</td>
</tr>
<tr>
<td>help &lt;命令&gt;</td>
<td>查看命令帮助（如 help break）</td>
<td>h</td>
</tr>
<tr>
<td>list &lt;文件名:行号&gt;</td>
<td>显示源码（默认显示当前位置附近）</td>
<td>l</td>
</tr>
<tr>
<td>set args &lt;参数&gt;</td>
<td>设置程序运行参数（如 set args 10 20）</td>
<td>-</td>
</tr>
<tr>
<td>show args</td>
<td>查看当前设置的运行参数</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="三、断点调试：控制程序执行流程"><a href="#三、断点调试：控制程序执行流程" class="headerlink" title="三、断点调试：控制程序执行流程"></a>三、断点调试：控制程序执行流程</h2><p>断点是调试的核心工具，用于在指定位置暂停程序执行，以便查看变量状态、调用栈等。GDB 支持多种类型的断点，满足不同场景需求。</p>
<h3 id="1-基本断点（按行号-函数）"><a href="#1-基本断点（按行号-函数）" class="headerlink" title="1. 基本断点（按行号 &#x2F; 函数）"></a>1. 基本断点（按行号 &#x2F; 函数）</h3><ul>
<li><strong>按行号设置断点</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break test.c:10  # 在test.c的第10行设置断点</span><br><span class="line">(gdb) b main.cpp:25    # 简化命令（b = break）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>按函数名设置断点</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break add  # 在函数add()入口设置断点（适用于全局函数）</span><br><span class="line">(gdb) b MyClass::method  # C++类成员函数（需带类名）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看所有断点</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints  # 显示断点编号、位置、状态</span><br><span class="line">(gdb) i b  # 简化形式</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>删除断点</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) delete 1  # 删除编号为1的断点</span><br><span class="line">(gdb) d 2       # 简化形式（d = delete）</span><br><span class="line">(gdb) clear test.c:10  # 删除指定行的断点</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>临时禁用 &#x2F; 启用断点</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disable 1  # 禁用编号1的断点（不删除，状态为n）</span><br><span class="line">(gdb) enable 1   # 启用编号1的断点（状态为y）</span><br></pre></td></tr></table></figure>

<h3 id="2-条件断点：满足条件时暂停"><a href="#2-条件断点：满足条件时暂停" class="headerlink" title="2. 条件断点：满足条件时暂停"></a>2. 条件断点：满足条件时暂停</h3><p>当需要在特定条件下暂停程序（如变量达到某个值、表达式为真），可使用条件断点，避免无意义的暂停。</p>
<p><strong>示例</strong>：</p>
<p>在循环中，当 i &#x3D;&#x3D; 100 时暂停：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break loop.c:5 if i == 100  # loop.c第5行，i等于100时触发</span><br></pre></td></tr></table></figure>

<p>修改已有断点的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) condition 1 (x &gt; 100 &amp;&amp; y &lt; 50)  # 为编号1的断点设置新条件</span><br></pre></td></tr></table></figure>

<h3 id="3-监视断点：跟踪变量-表达式变化"><a href="#3-监视断点：跟踪变量-表达式变化" class="headerlink" title="3. 监视断点：跟踪变量 &#x2F; 表达式变化"></a>3. 监视断点：跟踪变量 &#x2F; 表达式变化</h3><p>监视断点（watch）用于在变量或表达式的值发生变化时自动暂停程序，适合追踪变量被意外修改的场景。</p>
<ul>
<li><p>watch &lt;变量&#x2F;表达式&gt;：当值被修改时暂停（写监视）。</p>
</li>
<li><p>rwatch &lt;变量&#x2F;表达式&gt;：当值被读取时暂停（读监视）。</p>
</li>
<li><p>awatch &lt;变量&#x2F;表达式&gt;：当值被读取或修改时暂停（读写监视）。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch count  # 当count被修改时暂停</span><br><span class="line">(gdb) rwatch array[0]  # 当array[0]被读取时暂停</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：监视断点仅在程序运行时生效，且可能影响性能（频繁修改的变量会多次触发暂停）。</p>
</blockquote>
<h3 id="4-执行控制：单步调试与继续运行"><a href="#4-执行控制：单步调试与继续运行" class="headerlink" title="4. 执行控制：单步调试与继续运行"></a>4. 执行控制：单步调试与继续运行</h3><p>程序暂停后，可通过以下命令控制执行流程：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>简化形式</th>
</tr>
</thead>
<tbody><tr>
<td>next</td>
<td>执行下一行（跳过函数调用，视为一步）</td>
<td>n</td>
</tr>
<tr>
<td>step</td>
<td>执行下一行（进入函数调用，逐语句执行）</td>
<td>s</td>
</tr>
<tr>
<td>continue</td>
<td>继续执行到下一个断点</td>
<td>c</td>
</tr>
<tr>
<td>finish</td>
<td>执行完当前函数并返回（跳出函数）</td>
<td>fin</td>
</tr>
<tr>
<td>until &lt;行号&gt;</td>
<td>执行到指定行（常用于跳出循环）</td>
<td>u</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) n  # 单步执行，不进入函数</span><br><span class="line">(gdb) s  # 单步执行，进入当前行的函数</span><br><span class="line">(gdb) c  # 继续运行到下一个断点</span><br><span class="line">(gdb) fin  # 执行完当前函数后暂停</span><br></pre></td></tr></table></figure>

<h2 id="四、变量与内存查看技巧"><a href="#四、变量与内存查看技巧" class="headerlink" title="四、变量与内存查看技巧"></a>四、变量与内存查看技巧</h2><p>程序暂停时，需查看变量值、内存状态等信息以定位问题。GDB 提供了丰富的命令用于检查数据。</p>
<h3 id="1-查看变量值"><a href="#1-查看变量值" class="headerlink" title="1. 查看变量值"></a>1. 查看变量值</h3><ul>
<li><strong>基本变量查看</strong>：</li>
</ul>
<p>使用 print 命令打印变量或表达式的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print x  # 打印变量x的值</span><br><span class="line">(gdb) p sum + 10  # 简化命令（p = print），打印表达式sum+10</span><br><span class="line">(gdb) p array[0..5]  # 打印数组array的前6个元素（0到5索引）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自动刷新变量</strong>：</li>
</ul>
<p>使用 display 命令设置自动显示的变量（程序暂停时自动打印）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) display i  # 每次暂停自动显示i的值</span><br><span class="line">(gdb) undisplay 1  # 取消编号1的自动显示（通过info display查看编号）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看字符串与结构体</strong>：</li>
</ul>
<p>GDB 会自动解析数据类型，直接打印即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p str  # 打印字符串（char*类型）</span><br><span class="line">(gdb) p student  # 打印结构体student的所有成员（如name、age）</span><br><span class="line">(gdb) p student.name  # 打印结构体成员name</span><br></pre></td></tr></table></figure>

<h3 id="2-内存查看与修改"><a href="#2-内存查看与修改" class="headerlink" title="2. 内存查看与修改"></a>2. 内存查看与修改</h3><ul>
<li><strong>查看内存内容</strong>：</li>
</ul>
<p>使用 x 命令（examine）查看指定内存地址的内容，格式为 x&#x2F;<n><f><u>：</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/10xw 0x7fffffffde40  # 以16进制（x）、4字节（w）显示从0x7fffffffde40开始的10个单元</span><br><span class="line">(gdb) x/s str  # 以字符串格式显示变量str指向的内存</span><br><span class="line">(gdb) x/5i $pc  # 显示当前程序计数器（$pc）指向的5条汇编指令</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>n：显示的单元数</li>
</ul>
</li>
<li><ul>
<li>f：格式（x&#x3D; 十六进制，d&#x3D; 十进制，s&#x3D; 字符串，i&#x3D; 指令）</li>
</ul>
</li>
<li><ul>
<li>u：单元大小（b&#x3D;1 字节，h&#x3D;2 字节，w&#x3D;4 字节，g&#x3D;8 字节）</li>
</ul>
</li>
<li><p><strong>修改内存值</strong>：</p>
</li>
</ul>
<p>使用 set 命令修改变量或内存地址的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set x = 100  # 将变量x的值改为100</span><br><span class="line">(gdb) set *0x7fffffffde40 = 200  # 直接修改内存地址的值为200</span><br></pre></td></tr></table></figure>

<h3 id="3-查看调用栈"><a href="#3-查看调用栈" class="headerlink" title="3. 查看调用栈"></a>3. 查看调用栈</h3><p>调用栈（Call Stack）记录了函数调用关系（从当前函数到 main 函数的层级），通过 backtrace 命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) backtrace  # 显示完整调用栈</span><br><span class="line">(gdb) bt  # 简化命令</span><br><span class="line">(gdb) bt 3  # 只显示最内层的3个函数</span><br></pre></td></tr></table></figure>

<p>切换调用栈帧（查看上层函数的变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) frame 1  # 切换到编号1的栈帧（上层函数）</span><br><span class="line">(gdb) f 0  # 简化命令（f = frame），切换到当前函数（编号0）</span><br></pre></td></tr></table></figure>

<h2 id="五、多文件与多线程调试"><a href="#五、多文件与多线程调试" class="headerlink" title="五、多文件与多线程调试"></a>五、多文件与多线程调试</h2><h3 id="1-多文件调试"><a href="#1-多文件调试" class="headerlink" title="1. 多文件调试"></a>1. 多文件调试</h3><p>当程序包含多个源文件时，需通过文件名定位代码或设置断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) list func.c:15  # 显示func.c的第15行</span><br><span class="line">(gdb) break utils.h:init  # 在头文件utils.h中定义的init函数处设断点</span><br><span class="line">(gdb) p &#x27;file.c::global_var&#x27;  # 访问其他文件的全局变量（避免重名）</span><br></pre></td></tr></table></figure>

<h3 id="2-多线程调试"><a href="#2-多线程调试" class="headerlink" title="2. 多线程调试"></a>2. 多线程调试</h3><p>GDB 支持多线程程序的调试，核心命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>info threads</td>
<td>显示所有线程（包含线程 ID、状态、所在函数）</td>
</tr>
<tr>
<td>thread <ID></td>
<td>切换到指定 ID 的线程</td>
</tr>
<tr>
<td>break &lt;位置&gt; thread <ID></td>
<td>仅在指定线程设置断点</td>
</tr>
<tr>
<td>set scheduler-locking on</td>
<td>调试当前线程时，暂停其他线程（避免干扰）</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info threads  # 查看所有线程</span><br><span class="line">  1 Thread 0x7ffff7fc1700 (LWP 1234)  main() at test.c:5</span><br><span class="line">* 2 Thread 0x7ffff77c0700 (LWP 1235)  worker() at func.c:20</span><br><span class="line"># 带*的为当前线程（ID=2）</span><br><span class="line"></span><br><span class="line">(gdb) thread 1  # 切换到线程1</span><br><span class="line">(gdb) b test.c:10 thread 1  # 仅在线程1的test.c第10行设断点</span><br><span class="line">(gdb) set scheduler-locking on  # 锁定当前线程，其他线程暂停</span><br></pre></td></tr></table></figure>

<h2 id="六、调试核心转储文件（Core-Dump）"><a href="#六、调试核心转储文件（Core-Dump）" class="headerlink" title="六、调试核心转储文件（Core Dump）"></a>六、调试核心转储文件（Core Dump）</h2><p>当程序崩溃（如段错误 Segmentation fault）时，可通过核心转储文件（core dump）记录崩溃瞬间的内存状态，事后分析原因。</p>
<h3 id="1-开启核心转储"><a href="#1-开启核心转储" class="headerlink" title="1. 开启核心转储"></a>1. 开启核心转储</h3><p>默认情况下，系统可能关闭核心转储功能，需先开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited  # 临时开启核心转储（当前终端有效）</span><br><span class="line"># 永久开启：在/etc/security/limits.conf中添加</span><br><span class="line"># * soft core unlimited</span><br></pre></td></tr></table></figure>

<p>程序崩溃后会生成名为 core.<PID> 的文件（如 core.1234）。</p>
<h3 id="2-分析核心转储文件"><a href="#2-分析核心转储文件" class="headerlink" title="2. 分析核心转储文件"></a>2. 分析核心转储文件</h3><p>使用 GDB 加载核心文件和可执行文件，重现崩溃状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./test core.1234  # 加载可执行文件test和核心文件core.1234</span><br></pre></td></tr></table></figure>

<p>加载后，GDB 会显示崩溃位置（如函数、行号、信号类型），结合 bt 命令查看调用栈即可定位问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt  # 查看崩溃时的调用栈，快速找到错误函数</span><br></pre></td></tr></table></figure>

<h2 id="七、实用调试技巧与注意事项"><a href="#七、实用调试技巧与注意事项" class="headerlink" title="七、实用调试技巧与注意事项"></a>七、实用调试技巧与注意事项</h2><ol>
<li><strong>忽略信号</strong>：</li>
</ol>
<p>程序可能因某些信号（如 SIGPIPE）退出，可通过 handle 命令忽略或捕获信号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) handle SIGPIPE nostop noprint  # 忽略SIGPIPE信号（不暂停、不打印）</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>宏调试</strong>：</li>
</ol>
<p>若使用 -g3 编译，可通过 info macro 查看宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info macro MAX  # 查看宏MAX的定义和位置</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>保存调试会话</strong>：</li>
</ol>
<p>通过 save commands &lt;文件&gt; 保存当前调试命令，下次通过 source &lt;文件&gt; 加载，避免重复输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) save commands debug_cmds.txt  # 保存命令</span><br><span class="line">(gdb) source debug_cmds.txt  # 加载命令</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>避免常见陷阱</strong>：</li>
</ol>
<ul>
<li><ul>
<li>优化导致的变量不可见：若变量被 -O2 等优化掉，需改用 -O0 或 -Og 编译。</li>
</ul>
</li>
<li><ul>
<li>多线程竞争：使用 scheduler-locking 锁定线程，逐步调试竞争条件。</li>
</ul>
</li>
<li><ul>
<li>动态库调试：确保动态库也包含调试信息（编译时加 -g），否则可能无法查看库内函数。</li>
</ul>
</li>
</ul>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>GCC&#x2F;G++ 与 GDB 结合提供了强大的调试能力，核心流程可概括为：</p>
<ol>
<li><p>用 -g 编译含调试信息的程序；</p>
</li>
<li><p>通过 GDB 启动程序，设置断点控制执行；</p>
</li>
<li><p>利用 print、backtrace 等命令查看变量和调用栈；</p>
</li>
<li><p>结合多线程调试、核心转储分析等高级功能解决复杂问题。</p>
</li>
</ol>
<p>掌握这些技巧能显著提升调试效率，尤其在定位逻辑错误、内存泄漏、多线程竞争等问题时不可或缺。实际开发中，可根据项目复杂度灵活选择调试命令，逐步积累调试经验。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI串行通信协议</title>
    <url>/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/SPI%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>当然可以！SPI（Serial Peripheral Interface，串行外设接口）是一种<strong>高速、全双工、同步、主从式</strong>的串行通信协议，由 Motorola 在 1980 年代提出，广泛用于微控制器与各类外设（如 Flash、ADC、DAC、LCD、传感器、RF 模块等）之间的短距离通信。</p>
<hr>
<h2 id="一、SPI-的核心特点"><a href="#一、SPI-的核心特点" class="headerlink" title="一、SPI 的核心特点"></a>一、SPI 的核心特点</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信方式</strong></td>
<td>同步（由主设备提供时钟）</td>
</tr>
<tr>
<td><strong>数据流向</strong></td>
<td>全双工（主从可同时收发）</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>高速（可达几十 Mbps，甚至上百 Mbps）</td>
</tr>
<tr>
<td><strong>线数</strong></td>
<td>通常 4 线（可简化为 3 线或 2 线）</td>
</tr>
<tr>
<td><strong>拓扑结构</strong></td>
<td>主从架构（1 主 + N 从）</td>
</tr>
<tr>
<td><strong>驱动方式</strong></td>
<td>推挽输出（信号边沿陡峭，抗干扰强）</td>
</tr>
<tr>
<td><strong>协议复杂度</strong></td>
<td>无地址、无应答、无校验（简单高效）</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、SPI-的信号线（4-线制标准）"><a href="#二、SPI-的信号线（4-线制标准）" class="headerlink" title="二、SPI 的信号线（4 线制标准）"></a>二、SPI 的信号线（4 线制标准）</h2><table>
<thead>
<tr>
<th>信号线</th>
<th>全称</th>
<th>方向</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SCLK</strong></td>
<td>Serial Clock</td>
<td>主 → 从</td>
<td>时钟信号，由主设备产生，同步数据传输</td>
</tr>
<tr>
<td><strong>MOSI</strong></td>
<td>Master Out Slave In</td>
<td>主 → 从</td>
<td>主设备发送，从设备接收的数据线</td>
</tr>
<tr>
<td><strong>MISO</strong></td>
<td>Master In Slave Out</td>
<td>从 → 主</td>
<td>从设备发送，主设备接收的数据线</td>
</tr>
<tr>
<td><strong>CS&#x2F;SS</strong></td>
<td>Chip Select &#x2F; Slave Select</td>
<td>主 → 从</td>
<td>片选信号，低电平有效，用于选择特定从设备</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 注意：每个从设备需要<strong>独立的 CS 信号线</strong>，因此从设备越多，主设备占用的 GPIO 越多。</p>
</blockquote>
<hr>
<h2 id="三、SPI-的工作原理"><a href="#三、SPI-的工作原理" class="headerlink" title="三、SPI 的工作原理"></a>三、SPI 的工作原理</h2><h3 id="1-主从架构"><a href="#1-主从架构" class="headerlink" title="1. 主从架构"></a>1. <strong>主从架构</strong></h3><ul>
<li><strong>主设备（Master）</strong>：通常是 MCU，负责产生 SCLK 和 CS 信号，发起通信。</li>
<li><strong>从设备（Slave）</strong>：如传感器、Flash 等，被动响应主设备。</li>
</ul>
<h3 id="2-通信流程"><a href="#2-通信流程" class="headerlink" title="2. 通信流程"></a>2. <strong>通信流程</strong></h3><ol>
<li>主设备将目标从设备的 <strong>CS 拉低</strong>（激活从设备）。</li>
<li>主设备开始发送 <strong>SCLK 时钟</strong>。</li>
<li>在每个时钟边沿：<ul>
<li>主设备通过 <strong>MOSI</strong> 发送 1 位数据；</li>
<li>从设备通过 <strong>MISO</strong> 同时发送 1 位数据（全双工）。</li>
</ul>
</li>
<li>通常传输 <strong>8 位（1 字节）为单位</strong>，可连续发送多字节。</li>
<li>通信结束后，主设备将 <strong>CS 拉高</strong>，结束本次传输。</li>
</ol>
<blockquote>
<p>✅ 优势：无需应答、无地址开销，效率极高。</p>
</blockquote>
<hr>
<h2 id="四、SPI-的时序模式：CPOL-与-CPHA"><a href="#四、SPI-的时序模式：CPOL-与-CPHA" class="headerlink" title="四、SPI 的时序模式：CPOL 与 CPHA"></a>四、SPI 的时序模式：CPOL 与 CPHA</h2><p>SPI 有 <strong>4 种工作模式</strong>，由两个参数决定：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPOL（Clock Polarity）</strong></td>
<td>时钟空闲时的电平： • CPOL&#x3D;0：空闲时 SCLK&#x3D;0（低电平） • CPOL&#x3D;1：空闲时 SCLK&#x3D;1（高电平）</td>
</tr>
<tr>
<td><strong>CPHA（Clock Phase）</strong></td>
<td>数据采样时机： • CPHA&#x3D;0：在<strong>第一个</strong>时钟边沿采样 • CPHA&#x3D;1：在<strong>第二个</strong>时钟边沿采样</td>
</tr>
</tbody></table>
<h3 id="四种模式组合："><a href="#四种模式组合：" class="headerlink" title="四种模式组合："></a>四种模式组合：</h3><table>
<thead>
<tr>
<th>模式</th>
<th>CPOL</th>
<th>CPHA</th>
<th>时钟空闲电平</th>
<th>采样边沿</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mode 0</strong></td>
<td>0</td>
<td>0</td>
<td>低</td>
<td>上升沿（0→1）</td>
</tr>
<tr>
<td><strong>Mode 1</strong></td>
<td>0</td>
<td>1</td>
<td>低</td>
<td>下降沿（1→0）</td>
</tr>
<tr>
<td><strong>Mode 2</strong></td>
<td>1</td>
<td>0</td>
<td>高</td>
<td>下降沿（1→0）</td>
</tr>
<tr>
<td><strong>Mode 3</strong></td>
<td>1</td>
<td>1</td>
<td>高</td>
<td>上升沿（0→1）</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ <strong>主从设备必须使用相同的模式</strong>，否则通信失败！</p>
</blockquote>
<hr>
<h2 id="五、SPI-的接线方式"><a href="#五、SPI-的接线方式" class="headerlink" title="五、SPI 的接线方式"></a>五、SPI 的接线方式</h2><h3 id="1-标准-1-主-N-从（独立片选）"><a href="#1-标准-1-主-N-从（独立片选）" class="headerlink" title="1. 标准 1 主 N 从（独立片选）"></a>1. <strong>标准 1 主 N 从（独立片选）</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+      +--------+      +--------+</span><br><span class="line">| Slave1 |      | Slave2 |      | SlaveN |</span><br><span class="line">+--------+      +--------+      +--------+</span><br><span class="line">   ↑  ↑             ↑  ↑             ↑  ↑</span><br><span class="line">  MISO MOSI       MISO MOSI        MISO MOSI</span><br><span class="line">   │    │           │    │           │    │</span><br><span class="line">   └────┼───────────┼────┼───────────┘    │</span><br><span class="line">        │           │    │                │</span><br><span class="line">      ┌─┴───────────┴────┴────────────────┴─┐</span><br><span class="line">      │               Master                 │</span><br><span class="line">      │  SCLK ───────────────────────────────┘</span><br><span class="line">      │  CS1 ────────────┐</span><br><span class="line">      │  CS2 ────────────────┐</span><br><span class="line">      │  CSN ────────────────────┐</span><br><span class="line">      └──────────────────────────┘</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：简单可靠，从设备互不影响。</li>
<li>缺点：每增加一个从设备，需多一个 CS 引脚。</li>
</ul>
<h3 id="2-菊花链（Daisy-Chain）"><a href="#2-菊花链（Daisy-Chain）" class="headerlink" title="2. 菊花链（Daisy Chain）"></a>2. <strong>菊花链（Daisy Chain）</strong></h3><ul>
<li>所有从设备<strong>共用一个 CS</strong>，MISO 串接：<br>Master → MOSI → Slave1 → Slave2 → … → MISO → Master</li>
<li>适用于级联移位寄存器等场景（如 LED 驱动）。</li>
<li>缺点：不能单独访问某个从设备，延迟大。</li>
</ul>
<hr>
<h2 id="六、SPI-的优缺点"><a href="#六、SPI-的优缺点" class="headerlink" title="六、SPI 的优缺点"></a>六、SPI 的优缺点</h2><h3 id="✅-优点："><a href="#✅-优点：" class="headerlink" title="✅ 优点："></a>✅ 优点：</h3><ul>
<li><strong>高速</strong>：无协议开销，可达系统时钟的 1&#x2F;2（如 STM32 可达 50+ Mbps）。</li>
<li><strong>全双工</strong>：收发同时进行，效率高。</li>
<li><strong>硬件实现简单</strong>：多数 MCU 内置 SPI 控制器。</li>
<li><strong>信号质量好</strong>：推挽输出，边沿陡峭，抗干扰强。</li>
<li><strong>灵活的数据长度</strong>：支持 4~16 位（甚至更多）每帧。</li>
</ul>
<h3 id="❌-缺点："><a href="#❌-缺点：" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h3><ul>
<li><strong>引脚占用多</strong>：每个从设备需独立 CS。</li>
<li><strong>无流控&#x2F;应答机制</strong>：无法确认从设备是否收到（需软件实现）。</li>
<li><strong>无标准协议层</strong>：不同厂商设备命令格式各异，需查手册。</li>
<li><strong>不支持多主</strong>：只能有一个主设备（除非用额外逻辑仲裁）。</li>
<li><strong>距离短</strong>：一般用于板内通信（&lt; 30cm），高速时更短。</li>
</ul>
<hr>
<h2 id="七、SPI-vs-I²C-vs-UART（简要对比）"><a href="#七、SPI-vs-I²C-vs-UART（简要对比）" class="headerlink" title="七、SPI vs I²C vs UART（简要对比）"></a>七、SPI vs I²C vs UART（简要对比）</h2><table>
<thead>
<tr>
<th>特性</th>
<th>SPI</th>
<th>I²C</th>
<th>UART</th>
</tr>
</thead>
<tbody><tr>
<td>线数</td>
<td>3~4（+CS）</td>
<td>2</td>
<td>2（TX&#x2F;RX）</td>
</tr>
<tr>
<td>速度</td>
<td>高（Mbps~100+ Mbps）</td>
<td>低（100kbps~3.4Mbps）</td>
<td>中（9600~10Mbps）</td>
</tr>
<tr>
<td>全&#x2F;半双工</td>
<td>全双工</td>
<td>半双工</td>
<td>全双工（异步）</td>
</tr>
<tr>
<td>主从结构</td>
<td>1 主多从</td>
<td>多主多从</td>
<td>点对点</td>
</tr>
<tr>
<td>地址机制</td>
<td>片选（硬件）</td>
<td>软件地址</td>
<td>无（点对点）</td>
</tr>
<tr>
<td>抗干扰</td>
<td>强（推挽）</td>
<td>弱（开漏）</td>
<td>中（依赖电平标准）</td>
</tr>
<tr>
<td>距离</td>
<td>短（板内）</td>
<td>短</td>
<td>可较长（加驱动）</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、典型应用场景"><a href="#八、典型应用场景" class="headerlink" title="八、典型应用场景"></a>八、典型应用场景</h2><ul>
<li><strong>Flash 存储器</strong>：W25Q128（SPI Flash）</li>
<li><strong>显示屏</strong>：OLED（SSD1306）、TFT LCD</li>
<li><strong>ADC&#x2F;DAC</strong>：MCP3008（ADC）、MCP4921（DAC）</li>
<li><strong>传感器</strong>：MPU6050（陀螺仪）、BMP280（气压）</li>
<li><strong>RF 模块</strong>：nRF24L01、LoRa（SX1278）</li>
<li><strong>音频编解码器</strong>：PCM5102</li>
</ul>
<hr>
<h2 id="九、使用注意事项"><a href="#九、使用注意事项" class="headerlink" title="九、使用注意事项"></a>九、使用注意事项</h2><ol>
<li><strong>模式匹配</strong>：务必确认主从设备的 CPOL&#x2F;CPHA 一致。</li>
<li><strong>CS 时序</strong>：有些设备要求 CS 在字节间不能释放（如 Flash 写命令）。</li>
<li><strong>电源与地</strong>：高速 SPI 对电源噪声敏感，需良好去耦。</li>
<li><strong>走线等长</strong>：MOSI&#x2F;MISO&#x2F;SCLK 尽量等长，减少 skew。</li>
<li><strong>上拉&#x2F;下拉</strong>：CS 通常需上拉电阻，防止上电时误触发。</li>
</ol>
<hr>
<h2 id="十、扩展：QSPI-Dual-Quad-SPI"><a href="#十、扩展：QSPI-Dual-Quad-SPI" class="headerlink" title="十、扩展：QSPI &#x2F; Dual&#x2F;Quad SPI"></a>十、扩展：QSPI &#x2F; Dual&#x2F;Quad SPI</h2><p>为提升速度，许多 Flash 支持 <strong>Dual SPI（2 位并行）</strong> 或 <strong>Quad SPI（4 位并行）</strong>，使用额外的 IO 引脚同时传输多位数据，速率提升 2~4 倍。STM32 等 MCU 也支持 <strong>QSPI 接口</strong>，用于高速访问外部 Flash。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>SPI通信</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译</title>
    <url>/2025/07/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="交叉编译详解：从基础到实践"><a href="#交叉编译详解：从基础到实践" class="headerlink" title="交叉编译详解：从基础到实践"></a>交叉编译详解：从基础到实践</h1><p>在嵌入式开发、跨平台应用部署等场景中，交叉编译是一项核心技术。它解决了 “在高性能主机上为资源受限的目标设备编译程序” 的问题。本文将从基础概念出发，逐步深入交叉编译的工具链使用、流程设计及常见问题解决，帮助读者掌握跨平台开发的关键技能。</p>
<h2 id="一、交叉编译基础"><a href="#一、交叉编译基础" class="headerlink" title="一、交叉编译基础"></a>一、交叉编译基础</h2><h3 id="（一）什么是交叉编译？"><a href="#（一）什么是交叉编译？" class="headerlink" title="（一）什么是交叉编译？"></a>（一）什么是交叉编译？</h3><p>交叉编译是指在<strong>主机平台</strong>（如 x86 架构的 PC）上编译出能在<strong>目标平台</strong>（如 ARM 架构的嵌入式设备）上运行的程序。与本地编译（在目标平台上直接编译）相比，交叉编译的核心优势在于：</p>
<ul>
<li><p>目标设备资源有限（如嵌入式芯片算力低、存储空间小），无法直接运行编译器。</p>
</li>
<li><p>提高开发效率：主机平台（如 PC）性能更强，编译速度更快。</p>
</li>
<li><p>支持多平台开发：一套代码可通过交叉编译适配不同架构（ARM、MIPS、RISC-V 等）。</p>
</li>
</ul>
<h3 id="（二）交叉编译与本地编译的区别"><a href="#（二）交叉编译与本地编译的区别" class="headerlink" title="（二）交叉编译与本地编译的区别"></a>（二）交叉编译与本地编译的区别</h3><table>
<thead>
<tr>
<th>维度</th>
<th>本地编译</th>
<th>交叉编译</th>
</tr>
</thead>
<tbody><tr>
<td>编译环境</td>
<td>目标平台自身</td>
<td>主机平台（如 x86 PC）</td>
</tr>
<tr>
<td>编译器</td>
<td>目标平台原生编译器（如gcc）</td>
<td>交叉编译器（如arm-linux-gcc）</td>
</tr>
<tr>
<td>依赖库</td>
<td>主机与目标平台一致</td>
<td>需使用目标平台专用库</td>
</tr>
<tr>
<td>应用场景</td>
<td>桌面程序、服务器程序</td>
<td>嵌入式设备、跨平台应用</td>
</tr>
</tbody></table>
<h3 id="（三）典型应用场景"><a href="#（三）典型应用场景" class="headerlink" title="（三）典型应用场景"></a>（三）典型应用场景</h3><ol>
<li><p><strong>嵌入式开发</strong>：为 ARM 架构的单片机、物联网设备（如树莓派、路由器）编译程序。</p>
</li>
<li><p><strong>跨架构部署</strong>：为 MIPS 架构的路由器、RISC-V 架构的开发板编译定制化工具。</p>
</li>
<li><p><strong>资源受限设备</strong>：为内存仅几 MB 的嵌入式芯片（如 STM32）编译固件。</p>
</li>
<li><p><strong>多平台适配</strong>：开源项目（如 Linux 内核、FFmpeg）需支持多种架构，通过交叉编译实现一次代码多平台输出。</p>
</li>
</ol>
<h2 id="二、交叉编译工具链"><a href="#二、交叉编译工具链" class="headerlink" title="二、交叉编译工具链"></a>二、交叉编译工具链</h2><p>交叉编译的核心是<strong>交叉工具链</strong>—— 一套针对目标平台的编译器、链接器、库文件等工具的集合。理解工具链的命名规则和组成，是使用交叉编译的前提。</p>
<h3 id="（一）工具链的命名规则"><a href="#（一）工具链的命名规则" class="headerlink" title="（一）工具链的命名规则"></a>（一）工具链的命名规则</h3><p>交叉工具链的命名通常遵循固定格式，通过名称可直接判断其支持的目标平台。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc</span><br></pre></td></tr></table></figure>

<p>命名拆解：</p>
<ul>
<li><p>arm：目标平台的<strong>架构</strong>（如 arm、mips、riscv、x86_64）。</p>
</li>
<li><p>linux：目标平台的<strong>操作系统</strong>（如 linux、none-eabi 表示无操作系统的裸机环境）。</p>
</li>
<li><p>gnueabihf：<strong>ABI（应用二进制接口）</strong> 及浮点策略（hf表示硬件浮点支持）。</p>
</li>
<li><p>gcc：工具类型（编译器，其他如g++、ld、objcopy等）。</p>
</li>
</ul>
<p>常见工具链名称示例：</p>
<ul>
<li><p>mipsel-linux-gcc：针对小端模式（el）MIPS 架构 Linux 系统的编译器。</p>
</li>
<li><p>riscv64-unknown-linux-gnu-gcc：针对 64 位 RISC-V 架构 Linux 系统的编译器。</p>
</li>
<li><p>arm-none-eabi-gcc：针对 ARM 架构裸机环境（无操作系统）的编译器（常用于单片机）。</p>
</li>
</ul>
<h3 id="（二）工具链的组成"><a href="#（二）工具链的组成" class="headerlink" title="（二）工具链的组成"></a>（二）工具链的组成</h3><p>一套完整的交叉工具链包含以下核心组件：</p>
<ol>
<li><p><strong>编译器</strong>：如arm-linux-gcc（C 编译器）、arm-linux-g++（C++ 编译器）。</p>
</li>
<li><p><strong>链接器</strong>：arm-linux-ld，负责将目标文件链接为可执行文件。</p>
</li>
<li><p><strong>二进制工具</strong>：arm-linux-objcopy（格式转换）、arm-linux-objdump（反汇编）等。</p>
</li>
<li><p><strong>目标平台库</strong>：包含目标架构的标准库（如libc）、数学库（libm）等，路径通常在工具链的sysroot&#x2F;usr&#x2F;lib目录下。</p>
</li>
<li><p><strong>头文件</strong>：目标平台的系统头文件（如stdio.h），路径通常在sysroot&#x2F;usr&#x2F;include。</p>
</li>
</ol>
<h3 id="（三）工具链的获取与安装"><a href="#（三）工具链的获取与安装" class="headerlink" title="（三）工具链的获取与安装"></a>（三）工具链的获取与安装</h3><h4 id="1-包管理器安装（适用于主流-Linux-发行版）"><a href="#1-包管理器安装（适用于主流-Linux-发行版）" class="headerlink" title="1. 包管理器安装（适用于主流 Linux 发行版）"></a>1. 包管理器安装（适用于主流 Linux 发行版）</h4><p>Ubuntu&#x2F;Debian 系统可通过apt直接安装常用交叉工具链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装ARM 32位Linux工具链（支持硬件浮点）</span><br><span class="line">sudo apt install gcc-arm-linux-gnueabihf</span><br><span class="line"># 安装ARM 64位Linux工具链</span><br><span class="line">sudo apt install gcc-aarch64-linux-gnu</span><br><span class="line"># 安装MIPS 32位工具链</span><br><span class="line">sudo apt install gcc-mips-linux-gnu</span><br></pre></td></tr></table></figure>

<h4 id="2-官方工具链下载"><a href="#2-官方工具链下载" class="headerlink" title="2. 官方工具链下载"></a>2. 官方工具链下载</h4><p>嵌入式芯片厂商（如 NXP、TI）或开源组织会提供专用工具链：</p>
<ul>
<li><p><strong>Linaro</strong>：专注于 ARM 架构的开源工具链（<a href="https://releases.linaro.org/">https://releases.linar</a><a href="https://releases.linaro.org/">o.org</a><a href="https://releases.linaro.org/">&#x2F;</a>）。</p>
</li>
<li><p><strong>Buildroot&#x2F;Yocto</strong>：可定制嵌入式系统的工具链生成工具（适合复杂场景）。</p>
</li>
<li><p>芯片厂商官网：如 NVIDIA Jetson 系列、华为海思芯片的专用工具链。</p>
</li>
</ul>
<h4 id="3-手动编译工具链（进阶）"><a href="#3-手动编译工具链（进阶）" class="headerlink" title="3. 手动编译工具链（进阶）"></a>3. 手动编译工具链（进阶）</h4><p>通过crosstool-ng工具可自定义工具链（支持指定 GCC 版本、目标架构等），步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">sudo apt install autoconf automake libtool ncurses-dev</span><br><span class="line"># 下载crosstool-ng</span><br><span class="line">git clone https://github.com/crosstool-ng/crosstool-ng.git</span><br><span class="line">cd crosstool-ng</span><br><span class="line"># 配置并编译</span><br><span class="line">./bootstrap &amp;&amp; ./configure --prefix=/opt/ct-ng</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"># 配置目标工具链（如ARMv7架构）</span><br><span class="line">ct-ng arm-cortexa9-linux-gnueabihf</span><br><span class="line"># 编译工具链（耗时较长）</span><br><span class="line">ct-ng build</span><br></pre></td></tr></table></figure>

<h2 id="三、交叉编译基本流程"><a href="#三、交叉编译基本流程" class="headerlink" title="三、交叉编译基本流程"></a>三、交叉编译基本流程</h2><p>以 “在 x86_64 Linux 主机上为 ARM 架构 Linux 设备编译程序” 为例，详解交叉编译的完整流程。</p>
<h3 id="（一）环境准备"><a href="#（一）环境准备" class="headerlink" title="（一）环境准备"></a>（一）环境准备</h3><ol>
<li><strong>安装交叉工具链</strong>：</li>
</ol>
<p>以arm-linux-gnueabihf为例（适用于 ARM 32 位带硬件浮点的设备）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>验证工具链</strong>：</li>
</ol>
<p>检查工具链是否正确安装及目标架构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v  # 查看版本及目标架构</span><br><span class="line"># 输出应包含&quot;Target: arm-linux-gnueabihf&quot;</span><br></pre></td></tr></table></figure>

<h3 id="（二）编译单个源文件"><a href="#（二）编译单个源文件" class="headerlink" title="（二）编译单个源文件"></a>（二）编译单个源文件</h3><p>假设存在hello.c文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello, cross-compilation!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用交叉编译器编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 交叉编译为ARM平台可执行文件</span><br><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello_arm</span><br></pre></td></tr></table></figure>

<p><strong>验证文件格式</strong>：</p>
<p>通过file命令确认生成的是目标平台文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file hello_arm</span><br><span class="line"># 输出应包含&quot;ARM, EABI5 version 1 (SYSV)&quot;等信息</span><br></pre></td></tr></table></figure>

<h3 id="（三）多文件交叉编译"><a href="#（三）多文件交叉编译" class="headerlink" title="（三）多文件交叉编译"></a>（三）多文件交叉编译</h3><p>对于包含多个源文件的项目（如main.c和func.c），流程与本地编译类似，仅需替换编译器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 分别编译为目标平台目标文件（.o）</span><br><span class="line">arm-linux-gnueabihf-gcc -c main.c -o main_arm.o</span><br><span class="line">arm-linux-gnueabihf-gcc -c func.c -o func_arm.o</span><br><span class="line"></span><br><span class="line"># 2. 链接为可执行文件</span><br><span class="line">arm-linux-gnueabihf-gcc main_arm.o func_arm.o -o app_arm</span><br></pre></td></tr></table></figure>

<h3 id="（四）链接目标平台库"><a href="#（四）链接目标平台库" class="headerlink" title="（四）链接目标平台库"></a>（四）链接目标平台库</h3><p>当程序依赖目标平台的库（如数学库、动态链接库）时，需指定目标库的路径。</p>
<p><strong>示例</strong>：编译依赖数学库的程序math_test.c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;sqrt(2) = %f\n&quot;, sqrt(2.0));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时需链接目标平台的数学库（-lm）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc math_test.c -o math_test_arm -lm</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关键</strong>：交叉编译时，编译器会自动查找工具链自带的目标平台库（如&#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F;lib），无需手动指定系统库路径。若使用自定义库，需通过-L指定目标平台库的路径（<strong>不可使用主机库</strong>）。</p>
</blockquote>
<h3 id="（五）部署与运行"><a href="#（五）部署与运行" class="headerlink" title="（五）部署与运行"></a>（五）部署与运行</h3><p>将编译生成的hello_arm通过 SSH、SD 卡等方式传输到 ARM 目标设备，赋予执行权限并运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在目标设备上执行</span><br><span class="line">chmod +x hello_arm</span><br><span class="line">./hello_arm  # 输出&quot;Hello, cross-compilation!&quot;</span><br></pre></td></tr></table></figure>

<h2 id="四、复杂项目的交叉编译：配置与自动化"><a href="#四、复杂项目的交叉编译：配置与自动化" class="headerlink" title="四、复杂项目的交叉编译：配置与自动化"></a>四、复杂项目的交叉编译：配置与自动化</h2><p>对于使用configure或CMake管理的开源项目（如 OpenSSL、Libcurl），需通过参数指定交叉编译工具链。</p>
<h3 id="（一）基于-configure-的项目"><a href="#（一）基于-configure-的项目" class="headerlink" title="（一）基于 configure 的项目"></a>（一）基于 configure 的项目</h3><p>开源项目通常通过configure脚本适配不同平台，交叉编译时需指定–host参数（目标平台）。</p>
<p><strong>示例：交叉编译 zlib 库（压缩库）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 下载源码</span><br><span class="line">wget https://zlib.net/zlib-1.3.tar.gz</span><br><span class="line">tar -zxf zlib-1.3.tar.gz &amp;&amp; cd zlib-1.3</span><br><span class="line"></span><br><span class="line"># 2. 配置交叉编译（指定目标平台工具链）</span><br><span class="line">./configure --prefix=/path/to/output \  # 安装路径</span><br><span class="line">            --host=arm-linux-gnueabihf  # 目标平台</span><br><span class="line"></span><br><span class="line"># 3. 编译并安装（使用-j加速编译）</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>编译完成后，&#x2F;path&#x2F;to&#x2F;output下会生成目标平台的库文件（libz.a静态库、<a href="http://libz.so/">libz.so</a>动态库）和头文件。</p>
<h3 id="（二）基于-CMake-的项目"><a href="#（二）基于-CMake-的项目" class="headerlink" title="（二）基于 CMake 的项目"></a>（二）基于 CMake 的项目</h3><p>CMake 通过CMAKE_C_COMPILER和CMAKE_CXX_COMPILER指定交叉编译器，需创建<strong>工具链文件</strong>（如arm-toolchain.cmake）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arm-toolchain.cmake</span><br><span class="line">set(CMAKE_SYSTEM_NAME Linux)           # 目标系统</span><br><span class="line">set(CMAKE_SYSTEM_PROCESSOR arm)        # 目标架构</span><br><span class="line">set(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)  # C交叉编译器</span><br><span class="line">set(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++) # C++交叉编译器</span><br><span class="line">set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)    # 不搜索目标平台的程序</span><br><span class="line">set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)     # 仅搜索目标平台的库</span><br></pre></td></tr></table></figure>

<p>使用工具链文件编译项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build_arm &amp;&amp; cd build_arm</span><br><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=../arm-toolchain.cmake ..</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<h2 id="五、交叉编译常见问题与解决方案"><a href="#五、交叉编译常见问题与解决方案" class="headerlink" title="五、交叉编译常见问题与解决方案"></a>五、交叉编译常见问题与解决方案</h2><h3 id="（一）头文件或库文件找不到"><a href="#（一）头文件或库文件找不到" class="headerlink" title="（一）头文件或库文件找不到"></a>（一）头文件或库文件找不到</h3><p><strong>现象</strong>：编译时出现fatal error: stdio.h: No such file or directory或undefined reference to xxx。</p>
<p><strong>原因</strong>：编译器未找到目标平台的头文件或库文件。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>确认工具链安装完整（部分系统需额外安装libc6-dev-armhf-cross等目标库）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install libc6-dev-armhf-cross  # ARM 32位目标平台的C库开发文件</span><br></pre></td></tr></table></figure>

<ol>
<li>通过-I指定目标头文件路径，-L指定目标库路径：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc test.c -o test_arm \</span><br><span class="line">  -I/usr/arm-linux-gnueabihf/include \  # 目标头文件路径</span><br><span class="line">  -L/usr/arm-linux-gnueabihf/lib        # 目标库路径</span><br></pre></td></tr></table></figure>

<h3 id="（二）动态链接库依赖问题"><a href="#（二）动态链接库依赖问题" class="headerlink" title="（二）动态链接库依赖问题"></a>（二）动态链接库依赖问题</h3><p><strong>现象</strong>：目标设备运行程序时提示error while loading shared libraries: <a href="http://libxxx.so/">libxxx.so</a>: cannot open shared object file。</p>
<p><strong>原因</strong>：目标设备缺少程序依赖的动态库。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>静态链接</strong>：编译时使用-static强制静态链接（将库打包到可执行文件，增加体积但避免依赖）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>拷贝动态库</strong>：将依赖的动态库（如<a href="http://libm.so/">libm.so</a>）从工具链目录拷贝到目标设备的&#x2F;lib或&#x2F;usr&#x2F;lib目录。</li>
</ol>
<h3 id="（三）架构不匹配"><a href="#（三）架构不匹配" class="headerlink" title="（三）架构不匹配"></a>（三）架构不匹配</h3><p><strong>现象</strong>：目标设备运行时提示exec format error。</p>
<p><strong>原因</strong>：编译的程序架构与目标设备不匹配（如为 ARM 64 位编译的程序运行在 ARM 32 位设备上）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p>确认目标设备架构（通过uname -m在目标设备上查看，如armv7l对应 32 位 ARM，aarch64对应 64 位 ARM）。</p>
</li>
<li><p>选择匹配的工具链（如aarch64-linux-gnu-gcc用于 ARM 64 位设备）。</p>
</li>
</ul>
<h3 id="（四）浮点支持问题"><a href="#（四）浮点支持问题" class="headerlink" title="（四）浮点支持问题"></a>（四）浮点支持问题</h3><p><strong>现象</strong>：程序使用浮点运算时崩溃或结果异常。</p>
<p><strong>原因</strong>：目标设备不支持硬件浮点，而编译时使用了硬件浮点工具链（如gnueabihf）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p>若目标设备无硬件浮点，改用软浮点工具链（如arm-linux-gnueabi，末尾无hf）。</p>
</li>
<li><p>编译时通过-mfloat-abi&#x3D;soft强制使用软件浮点。</p>
</li>
</ul>
<h2 id="六、交叉编译实例：编译-FFmpeg-到-ARM-设备"><a href="#六、交叉编译实例：编译-FFmpeg-到-ARM-设备" class="headerlink" title="六、交叉编译实例：编译 FFmpeg 到 ARM 设备"></a>六、交叉编译实例：编译 FFmpeg 到 ARM 设备</h2><p>FFmpeg 是多媒体处理的核心库，交叉编译 FFmpeg 到 ARM 设备可实现嵌入式平台的音视频处理。</p>
<h3 id="（步骤）"><a href="#（步骤）" class="headerlink" title="（步骤）"></a>（步骤）</h3><ol>
<li><strong>下载 FFmpeg 源码</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://ffmpeg.org/releases/ffmpeg-6.1.tar.gz</span><br><span class="line">tar -zxf ffmpeg-6.1.tar.gz &amp;&amp; cd ffmpeg-6.1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>配置交叉编译</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --prefix=/path/to/ffmpeg_arm \</span><br><span class="line">  --host=arm-linux-gnueabihf \</span><br><span class="line">  --cross-prefix=arm-linux-gnueabihf- \  # 交叉工具前缀</span><br><span class="line">  --arch=arm \                           # 架构</span><br><span class="line">  --target-os=linux \                    # 目标系统</span><br><span class="line">  --enable-static \                      # 静态链接</span><br><span class="line">  --disable-shared \                     # 禁用动态库</span><br><span class="line">  --disable-x86asm \                     # 禁用x86汇编优化</span><br><span class="line">  --extra-cflags=&quot;-march=armv7-a&quot;        # 针对ARMv7架构优化</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>编译并安装</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>编译完成后，&#x2F;path&#x2F;to&#x2F;ffmpeg_arm&#x2F;bin&#x2F;ffmpeg即为 ARM 平台的 FFmpeg 可执行文件，可传输到目标设备使用。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>交叉编译的核心是 “工具链匹配” 和 “环境隔离”—— 确保使用目标平台的编译器、库和头文件，而非主机平台。从简单程序到复杂库，交叉编译的流程虽有差异，但核心原则一致：通过参数或配置文件告诉编译器 “目标平台是什么”“去哪里找依赖”。</p>
<p>掌握交叉编译后，开发者可轻松应对嵌入式开发、物联网设备固件定制、多平台应用适配等场景。实际操作中，需根据目标设备的架构、操作系统和硬件特性，灵活调整工具链和编译参数，逐步积累调试经验。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim操作命令笔记：从入门到高效的必备指南</title>
    <url>/2025/09/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/vim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Vim 是 Linux&#x2F;UNIX 环境下最经典的文本编辑器之一，核心优势是“<strong>模式化编辑</strong>”和“<strong>键盘流高效操作</strong>”——无需依赖鼠标，通过快捷键即可完成文本编辑、搜索替换、窗口管理等所有操作。对于嵌入式开发、后端开发等频繁编辑代码的场景，熟练使用 Vim 能大幅提升效率。本文按“基础→进阶→实用技巧”的逻辑，整理 Vim 核心操作命令，适合新手入门和老手查漏补缺。</p>
<h2 id="一、Vim-核心：模式切换（新手必懂！）"><a href="#一、Vim-核心：模式切换（新手必懂！）" class="headerlink" title="一、Vim 核心：模式切换（新手必懂！）"></a>一、Vim 核心：模式切换（新手必懂！）</h2><p>Vim 与其他编辑器（如 VS Code、记事本）的最大区别是“<strong>多模式编辑</strong>”，不同模式下快捷键功能不同。核心模式有 4 种，切换逻辑是入门关键：</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>核心作用</th>
<th>进入方式</th>
<th>退出方式（回正常模式）</th>
</tr>
</thead>
<tbody><tr>
<td>正常模式（Normal）</td>
<td>光标移动、快捷键操作（核心模式）</td>
<td>打开 Vim 默认进入；其他模式按 <code>ESC</code></td>
<td>-</td>
</tr>
<tr>
<td>插入模式（Insert）</td>
<td>输入文本（类似普通编辑器）</td>
<td>正常模式下按 <code>i/a/o/I/A/O</code></td>
<td>按 <code>ESC</code></td>
</tr>
<tr>
<td>命令行模式（Command）</td>
<td>执行命令（如保存、退出、搜索）</td>
<td>正常模式下按 <code>:</code>（冒号）</td>
<td>执行命令后自动回正常模式；或按 <code>ESC</code></td>
</tr>
<tr>
<td>可视模式（Visual）</td>
<td>选中文本（批量操作）</td>
<td>正常模式下按 <code>v/V/&lt;Ctrl+v&gt;</code></td>
<td>按 <code>ESC</code></td>
</tr>
</tbody></table>
<blockquote>
<p>🔔 关键提醒：<strong>所有快捷键都需在“正常模式”下触发</strong>，如果操作没反应，先按 <code>ESC</code> 确认回到正常模式！</p>
</blockquote>
<h2 id="二、基础操作：光标移动与文本编辑"><a href="#二、基础操作：光标移动与文本编辑" class="headerlink" title="二、基础操作：光标移动与文本编辑"></a>二、基础操作：光标移动与文本编辑</h2><h3 id="1-正常模式：光标移动（高效核心）"><a href="#1-正常模式：光标移动（高效核心）" class="headerlink" title="1. 正常模式：光标移动（高效核心）"></a>1. 正常模式：光标移动（高效核心）</h3><p>正常模式下，光标移动不依赖方向键，用字母键即可完成，速度更快。按“移动范围”分类如下：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>h/j/k/l</code></td>
<td>左&#x2F;下&#x2F;上&#x2F;右移动（替代 ←↓↑→ 键）</td>
<td>按 <code>j</code> 向下移动一行</td>
</tr>
<tr>
<td><code>w</code></td>
<td>光标跳至<strong>下一个单词开头</strong></td>
<td>从“hello world”的 <code>h</code> 跳至 <code>w</code></td>
</tr>
<tr>
<td><code>b</code></td>
<td>光标跳至<strong>上一个单词开头</strong></td>
<td>从“world”的 <code>w</code> 跳回 <code>h</code></td>
</tr>
<tr>
<td><code>e</code></td>
<td>光标跳至<strong>当前单词结尾</strong></td>
<td>从“hello”的 <code>h</code> 跳至 <code>o</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td>光标跳至<strong>当前行开头</strong>（数字 0）</td>
<td>行首有缩进时，跳至最左侧</td>
</tr>
<tr>
<td><code>^</code></td>
<td>光标跳至<strong>当前行第一个非空白字符</strong></td>
<td>跳过行首缩进，定位到代码开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>光标跳至<strong>当前行结尾</strong></td>
<td>快速编辑行尾注释</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>光标跳至<strong>文件开头</strong></td>
<td>打开大文件后定位到首行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>光标跳至<strong>文件结尾</strong></td>
<td>查看日志文件最后几行</td>
</tr>
<tr>
<td><code>nG</code></td>
<td>光标跳至<strong>第 n 行</strong>（n 为数字）</td>
<td>按 <code>10G</code> 跳至第 10 行</td>
</tr>
<tr>
<td><code>H</code></td>
<td>光标跳至<strong>当前屏幕顶部</strong></td>
<td>快速回到屏幕可视范围顶部</td>
</tr>
<tr>
<td><code>M</code></td>
<td>光标跳至<strong>当前屏幕中间</strong></td>
<td>屏幕内容多时定位到中间</td>
</tr>
<tr>
<td><code>L</code></td>
<td>光标跳至<strong>当前屏幕底部</strong></td>
<td>快速查看屏幕底部内容</td>
</tr>
<tr>
<td><code>Ctrl+f</code></td>
<td>屏幕<strong>向下翻一页</strong>（forward）</td>
<td>类似 PageDown 键</td>
</tr>
<tr>
<td><code>Ctrl+b</code></td>
<td>屏幕<strong>向上翻一页</strong>（backward）</td>
<td>类似 PageUp 键</td>
</tr>
<tr>
<td><code>Ctrl+d</code></td>
<td>屏幕<strong>向下翻半页</strong>（down）</td>
<td>缓慢滚动查看内容</td>
</tr>
<tr>
<td><code>Ctrl+u</code></td>
<td>屏幕<strong>向上翻半页</strong>（up）</td>
<td>同上</td>
</tr>
</tbody></table>
<h3 id="2-插入模式：文本输入（6种进入方式）"><a href="#2-插入模式：文本输入（6种进入方式）" class="headerlink" title="2. 插入模式：文本输入（6种进入方式）"></a>2. 插入模式：文本输入（6种进入方式）</h3><p>正常模式下按以下键进入插入模式，区别在于“光标位置”，根据场景选择更高效：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>进入插入模式的位置</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>光标<strong>当前位置前</strong>插入</td>
<td>在单词中间补字符（如“heo”→补“l”）</td>
</tr>
<tr>
<td><code>a</code></td>
<td>光标<strong>当前位置后</strong>插入</td>
<td>在单词末尾加字符（如“hello”→加“!”）</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在光标<strong>当前行下方新建一行</strong>插入</td>
<td>向下新增代码行</td>
</tr>
<tr>
<td><code>I</code></td>
<td>光标跳至<strong>当前行开头</strong>插入</td>
<td>在行首加注释（如“&#x2F;&#x2F;”）</td>
</tr>
<tr>
<td><code>A</code></td>
<td>光标跳至<strong>当前行结尾</strong>插入</td>
<td>在行尾加分号（如 C&#x2F;C++ 语句结尾）</td>
</tr>
<tr>
<td><code>O</code></td>
<td>在光标<strong>当前行上方新建一行</strong>插入</td>
<td>向上新增代码行</td>
</tr>
</tbody></table>
<h3 id="3-正常模式：文本编辑（删除-复制-粘贴-撤销）"><a href="#3-正常模式：文本编辑（删除-复制-粘贴-撤销）" class="headerlink" title="3. 正常模式：文本编辑（删除&#x2F;复制&#x2F;粘贴&#x2F;撤销）"></a>3. 正常模式：文本编辑（删除&#x2F;复制&#x2F;粘贴&#x2F;撤销）</h3><p>这部分是 Vim 最常用的编辑操作，所有删除的内容会自动存入“寄存器”，支持后续粘贴，无需担心误删。</p>
<h4 id="（1）删除操作（d-delete）"><a href="#（1）删除操作（d-delete）" class="headerlink" title="（1）删除操作（d &#x3D; delete）"></a>（1）删除操作（d &#x3D; delete）</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>删除光标<strong>当前位置的字符</strong></td>
<td>光标在“h”上，按 <code>x</code> 删除“h”</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除光标<strong>从当前位置到下一个单词开头</strong>的内容</td>
<td>“hello world”中，光标在“h”→按 <code>dw</code> 删除“hello”</td>
</tr>
<tr>
<td><code>db</code></td>
<td>删除光标<strong>从当前位置到上一个单词开头</strong>的内容</td>
<td>“hello world”中，光标在“w”→按 <code>db</code> 删除“ world”</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除光标<strong>当前行</strong></td>
<td>快速删除一行代码</td>
</tr>
<tr>
<td><code>ndd</code></td>
<td>删除光标<strong>当前行开始的 n 行</strong>（n 为数字）</td>
<td>按 <code>3dd</code> 删除当前行及下方 2 行</td>
</tr>
<tr>
<td><code>d$</code></td>
<td>删除光标<strong>从当前位置到行尾</strong>的内容</td>
<td>清除行尾多余字符</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除光标<strong>从当前位置到行首</strong>的内容</td>
<td>清除行首多余空格</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除光标<strong>从当前行到文件结尾</strong>的内容</td>
<td>清空文件后半部分</td>
</tr>
<tr>
<td><code>dgg</code></td>
<td>删除光标<strong>从当前行到文件开头</strong>的内容</td>
<td>清空文件前半部分</td>
</tr>
</tbody></table>
<h4 id="（2）复制操作（y-yank，意为“-Yank-复制”）"><a href="#（2）复制操作（y-yank，意为“-Yank-复制”）" class="headerlink" title="（2）复制操作（y &#x3D; yank，意为“ Yank 复制”）"></a>（2）复制操作（y &#x3D; yank，意为“ Yank 复制”）</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>yw</code></td>
<td>复制光标<strong>从当前位置到下一个单词开头</strong>的内容</td>
<td>复制一个单词</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>复制光标<strong>当前行</strong></td>
<td>复制一行代码</td>
</tr>
<tr>
<td><code>nyy</code></td>
<td>复制光标<strong>当前行开始的 n 行</strong></td>
<td>按 <code>5yy</code> 复制 5 行代码</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制光标<strong>从当前位置到行尾</strong>的内容</td>
<td>复制行尾部分内容</td>
</tr>
<tr>
<td><code>y^</code></td>
<td>复制光标<strong>从当前位置到行首</strong>的内容</td>
<td>复制行首部分内容</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制光标<strong>从当前行到文件结尾</strong>的内容</td>
<td>复制文件后半部分</td>
</tr>
<tr>
<td><code>ygg</code></td>
<td>复制光标<strong>从当前行到文件开头</strong>的内容</td>
<td>复制文件前半部分</td>
</tr>
</tbody></table>
<h4 id="（3）粘贴操作（p-put，意为“-Put-粘贴”）"><a href="#（3）粘贴操作（p-put，意为“-Put-粘贴”）" class="headerlink" title="（3）粘贴操作（p &#x3D; put，意为“ Put 粘贴”）"></a>（3）粘贴操作（p &#x3D; put，意为“ Put 粘贴”）</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>p</code></td>
<td>在光标<strong>当前位置后</strong>粘贴内容</td>
<td>复制一行后，按 <code>p</code> 粘贴到下一行</td>
</tr>
<tr>
<td><code>P</code></td>
<td>在光标<strong>当前位置前</strong>粘贴内容</td>
<td>复制一行后，按 <code>P</code> 粘贴到上一行</td>
</tr>
<tr>
<td><code>np</code></td>
<td>粘贴 n 次复制的内容（n 为数字）</td>
<td>按 <code>3p</code> 粘贴 3 次</td>
</tr>
</tbody></table>
<h4 id="（4）撤销与恢复（u-undo，Ctrl-r-redo）"><a href="#（4）撤销与恢复（u-undo，Ctrl-r-redo）" class="headerlink" title="（4）撤销与恢复（u &#x3D; undo，Ctrl+r &#x3D; redo）"></a>（4）撤销与恢复（u &#x3D; undo，Ctrl+r &#x3D; redo）</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>撤销上一步操作</td>
<td>误删一行后，按 <code>u</code> 恢复</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>恢复（反撤销）上一步被撤销的操作</td>
<td>撤销多了，按 <code>Ctrl+r</code> 找回</td>
</tr>
<tr>
<td><code>U</code></td>
<td>撤销当前行的所有修改</td>
<td>一行改乱了，按 <code>U</code> 恢复原样</td>
</tr>
</tbody></table>
<h2 id="三、进阶操作：搜索替换与窗口管理"><a href="#三、进阶操作：搜索替换与窗口管理" class="headerlink" title="三、进阶操作：搜索替换与窗口管理"></a>三、进阶操作：搜索替换与窗口管理</h2><h3 id="1-搜索操作（正常模式-命令行模式）"><a href="#1-搜索操作（正常模式-命令行模式）" class="headerlink" title="1. 搜索操作（正常模式 + 命令行模式）"></a>1. 搜索操作（正常模式 + 命令行模式）</h3><p>Vim 支持快速搜索文本，且能高亮匹配结果，适合大文件中找关键词。</p>
<h4 id="（1）正常模式：快速搜索"><a href="#（1）正常模式：快速搜索" class="headerlink" title="（1）正常模式：快速搜索"></a>（1）正常模式：快速搜索</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>/关键词</code></td>
<td>从光标位置<strong>向下搜索</strong>“关键词”</td>
<td>按 <code>/printf</code> 搜索所有 printf 函数</td>
</tr>
<tr>
<td><code>?关键词</code></td>
<td>从光标位置<strong>向上搜索</strong>“关键词”</td>
<td>按 <code>?error</code> 向上找 error 日志</td>
</tr>
<tr>
<td><code>n</code></td>
<td>跳至<strong>下一个</strong>匹配结果</td>
<td>搜索后按 <code>n</code> 继续找下一个</td>
</tr>
<tr>
<td><code>N</code></td>
<td>跳至<strong>上一个</strong>匹配结果</td>
<td>按 <code>N</code> 回到上一个匹配位置</td>
</tr>
<tr>
<td><code>*</code></td>
<td>快速搜索<strong>当前光标所在单词</strong>（向下）</td>
<td>光标在“hello”上，按 <code>*</code> 搜索所有 hello</td>
</tr>
<tr>
<td><code>#</code></td>
<td>快速搜索<strong>当前光标所在单词</strong>（向上）</td>
<td>同上，向上搜索</td>
</tr>
</tbody></table>
<h4 id="（2）命令行模式：搜索配置"><a href="#（2）命令行模式：搜索配置" class="headerlink" title="（2）命令行模式：搜索配置"></a>（2）命令行模式：搜索配置</h4><table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>:set hlsearch</code></td>
<td>开启搜索结果<strong>高亮显示</strong>（默认开启）</td>
<td>按 <code>:set hlsearch</code> 启用</td>
</tr>
<tr>
<td><code>:set nohlsearch</code></td>
<td>关闭搜索结果高亮显示</td>
<td>按 <code>:nohlsearch</code> 临时关闭高亮</td>
</tr>
<tr>
<td><code>:set ignorecase</code></td>
<td>搜索时<strong>忽略大小写</strong>（如 Hello 和 hello 视为相同）</td>
<td>按 <code>:set ic</code> 简写启用</td>
</tr>
<tr>
<td><code>:set noignorecase</code></td>
<td>搜索时<strong>区分大小写</strong></td>
<td>按 <code>:set noic</code> 简写关闭</td>
</tr>
</tbody></table>
<h3 id="2-替换操作（命令行模式，-s-命令）"><a href="#2-替换操作（命令行模式，-s-命令）" class="headerlink" title="2. 替换操作（命令行模式，:s 命令）"></a>2. 替换操作（命令行模式，:s 命令）</h3><p>Vim 的替换功能支持“局部替换”和“全局替换”，语法灵活，核心格式为：<br><code>:范围 s/旧内容/新内容/选项</code></p>
<table>
<thead>
<tr>
<th>命令示例</th>
<th>功能描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>:s/old/new</code></td>
<td>替换<strong>当前行</strong>第一个“old”为“new”</td>
<td>一行内改单个关键词</td>
</tr>
<tr>
<td><code>:s/old/new/g</code></td>
<td>替换<strong>当前行</strong>所有“old”为“new”</td>
<td>一行内改多个相同关键词</td>
</tr>
<tr>
<td><code>:#,#s/old/new/g</code></td>
<td>替换<strong>第 # 行到第 # 行</strong>所有“old”为“new”</td>
<td>按 <code>:10,20s/printf/print/g</code> 改 10-20 行的 printf 为 print</td>
</tr>
<tr>
<td><code>:%s/old/new/g</code></td>
<td>替换<strong>整个文件</strong>所有“old”为“new”</td>
<td>批量修改变量名（如把 foo 改为 bar）</td>
</tr>
<tr>
<td><code>:%s/old/new/gc</code></td>
<td>替换整个文件所有“old”为“new”，且<strong>每次替换前确认</strong></td>
<td>避免误改，按 <code>y</code> 确认替换，<code>n</code> 跳过</td>
</tr>
<tr>
<td><code>:%s/^/\/\/ /g</code></td>
<td>在<strong>所有行首</strong>加“&#x2F;&#x2F; ”（注释行）</td>
<td>批量注释 C&#x2F;C++ 代码</td>
</tr>
<tr>
<td><code>:%s/^\/\/ //g</code></td>
<td>移除<strong>所有行首</strong>的“&#x2F;&#x2F; ”（取消注释）</td>
<td>批量取消注释</td>
</tr>
</tbody></table>
<blockquote>
<p>🔔 说明：<code>^</code> 代表行首，<code>$</code> 代表行尾；选项 <code>g</code> 代表“全局（global）”，<code>c</code> 代表“确认（confirm）”。</p>
</blockquote>
<h3 id="3-窗口管理（多文件编辑必备）"><a href="#3-窗口管理（多文件编辑必备）" class="headerlink" title="3. 窗口管理（多文件编辑必备）"></a>3. 窗口管理（多文件编辑必备）</h3><p>Vim 支持分屏显示多个文件，适合对比代码、同时编辑头文件和源文件，核心命令在命令行模式下执行：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
<th>操作示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>:sp 文件名</code></td>
<td>水平分屏（上下分屏），新窗口打开“文件名”</td>
<td>按 <code>:sp main.c</code> 水平分屏打开 main.c</td>
</tr>
<tr>
<td><code>:vsp 文件名</code></td>
<td>垂直分屏（左右分屏），新窗口打开“文件名”</td>
<td>按 <code>:vsp test.h</code> 垂直分屏打开 test.h</td>
</tr>
<tr>
<td><code>Ctrl+w+h/j/k/l</code></td>
<td>切换到<strong>左&#x2F;下&#x2F;上&#x2F;右</strong>侧的窗口</td>
<td>按 <code>Ctrl+w+j</code> 切换到下方窗口</td>
</tr>
<tr>
<td><code>Ctrl+w+w</code></td>
<td>循环切换所有窗口</td>
<td>快速在多个分屏间切换</td>
</tr>
<tr>
<td><code>Ctrl+w+=</code></td>
<td>所有分屏窗口<strong>平均分配大小</strong></td>
<td>分屏大小乱了，快速恢复平衡</td>
</tr>
<tr>
<td><code>Ctrl+w+-</code></td>
<td>当前窗口<strong>高度减小</strong>（水平分屏时）</td>
<td>缩小当前窗口高度</td>
</tr>
<tr>
<td><code>Ctrl+w++</code></td>
<td>当前窗口<strong>高度增大</strong>（水平分屏时）</td>
<td>增大当前窗口高度</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>关闭当前窗口（若只有一个窗口则退出Vim）</td>
<td>按 <code>:q</code> 关闭不需要的分屏</td>
</tr>
<tr>
<td><code>:qall</code></td>
<td>关闭所有窗口并退出Vim</td>
<td>结束编辑时用</td>
</tr>
<tr>
<td><code>:wall</code></td>
<td>保存所有窗口的文件</td>
<td>批量保存多个编辑的文件</td>
</tr>
</tbody></table>
<h2 id="四、实用技巧：提升效率的关键操作"><a href="#四、实用技巧：提升效率的关键操作" class="headerlink" title="四、实用技巧：提升效率的关键操作"></a>四、实用技巧：提升效率的关键操作</h2><h3 id="1-文件操作（命令行模式）"><a href="#1-文件操作（命令行模式）" class="headerlink" title="1. 文件操作（命令行模式）"></a>1. 文件操作（命令行模式）</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>:e 文件名</code></td>
<td>在当前窗口<strong>打开新文件</strong>（关闭当前文件）</td>
<td>按 <code>:e config.h</code> 打开 config.h</td>
</tr>
<tr>
<td><code>:new</code></td>
<td>新建一个空白文件并水平分屏显示</td>
<td>快速新建临时文件</td>
</tr>
<tr>
<td><code>:w</code></td>
<td>保存当前文件</td>
<td>编辑中随时保存，避免丢失</td>
</tr>
<tr>
<td><code>:w 新文件名</code></td>
<td>另存为“新文件名”（不覆盖原文件）</td>
<td>按 <code>:w main_bak.c</code> 备份 main.c</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td>保存当前文件并退出Vim</td>
<td>编辑完成后常用</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出Vim，<strong>不保存</strong>修改</td>
<td>编辑错了，放弃修改退出</td>
</tr>
<tr>
<td><code>:ls</code></td>
<td>查看当前打开的所有文件（缓冲区列表）</td>
<td>按 <code>:ls</code> 查看已打开的文件编号</td>
</tr>
<tr>
<td><code>:b 编号/文件名</code></td>
<td>切换到“编号”或“文件名”对应的文件</td>
<td>按 <code>:b 2</code> 切换到第2个缓冲区的文件</td>
</tr>
</tbody></table>
<h3 id="2-可视模式：批量操作（v-V-Ctrl-v）"><a href="#2-可视模式：批量操作（v-V-Ctrl-v）" class="headerlink" title="2. 可视模式：批量操作（v&#x2F;V&#x2F;Ctrl+v）"></a>2. 可视模式：批量操作（v&#x2F;V&#x2F;Ctrl+v）</h3><p>可视模式用于“选中一块文本”后批量操作，比鼠标选中更精准，支持三种选中方式：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>可视模式类型</th>
<th>选中方式</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>v</code></td>
<td>字符可视模式</td>
<td>按 <code>v</code> 后移动光标，选中单个字符</td>
<td>选中单词、短语</td>
</tr>
<tr>
<td><code>V</code></td>
<td>行可视模式</td>
<td>按 <code>V</code> 后移动光标，选中整行</td>
<td>批量删除&#x2F;复制多行代码</td>
</tr>
<tr>
<td><code>Ctrl+v</code></td>
<td>块可视模式（列模式）</td>
<td>按 <code>Ctrl+v</code> 后移动光标，选中矩形块</td>
<td>批量添加&#x2F;删除列注释</td>
</tr>
</tbody></table>
<h4 id="块可视模式示例：批量添加行注释（C-C-代码）"><a href="#块可视模式示例：批量添加行注释（C-C-代码）" class="headerlink" title="块可视模式示例：批量添加行注释（C&#x2F;C++ 代码）"></a>块可视模式示例：批量添加行注释（C&#x2F;C++ 代码）</h4><ol>
<li>光标移到要注释的第一行开头；</li>
<li>按 <code>Ctrl+v</code> 进入块可视模式；</li>
<li>按 <code>j</code> 向下移动光标，选中所有要注释的行的“行首”；</li>
<li>按 <code>I</code>（大写 I）进入插入模式，输入 <code>// </code>（双斜杠+空格）；</li>
<li>按 <code>ESC</code>，所有选中的行首会自动添加 <code>// </code>，完成批量注释。</li>
</ol>
<h3 id="3-寄存器：灵活粘贴（进阶技巧）"><a href="#3-寄存器：灵活粘贴（进阶技巧）" class="headerlink" title="3. 寄存器：灵活粘贴（进阶技巧）"></a>3. 寄存器：灵活粘贴（进阶技巧）</h3><p>Vim 的“寄存器”类似剪贴板，默认删除&#x2F;复制的内容会存入“无名寄存器”（<code>&quot;&quot;</code>），但也支持自定义寄存器（a-z），适合同时复制多段内容：</p>
<table>
<thead>
<tr>
<th>操作示例</th>
<th>功能描述</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;ayy</code></td>
<td>复制当前行到“a 寄存器”</td>
<td>第一个要复制的内容存 a 寄存器</td>
</tr>
<tr>
<td><code>&quot;byw</code></td>
<td>复制当前单词到“b 寄存器”</td>
<td>第二个要复制的内容存 b 寄存器</td>
</tr>
<tr>
<td><code>&quot;ap</code></td>
<td>粘贴“a 寄存器”的内容</td>
<td>粘贴第一个内容</td>
</tr>
<tr>
<td><code>&quot;bp</code></td>
<td>粘贴“b 寄存器”的内容</td>
<td>粘贴第二个内容</td>
</tr>
<tr>
<td><code>&quot;0p</code></td>
<td>粘贴最近一次复制的内容（不受删除操作影响）</td>
<td>避免删除操作覆盖复制的内容</td>
</tr>
</tbody></table>
<h3 id="4-宏录制：重复执行操作（自动化）"><a href="#4-宏录制：重复执行操作（自动化）" class="headerlink" title="4. 宏录制：重复执行操作（自动化）"></a>4. 宏录制：重复执行操作（自动化）</h3><p>Vim 宏（Macro）可录制一系列操作，后续通过快捷键重复执行，适合“重复相同编辑动作”（如格式化多行代码）：</p>
<h4 id="宏录制步骤："><a href="#宏录制步骤：" class="headerlink" title="宏录制步骤："></a>宏录制步骤：</h4><ol>
<li>正常模式下按 <code>q+字母</code>（如 <code>qa</code>），开始录制宏（存入 a 寄存器），状态栏会显示 <code>recording</code>；</li>
<li>执行要重复的操作（如删除行尾空格、添加分号）；</li>
<li>按 <code>q</code> 结束录制；</li>
<li>按 <code>@+字母</code>（如 <code>@a</code>）执行宏；按 <code>n@a</code>（如 <code>5@a</code>）重复执行 5 次宏。</li>
</ol>
<h4 id="示例：给-10-行代码末尾加分号"><a href="#示例：给-10-行代码末尾加分号" class="headerlink" title="示例：给 10 行代码末尾加分号"></a>示例：给 10 行代码末尾加分号</h4><ol>
<li>光标移到第一行末尾；</li>
<li>按 <code>qa</code> 开始录制宏；</li>
<li>按 <code>A;ESC</code>（A 到行尾插入，加 <code>;</code>，回正常模式）；</li>
<li>按 <code>j</code> 移动到下一行；</li>
<li>按 <code>q</code> 结束录制；</li>
<li>按 <code>9@a</code> 执行 9 次宏，完成剩余 9 行的操作。</li>
</ol>
<h3 id="5-Vim-配置：个性化设置（-vimrc-文件）"><a href="#5-Vim-配置：个性化设置（-vimrc-文件）" class="headerlink" title="5. Vim 配置：个性化设置（.vimrc 文件）"></a>5. Vim 配置：个性化设置（.vimrc 文件）</h3><p>Vim 启动时会加载用户目录下的 <code>.vimrc</code> 文件（Linux 路径 <code>~/.vimrc</code>，Windows 路径 <code>C:\Users\用户名\_vimrc</code>），在该文件中添加配置可自定义 Vim 行为，常用配置如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 基础配置</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span>              <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> autoindent      <span class="comment">&quot; 自动缩进（新行继承上一行缩进）</span></span><br><span class="line"><span class="keyword">set</span> smartindent     <span class="comment">&quot; 智能缩进（代码块缩进更合理，适合编程）</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>       <span class="comment">&quot; Tab 键对应 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>    <span class="comment">&quot; 自动缩进时的缩进宽度（与 tabstop 一致）</span></span><br><span class="line"><span class="keyword">set</span> expandtab       <span class="comment">&quot; 将 Tab 键转为空格（避免不同编辑器 Tab 显示不一致）</span></span><br><span class="line"><span class="keyword">set</span> hlsearch        <span class="comment">&quot; 搜索结果高亮</span></span><br><span class="line"><span class="keyword">set</span> ignorecase      <span class="comment">&quot; 搜索忽略大小写</span></span><br><span class="line"><span class="keyword">set</span> cursorline      <span class="comment">&quot; 高亮当前光标所在行（方便定位）</span></span><br><span class="line"><span class="keyword">set</span> wrap            <span class="comment">&quot; 自动换行（长行内容不超出屏幕）</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span>  <span class="comment">&quot; 支持 UTF-8 编码（避免中文乱码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 快捷键映射（自定义快捷键）</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span>     <span class="comment">&quot; 按 F2 键保存文件（&lt;CR&gt; 代表回车）</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F3&gt;</span> :q<span class="symbol">&lt;CR&gt;</span>     <span class="comment">&quot; 按 F3 键退出当前窗口</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F5&gt;</span> :!gcc % -<span class="keyword">o</span> %&lt; &amp;&amp; ./%&lt; <span class="symbol">&lt;CR&gt;</span>  <span class="comment">&quot; 按 F5 键编译并运行 C 程序（% 代表当前文件名）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置后保存 <code>.vimrc</code>，重启 Vim 即可生效；也可在 Vim 中按 <code>:source ~/.vimrc</code> 临时生效。</p>
</blockquote>
<h2 id="五、总结：Vim-学习建议"><a href="#五、总结：Vim-学习建议" class="headerlink" title="五、总结：Vim 学习建议"></a>五、总结：Vim 学习建议</h2><ol>
<li><strong>先练基础模式</strong>：新手初期重点掌握“正常模式→插入模式”切换、光标移动（h&#x2F;j&#x2F;k&#x2F;l&#x2F;w&#x2F;b）、删除&#x2F;复制&#x2F;粘贴（dd&#x2F;yy&#x2F;p），这些是所有操作的基础；</li>
<li><strong>拒绝鼠标依赖</strong>：刻意不用鼠标，强迫自己用快捷键，1-2 周后会形成肌肉记忆；</li>
<li><strong>按需查命令</strong>：遇到复杂操作（如批量替换、分屏）时，对照本文或 <code>:help 命令</code>（如 <code>:help :s</code> 查看替换命令帮助）查找，逐步积累；</li>
<li><strong>个性化配置</strong>：根据自己的开发语言（如 C&#x2F;C++、Python）调整 <code>.vimrc</code>，提升长期使用体验。</li>
</ol>
<p>Vim 的核心魅力是“用键盘流实现高效编辑”，熟练后能大幅减少手部在键盘和鼠标间的切换，尤其适合长时间代码开发。坚持练习，你会发现它比图形化编辑器更“顺手”！</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>使用qemu安装ARM64 (aarch64) 架构的 Ubuntu Server 虚拟机</title>
    <url>/2025/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85ARM64%20(aarch64)%20%E6%9E%B6%E6%9E%84%E7%9A%84%20Ubuntu%20Server%20%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="使用-qemu-安装-ARM64-aarch64-架构的-Ubuntu-Server-虚拟机"><a href="#使用-qemu-安装-ARM64-aarch64-架构的-Ubuntu-Server-虚拟机" class="headerlink" title="使用 qemu 安装 ARM64 (aarch64) 架构的 Ubuntu Server 虚拟机"></a>使用 qemu 安装 ARM64 (aarch64) 架构的 Ubuntu Server 虚拟机</h1><blockquote>
<p>本文基于 Ubuntu 24.04.3 LTS for ARM64，演示如何在 x86_64 主机上利用 qemu-system-aarch64 快速搭建一台可 SSH 登录的 ARM64 Server 虚拟机。</p>
</blockquote>
<hr>
<h2 id="一、安装前准备"><a href="#一、安装前准备" class="headerlink" title="一、安装前准备"></a>一、安装前准备</h2><h3 id="1-1-安装-QEMU-及相关工具"><a href="#1-1-安装-QEMU-及相关工具" class="headerlink" title="1.1 安装 QEMU 及相关工具"></a>1.1 安装 QEMU 及相关工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">  qemu-system-arm \</span><br><span class="line">  qemu-system-aarch64 \</span><br><span class="line">  qemu-efi-aarch64 \</span><br><span class="line">  qemu-utils</span><br></pre></td></tr></table></figure>

<h3 id="1-2-验证安装"><a href="#1-2-验证安装" class="headerlink" title="1.2 验证安装"></a>1.2 验证安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 --version</span><br></pre></td></tr></table></figure>

<p>出现版本号即表示安装成功。</p>
<h3 id="1-3-下载-Ubuntu-Server-ARM64-ISO"><a href="#1-3-下载-Ubuntu-Server-ARM64-ISO" class="headerlink" title="1.3 下载 Ubuntu Server ARM64 ISO"></a>1.3 下载 Ubuntu Server ARM64 ISO</h3><ul>
<li>官方镜像页面：<a href="https://ubuntu.com/download/server/arm">https://ubuntu.com/download/server/arm</a></li>
<li>选择 <strong>Ubuntu 24.04.3 LTS</strong> 的 <strong>live-server-arm64.iso</strong> 文件并下载到本地。</li>
</ul>
<hr>
<h2 id="二、正式安装"><a href="#二、正式安装" class="headerlink" title="二、正式安装"></a>二、正式安装</h2><h3 id="2-1-创建工作目录"><a href="#2-1-创建工作目录" class="headerlink" title="2.1 创建工作目录"></a>2.1 创建工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/arm64 &amp;&amp; <span class="built_in">cd</span> ~/arm64</span><br></pre></td></tr></table></figure>

<h3 id="2-2-复制-ISO-镜像"><a href="#2-2-复制-ISO-镜像" class="headerlink" title="2.2 复制 ISO 镜像"></a>2.2 复制 ISO 镜像</h3><p>将下载好的 ISO 复制到工作目录（请替换实际路径）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /path/to/ubuntu-24.04.3-live-server-arm64.iso ./</span><br></pre></td></tr></table></figure>

<h3 id="2-3-创建虚拟磁盘"><a href="#2-3-创建虚拟磁盘" class="headerlink" title="2.3 创建虚拟磁盘"></a>2.3 创建虚拟磁盘</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 ubuntu-24.04-arm64.qcow2 32G</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f qcow2</code></td>
<td>使用 QCOW2 格式，支持快照与稀疏分配</td>
</tr>
<tr>
<td><code>32G</code></td>
<td>建议至少 20 GB，Server 场景推荐 32 GB 以上</td>
</tr>
</tbody></table>
<h3 id="2-4-准备-UEFI-固件（OVMF）"><a href="#2-4-准备-UEFI-固件（OVMF）" class="headerlink" title="2.4 准备 UEFI 固件（OVMF）"></a>2.4 准备 UEFI 固件（OVMF）</h3><p>安装 <code>qemu-efi-aarch64</code> 后，固件通常位于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找固件路径</span></span><br><span class="line">dpkg -L qemu-efi-aarch64 | grep fd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到工作目录，方便移植</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/qemu-efi-aarch64/QEMU_EFI.fd ./</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、启动-QEMU-安装虚拟机"><a href="#三、启动-QEMU-安装虚拟机" class="headerlink" title="三、启动 QEMU 安装虚拟机"></a>三、启动 QEMU 安装虚拟机</h2><h3 id="3-1-一键启动命令"><a href="#3-1-一键启动命令" class="headerlink" title="3.1 一键启动命令"></a>3.1 一键启动命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">  -name <span class="string">&quot;Ubuntu 24.04 ARM64&quot;</span> \</span><br><span class="line">  -machine virt \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -smp 4 \</span><br><span class="line">  -m 4096 \</span><br><span class="line">  -bios QEMU_EFI.fd \</span><br><span class="line">  -device virtio-blk-device,drive=hd0 \</span><br><span class="line">  -drive file=ubuntu-24.04-arm64.qcow2,<span class="keyword">if</span>=none,format=qcow2,<span class="built_in">id</span>=hd0 \</span><br><span class="line">  -device virtio-blk-device,drive=cd0 \</span><br><span class="line">  -drive file=ubuntu-24.04.3-live-server-arm64.iso,media=cdrom,format=raw,<span class="keyword">if</span>=none,<span class="built_in">id</span>=cd0 \</span><br><span class="line">  -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::2222-:22 \</span><br><span class="line">  -device virtio-net-device,netdev=net0 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -serial mon:stdio</span><br></pre></td></tr></table></figure>

<h3 id="3-2-参数速查表"><a href="#3-2-参数速查表" class="headerlink" title="3.2 参数速查表"></a>3.2 参数速查表</h3><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-name</code></td>
<td>虚拟机名称</td>
</tr>
<tr>
<td><code>-machine virt</code></td>
<td>通用 ARM virt 平台</td>
</tr>
<tr>
<td><code>-cpu cortex-a57</code></td>
<td>兼容性最佳的 CPU 模型</td>
</tr>
<tr>
<td><code>-smp 4</code></td>
<td>4 vCPU</td>
</tr>
<tr>
<td><code>-m 4096</code></td>
<td>4 GB 内存</td>
</tr>
<tr>
<td><code>-bios</code></td>
<td>UEFI 固件</td>
</tr>
<tr>
<td><code>-device virtio-blk-device</code></td>
<td>高性能 virtio 块设备</td>
</tr>
<tr>
<td><code>-netdev user</code></td>
<td>用户模式网络</td>
</tr>
<tr>
<td><code>hostfwd=tcp::2222-:22</code></td>
<td>主机 2222 端口 → 虚拟机 22 端口</td>
</tr>
<tr>
<td><code>-nographic</code></td>
<td>关闭图形，串口输出到当前终端</td>
</tr>
<tr>
<td><code>-serial mon:stdio</code></td>
<td>串口重定向到标准输入输出</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、后续步骤"><a href="#四、后续步骤" class="headerlink" title="四、后续步骤"></a>四、后续步骤</h2><ol>
<li>终端出现 <strong>UEFI → GRUB → Ubuntu Server Installer</strong> 流程，按提示完成安装。  </li>
<li>安装完成后，虚拟机将自动重启并进入已装好的系统。  </li>
<li>在宿主机上通过 SSH 连接：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 2222 &lt;vm_user&gt;@localhost</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>祝你玩得开心！如需图形界面或更多高级配置，可在此基础上自行扩展。</p>
</blockquote>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>ARM64</tag>
        <tag>Ubuntu Server</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V的OpenSBI</title>
    <url>/2025/11/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/openSBI/</url>
    <content><![CDATA[<p><strong>OpenSBI</strong>（Open Source Supervisor Binary Interface）是 RISC-V 架构中一个<strong>开源的、标准化的固件（firmware）实现</strong>，用于在 <strong>Machine 模式（M-mode）</strong> 下为上层软件（如操作系统、Hypervisor、Bootloader）提供统一的 <strong>SBI（Supervisor Binary Interface）</strong> 服务。</p>
<p>它是 RISC-V 软件栈中<strong>承上启下的关键组件</strong>，相当于 RISC-V 的“BIOS + 中断&#x2F;电源管理服务层”。</p>
<hr>
<h2 id="一、为什么需要-OpenSBI？"><a href="#一、为什么需要-OpenSBI？" class="headerlink" title="一、为什么需要 OpenSBI？"></a>一、为什么需要 OpenSBI？</h2><h3 id="RISC-V-的特权模式分层"><a href="#RISC-V-的特权模式分层" class="headerlink" title="RISC-V 的特权模式分层"></a>RISC-V 的特权模式分层</h3><p>RISC-V 定义了多级特权模式（Privilege Levels）：</p>
<ul>
<li><strong>M-mode（Machine Mode）</strong>：最高权限，直接控制硬件（必须实现）</li>
<li><strong>S-mode（Supervisor Mode）</strong>：操作系统内核运行在此（如 Linux）</li>
<li><strong>U-mode（User Mode）</strong>：应用程序运行在此</li>
</ul>
<blockquote>
<p>📌 <strong>问题</strong>：S-mode（如 Linux）<strong>不能直接访问某些硬件资源</strong>（如中断控制器、时钟、电源管理寄存器），因为这些操作必须在 M-mode 下完成。</p>
</blockquote>
<h3 id="解决方案：SBI（Supervisor-Binary-Interface）"><a href="#解决方案：SBI（Supervisor-Binary-Interface）" class="headerlink" title="解决方案：SBI（Supervisor Binary Interface）"></a>解决方案：SBI（Supervisor Binary Interface）</h3><ul>
<li>SBI 是 RISC-V 官方定义的一套 <strong>M-mode 与 S-mode 之间的标准调用接口</strong></li>
<li>类似于 ARM 的 <strong>SMC（Secure Monitor Call）</strong> 或 x86 的 <strong>UEFI Runtime Services</strong></li>
</ul>
<blockquote>
<p>✅ <strong>OpenSBI 就是 SBI 规范的一个高质量、开源、可移植的参考实现</strong>。</p>
</blockquote>
<hr>
<h2 id="二、OpenSBI-的核心功能"><a href="#二、OpenSBI-的核心功能" class="headerlink" title="二、OpenSBI 的核心功能"></a>二、OpenSBI 的核心功能</h2><p>OpenSBI 在 M-mode 运行，为 S-mode 软件提供以下服务：</p>
<table>
<thead>
<tr>
<th>功能类别</th>
<th>具体服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础服务</strong></td>
<td><code>sbi_console_putchar</code> &#x2F; <code>getchar</code></td>
<td>串口调试输出（早期打印）</td>
</tr>
<tr>
<td><strong>系统控制</strong></td>
<td><code>sbi_system_reset</code></td>
<td>重启或关机</td>
</tr>
<tr>
<td><strong>定时器管理</strong></td>
<td><code>sbi_set_timer</code></td>
<td>设置 <code>mtimecmp</code>，触发定时器中断</td>
</tr>
<tr>
<td><strong>IPI（核间中断）</strong></td>
<td><code>sbi_send_ipi</code></td>
<td>触发其他核心的软件中断（用于多核启动&#x2F;调度）</td>
</tr>
<tr>
<td><strong>中断转发</strong></td>
<td>处理外部中断（PLIC）并转发给 S-mode</td>
<td>有些平台由 OpenSBI 代理中断使能</td>
</tr>
<tr>
<td><strong>HSM（Hart State Management）</strong></td>
<td><code>sbi_hart_start/stop</code></td>
<td>控制其他 CPU 核（hart）的启停（多核支持）</td>
</tr>
<tr>
<td><strong>RFENCE（远程屏障）</strong></td>
<td><code>sbi_remote_fence_i</code></td>
<td>多核缓存一致性操作</td>
</tr>
<tr>
<td><strong>PMU（性能监控）</strong></td>
<td>访问性能计数器</td>
<td>可选扩展</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 所有这些操作都通过 <strong>ECALL 指令 + SBI 调用号</strong> 从 S-mode 发起，由 OpenSBI 在 M-mode 安全执行。</p>
</blockquote>
<hr>
<h2 id="三、OpenSBI-在启动流程中的位置"><a href="#三、OpenSBI-在启动流程中的位置" class="headerlink" title="三、OpenSBI 在启动流程中的位置"></a>三、OpenSBI 在启动流程中的位置</h2><p>典型的 RISC-V 启动流程（以 Linux 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROM Bootloader（可选）</span><br><span class="line">        ↓</span><br><span class="line">First Stage Bootloader（FSBL，如 U-Boot SPL / Xilinx FSBL）</span><br><span class="line">        ↓</span><br><span class="line">**OpenSBI（M-mode 固件）**</span><br><span class="line">        ↓</span><br><span class="line">Second Stage Bootloader（如 U-Boot / coreboot） → 运行在 S-mode</span><br><span class="line">        ↓</span><br><span class="line">Linux Kernel（S-mode）</span><br></pre></td></tr></table></figure>

<ul>
<li>OpenSBI 是 <strong>第一个运行在标准 RISC-V 环境下的通用固件</strong></li>
<li>它初始化：<ul>
<li>CLINT &#x2F; PLIC</li>
<li>串口（用于 early console）</li>
<li>多核（通过 HSM 启动 secondary harts）</li>
<li>FDT（设备树）传递</li>
</ul>
</li>
<li>然后跳转到下一阶段（如 U-Boot 或直接 Linux）</li>
</ul>
<blockquote>
<p>✅ <strong>没有 OpenSBI，Linux 无法在标准 RISC-V 平台上启动</strong>（除非自己实现 SBI）。</p>
</blockquote>
<hr>
<h2 id="四、OpenSBI-的架构特点"><a href="#四、OpenSBI-的架构特点" class="headerlink" title="四、OpenSBI 的架构特点"></a>四、OpenSBI 的架构特点</h2><h3 id="1-模块化设计"><a href="#1-模块化设计" class="headerlink" title="1. 模块化设计"></a>1. <strong>模块化设计</strong></h3><ul>
<li><strong>Firmware</strong>：核心 SBI 实现</li>
<li><strong>Platform Support</strong>：针对不同 SoC（如 QEMU、SiFive Unleashed、Allwinner、StarFive）的适配层</li>
<li><strong>Domains</strong>（高级）：支持安全世界&#x2F;非安全世界隔离（类似 ARM TrustZone）</li>
</ul>
<h3 id="2-轻量高效"><a href="#2-轻量高效" class="headerlink" title="2. 轻量高效"></a>2. <strong>轻量高效</strong></h3><ul>
<li>代码精简（C + 汇编），通常 &lt; 64KB</li>
<li>启动速度快，适合嵌入式和服务器</li>
</ul>
<h3 id="3-开源与社区驱动"><a href="#3-开源与社区驱动" class="headerlink" title="3. 开源与社区驱动"></a>3. <strong>开源与社区驱动</strong></h3><ul>
<li>项目地址：<a href="https://github.com/riscv-software-src/opensbi">https://github.com/riscv-software-src/opensbi</a></li>
<li>由 RISC-V International 和多家公司（Andes, SiFive, Alibaba, Western Digital 等）共同维护</li>
<li>已被 <strong>Linux、U-Boot、Zephyr、FreeBSD</strong> 等主流系统采用</li>
</ul>
<hr>
<h2 id="五、OpenSBI-与类似组件对比"><a href="#五、OpenSBI-与类似组件对比" class="headerlink" title="五、OpenSBI 与类似组件对比"></a>五、OpenSBI 与类似组件对比</h2><table>
<thead>
<tr>
<th>组件</th>
<th>架构</th>
<th>作用</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OpenSBI</strong></td>
<td>RISC-V</td>
<td>M-mode 固件，提供 SBI 服务</td>
<td>RISC-V 的 “UEFI + PSCI”</td>
</tr>
<tr>
<td><strong>ARM Trusted Firmware (ATF)</strong></td>
<td>ARM</td>
<td>EL3 固件，提供 SMC 服务（如 PSCI）</td>
<td>功能类似，但用于 ARM</td>
</tr>
<tr>
<td><strong>U-Boot SPL</strong></td>
<td>多架构</td>
<td>第一阶段 bootloader</td>
<td>OpenSBI 常由 SPL 加载</td>
</tr>
<tr>
<td><strong>Coreboot</strong></td>
<td>x86&#x2F;RISC-V</td>
<td>开源固件</td>
<td>可集成 OpenSBI 作为 payload</td>
</tr>
</tbody></table>
<blockquote>
<p>🔸 在 ARM 中，<strong>PSCI</strong>（Power State Coordination Interface）的功能 ≈ OpenSBI 的 HSM + system_reset。</p>
</blockquote>
<hr>
<h2 id="六、实际使用示例"><a href="#六、实际使用示例" class="headerlink" title="六、实际使用示例"></a>六、实际使用示例</h2><h3 id="编译-OpenSBI（以-QEMU-virt-平台为例）："><a href="#编译-OpenSBI（以-QEMU-virt-平台为例）：" class="headerlink" title="编译 OpenSBI（以 QEMU virt 平台为例）："></a>编译 OpenSBI（以 QEMU virt 平台为例）：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/riscv-software-src/opensbi.git</span><br><span class="line"><span class="built_in">cd</span> opensbi</span><br><span class="line">make PLATFORM=generic</span><br></pre></td></tr></table></figure>

<p>生成 <code>build/platform/generic/firmware/fw_payload.elf</code>（包含 OpenSBI + 可选 payload）</p>
<h3 id="启动-Linux（QEMU）："><a href="#启动-Linux（QEMU）：" class="headerlink" title="启动 Linux（QEMU）："></a>启动 Linux（QEMU）：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">  -machine virt \</span><br><span class="line">  -kernel Image \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/vda2 rw console=ttyS0&quot;</span> \</span><br><span class="line">  -bios opensbi/build/platform/generic/firmware/fw_jump.elf \</span><br><span class="line">  -drive file=rootfs.ext2,format=raw,<span class="built_in">id</span>=hd0 \</span><br><span class="line">  -serial stdio</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-bios</code> 指定 OpenSBI 作为固件</li>
<li>OpenSBI 初始化硬件后跳转到 <code>-kernel</code> 指定的 Linux</li>
</ul>
<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>是什么</strong></td>
<td>RISC-V 的开源 M-mode 固件，实现 SBI 标准</td>
</tr>
<tr>
<td><strong>为什么需要</strong></td>
<td>让 S-mode 软件（如 Linux）安全访问底层硬件</td>
</tr>
<tr>
<td><strong>核心功能</strong></td>
<td>多核管理、定时器、IPI、系统控制、中断代理</td>
</tr>
<tr>
<td><strong>地位</strong></td>
<td>RISC-V 软件生态的<strong>基础设施</strong>，类似 ARM 的 ATF</td>
</tr>
<tr>
<td><strong>开源地址</strong></td>
<td><a href="https://github.com/riscv-software-src/opensbi">https://github.com/riscv-software-src/opensbi</a></td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>简单说：OpenSBI &#x3D; RISC-V 的“标准固件层”，没有它，操作系统无法在真实硬件上正常运行。</strong></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>openSBI</tag>
      </tags>
  </entry>
  <entry>
    <title>程序编译全过程详解</title>
    <url>/2025/08/19/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%8Ec%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<h1 id="程序编译全过程详解：从-C-源码到可执行文件的深度剖析"><a href="#程序编译全过程详解：从-C-源码到可执行文件的深度剖析" class="headerlink" title="程序编译全过程详解：从 C 源码到可执行文件的深度剖析"></a><strong>程序编译全过程详解：从 C 源码到可执行文件的深度剖析</strong></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>当你写下一段简单的 C 代码，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>

<p>你可能以为这只是“编译”了一下。但实际上，这背后隐藏着一个极其复杂而精密的系统工程。本文将带你深入探索：<strong>一个 <code>.c</code> 源文件是如何经过一系列转换，最终变成一个可以在操作系统上运行的可执行文件的？</strong> 我们将逐层剖析预处理、编译、汇编、链接四大阶段，深入 ELF 文件结构、符号解析、重定位、动态链接机制等底层细节。</p>
<hr>
<h2 id="第一部分：程序构建的四个阶段"><a href="#第一部分：程序构建的四个阶段" class="headerlink" title="第一部分：程序构建的四个阶段"></a><strong>第一部分：程序构建的四个阶段</strong></h2><p>整个编译过程可以分为四个主要阶段：</p>
<ol>
<li><strong>预处理 (Preprocessing)</strong></li>
<li><strong>编译 (Compilation)</strong></li>
<li><strong>汇编 (Assembly)</strong></li>
<li><strong>链接 (Linking)</strong></li>
</ol>
<p>我们以 <code>gcc</code> 为例，逐步分解。</p>
<hr>
<h3 id="1-预处理-Preprocessing"><a href="#1-预处理-Preprocessing" class="headerlink" title="1. 预处理 (Preprocessing)"></a><strong>1. 预处理 (Preprocessing)</strong></h3><p><strong>目标：</strong> 将源代码中的宏、头文件、条件编译等“预处理指令”展开，生成一个纯 C 代码的 <code>.i</code> 文件。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<ul>
<li><code>#include &lt;stdio.h&gt;</code>：被替换为 <code>stdio.h</code> 的完整内容（通常在 <code>/usr/include/</code> 中）。</li>
<li><code>#define</code> 宏被展开。</li>
<li>条件编译 <code>#ifdef</code>, <code>#ifndef</code> 等被求值。</li>
<li>注释被删除。</li>
<li>行号和文件名信息被保留（用于调试）。</li>
</ul>
<p><strong><code>hello.i</code> 示例（简化）：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 大量 stdio.h 内容 ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>预处理器不理解 C 语法，它只是文本替换。</li>
<li>生成的 <code>.i</code> 文件仍然是 C 语言代码，但已经“展开”了所有宏和头文件。</li>
</ul>
<hr>
<h3 id="2-编译-Compilation"><a href="#2-编译-Compilation" class="headerlink" title="2. 编译 (Compilation)"></a><strong>2. 编译 (Compilation)</strong></h3><p><strong>目标：</strong> 将预处理后的 C 代码（<code>.i</code> 文件）翻译成汇编语言（<code>.s</code> 文件）。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<p>这是最复杂的阶段，包括：</p>
<h4 id="1-词法分析-Lexical-Analysis"><a href="#1-词法分析-Lexical-Analysis" class="headerlink" title="(1) 词法分析 (Lexical Analysis)"></a><strong>(1) 词法分析 (Lexical Analysis)</strong></h4><ul>
<li>将字符流分解为“词法单元”（Tokens）：<code>int</code>, <code>main</code>, <code>(</code>, <code>)</code>, <code>&#123;</code>, <code>printf</code>, <code>(</code>, <code>&quot;Hello&quot;</code>, <code>)</code>, <code>;</code>, <code>return</code>, <code>0</code>, <code>;</code>, <code>&#125;</code>。</li>
<li>忽略空白、注释。</li>
</ul>
<h4 id="2-语法分析-Syntax-Analysis-Parsing"><a href="#2-语法分析-Syntax-Analysis-Parsing" class="headerlink" title="(2) 语法分析 (Syntax Analysis &#x2F; Parsing)"></a><strong>(2) 语法分析 (Syntax Analysis &#x2F; Parsing)</strong></h4><ul>
<li>使用上下文无关文法（CFG）构建<strong>抽象语法树（AST）</strong>。</li>
<li>例如，<code>printf(&quot;Hello, World!\n&quot;);</code> 被解析为一个函数调用节点，子节点是字符串字面量。</li>
</ul>
<h4 id="3-语义分析-Semantic-Analysis"><a href="#3-语义分析-Semantic-Analysis" class="headerlink" title="(3) 语义分析 (Semantic Analysis)"></a><strong>(3) 语义分析 (Semantic Analysis)</strong></h4><ul>
<li>检查类型是否匹配（如 <code>int x = &quot;hello&quot;;</code> 会报错）。</li>
<li>构建<strong>符号表（Symbol Table）</strong>：记录变量、函数、作用域等信息。</li>
<li>检查函数是否已声明。</li>
</ul>
<h4 id="4-中间代码生成-IR-Generation"><a href="#4-中间代码生成-IR-Generation" class="headerlink" title="(4) 中间代码生成 (IR Generation)"></a><strong>(4) 中间代码生成 (IR Generation)</strong></h4><ul>
<li>将 AST 转换为<strong>中间表示（Intermediate Representation, IR）</strong>，如 GIMPLE（GCC）、LLVM IR。</li>
<li>IR 是平台无关的，便于进行优化。</li>
</ul>
<h4 id="5-优化-Optimization"><a href="#5-优化-Optimization" class="headerlink" title="(5) 优化 (Optimization)"></a><strong>(5) 优化 (Optimization)</strong></h4><ul>
<li>在 IR 层进行各种优化：<ul>
<li>常量折叠：<code>int x = 2 + 3;</code> → <code>int x = 5;</code></li>
<li>死代码消除</li>
<li>循环优化</li>
<li>内联函数</li>
</ul>
</li>
<li>优化后重新生成汇编代码。</li>
</ul>
<h4 id="6-目标代码生成"><a href="#6-目标代码生成" class="headerlink" title="(6) 目标代码生成"></a><strong>(6) 目标代码生成</strong></h4><ul>
<li>将优化后的 IR 转换为特定架构（如 x86-64）的<strong>汇编代码</strong>。</li>
</ul>
<p><strong><code>hello.s</code> 示例（x86-64，简化）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    leaq    .LC0(%rip), %rdi     # 加载字符串地址</span><br><span class="line">    call    printf@PLT           # 调用 printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>输出是人类可读的汇编代码（<code>.s</code> 文件）。</li>
<li>此时还未分配最终内存地址。</li>
</ul>
<hr>
<h3 id="3-汇编-Assembly"><a href="#3-汇编-Assembly" class="headerlink" title="3. 汇编 (Assembly)"></a><strong>3. 汇编 (Assembly)</strong></h3><p><strong>目标：</strong> 将汇编代码（<code>.s</code>）翻译成机器码，生成<strong>目标文件（Object File）</strong>，通常是 <code>.o</code> 文件。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>或直接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<ul>
<li>汇编器（如 <code>as</code>）读取 <code>.s</code> 文件。</li>
<li>将每条汇编指令翻译为对应的<strong>机器码（二进制）</strong>。</li>
<li>生成一个 <strong>ELF 格式</strong> 的目标文件 <code>hello.o</code>。</li>
</ul>
<p><strong>目标文件 <code>hello.o</code> 包含什么？</strong></p>
<p>我们使用 <code>objdump</code> 和 <code>readelf</code> 来分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d hello.o      <span class="comment"># 反汇编代码段</span></span><br><span class="line">readelf -a hello.o      <span class="comment"># 查看所有信息</span></span><br></pre></td></tr></table></figure>

<h3 id="目标文件结构（ELF-格式）"><a href="#目标文件结构（ELF-格式）" class="headerlink" title="目标文件结构（ELF 格式）"></a><strong>目标文件结构（ELF 格式）</strong></h3><p>ELF（Executable and Linkable Format）是 Unix&#x2F;Linux 系统的标准可执行文件格式。</p>
<p>一个典型的 <code>.o</code> 文件包含以下关键部分：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><strong>代码段</strong>：存放编译后的机器指令（如 <code>main</code> 函数）。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td><strong>已初始化数据段</strong>：存放已初始化的全局&#x2F;静态变量（如 <code>int x = 10;</code>）。</td>
</tr>
<tr>
<td><code>.bss</code></td>
<td><strong>未初始化数据段</strong>：存放未初始化的全局&#x2F;静态变量（如 <code>int y;</code>）。在文件中不占空间，运行时由系统清零。</td>
</tr>
<tr>
<td><code>.rodata</code></td>
<td><strong>只读数据段</strong>：存放字符串常量、const 变量等。</td>
</tr>
<tr>
<td><code>.symtab</code></td>
<td><strong>符号表</strong>：记录所有函数和变量的名称、类型、作用域、所在节等。</td>
</tr>
<tr>
<td><code>.strtab</code></td>
<td><strong>字符串表</strong>：存放符号表中用到的字符串（如函数名）。</td>
</tr>
<tr>
<td><code>.rela.text</code></td>
<td><strong>重定位表（代码段）</strong>：记录代码段中哪些位置需要在链接时进行地址修正。</td>
</tr>
<tr>
<td><code>.rela.data</code></td>
<td><strong>重定位表（数据段）</strong>：同上，用于数据段。</td>
</tr>
</tbody></table>
<h4 id="符号表（-symtab）示例："><a href="#符号表（-symtab）示例：" class="headerlink" title="符号表（.symtab）示例："></a><strong>符号表（<code>.symtab</code>）示例：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -s hello.o</span><br></pre></td></tr></table></figure>
<p>输出可能包含：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">  0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">  1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">  2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">  5: 0000000000000000    29 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">  6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>main</code>：类型为 <code>FUNC</code>，绑定为 <code>GLOBAL</code>，位于 <code>.text</code> 节（Ndx&#x3D;1）。</li>
<li><code>printf</code>：类型为 <code>NOTYPE</code>，绑定为 <code>GLOBAL</code>，但 <code>Ndx=UND</code>（未定义），表示它将在链接时从其他地方解析。</li>
</ul>
<h4 id="重定位表（-rela-text）示例："><a href="#重定位表（-rela-text）示例：" class="headerlink" title="重定位表（.rela.text）示例："></a><strong>重定位表（<code>.rela.text</code>）示例：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -r hello.o</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Relocation section &#x27;.rela.text&#x27; at offset 0x218 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000007  000500000004 R_X86_64_PLT32    0000000000000000 printf - 4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Offset</strong>: 在 <code>.text</code> 段中的偏移位置（0x7），即 <code>call</code> 指令的操作数位置。</li>
<li><strong>Type</strong>: <code>R_X86_64_PLT32</code>，表示这是一个 PLT（Procedure Linkage Table）相对调用。</li>
<li><strong>Sym. Name</strong>: <code>printf</code>，表示这个位置引用了 <code>printf</code> 符号。</li>
<li><strong>Addend</strong>: -4，用于计算最终地址。</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li>目标文件是<strong>可重定位文件（Relocatable Object File）</strong>。</li>
<li>它包含机器码，但地址是相对的，需要链接器进行“重定位”才能确定最终地址。</li>
<li>它可能引用外部符号（如 <code>printf</code>），这些符号在链接时解析。</li>
</ul>
<hr>
<h3 id="4-链接-Linking"><a href="#4-链接-Linking" class="headerlink" title="4. 链接 (Linking)"></a><strong>4. 链接 (Linking)</strong></h3><p><strong>目标：</strong> 将一个或多个目标文件（<code>.o</code>）和库文件（<code>.a</code>, <code>.so</code>）合并，生成一个<strong>可执行文件（Executable File）</strong> 或共享库。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<p><strong>链接器（<code>ld</code>）做了什么？</strong></p>
<h4 id="1-符号解析（Symbol-Resolution）"><a href="#1-符号解析（Symbol-Resolution）" class="headerlink" title="(1) 符号解析（Symbol Resolution）"></a><strong>(1) 符号解析（Symbol Resolution）</strong></h4><ul>
<li>遍历所有输入文件（<code>hello.o</code> 和标准库如 <code>libc.a</code> 或 <code>libc.so</code>）。</li>
<li>建立全局符号表。</li>
<li>解析未定义符号：<ul>
<li><code>hello.o</code> 中 <code>printf</code> 是未定义的。</li>
<li>链接器在 <code>libc</code> 库中找到 <code>printf</code> 的定义。</li>
</ul>
</li>
<li>如果找不到，链接失败（<code>undefined reference</code> 错误）。</li>
</ul>
<h4 id="2-重定位（Relocation）"><a href="#2-重定位（Relocation）" class="headerlink" title="(2) 重定位（Relocation）"></a><strong>(2) 重定位（Relocation）</strong></h4><ul>
<li><strong>合并节（Section Merging）</strong>：<ul>
<li>所有 <code>.text</code> 节合并为一个 <code>.text</code> 段。</li>
<li>所有 <code>.data</code> 节合并为一个 <code>.data</code> 段。</li>
<li>…</li>
</ul>
</li>
<li><strong>分配运行时内存地址</strong>：<ul>
<li>链接器根据程序的内存布局（如 ELF 的 Program Headers），为每个段分配虚拟内存地址。</li>
<li>例如，<code>.text</code> 段可能被分配到 <code>0x400000</code>。</li>
</ul>
</li>
<li><strong>修正地址引用</strong>：<ul>
<li>遍历重定位表（<code>.rela.text</code>）。</li>
<li>找到 <code>call printf</code> 指令的位置。</li>
<li>计算 <code>printf</code> 的<strong>运行时地址</strong>（可能通过 PLT&#x2F;GOT 机制）。</li>
<li>将相对偏移写入该位置。</li>
</ul>
</li>
</ul>
<h4 id="3-处理库文件"><a href="#3-处理库文件" class="headerlink" title="(3) 处理库文件"></a><strong>(3) 处理库文件</strong></h4><ul>
<li><strong>静态库（<code>.a</code>）</strong>：是 <code>.o</code> 文件的归档。链接器只提取需要的 <code>.o</code> 文件（如 <code>printf.o</code>）并合并进来。生成的可执行文件包含库代码，体积大，但独立。</li>
<li><strong>共享库（<code>.so</code>）</strong>：动态链接。链接器只记录依赖（如 <code>libc.so.6</code>），不包含实际代码。运行时由<strong>动态链接器（<code>ld-linux.so</code>）</strong> 加载。</li>
</ul>
<hr>
<h2 id="第二部分：可执行文件与加载执行"><a href="#第二部分：可执行文件与加载执行" class="headerlink" title="第二部分：可执行文件与加载执行"></a><strong>第二部分：可执行文件与加载执行</strong></h2><h3 id="最终的可执行文件-hello"><a href="#最终的可执行文件-hello" class="headerlink" title="最终的可执行文件 hello"></a><strong>最终的可执行文件 <code>hello</code></strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file hello</span><br><span class="line"><span class="comment"># 输出：hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped</span></span><br></pre></td></tr></table></figure>

<p><strong>关键信息：</strong></p>
<ul>
<li><strong>ELF 可执行文件</strong>。</li>
<li><strong>动态链接</strong>：依赖共享库。</li>
<li><strong>解释器（Interpreter）</strong>：<code>/lib64/ld-linux-x86-64.so.2</code>，即动态链接器。</li>
</ul>
<h3 id="程序的加载与执行过程"><a href="#程序的加载与执行过程" class="headerlink" title="程序的加载与执行过程"></a><strong>程序的加载与执行过程</strong></h3><ol>
<li><strong>用户执行 <code>./hello</code></strong></li>
<li><strong>操作系统内核</strong>：<ul>
<li>读取文件头，识别为 ELF 文件。</li>
<li>发现需要解释器 <code>/lib64/ld-linux-x86-64.so.2</code>。</li>
</ul>
</li>
<li><strong>内核加载动态链接器</strong>：<ul>
<li>将 <code>ld-linux.so</code> 加载到内存。</li>
<li>将控制权交给它。</li>
</ul>
</li>
<li><strong>动态链接器（<code>ld-linux.so</code>）</strong>：<ul>
<li>解析 <code>hello</code> 的依赖（如 <code>libc.so.6</code>）。</li>
<li>在系统路径（<code>/lib</code>, <code>/usr/lib</code>）中查找并加载这些共享库到内存。</li>
<li>进行<strong>动态重定位</strong>（如填充 GOT 表）。</li>
<li>调用 <code>hello</code> 的初始化函数（如果有）。</li>
</ul>
</li>
<li><strong>跳转到 <code>_start</code></strong><ul>
<li>动态链接器将控制权交给程序的入口点 <code>_start</code>（由 C 运行时库 <code>crt0.o</code> 提供）。</li>
</ul>
</li>
<li><strong>C 运行时初始化</strong><ul>
<li><code>_start</code> 设置堆栈、环境变量、调用 <code>__libc_start_main</code>。</li>
<li>初始化 <code>libc</code>，调用全局构造函数（C++）。</li>
</ul>
</li>
<li><strong>调用 <code>main()</code></strong><ul>
<li>最终调用我们写的 <code>main()</code> 函数。</li>
</ul>
</li>
<li><strong>程序运行</strong></li>
<li><strong><code>main()</code> 返回</strong><ul>
<li>调用 <code>exit()</code>，清理资源，返回状态码给操作系统。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第三部分：高级主题"><a href="#第三部分：高级主题" class="headerlink" title="第三部分：高级主题"></a><strong>第三部分：高级主题</strong></h2><h3 id="1-静态链接-vs-动态链接"><a href="#1-静态链接-vs-动态链接" class="headerlink" title="1. 静态链接 vs 动态链接"></a><strong>1. 静态链接 vs 动态链接</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td>生成文件</td>
<td>包含所有代码</td>
<td>只包含自身代码，依赖外部 <code>.so</code></td>
</tr>
<tr>
<td>体积</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>启动速度</td>
<td>快（无需加载库）</td>
<td>稍慢（需加载和链接库）</td>
</tr>
<tr>
<td>内存占用</td>
<td>每个进程独立副本</td>
<td>多个进程共享同一库</td>
</tr>
<tr>
<td>更新</td>
<td>需重新编译</td>
<td>只需替换 <code>.so</code> 文件</td>
</tr>
<tr>
<td>命令</td>
<td><code>gcc -static hello.c</code></td>
<td>默认行为</td>
</tr>
</tbody></table>
<h3 id="2-PLT-Procedure-Linkage-Table-与-GOT-Global-Offset-Table"><a href="#2-PLT-Procedure-Linkage-Table-与-GOT-Global-Offset-Table" class="headerlink" title="2. PLT (Procedure Linkage Table) 与 GOT (Global Offset Table)"></a><strong>2. PLT (Procedure Linkage Table) 与 GOT (Global Offset Table)</strong></h3><p>用于实现<strong>延迟绑定（Lazy Binding）</strong>，提高启动速度。</p>
<ul>
<li><strong>GOT</strong>：存放函数的实际地址（运行时由动态链接器填充）。</li>
<li><strong>PLT</strong>：一段跳转代码。<ul>
<li>第一次调用 <code>printf</code>：<ul>
<li>跳转到 PLT 条目。</li>
<li>PLT 跳转到 GOT。</li>
<li>GOT 指向 PLT 中的“解析代码”。</li>
<li>解析代码调用动态链接器查找 <code>printf</code> 地址，写入 GOT。</li>
<li>跳转到 <code>printf</code>。</li>
</ul>
</li>
<li>后续调用：<ul>
<li>PLT → GOT → 直接跳转到 <code>printf</code>（无需解析）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-ELF-文件结构详解"><a href="#3-ELF-文件结构详解" class="headerlink" title="3. ELF 文件结构详解"></a><strong>3. ELF 文件结构详解</strong></h3><p>一个 ELF 文件包含：</p>
<ul>
<li><strong>ELF Header</strong>：描述文件类型、架构、入口点、Program Header Table 和 Section Header Table 的位置。</li>
<li><strong>Program Header Table</strong>：用于加载器，描述如何将文件映射到内存（如 <code>.text</code>, <code>.data</code> 段）。</li>
<li><strong>Section Header Table</strong>：用于链接器和调试器，描述各个节（<code>.text</code>, <code>.symtab</code> 等）。</li>
<li><strong>Segments</strong>：由 Program Headers 描述，是加载时的单位。</li>
<li><strong>Sections</strong>：由 Section Headers 描述，是链接时的单位。</li>
</ul>
<blockquote>
<p>通常，一个 Segment 包含多个 Section。</p>
</blockquote>
<h3 id="4-位置无关代码-PIC-与位置无关可执行文件-PIE"><a href="#4-位置无关代码-PIC-与位置无关可执行文件-PIE" class="headerlink" title="4. 位置无关代码 (PIC) 与位置无关可执行文件 (PIE)"></a><strong>4. 位置无关代码 (PIC) 与位置无关可执行文件 (PIE)</strong></h3><ul>
<li><strong>PIC</strong>：代码可以加载到任意内存地址执行（共享库必须是 PIC）。</li>
<li><strong>PIE</strong>：可执行文件也是 PIC，提高安全性（ASLR）。</li>
<li>编译选项：<code>-fPIC</code>（生成 PIC 目标文件），<code>-fPIE -pie</code>（生成 PIE 可执行文件）。</li>
</ul>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>从一行 <code>#include &lt;stdio.h&gt;</code> 到屏幕上打印 “Hello, World!”，背后是预处理器、编译器、汇编器、链接器、操作系统内核、动态链接器等多个组件的精密协作。理解这一过程，不仅有助于编写更高效的代码，更能深入掌握程序的运行本质。</p>
<p><strong>关键收获：</strong></p>
<ul>
<li>编译是<strong>预处理 → 编译 → 汇编 → 链接</strong>的流水线。</li>
<li>目标文件（<code>.o</code>）是<strong>可重定位</strong>的，包含代码、数据、符号表、重定位表。</li>
<li>链接器负责<strong>符号解析</strong>和<strong>重定位</strong>，合并多个目标文件。</li>
<li>可执行文件的加载依赖<strong>动态链接器</strong>，通过 <strong>PLT&#x2F;GOT</strong> 实现函数调用。</li>
<li><strong>ELF</strong> 是 Linux 下程序的“身份证”，定义了所有结构。</li>
</ul>
<p>掌握这些底层知识，你将不再只是“写代码”，而是真正“理解程序如何运行”。</p>
<hr>
<p><strong>参考文献：</strong></p>
<ol>
<li>《程序员的自我修养：链接、装载与库》—— 俞甲子、石凡、潘爱民</li>
<li>《Linkers and Loaders》—— John R. Levine</li>
<li>《Computer Systems: A Programmer’s Perspective》—— Bryant &amp; O’Hallaron</li>
<li>GCC, Binutils, Glibc 官方文档</li>
<li>ELF Specification (Tool Interface Standard)</li>
</ol>
<p><strong>工具推荐：</strong></p>
<ul>
<li><code>gcc</code>, <code>clang</code>：编译器</li>
<li><code>as</code>, <code>ld</code>：汇编器和链接器</li>
<li><code>objdump</code>, <code>readelf</code>, <code>nm</code>：二进制分析</li>
<li><code>gdb</code>：调试器</li>
<li><code>strace</code>, <code>ltrace</code>：系统调用和库调用跟踪</li>
</ul>
<blockquote>
<p>本文内容基于 x86-64 Linux 系统，其他平台（如 ARM, Windows PE）原理类似，细节略有不同。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>可执行文件，编译</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解cpio：Linux下的归档工具与嵌入式领域核心应用</title>
    <url>/2025/09/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%80%E4%B9%88%E6%98%AFcpio/</url>
    <content><![CDATA[<p>在Unix&#x2F;Linux系统中，归档工具是数据打包、备份和系统构建的基础组件。除了广为人知的<code>tar</code>，<code>cpio</code>（Copy-In&#x2F;Copy-Out）也是一款历史悠久且功能灵活的归档工具，尤其在<strong>嵌入式系统构建</strong>（如生成initramfs根文件系统）和<strong>系统级操作</strong>（如内核模块打包、日志归档）中不可或缺。本文将从cpio的定义、核心特性、常用操作命令，到其在嵌入式领域的关键应用，全面解析cpio的原理与实践。</p>
<h2 id="一、cpio的基本定义与核心用途"><a href="#一、cpio的基本定义与核心用途" class="headerlink" title="一、cpio的基本定义与核心用途"></a>一、cpio的基本定义与核心用途</h2><p><code>cpio</code>是Unix&#x2F;Linux系统中的一款<strong>流式归档工具</strong>，核心功能是将多个文件&#x2F;目录打包成单一的“cpio归档文件”（通常以<code>.cpio</code>为后缀），或从归档文件中提取内容。其设计理念是“通过标准输入（stdin）接收文件列表，通过标准输出（stdout）生成归档数据”，这种“流式处理”特性使其能灵活结合管道（<code>|</code>）与其他工具（如<code>find</code>、<code>gzip</code>）协作，适应复杂的文件打包场景。</p>
<h3 id="与tar的核心差异：为什么需要cpio？"><a href="#与tar的核心差异：为什么需要cpio？" class="headerlink" title="与tar的核心差异：为什么需要cpio？"></a>与tar的核心差异：为什么需要cpio？</h3><p><code>cpio</code>与<code>tar</code>同为归档工具，但设计思路和适用场景有显著区别，理解二者差异能帮助你选择合适的工具：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>cpio</th>
<th>tar（GNU tar）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入方式</strong></td>
<td>依赖外部工具（如<code>find</code>）通过管道提供文件列表，不直接支持“目录递归打包”</td>
<td>可直接指定目录（如<code>tar -cf archive.tar dir/</code>），自动递归处理子目录</td>
</tr>
<tr>
<td><strong>归档格式</strong></td>
<td>支持多种格式（bin、odc、newc、crc等），兼容性强</td>
<td>主要使用tar格式（支持gzip&#x2F;bzip2压缩扩展）</td>
</tr>
<tr>
<td><strong>核心优势</strong></td>
<td>1. 流式处理灵活，易与管道结合；<br>2. 支持设备文件、符号链接、硬链接等特殊文件；<br>3. <code>newc</code>格式适合嵌入式initramfs</td>
<td>1. 操作简单，日常归档场景更易用；<br>2. 内置压缩支持（如<code>-z</code>启用gzip）；<br>3. 广泛兼容各类系统</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>1. 嵌入式Linux生成initramfs根文件系统；<br>2. 系统级备份（如打包&#x2F;dev目录下的设备文件）；<br>3. 内核模块或驱动的归档</td>
<td>1. 日常文件&#x2F;目录备份（如<code>tar -czf backup.tar.gz docs/</code>）；<br>2. 跨系统文件传输；<br>3. 源码包分发</td>
</tr>
</tbody></table>
<h2 id="二、cpio的核心特性与归档格式"><a href="#二、cpio的核心特性与归档格式" class="headerlink" title="二、cpio的核心特性与归档格式"></a>二、cpio的核心特性与归档格式</h2><h3 id="1-核心特性"><a href="#1-核心特性" class="headerlink" title="1. 核心特性"></a>1. 核心特性</h3><p>cpio的灵活性源于其独特的设计，主要特性包括：</p>
<ul>
<li><strong>流式I&#x2F;O</strong>：不直接操作目录，而是通过“标准输入接收文件路径列表，标准输出生成归档数据”，可无缝结合管道（如<code>find ./files | cpio -o &gt; archive.cpio</code>）；</li>
<li><strong>全文件类型支持</strong>：可归档普通文件、目录、设备文件（字符设备、块设备）、符号链接、硬链接，且能保留文件的权限、所有者、修改时间等元数据；</li>
<li><strong>多格式兼容</strong>：支持多种归档格式，适配不同场景（如嵌入式、老旧系统兼容）；</li>
<li><strong>无压缩默认</strong>：cpio本身仅负责归档，不内置压缩功能，需配合<code>gzip</code>&#x2F;<code>bzip2</code>等工具实现压缩（如<code>cpio -o | gzip &gt; archive.cpio.gz</code>）。</li>
</ul>
<h3 id="2-常用归档格式"><a href="#2-常用归档格式" class="headerlink" title="2. 常用归档格式"></a>2. 常用归档格式</h3><p>cpio支持多种归档格式，通过<code>-H</code>参数指定，不同格式的适用场景不同：</p>
<ul>
<li><strong>bin格式</strong>（默认）：最早期的cpio格式，兼容性强，但不支持超过4GB的文件，且无校验机制，易出错；</li>
<li><strong>odc格式</strong>（Old ASCII Format）：ASCII编码的格式，兼容性优于bin，支持更大文件，但仍无校验；</li>
<li><strong>newc格式</strong>（SVR4 Portable Format）：最常用的格式，支持32位inode、大文件（超过4GB）、文件权限扩展，且包含简单校验，<strong>嵌入式Linux的initramfs必须使用newc格式</strong>；</li>
<li><strong>crc格式</strong>：在newc基础上增加了文件的CRC校验，适合对数据完整性要求高的场景（如备份）；</li>
<li><strong>hpux格式</strong>：适配HP-UX系统的格式，日常使用极少。</li>
</ul>
<h2 id="三、cpio的关键操作命令（实战示例）"><a href="#三、cpio的关键操作命令（实战示例）" class="headerlink" title="三、cpio的关键操作命令（实战示例）"></a>三、cpio的关键操作命令（实战示例）</h2><p>cpio的命令格式遵循“模式+参数”的逻辑，核心模式包括<strong>创建归档（-o）</strong>、<strong>提取归档（-i）</strong>、<strong>列表查看（-t）</strong>，结合不同参数实现具体功能。以下是最常用的操作示例（基于Linux系统）：</p>
<h3 id="1-基础准备：理解“文件列表输入”"><a href="#1-基础准备：理解“文件列表输入”" class="headerlink" title="1. 基础准备：理解“文件列表输入”"></a>1. 基础准备：理解“文件列表输入”</h3><p>cpio不直接支持<code>cpio -o archive.cpio dir/</code>这类“指定目录”的操作，必须通过<strong>文件列表</strong>（每行一个文件&#x2F;目录路径）作为输入。最常用的方式是通过<code>find</code>命令生成文件列表，再通过管道传递给cpio，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成当前目录下所有文件（含子目录）的列表，输出到文件list.txt</span></span><br><span class="line">find . &gt; list.txt</span><br><span class="line"><span class="comment"># 查看列表内容（每行一个路径）</span></span><br><span class="line"><span class="built_in">cat</span> list.txt</span><br></pre></td></tr></table></figure>


<h3 id="2-创建cpio归档（-o模式）"><a href="#2-创建cpio归档（-o模式）" class="headerlink" title="2. 创建cpio归档（-o模式）"></a>2. 创建cpio归档（-o模式）</h3><p><code>-o</code>（copy-out）模式用于创建归档，核心参数：</p>
<ul>
<li><code>-H 格式</code>：指定归档格式（如<code>-H newc</code>）；</li>
<li><code>-v</code>：详细输出（显示正在归档的文件路径）；</li>
<li>输入：通过管道或文件提供文件列表；</li>
<li>输出：通过重定向（<code>&gt;</code>）生成归档文件。</li>
</ul>
<h4 id="示例1：创建newc格式的归档（嵌入式常用）"><a href="#示例1：创建newc格式的归档（嵌入式常用）" class="headerlink" title="示例1：创建newc格式的归档（嵌入式常用）"></a>示例1：创建newc格式的归档（嵌入式常用）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景：将./rootfs目录下的所有文件归档为rootfs.cpio（newc格式）</span></span><br><span class="line"><span class="comment"># 1. 用find生成./rootfs下的所有文件列表，通过管道传给cpio</span></span><br><span class="line"><span class="comment"># 2. -o：创建归档；-H newc：指定newc格式；-v：详细输出</span></span><br><span class="line"><span class="comment"># 3. &gt; rootfs.cpio：将归档数据写入文件</span></span><br><span class="line">find ./rootfs | cpio -o -H newc -v &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>

<h4 id="示例2：创建带压缩的归档（结合gzip）"><a href="#示例2：创建带压缩的归档（结合gzip）" class="headerlink" title="示例2：创建带压缩的归档（结合gzip）"></a>示例2：创建带压缩的归档（结合gzip）</h4><p>cpio本身不支持压缩，需通过管道结合<code>gzip</code>&#x2F;<code>bzip2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景：创建压缩的cpio归档（gzip压缩，后缀通常为.cpio.gz）</span></span><br><span class="line">find ./docs | cpio -o -H newc | gzip -9 &gt; docs.cpio.gz</span><br><span class="line"><span class="comment"># 说明：-9是gzip的最高压缩级别，压缩率高但速度慢；-1是最快压缩</span></span><br></pre></td></tr></table></figure>


<h3 id="3-提取cpio归档（-i模式）"><a href="#3-提取cpio归档（-i模式）" class="headerlink" title="3. 提取cpio归档（-i模式）"></a>3. 提取cpio归档（-i模式）</h3><p><code>-i</code>（copy-in）模式用于从归档中提取文件，核心参数：</p>
<ul>
<li><code>-d</code>：自动创建提取所需的目录（若归档中的文件包含子目录，必须加此参数，否则会报错）；</li>
<li><code>-m</code>：保留文件的修改时间（默认提取后文件时间为当前时间）；</li>
<li><code>-v</code>：详细输出（显示正在提取的文件路径）；</li>
<li><code>-F 归档文件</code>：指定要提取的归档文件（也可通过标准输入传递，如<code>cat archive.cpio | cpio -i</code>）。</li>
</ul>
<h4 id="示例1：提取未压缩的归档"><a href="#示例1：提取未压缩的归档" class="headerlink" title="示例1：提取未压缩的归档"></a>示例1：提取未压缩的归档</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景：提取rootfs.cpio到当前目录</span></span><br><span class="line"><span class="comment"># -i：提取模式；-d：创建目录；-m：保留修改时间；-v：详细输出</span></span><br><span class="line"><span class="comment"># -F rootfs.cpio：指定要提取的归档文件</span></span><br><span class="line">cpio -i -d -m -v -F rootfs.cpio</span><br><span class="line"><span class="comment"># 提取后，当前目录会生成./rootfs目录及其中的文件（与归档时的结构一致）</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2：提取压缩的归档（结合gunzip）"><a href="#示例2：提取压缩的归档（结合gunzip）" class="headerlink" title="示例2：提取压缩的归档（结合gunzip）"></a>示例2：提取压缩的归档（结合gunzip）</h4><p>若归档是压缩的（如.cpio.gz），需先解压再提取，或通过管道直接处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1：先解压为未压缩归档，再提取（两步操作）</span></span><br><span class="line">gunzip docs.cpio.gz  <span class="comment"># 生成docs.cpio</span></span><br><span class="line">cpio -i -d -m -v -F docs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：通过管道直接解压并提取（一步操作，更高效）</span></span><br><span class="line">gunzip -c docs.cpio.gz | cpio -i -d -m -v</span><br><span class="line"><span class="comment"># 说明：gunzip -c 表示将解压结果输出到stdout，不生成中间文件docs.cpio</span></span><br></pre></td></tr></table></figure>


<h3 id="4-查看归档内容（-t模式）"><a href="#4-查看归档内容（-t模式）" class="headerlink" title="4. 查看归档内容（-t模式）"></a>4. 查看归档内容（-t模式）</h3><p><code>-t</code>（table）模式用于查看归档中的文件列表，无需提取，核心参数与<code>-i</code>类似：</p>
<h4 id="示例1：查看未压缩归档的内容"><a href="#示例1：查看未压缩归档的内容" class="headerlink" title="示例1：查看未压缩归档的内容"></a>示例1：查看未压缩归档的内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景：查看rootfs.cpio中的文件列表</span></span><br><span class="line">cpio -t -v -F rootfs.cpio</span><br><span class="line"><span class="comment"># 输出：类似ls -l的格式，显示每个文件的权限、所有者、大小、路径</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2：查看压缩归档的内容"><a href="#示例2：查看压缩归档的内容" class="headerlink" title="示例2：查看压缩归档的内容"></a>示例2：查看压缩归档的内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景：查看docs.cpio.gz中的文件列表（先解压再列表）</span></span><br><span class="line">gunzip -c docs.cpio.gz | cpio -t -v</span><br></pre></td></tr></table></figure>


<h3 id="5-高级操作：筛选提取特定文件"><a href="#5-高级操作：筛选提取特定文件" class="headerlink" title="5. 高级操作：筛选提取特定文件"></a>5. 高级操作：筛选提取特定文件</h3><p>cpio支持在提取时通过“模式匹配”筛选文件，只需在命令末尾添加文件名或通配符：</p>
<h4 id="示例：从rootfs-cpio中仅提取etc目录下的passwd文件"><a href="#示例：从rootfs-cpio中仅提取etc目录下的passwd文件" class="headerlink" title="示例：从rootfs.cpio中仅提取etc目录下的passwd文件"></a>示例：从rootfs.cpio中仅提取etc目录下的passwd文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式：cpio -i -d -m -v -F 归档文件 目标文件路径</span></span><br><span class="line">cpio -i -d -m -v -F rootfs.cpio ./rootfs/etc/passwd</span><br><span class="line"><span class="comment"># 提取后，当前目录会生成./rootfs/etc/passwd（完整路径结构）</span></span><br></pre></td></tr></table></figure>


<h2 id="四、cpio的典型应用场景（重点：嵌入式initramfs）"><a href="#四、cpio的典型应用场景（重点：嵌入式initramfs）" class="headerlink" title="四、cpio的典型应用场景（重点：嵌入式initramfs）"></a>四、cpio的典型应用场景（重点：嵌入式initramfs）</h2><p>cpio的最核心应用是<strong>嵌入式Linux系统的initramfs根文件系统构建</strong>，这也是区别于tar的关键场景。以下详细解析这一应用：</p>
<h3 id="1-什么是initramfs？"><a href="#1-什么是initramfs？" class="headerlink" title="1. 什么是initramfs？"></a>1. 什么是initramfs？</h3><p>initramfs（Initial RAM Filesystem）是嵌入式Linux启动时加载到内存中的<strong>临时根文件系统</strong>，其作用是：</p>
<ul>
<li>启动阶段（内核启动后、真正的根文件系统挂载前）提供必要的工具和驱动，如加载磁盘驱动、检测硬件、挂载真实根文件系统（如SD卡、NAND Flash中的rootfs）；</li>
<li>体积小、加载快，需紧凑的归档格式存储，而cpio的newc格式恰好满足这一需求（支持大文件、保留权限、易于内核解析）。</li>
</ul>
<h3 id="2-用cpio生成initramfs的完整流程"><a href="#2-用cpio生成initramfs的完整流程" class="headerlink" title="2. 用cpio生成initramfs的完整流程"></a>2. 用cpio生成initramfs的完整流程</h3><p>嵌入式开发中，生成initramfs的步骤通常为：</p>
<h4 id="步骤1：构建initramfs目录结构"><a href="#步骤1：构建initramfs目录结构" class="headerlink" title="步骤1：构建initramfs目录结构"></a>步骤1：构建initramfs目录结构</h4><p>先创建initramfs所需的目录和文件（如<code>bin</code>、<code>etc</code>、<code>lib</code>、<code>sbin</code>、<code>init</code>脚本），示例结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./initramfs/</span><br><span class="line">├── bin/          # 基础命令（如sh、ls、mount）</span><br><span class="line">├── etc/          # 配置文件（如fstab、inittab）</span><br><span class="line">├── lib/          # 动态链接库（支持bin目录下的命令）</span><br><span class="line">├── sbin/         # 系统命令（如insmod、mount）</span><br><span class="line">└── init          # 启动脚本（initramfs的入口，内核启动后执行）</span><br></pre></td></tr></table></figure>
<p>其中，<code>init</code>脚本是核心，负责加载驱动、挂载真实根文件系统，示例简化版<code>init</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 挂载proc和sysfs文件系统（内核必要的虚拟文件系统）</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载磁盘驱动模块（如mmc驱动，用于识别SD卡）</span></span><br><span class="line">insmod /lib/mmc_block.ko</span><br><span class="line">insmod /lib/sdhci.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载真实根文件系统（假设真实rootfs在/dev/mmcblk0p2，ext4格式）</span></span><br><span class="line">mount -t ext4 /dev/mmcblk0p2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到真实根文件系统，执行/sbin/init</span></span><br><span class="line"><span class="built_in">exec</span> switch_root /mnt /sbin/init</span><br></pre></td></tr></table></figure>

<h4 id="步骤2：用cpio生成newc格式的initramfs镜像"><a href="#步骤2：用cpio生成newc格式的initramfs镜像" class="headerlink" title="步骤2：用cpio生成newc格式的initramfs镜像"></a>步骤2：用cpio生成newc格式的initramfs镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入initramfs目录的上级目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/parent</span><br><span class="line"><span class="comment"># 生成initramfs.cpio（newc格式）</span></span><br><span class="line">find ./initramfs | cpio -o -H newc &gt; initramfs.cpio</span><br><span class="line"><span class="comment"># （可选）压缩镜像（减少体积，内核支持gzip压缩的initramfs）</span></span><br><span class="line">gzip -9 initramfs.cpio  <span class="comment"># 生成initramfs.cpio.gz</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤3：内核加载initramfs"><a href="#步骤3：内核加载initramfs" class="headerlink" title="步骤3：内核加载initramfs"></a>步骤3：内核加载initramfs</h4><p>将生成的<code>initramfs.cpio</code>或<code>initramfs.cpio.gz</code>与内核镜像（zImage）一起烧录到嵌入式设备，内核启动时会自动识别并加载initramfs，执行其中的<code>init</code>脚本，完成后续启动流程。</p>
<h3 id="3-其他应用场景"><a href="#3-其他应用场景" class="headerlink" title="3. 其他应用场景"></a>3. 其他应用场景</h3><p>除了嵌入式initramfs，cpio还用于以下场景：</p>
<ul>
<li><strong>系统设备文件备份</strong>：<code>/dev</code>目录下的设备文件（如<code>/dev/sda</code>、<code>/dev/ttyS0</code>）是特殊文件，tar备份可能丢失元数据，而cpio可完整归档：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /dev -<span class="built_in">type</span> b -o -<span class="built_in">type</span> c | cpio -o -H newc &gt; dev_backup.cpio</span><br></pre></td></tr></table></figure></li>
<li><strong>内核模块归档</strong>：将多个内核模块（.ko文件）打包成cpio归档，便于在initramfs中加载：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./kernel_modules -name <span class="string">&quot;*.ko&quot;</span> | cpio -o -H newc &gt; modules.cpio</span><br></pre></td></tr></table></figure></li>
<li><strong>日志或临时文件归档</strong>：对分散的日志文件（如<code>/var/log/</code>下的多个日志），用find筛选后归档：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/log -name <span class="string">&quot;*.log&quot;</span> -mtime +7 | cpio -o -H newc | gzip &gt; old_logs.cpio.gz</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="五、使用cpio的注意事项"><a href="#五、使用cpio的注意事项" class="headerlink" title="五、使用cpio的注意事项"></a>五、使用cpio的注意事项</h2><ol>
<li><strong>文件路径必须完整</strong>：cpio归档的文件路径是<code>find</code>输出的路径（如<code>./rootfs/etc/passwd</code>），提取时会按完整路径生成目录，若需“扁平提取”（忽略上级目录），需先处理文件列表（如用<code>sed</code>替换路径）；</li>
<li><strong>newc格式是嵌入式的首选</strong>：生成initramfs时，必须使用<code>-H newc</code>，否则内核无法解析；</li>
<li><strong>权限与所有者问题</strong>：归档时会保留文件的权限和所有者（如root用户），提取时若当前用户不是root，可能因权限不足无法提取某些文件（需加<code>sudo</code>）；</li>
<li><strong>压缩与解压的配合</strong>：cpio不内置压缩，需明确结合<code>gzip</code>&#x2F;<code>gunzip</code>，避免直接提取压缩归档（如<code>cpio -i -F docs.cpio.gz</code>会报错，需先解压）；</li>
<li><strong>大文件支持</strong>：若归档包含超过4GB的文件，必须使用<code>newc</code>或<code>crc</code>格式，bin&#x2F;odc格式不支持大文件。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>cpio是一款功能灵活的流式归档工具，其核心优势在于<strong>支持特殊文件、流式管道操作、newc格式适配嵌入式initramfs</strong>，虽日常归档场景不如tar易用，但在系统级操作和嵌入式开发中不可或缺。</p>
<ul>
<li>若你是<strong>嵌入式开发者</strong>，cpio是生成initramfs的必备工具，需熟练掌握<code>find + cpio -o -H newc</code>的组合命令；</li>
<li>若你是<strong>Linux系统管理员</strong>，cpio可用于设备文件备份、特殊场景的归档，补充tar的不足；</li>
<li>若你是<strong>普通用户</strong>，日常文件归档优先选择tar（操作更简单），仅在需要处理特殊文件或流式场景时考虑cpio。</li>
</ul>
<p>掌握cpio的核心操作与应用场景，能让你在Linux系统操作和嵌入式开发中更灵活地处理归档需求。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>cpio</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解字节序</title>
    <url>/2025/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%AD%97%E8%8A%82%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="深入理解字节序：计算机数据存储的基石"><a href="#深入理解字节序：计算机数据存储的基石" class="headerlink" title="深入理解字节序：计算机数据存储的基石"></a>深入理解字节序：计算机数据存储的基石</h1><p>在计算机系统和网络通信中，数据的表示和传输是一个基础而关键的问题。当我们讨论数据如何在内存中存储，或者如何在网络上发送时，一个看似微小但影响深远的概念便浮现出来：<strong>字节序（Endianness）</strong>。字节序决定了多字节数据类型（如整数、浮点数）在内存中的字节排列顺序。理解字节序对于开发跨平台软件、进行网络编程以及调试底层系统问题至关重要。</p>
<h2 id="什么是字节序？"><a href="#什么是字节序？" class="headerlink" title="什么是字节序？"></a>什么是字节序？</h2><p>字节序描述的是多字节数据类型在内存中存储时，其字节的排列顺序。具体来说，它定义了最高有效字节（Most Significant Byte, MSB）和最低有效字节（Least Significant Byte, LSB）在内存地址中的位置。</p>
<p>想象一下，我们要在内存中存储一个32位（4字节）的整数 <code>0x12345678</code>：</p>
<ul>
<li><strong>最高有效字节 (MSB)</strong>: <code>0x12</code> (代表最高位的数值)</li>
<li><strong>最低有效字节 (LSB)</strong>: <code>0x78</code> (代表最低位的数值)</li>
</ul>
<p>不同的字节序规则会以不同的方式将这四个字节 <code>12</code>, <code>34</code>, <code>56</code>, <code>78</code> 放置在连续的内存地址中。</p>
<h3 id="1-大端序-Big-Endian"><a href="#1-大端序-Big-Endian" class="headerlink" title="1. 大端序 (Big-Endian)"></a>1. 大端序 (Big-Endian)</h3><p>在大端序系统中，<strong>最高有效字节存储在最低的内存地址</strong>上。字节的排列顺序与我们人类书写数字的习惯一致。</p>
<p>以存储 <code>0x12345678</code> 为例：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">字节值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x1000</td>
<td align="left">0x12 (MSB)</td>
</tr>
<tr>
<td align="left">0x1001</td>
<td align="left">0x34</td>
</tr>
<tr>
<td align="left">0x1002</td>
<td align="left">0x56</td>
</tr>
<tr>
<td align="left">0x1003</td>
<td align="left">0x78 (LSB)</td>
</tr>
</tbody></table>
<p><strong>特点</strong>:</p>
<ul>
<li>人类可读性强，符合从左到右、从高位到低位的阅读习惯。</li>
<li>网络协议（如TCP&#x2F;IP）标准采用大端序，因此大端序也被称为<strong>网络字节序 (Network Byte Order)</strong>。</li>
<li>常见于：IBM大型机、Motorola 68000系列处理器、SPARC架构，以及网络传输。</li>
</ul>
<h3 id="2-小端序-Little-Endian"><a href="#2-小端序-Little-Endian" class="headerlink" title="2. 小端序 (Little-Endian)"></a>2. 小端序 (Little-Endian)</h3><p>在小端序系统中，<strong>最低有效字节存储在最低的内存地址</strong>上。字节的排列顺序与人类习惯相反。</p>
<p>同样存储 <code>0x12345678</code>：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">字节值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x1000</td>
<td align="left">0x78 (LSB)</td>
</tr>
<tr>
<td align="left">0x1001</td>
<td align="left">0x56</td>
</tr>
<tr>
<td align="left">0x1002</td>
<td align="left">0x34</td>
</tr>
<tr>
<td align="left">0x1003</td>
<td align="left">0x12 (MSB)</td>
</tr>
</tbody></table>
<p><strong>特点</strong>:</p>
<ul>
<li>在进行数值比较或加法运算时，可以从最低地址开始逐字节处理，效率较高。</li>
<li>现代大多数个人计算机和服务器采用小端序。</li>
<li>常见于：x86、x86_64 (Intel&#x2F;AMD) 架构，这是目前PC和服务器市场的主流。</li>
</ul>
<h3 id="3-混合序-Middle-Endian-PDP-Endian"><a href="#3-混合序-Middle-Endian-PDP-Endian" class="headerlink" title="3. 混合序 (Middle-Endian &#x2F; PDP-Endian)"></a>3. 混合序 (Middle-Endian &#x2F; PDP-Endian)</h3><p>这是一种较少见的字节序，也称为PDP-Endian，源自PDP-11计算机。它在多字节数据的字节排列上采用一种“混合”方式。例如，对于32位整数 <code>0x12345678</code>，它可能先按16位分组，再在组内按小端序存储：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">字节值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x1000</td>
<td align="left">0x56</td>
</tr>
<tr>
<td align="left">0x1001</td>
<td align="left">0x78</td>
</tr>
<tr>
<td align="left">0x1002</td>
<td align="left">0x12</td>
</tr>
<tr>
<td align="left">0x1003</td>
<td align="left">0x34</td>
</tr>
</tbody></table>
<p>这种字节序现在已基本被淘汰。</p>
<h2 id="为什么字节序如此重要？"><a href="#为什么字节序如此重要？" class="headerlink" title="为什么字节序如此重要？"></a>为什么字节序如此重要？</h2><p>字节序的重要性主要体现在以下几个方面：</p>
<ol>
<li><p><strong>跨平台数据交换</strong>:<br>当一台小端序机器（如你的PC）生成的数据文件被一台大端序机器（如某些嵌入式系统或旧式工作站）读取时，如果不对字节序进行转换，读取到的数值将是错误的。例如，PC上存储的 <code>0x1234</code> 在大端序机器上会被解释为 <code>0x3412</code>。</p>
</li>
<li><p><strong>网络通信</strong>:<br>TCP&#x2F;IP协议栈明确规定使用<strong>大端序</strong>作为网络字节序。这意味着无论你的计算机是小端序还是大端序，在发送网络数据包之前，都必须将多字节字段（如IP地址、端口号、序列号等）转换为大端序；在接收数据包后，需要将大端序的数据转换为本机字节序进行处理。C语言中的 <code>htons()</code> (host to network short), <code>htonl()</code> (host to network long), <code>ntohs()</code> (network to host short), <code>ntohl()</code> (network to host long) 等函数就是为此目的而设计的。</p>
</li>
<li><p><strong>文件格式兼容性</strong>:<br>许多文件格式（如图像格式PNG、TIFF，音频格式WAV，以及一些数据库文件）会明确规定其多字节字段的字节序。程序在读写这些文件时，必须遵循该格式的字节序约定，否则会导致数据解析错误。</p>
</li>
<li><p><strong>内存转储和调试</strong>:<br>在进行内存分析或调试时，理解目标系统的字节序对于正确解释内存中的原始字节数据至关重要。</p>
</li>
</ol>
<h2 id="如何判断系统的字节序？"><a href="#如何判断系统的字节序？" class="headerlink" title="如何判断系统的字节序？"></a>如何判断系统的字节序？</h2><p>我们可以通过编写简单的程序来检测当前系统的字节序。以下是一个经典的C语言示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *ptr = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value: 0x%08X\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address 0x%p: 0x%02X\n&quot;</span>, (<span class="type">void</span>*)ptr, ptr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address 0x%p: 0x%02X\n&quot;</span>, (<span class="type">void</span>*)(ptr+<span class="number">1</span>), ptr[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address 0x%p: 0x%02X\n&quot;</span>, (<span class="type">void</span>*)(ptr+<span class="number">2</span>), ptr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address 0x%p: 0x%02X\n&quot;</span>, (<span class="type">void</span>*)(ptr+<span class="number">3</span>), ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr[<span class="number">0</span>] == <span class="number">0x78</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This system is Little-Endian.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptr[<span class="number">0</span>] == <span class="number">0x12</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This system is Big-Endian.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This system has an unusual byte order (e.g., Middle-Endian).\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>：将一个已知的多字节整数（如 <code>0x12345678</code>）的地址强制转换为指向 <code>unsigned char</code> 的指针。通过检查最低地址 (<code>ptr[0]</code>) 存储的是 <code>0x78</code> 还是 <code>0x12</code>，即可判断是小端序还是大端序。</p>
<h2 id="处理字节序问题的策略"><a href="#处理字节序问题的策略" class="headerlink" title="处理字节序问题的策略"></a>处理字节序问题的策略</h2><ol>
<li><p><strong>使用标准库函数</strong>:<br>在进行网络编程时，务必使用 <code>htons</code>, <code>htonl</code>, <code>ntohs</code>, <code>ntohl</code> 等函数进行字节序转换。</p>
</li>
<li><p><strong>明确定义文件格式</strong>:<br>设计自定义文件格式或协议时，明确指定所有多字节字段的字节序（通常推荐使用大端序以保证跨平台兼容性）。</p>
</li>
<li><p><strong>使用跨平台库</strong>:<br>利用如 Google Protocol Buffers, Apache Thrift 等序列化库，它们内部处理了字节序问题，提供了语言和平台无关的数据交换格式。</p>
</li>
<li><p><strong>在代码中显式处理</strong>:<br>对于需要直接操作字节流的场景，编写字节序转换函数（如 <code>swap_bytes_16</code>, <code>swap_bytes_32</code>），并在必要时调用。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字节序是计算机底层数据表示的一个基本概念。虽然现代高级编程语言和框架在很大程度上隐藏了字节序的复杂性，但在系统编程、网络开发、嵌入式开发和处理二进制数据时，理解字节序的差异及其影响是必不可少的。记住：</p>
<ul>
<li><strong>大端序 (Big-Endian)</strong>: 高位字节存放在低地址，<strong>网络字节序</strong>。</li>
<li><strong>小端序 (Little-Endian)</strong>: 低位字节存放在低地址，<strong>x86&#x2F;x64 主流</strong>。</li>
<li><strong>网络传输</strong> 必须使用大端序。</li>
<li>跨平台数据交换时，<strong>字节序转换</strong>是关键。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>字节序</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qemu的Linux驱动开发</title>
    <url>/2025/09/25/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%9F%BA%E4%BA%8Eqemu%E7%9A%84Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="基于qemu的Linux驱动开发"><a href="#基于qemu的Linux驱动开发" class="headerlink" title="基于qemu的Linux驱动开发"></a>基于qemu的Linux驱动开发</h1><h2 id="📁-第一步：准备驱动代码（hello-c）"><a href="#📁-第一步：准备驱动代码（hello-c）" class="headerlink" title="📁 第一步：准备驱动代码（hello.c）"></a>📁 第一步：准备驱动代码（hello.c）</h2><p>在你的 Linux 系统中（或宿主机上交叉编译），创建一个文件 <code>hello.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">#include &lt;linux/cdev.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEVICE_NAME &quot;hello&quot;</span><br><span class="line">#define CLASS_NAME  &quot;hello_class&quot;</span><br><span class="line"></span><br><span class="line">static int major_number;</span><br><span class="line">static struct class* hello_class = NULL;</span><br><span class="line">static struct device* hello_device = NULL;</span><br><span class="line"></span><br><span class="line">static char message[32] = &quot;Hello, QEMU Linux!\n&quot;;</span><br><span class="line">static size_t msg_len;</span><br><span class="line"></span><br><span class="line">// 设备的 read 函数</span><br><span class="line">static ssize_t hello_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    if (*offset &gt;= msg_len)</span><br><span class="line">        return 0; // 已读完</span><br><span class="line"></span><br><span class="line">    if (len &gt; msg_len - *offset)</span><br><span class="line">        len = msg_len - *offset;</span><br><span class="line"></span><br><span class="line">    if (copy_to_user(buffer, message + *offset, len))</span><br><span class="line">        return -EFAULT;</span><br><span class="line"></span><br><span class="line">    *offset += len;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// file_operations 结构体</span><br><span class="line">static struct file_operations fops = &#123;</span><br><span class="line">    .read = hello_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 模块初始化函数</span><br><span class="line">static int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO &quot;Hello: Registering device...\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 注册设备号</span><br><span class="line">    major_number = register_chrdev(0, DEVICE_NAME, &amp;fops);</span><br><span class="line">    if (major_number &lt; 0) &#123;</span><br><span class="line">        printk(KERN_ALERT &quot;Hello: Failed to register major number.\n&quot;);</span><br><span class="line">        return major_number;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO &quot;Hello: Registered with major number %d\n&quot;, major_number);</span><br><span class="line"></span><br><span class="line">    // 创建设备类</span><br><span class="line">    hello_class = class_create(CLASS_NAME);</span><br><span class="line">    if (IS_ERR(hello_class)) &#123;</span><br><span class="line">        unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">        printk(KERN_ALERT &quot;Failed to create class.\n&quot;);</span><br><span class="line">        return PTR_ERR(hello_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建设备文件（/dev/hello）</span><br><span class="line">    hello_device = device_create(hello_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);</span><br><span class="line">    if (IS_ERR(hello_device)) &#123;</span><br><span class="line">        class_destroy(hello_class);</span><br><span class="line">        unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">        printk(KERN_ALERT &quot;Failed to create device.\n&quot;);</span><br><span class="line">        return PTR_ERR(hello_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg_len = strlen(message);</span><br><span class="line">    printk(KERN_INFO &quot;Hello: Device /dev/hello created successfully.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 模块退出函数</span><br><span class="line">static void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(hello_class, MKDEV(major_number, 0));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line">    unregister_chrdev(major_number, DEVICE_NAME);</span><br><span class="line">    printk(KERN_INFO &quot;Hello: Goodbye from kernel!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Your Name&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple Hello World Linux driver&quot;);</span><br><span class="line">MODULE_VERSION(&quot;0.1&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🛠-第二步：编写-Makefile（用于编译）"><a href="#🛠-第二步：编写-Makefile（用于编译）" class="headerlink" title="🛠 第二步：编写 Makefile（用于编译）"></a>🛠 第二步：编写 Makefile（用于编译）</h2><p>在同一目录下创建 <code>Makefile</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line">KDIR := ~/ext4linux/linux-6.6.106</span><br><span class="line"></span><br><span class="line"># 指定架构和交叉编译前缀</span><br><span class="line">ARCH := arm</span><br><span class="line">CROSS_COMPILE := arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) clean</span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 注意：如果你是在 QEMU 中直接编译（不推荐，因为可能缺少内核头文件），请确保安装了 <code>linux-headers-$(uname -r)</code>。更推荐在<strong>宿主机上交叉编译</strong>，然后把 <code>.ko</code> 文件传到 QEMU 里。</p>
</blockquote>
<hr>
<h2 id="🚀-第三步：编译并加载驱动"><a href="#🚀-第三步：编译并加载驱动" class="headerlink" title="🚀 第三步：编译并加载驱动"></a>🚀 第三步：编译并加载驱动</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>若编译报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODPOST /home/yxa/my_driver/hello/Module.symvers</span><br><span class="line">WARNING: Module.symvers is missing.</span><br><span class="line">         Modules may not have dependencies or modversions.</span><br><span class="line">         You may get many unresolved symbol errors.</span><br><span class="line">         You can set KBUILD_MODPOST_WARN=1 to turn errors into warning</span><br><span class="line">         if you want to proceed at your own risk.</span><br></pre></td></tr></table></figure>

<p>在宿主机上正确准备内核构建环境</p>
<hr>
<p>🚀 步骤 1：进入内核源码目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/yxa/ext4linux/linux-6.6.106</span><br></pre></td></tr></table></figure>

<hr>
<p>🛠 步骤 2：配置内核（生成 .config）</p>
<p>你需要一个基础配置。因为你是为 QEMU 编译，推荐使用默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- defconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 如果你知道你的 QEMU 系统用的是哪个 defconfig（比如 <code>vexpress_defconfig</code>, <code>multi_v7_defconfig</code>），可以用那个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- vexpress_defconfig</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<p>🛠 步骤 3：准备模块编译环境（最关键！）</p>
<p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules_prepare</span><br></pre></td></tr></table></figure>

<p>这个命令会：</p>
<ul>
<li>生成 <code>Module.symvers</code></li>
<li>编译必要的内核脚本（如 <code>modpost</code>, <code>genksyms</code> 等）</li>
<li>生成头文件依赖</li>
<li>设置好架构相关的符号链接</li>
</ul>
<blockquote>
<p>✅ 这是解决你当前所有 “undefined symbol” 错误的关键一步！</p>
</blockquote>
<hr>
<p>🧪 步骤 4：（可选）验证是否生成了 Module.symvers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l Module.symvers</span><br></pre></td></tr></table></figure>

<p>应该看到一个非空文件（几 KB 到几 MB）。</p>
<hr>
<p>🧹 步骤 5：回到你的驱动目录，重新编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/yxa/my_driver/hello</span><br><span class="line">make clean</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>现在应该能顺利编译通过！</p>
<h3 id="使用-9p-virtio-文件共享将驱动文件共享到qemu内的Linux系统"><a href="#使用-9p-virtio-文件共享将驱动文件共享到qemu内的Linux系统" class="headerlink" title="使用 9p virtio 文件共享将驱动文件共享到qemu内的Linux系统"></a>使用 <strong>9p virtio 文件共享</strong>将驱动文件共享到qemu内的Linux系统</h3><p>创建共享目录（可选，也可以直接用当前目录）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/qemushare/hello</span><br><span class="line">cp /home/yxa/my_driver/hello/hello.ko $HOME/qemushare/hello</span><br></pre></td></tr></table></figure>

<p>启动 QEMU 时添加 9p 参数（关键！）</p>
<p>修改run.sh文件内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">qemu-system-arm \</span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line">    -cpu cortex-a9 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ~/ext4linux/linux-6.6.106/arch/arm/boot/zImage \</span><br><span class="line">    -drive if=none,file=rootfs.ext4,format=raw,id=hd0 \</span><br><span class="line">    -device virtio-blk-device,drive=hd0 \</span><br><span class="line">    -dtb ~/ext4linux/linux-6.6.106/arch/arm/boot/dts/arm/vexpress-v2p-ca9.dtb \</span><br><span class="line">    -append &quot;console=ttyAMA0 root=/dev/vda rootfstype=ext4 rw init=/init&quot; \</span><br><span class="line">    -nographic \</span><br><span class="line">    -fsdev local,id=hostshare,path=$HOME/qemushare,security_model=none \</span><br><span class="line">    -device virtio-9p-device,fsdev=hostshare,mount_tag=hostshare</span><br></pre></td></tr></table></figure>

<p>成功启动后在 QEMU 系统中挂载共享目录</p>
<p>进入 QEMU 系统后，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/host</span><br><span class="line">mount -t 9p -o trans=virtio hostshare /mnt/host</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 QEMU 中测试</span><br><span class="line">cd /mnt/host/hello</span><br><span class="line">ls即可看到驱动文件</span><br></pre></td></tr></table></figure>

<h3 id="测试驱动模块："><a href="#测试驱动模块：" class="headerlink" title="测试驱动模块："></a>测试驱动模块：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加载模块</span><br><span class="line">sudo insmod hello.ko</span><br><span class="line"></span><br><span class="line"># 查看是否创建了设备节点</span><br><span class="line">ls -l /dev/hello</span><br><span class="line"></span><br><span class="line"># 测试读取</span><br><span class="line">cat /dev/hello</span><br></pre></td></tr></table></figure>

<p>你应该看到输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, QEMU Linux!</span><br></pre></td></tr></table></figure>

<p>卸载驱动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rmmod hello</span><br><span class="line">dmesg | tail  # 查看内核日志</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>qemu</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统中的冷启动与热启动</title>
    <url>/2025/11/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>在嵌入式系统中，<strong>热启动（Warm Boot &#x2F; Warm Reset）</strong> 和 <strong>冷启动（Cold Boot &#x2F; Cold Reset）</strong> 是两种不同的系统重启或初始化方式，它们在<strong>硬件状态、初始化范围、启动速度和应用场景</strong>上有显著区别。</p>
<hr>
<h2 id="一、冷启动（Cold-Boot）"><a href="#一、冷启动（Cold-Boot）" class="headerlink" title="一、冷启动（Cold Boot）"></a>一、冷启动（Cold Boot）</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>冷启动是指 <strong>系统从完全断电或完全复位状态开始的启动过程</strong>。此时，整个芯片（包括 CPU、内存、外设等）都处于<strong>初始上电状态</strong>，所有寄存器和存储单元的内容都是未定义或默认值。</p>
<h3 id="触发方式："><a href="#触发方式：" class="headerlink" title="触发方式："></a>触发方式：</h3><ul>
<li>上电（Power-on）</li>
<li>硬件复位引脚（RESET#）被拉低</li>
<li>看门狗超时导致的硬复位（部分系统）</li>
</ul>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>硬件状态</strong></td>
<td>所有寄存器、RAM、外设恢复到芯片手册定义的复位值</td>
</tr>
<tr>
<td><strong>内存内容</strong></td>
<td>RAM 数据丢失（除非有后备电源）；Flash&#x2F;ROM 保持不变</td>
</tr>
<tr>
<td><strong>初始化范围</strong></td>
<td><strong>完整初始化</strong>：时钟、电源、内存控制器、外设、中断控制器等全部重新配置</td>
</tr>
<tr>
<td><strong>启动时间</strong></td>
<td>较长（几十毫秒到几秒）</td>
</tr>
<tr>
<td><strong>软件流程</strong></td>
<td>从 BootROM 或复位向量开始，执行完整的 Bootloader → OS&#x2F;应用</td>
</tr>
</tbody></table>
<h3 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a>典型场景：</h3><ul>
<li>设备首次上电</li>
<li>系统崩溃后硬件复位</li>
<li>用户按下“复位按钮”</li>
</ul>
<blockquote>
<p>✅ <strong>冷启动 &#x3D; “从零开始，一切重来”</strong></p>
</blockquote>
<hr>
<h2 id="二、热启动（Warm-Boot）"><a href="#二、热启动（Warm-Boot）" class="headerlink" title="二、热启动（Warm Boot）"></a>二、热启动（Warm Boot）</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>热启动是指 <strong>系统在不断电、CPU 和部分内存仍保持供电的情况下，仅对软件或部分硬件进行重新初始化</strong>。通常由<strong>软件触发</strong>，硬件状态（如 RAM 内容）可能被保留。</p>
<h3 id="触发方式：-1"><a href="#触发方式：-1" class="headerlink" title="触发方式："></a>触发方式：</h3><ul>
<li>软件写特定寄存器（如系统控制寄存器中的复位位）</li>
<li>操作系统调用重启接口（如 Linux 的 <code>reboot()</code>）</li>
<li>应用程序主动跳转到复位向量（不触发硬件复位）</li>
</ul>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>硬件状态</strong></td>
<td><strong>部分保留</strong>：RAM 数据通常保留；外设可能未复位</td>
</tr>
<tr>
<td><strong>内存内容</strong></td>
<td>RAM 中的数据<strong>可能仍然有效</strong>（可用于传递重启原因、调试信息）</td>
</tr>
<tr>
<td><strong>初始化范围</strong></td>
<td><strong>部分初始化</strong>：可能跳过时钟、DDR 初始化等耗时步骤</td>
</tr>
<tr>
<td><strong>启动时间</strong></td>
<td>较短（几毫秒到几百毫秒）</td>
</tr>
<tr>
<td><strong>软件流程</strong></td>
<td>可能直接跳转到 Bootloader 或应用入口，跳过底层硬件初始化</td>
</tr>
</tbody></table>
<h3 id="典型场景：-1"><a href="#典型场景：-1" class="headerlink" title="典型场景："></a>典型场景：</h3><ul>
<li>系统软件升级后重启</li>
<li>应用程序崩溃后快速恢复</li>
<li>调试时快速重启（保留 RAM 中的日志）</li>
<li>低功耗唤醒后的“软复位”</li>
</ul>
<blockquote>
<p>✅ <strong>热启动 &#x3D; “快速重启，尽量保留现场”</strong></p>
</blockquote>
<hr>
<h2 id="三、关键区别对比表"><a href="#三、关键区别对比表" class="headerlink" title="三、关键区别对比表"></a>三、关键区别对比表</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>冷启动（Cold Boot）</th>
<th>热启动（Warm Boot）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>是否断电</strong></td>
<td>是（或等效断电）</td>
<td>否（系统持续供电）</td>
</tr>
<tr>
<td><strong>RAM 数据</strong></td>
<td>丢失</td>
<td>通常保留</td>
</tr>
<tr>
<td><strong>外设状态</strong></td>
<td>完全复位</td>
<td>可能保持原状态</td>
</tr>
<tr>
<td><strong>时钟&#x2F;电源</strong></td>
<td>重新初始化</td>
<td>可能跳过</td>
</tr>
<tr>
<td><strong>DDR 初始化</strong></td>
<td>必须执行</td>
<td>可能跳过（若 RAM 仍有效）</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td><strong>触发方式</strong></td>
<td>硬件复位、上电</td>
<td>软件复位、跳转</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>首次启动、严重错误恢复</td>
<td>快速重启、OTA 升级、调试</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、嵌入式系统中的实现示例"><a href="#四、嵌入式系统中的实现示例" class="headerlink" title="四、嵌入式系统中的实现示例"></a>四、嵌入式系统中的实现示例</h2><h3 id="1-通过复位原因寄存器区分"><a href="#1-通过复位原因寄存器区分" class="headerlink" title="1. 通过复位原因寄存器区分"></a>1. <strong>通过复位原因寄存器区分</strong></h3><p>许多 MCU（如 STM32、ESP32、RISC-V SoC）提供 <strong>复位状态寄存器（RSTSR &#x2F; RESET_CAUSE）</strong>，软件可在启动时读取以判断是冷启还是热启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (read_reset_cause() == WARM_RESET) &#123;</span><br><span class="line">    <span class="comment">// 跳过 DDR 初始化，直接使用 RAM</span></span><br><span class="line">    skip_ddr_init = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从 RAM 中读取上次保存的上下文</span></span><br><span class="line">    restore_context();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行完整初始化</span></span><br><span class="line">    init_clocks();</span><br><span class="line">    init_ddr();</span><br><span class="line">    init_peripherals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-保留-RAM-区域（Retention-RAM）"><a href="#2-保留-RAM-区域（Retention-RAM）" class="headerlink" title="2. 保留 RAM 区域（Retention RAM）"></a>2. <strong>保留 RAM 区域（Retention RAM）</strong></h3><ul>
<li>某些芯片提供 <strong>“备份域 RAM”</strong> 或 <strong>“低功耗 RAM”</strong>，即使在热启动中也保证数据不丢失</li>
<li>用于存储重启标志、崩溃日志、系统状态等</li>
</ul>
<h3 id="3-RISC-V-中的热启动"><a href="#3-RISC-V-中的热启动" class="headerlink" title="3. RISC-V 中的热启动"></a>3. <strong>RISC-V 中的热启动</strong></h3><ul>
<li>在 OpenSBI 或 Bootloader 中，可通过 <code>sbi_system_reset()</code> 触发热启动</li>
<li>若平台支持，可设置 <code>reset_type = SBI_SRST_RESET_TYPE_SHUTDOWN</code> 或 <code>WARM_REBOOT</code></li>
</ul>
<hr>
<h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol>
<li><strong>热启动不等于“安全”</strong><br>如果外设处于异常状态（如 UART FIFO 满、DMA 挂起），热启动可能导致系统行为异常。<strong>关键外设仍需软件复位</strong>。</li>
<li><strong>堆栈和全局变量不可依赖</strong><br>即使 RAM 保留，C 运行时环境（如 <code>.bss</code>、<code>.data</code> 段）通常会在启动时被重新初始化，<strong>不能假设全局变量值有效</strong>。</li>
<li><strong>看门狗复位通常是冷启动</strong><br>大多数看门狗超时会触发<strong>系统级硬复位</strong>，属于冷启动。</li>
</ol>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><table>
<thead>
<tr>
<th>启动类型</th>
<th>本质</th>
<th>速度</th>
<th>数据保留</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>冷启动</strong></td>
<td>硬件完全复位</td>
<td>慢</td>
<td>❌ 无</td>
<td>首次上电、严重故障恢复</td>
</tr>
<tr>
<td><strong>热启动</strong></td>
<td>软件控制重启</td>
<td>快</td>
<td>✅ 部分（RAM）</td>
<td>快速恢复、升级、调试</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>设计建议</strong>：<br>在嵌入式系统中，合理利用热启动可以显著提升用户体验（如设备“秒启”），但必须确保关键外设和状态机被正确重置。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>冷启动</tag>
        <tag>热启动</tag>
      </tags>
  </entry>
  <entry>
    <title>内部中断和外部中断</title>
    <url>/2025/11/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD%E5%92%8C%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p>在嵌入式系统中，<strong>中断（Interrupt）</strong> 是一种重要的机制，用于处理异步事件。它允许处理器暂停当前任务，转而去处理更紧急或更高优先级的事件，处理完毕后再返回原来的任务继续执行。根据中断源的不同，可以将中断分为 <strong>内部中断（Internal Interrupt）</strong> 和 <strong>外部中断（External Interrupt）</strong>。</p>
<hr>
<h2 id="一、内部中断（Internal-Interrupt）"><a href="#一、内部中断（Internal-Interrupt）" class="headerlink" title="一、内部中断（Internal Interrupt）"></a>一、内部中断（Internal Interrupt）</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>内部中断是由 <strong>CPU 内部产生的中断请求</strong>，通常由以下原因触发：</p>
<ul>
<li><strong>异常（Exception）</strong>：如除零错误、非法指令、地址越界等。</li>
<li><strong>软件中断（Software Interrupt）</strong>：通过特定指令（如 ARM 的 <code>SWI</code> 指令，x86 的 <code>INT</code> 指令）主动触发，常用于系统调用（System Call）。</li>
<li><strong>定时器中断（部分归为内部）</strong>：如果定时器集成在 CPU 内部（如 Cortex-M 系列的 SysTick），其产生的中断有时也被视为内部中断。</li>
</ul>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>中断源来自 CPU 内部逻辑。</li>
<li>通常与程序执行状态直接相关（如出错、调试、特权切换）。</li>
<li>响应速度快，因为不需要经过外部引脚或总线。</li>
<li>不可屏蔽（某些关键异常）或可通过软件控制是否响应。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul>
<li>在 ARM Cortex-M 中，<code>HardFault</code>、<code>MemManage</code>、<code>BusFault</code> 都是内部异常。</li>
<li>使用 <code>svc</code>（Supervisor Call）指令发起系统调用，触发 SVC 异常。</li>
</ul>
<hr>
<h2 id="二、外部中断（External-Interrupt）"><a href="#二、外部中断（External-Interrupt）" class="headerlink" title="二、外部中断（External Interrupt）"></a>二、外部中断（External Interrupt）</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>外部中断是由 <strong>CPU 外部硬件设备</strong> 通过专用中断引脚（如 IRQ、NMI）或中断控制器（如 NVIC、GIC）向 CPU 发出的中断请求。</p>
<p>常见来源包括：</p>
<ul>
<li>按键按下（GPIO 触发）</li>
<li>串口接收数据完成</li>
<li>ADC 转换结束</li>
<li>外部传感器信号变化</li>
<li>网络控制器收到数据包</li>
</ul>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>中断源来自芯片外部或片内外设（如 UART、SPI、GPIO 等）。</li>
<li>通常通过 <strong>边沿触发（上升&#x2F;下降沿）</strong> 或 <strong>电平触发（高&#x2F;低电平）</strong> 方式激活。</li>
<li>可配置优先级（尤其在支持 NVIC 的 MCU 中，如 STM32）。</li>
<li>可被屏蔽（通过中断使能&#x2F;禁止寄存器）。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><ul>
<li>STM32 的 EXTI（External Interrupt&#x2F;Event Controller）模块可将 GPIO 引脚配置为外部中断源。</li>
<li>当按键按下时，GPIO 电平变化触发 EXTI0 中断，CPU 跳转到对应的 ISR（中断服务例程）处理。</li>
</ul>
<hr>
<h2 id="三、对比总结"><a href="#三、对比总结" class="headerlink" title="三、对比总结"></a>三、对比总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>内部中断</th>
<th>外部中断</th>
</tr>
</thead>
<tbody><tr>
<td>中断源</td>
<td>CPU 内部（异常、指令、定时器等）</td>
<td>CPU 外部（外设、传感器、按键等）</td>
</tr>
<tr>
<td>触发方式</td>
<td>程序执行异常或软件指令</td>
<td>硬件信号（电平&#x2F;边沿）</td>
</tr>
<tr>
<td>是否可屏蔽</td>
<td>部分不可屏蔽（如 NMI、HardFault）</td>
<td>通常可屏蔽</td>
</tr>
<tr>
<td>典型用途</td>
<td>错误处理、系统调用、调试</td>
<td>实时响应外部事件</td>
</tr>
<tr>
<td>响应延迟</td>
<td>极低</td>
<td>略高（取决于引脚和电路）</td>
</tr>
<tr>
<td>是否需要配置引脚</td>
<td>否</td>
<td>是（如配置 GPIO 为中断输入）</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、实际应用中的协同"><a href="#四、实际应用中的协同" class="headerlink" title="四、实际应用中的协同"></a>四、实际应用中的协同</h2><p>在嵌入式开发中，内部中断和外部中断常常协同工作。例如：</p>
<ul>
<li>用户按下按键（外部中断） → 触发 ISR 设置标志位 → 主循环或 RTOS 任务读取标志并调用系统服务（可能涉及软件中断&#x2F;SVC）。</li>
<li>外设 DMA 传输完成（外部中断） → 触发内部调度器进行任务切换（可能涉及 PendSV 异常，属于内部中断）。</li>
</ul>
<hr>
<h2 id="五、典型架构示例（以-ARM-Cortex-M-为例）"><a href="#五、典型架构示例（以-ARM-Cortex-M-为例）" class="headerlink" title="五、典型架构示例（以 ARM Cortex-M 为例）"></a>五、典型架构示例（以 ARM Cortex-M 为例）</h2><p>Cortex-M 系列使用 <strong>NVIC（Nested Vectored Interrupt Controller）</strong> 统一管理中断，包括：</p>
<ul>
<li><strong>系统异常（内部）</strong>：如 Reset、NMI、HardFault、SVC、PendSV、SysTick。</li>
<li><strong>外部中断（IRQ0~IRQ240）</strong>：对应各种外设中断，如 EXTI、UART、TIMER 等。</li>
</ul>
<p>所有中断都具有可编程优先级，并支持嵌套中断（高优先级可打断低优先级）。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qemu的Linux系统移植</title>
    <url>/2025/09/18/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%9F%BA%E4%BA%8Eqemu%E7%9A%84Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<h1 id="基于qemu的Linux系统移植"><a href="#基于qemu的Linux系统移植" class="headerlink" title="基于qemu的Linux系统移植"></a>基于qemu的Linux系统移植</h1><ul>
<li>交叉编译 U-Boot</li>
<li>交叉编译 Linux 内核</li>
<li>制作根文件系统（initramfs &#x2F; initrd &#x2F; ext4 等）</li>
<li>使用 QEMU 模拟器“运行”整个系统</li>
<li>调试启动流程</li>
</ul>
<hr>
<h2 id="🎯-目标"><a href="#🎯-目标" class="headerlink" title="🎯 目标"></a>🎯 目标</h2><p>在 x86_64 主机 + 虚拟机（或直接在主机）环境下，为<strong>ARM架构</strong>（或其他架构，如 RISC-V）构建并运行一个完整的 Linux 系统（U-Boot + Kernel + RootFS），使用 QEMU 模拟目标硬件。</p>
<hr>
<h2 id="✅-推荐方案：使用-QEMU-ARM-架构模拟"><a href="#✅-推荐方案：使用-QEMU-ARM-架构模拟" class="headerlink" title="✅ 推荐方案：使用 QEMU + ARM 架构模拟"></a>✅ 推荐方案：使用 QEMU + ARM 架构模拟</h2><p>我们以 <strong>ARMv7 &#x2F; ARM64（aarch64）</strong> 为例，这是嵌入式最常用的架构之一。</p>
<hr>
<h1 id="🧱-一、环境准备"><a href="#🧱-一、环境准备" class="headerlink" title="🧱 一、环境准备"></a>🧱 一、环境准备</h1><h2 id="1-安装必要工具（在-Ubuntu-Debian-系统为例）"><a href="#1-安装必要工具（在-Ubuntu-Debian-系统为例）" class="headerlink" title="1. 安装必要工具（在 Ubuntu&#x2F;Debian 系统为例）"></a>1. 安装必要工具（在 Ubuntu&#x2F;Debian 系统为例）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y git build-essential gcc-arm-linux-gnueabihf gcc-aarch64-linux-gnu \</span><br><span class="line">    qemu-system-arm qemu-system-aarch64 qemu-utils debootstrap libncurses-dev \</span><br><span class="line">    flex bison libssl-dev libelf-dev bc kmod cpio</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你用的是 CentOS&#x2F;RHEL，请用 <code>yum</code> 或 <code>dnf</code> 安装对应包。</p>
</blockquote>
<hr>
<h2 id="2-创建工作目录"><a href="#2-创建工作目录" class="headerlink" title="2. 创建工作目录"></a>2. 创建工作目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/embedded-linux &amp;&amp; <span class="built_in">cd</span> ~/embedded-linux</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🛠️-二、编译-U-Boot（以-qemu-arm-virt-为例）"><a href="#🛠️-二、编译-U-Boot（以-qemu-arm-virt-为例）" class="headerlink" title="🛠️ 二、编译 U-Boot（以 qemu_arm_virt 为例）"></a>🛠️ 二、编译 U-Boot（以 qemu_arm_virt 为例）</h1><p>我们使用 QEMU 支持的 <code>virt</code> 板子（虚拟 ARM 板）。</p>
<h2 id="1-下载-U-Boot-源码"><a href="#1-下载-U-Boot-源码" class="headerlink" title="1. 下载 U-Boot 源码"></a>1. 下载 U-Boot 源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://source.denx.de/u-boot/u-boot.git</span><br><span class="line"><span class="built_in">cd</span> u-boot</span><br><span class="line">git checkout v2025.01  <span class="comment"># 选择一个稳定版本</span></span><br></pre></td></tr></table></figure>

<h2 id="2-配置并编译（ARM32）"><a href="#2-配置并编译（ARM32）" class="headerlink" title="2. 配置并编译（ARM32）"></a>2. 配置并编译（ARM32）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">make qemu_arm_defconfig</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译完成后会生成 <code>u-boot</code> 可执行文件（ELF 格式）。</p>
</blockquote>
<hr>
<h2 id="3-（可选）ARM64-编译"><a href="#3-（可选）ARM64-编译" class="headerlink" title="3. （可选）ARM64 编译"></a>3. （可选）ARM64 编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">git <span class="built_in">clone</span> https://source.denx.de/u-boot/u-boot.git u-boot-aarch64</span><br><span class="line"><span class="built_in">cd</span> u-boot-aarch64</span><br><span class="line">git checkout v2025.01</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"></span><br><span class="line">make qemu_arm64_defconfig</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>生成 <code>u-boot</code> 文件。</p>
<hr>
<h1 id="🐧-三、编译-Linux-内核"><a href="#🐧-三、编译-Linux-内核" class="headerlink" title="🐧 三、编译 Linux 内核"></a>🐧 三、编译 Linux 内核</h1><h2 id="1-下载内核源码"><a href="#1-下载内核源码" class="headerlink" title="1. 下载内核源码"></a>1. 下载内核源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/embedded-linux</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git</span><br><span class="line"><span class="built_in">cd</span> linux</span><br></pre></td></tr></table></figure>

<h2 id="2-配置内核（ARM32）"><a href="#2-配置内核（ARM32）" class="headerlink" title="2. 配置内核（ARM32）"></a>2. 配置内核（ARM32）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">make vexpress_defconfig  <span class="comment"># 适用于 QEMU ARM</span></span><br><span class="line"><span class="comment"># 或者更通用的：</span></span><br><span class="line">make multi_v7_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：图形化配置（需要 libncurses-dev）</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐启用：</p>
<ul>
<li><code>CONFIG_BLK_DEV_INITRD=y</code> （支持 initramfs）</li>
<li><code>CONFIG_DEVTMPFS=y</code> 和 <code>CONFIG_DEVTMPFS_MOUNT=y</code></li>
<li><code>CONFIG_SERIAL_AMBA_PL011=y</code> 和 <code>CONFIG_SERIAL_AMBA_PL011_CONSOLE=y</code>（串口支持）</li>
</ul>
</blockquote>
<h2 id="3-编译内核和设备树"><a href="#3-编译内核和设备树" class="headerlink" title="3. 编译内核和设备树"></a>3. 编译内核和设备树</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>) zImage dtbs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成文件：</p>
<ul>
<li><code>arch/arm/boot/zImage</code></li>
<li><code>arch/arm/boot/dts/virt.dtb</code>（或 <code>vexpress-v2p-ca9.dtb</code>）</li>
</ul>
</blockquote>
<hr>
<h2 id="4-（可选）ARM64-内核编译"><a href="#4-（可选）ARM64-内核编译" class="headerlink" title="4. （可选）ARM64 内核编译"></a>4. （可选）ARM64 内核编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig  <span class="comment"># 可选配置</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) Image dtbs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成 <code>arch/arm64/boot/Image</code></p>
</blockquote>
<hr>
<h1 id="📁-四、制作根文件系统（RootFS）"><a href="#📁-四、制作根文件系统（RootFS）" class="headerlink" title="📁 四、制作根文件系统（RootFS）"></a>📁 四、制作根文件系统（RootFS）</h1><h2 id="方法-1：使用-BusyBox-Initramfs（推荐入门）"><a href="#方法-1：使用-BusyBox-Initramfs（推荐入门）" class="headerlink" title="方法 1：使用 BusyBox + Initramfs（推荐入门）"></a>方法 1：使用 BusyBox + Initramfs（推荐入门）</h2><h3 id="1-下载并编译-BusyBox"><a href="#1-下载并编译-BusyBox" class="headerlink" title="1. 下载并编译 BusyBox"></a>1. 下载并编译 BusyBox</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/embedded-linux</span><br><span class="line">git <span class="built_in">clone</span> https://git.busybox.net/busybox</span><br><span class="line"><span class="built_in">cd</span> busybox</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 menuconfig 中设置：</p>
<ul>
<li><code>Settings → Build static binary (no shared libs)</code> → 启用（避免动态库依赖）</li>
<li><code>Settings → Use hardware accelerated instructions if possible</code> → 关闭（避免后续报错）</li>
<li><code>Linux System Utilities → [*] mdev</code>（用于设备管理）</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>) install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装到 <code>_install</code> 目录</p>
</blockquote>
<h3 id="2-创建-initramfs-目录结构"><a href="#2-创建-initramfs-目录结构" class="headerlink" title="2. 创建 initramfs 目录结构"></a>2. 创建 initramfs 目录结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/embedded-linux/initramfs/&#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;,dev,tmp&#125;</span><br><span class="line"><span class="built_in">cp</span> -a busybox/_install/* ~/embedded-linux/initramfs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 init 脚本</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ~/embedded-linux/initramfs/init &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello from embedded Linux!&quot;</span></span><br><span class="line"><span class="built_in">exec</span> /bin/sh</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x ~/embedded-linux/initramfs/init</span><br></pre></td></tr></table></figure>

<h3 id="3-打包成-initramfs"><a href="#3-打包成-initramfs" class="headerlink" title="3. 打包成 initramfs"></a>3. 打包成 initramfs</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/embedded-linux/initramfs</span><br><span class="line">find . | cpio -o -H newc | gzip &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>编写脚本文件run.sh便于启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">     -M vexpress-a9\</span><br><span class="line">     -cpu cortex-a9 \</span><br><span class="line">     -m 512M \</span><br><span class="line">     -kernel ~/embedded-linux/linux-6.6.106/arch/arm/boot/zImage \</span><br><span class="line">     -initrd ~/embedded-linux/initramfs.cpio.gz \</span><br><span class="line">     -dtb ~/embedded-linux/linux-6.6.106/arch/arm/boot/dts/arm/vexpress-v2p-ca9.dtb \</span><br><span class="line">     -append <span class="string">&quot;console=ttyAMA0 root=/dev/ram rw init=/init&quot;</span> \</span><br><span class="line">     -nographic</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="方法-2：使用-Buildroot（更完整，推荐进阶）"><a href="#方法-2：使用-Buildroot（更完整，推荐进阶）" class="headerlink" title="方法 2：使用 Buildroot（更完整，推荐进阶）"></a>方法 2：使用 Buildroot（更完整，推荐进阶）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/embedded-linux</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/buildroot/buildroot.git</span><br><span class="line"><span class="built_in">cd</span> buildroot</span><br><span class="line"></span><br><span class="line">make qemu_arm_virt_defconfig</span><br><span class="line">make menuconfig  <span class="comment"># 可选配置</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出在 <code>output/images/</code>：</p>
<ul>
<li><code>zImage</code></li>
<li><code>rootfs.ext2</code></li>
<li><code>u-boot.bin</code>（如果启用了）</li>
</ul>
</blockquote>
<h2 id="方法-3：直接使用-ext4作为根文件系统"><a href="#方法-3：直接使用-ext4作为根文件系统" class="headerlink" title="方法 3：直接使用 ext4作为根文件系统"></a>方法 3：直接使用 ext4作为根文件系统</h2><p>制作 ext4 根文件系统（核心替换步骤）</p>
<p>✅ 替换原来 initramfs 的部分，改为制作 ext4 镜像</p>
<h3 id="1-编译-BusyBox（和原来一样，但安装到-ext4-结构中）"><a href="#1-编译-BusyBox（和原来一样，但安装到-ext4-结构中）" class="headerlink" title="1. 编译 BusyBox（和原来一样，但安装到 ext4 结构中）"></a>1. 编译 BusyBox（和原来一样，但安装到 ext4 结构中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/embedded-linux/busybox</span><br><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置：</p>
<ul>
<li><code>Settings → Build static binary (no shared libs)</code> → 启用（避免动态库依赖）</li>
<li><code>Settings → Use hardware accelerated instructions if possible</code> → 关闭（避免后续报错）</li>
<li>其他默认即可</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成 <code>_install</code> 目录</p>
</blockquote>
<hr>
<h3 id="2-创建-ext4-根文件系统镜像"><a href="#2-创建-ext4-根文件系统镜像" class="headerlink" title="2. 创建 ext4 根文件系统镜像"></a>2. 创建 ext4 根文件系统镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/ext4linux</span><br><span class="line"></span><br><span class="line"># 创建 64MB 镜像文件</span><br><span class="line">dd if=/dev/zero of=rootfs.ext4 bs=1M count=64</span><br><span class="line"></span><br><span class="line"># 格式化为 ext4</span><br><span class="line">mkfs.ext4 rootfs.ext4</span><br><span class="line"></span><br><span class="line"># 挂载并填充内容</span><br><span class="line">mkdir -p mnt</span><br><span class="line">sudo mount rootfs.ext4 mnt</span><br><span class="line"></span><br><span class="line"># 复制 busybox 内容</span><br><span class="line">sudo cp -a busybox/_install/* mnt</span><br><span class="line"></span><br><span class="line"># 创建必要目录</span><br><span class="line">sudo mkdir -p mnt/&#123;proc,sys,dev,tmp,etc&#125;</span><br><span class="line"></span><br><span class="line"># 创建 /init（必须！）</span><br><span class="line">cat &lt;&lt; &#x27;EOF&#x27; | sudo tee mnt/init</span><br><span class="line">#!/bin/sh</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">echo &quot;Hello from EXT4 RootFS!&quot;</span><br><span class="line">exec /bin/sh</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo chmod +x mnt/init</span><br><span class="line"></span><br><span class="line"># 或者创建 /sbin/init（busybox 默认 fallback）</span><br><span class="line">sudo ln -sf mnt/init mnt/sbin/init</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line">sudo umount mnt</span><br><span class="line">rmdir mnt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ 现在你有了 <code>rootfs.ext4</code> —— 一个可以直接被内核挂载的根文件系统！</p>
</blockquote>
<p>编写脚本文件run.sh便于启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">     -M vexpress-a9\</span><br><span class="line">     -cpu cortex-a9 \</span><br><span class="line">     -m 512M \</span><br><span class="line">     -kernel ~/ext4linux/linux-6.6.106/arch/arm/boot/zImage \</span><br><span class="line">     -drive <span class="keyword">if</span>=none,file=rootfs.ext4,format=raw,<span class="built_in">id</span>=hd0 \</span><br><span class="line">     -device virtio-blk-device,drive=hd0 \</span><br><span class="line">     -dtb ~/ext4linux/linux-6.6.106/arch/arm/boot/dts/arm/vexpress-v2p-ca9.dtb \</span><br><span class="line">     -append <span class="string">&quot;console=ttyAMA0 root=/dev/vda rootfstype=ext4 rw init=/init&quot;</span> \</span><br><span class="line">     -nographic</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="🖥️-五、使用-QEMU-启动整个系统"><a href="#🖥️-五、使用-QEMU-启动整个系统" class="headerlink" title="🖥️ 五、使用 QEMU 启动整个系统"></a>🖥️ 五、使用 QEMU 启动整个系统</h1><h2 id="方式-1：直接启动内核-initramfs（跳过-U-Boot）"><a href="#方式-1：直接启动内核-initramfs（跳过-U-Boot）" class="headerlink" title="方式 1：直接启动内核 + initramfs（跳过 U-Boot）"></a>方式 1：直接启动内核 + initramfs（跳过 U-Boot）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">     -M vexpress-a9\</span><br><span class="line">     -cpu cortex-a9 \</span><br><span class="line">     -m 512M \</span><br><span class="line">     -kernel ~/embedded-linux/linux-6.6.106/arch/arm/boot/zImage \</span><br><span class="line">     -initrd ~/embedded-linux/initramfs.cpio.gz \</span><br><span class="line">     -dtb ~/embedded-linux/linux-6.6.106/arch/arm/boot/dts/arm/vexpress-v2p-ca9.dtb \</span><br><span class="line">     -append <span class="string">&quot;console=ttyAMA0 root=/dev/ram rdinit=/init&quot;</span> \</span><br><span class="line">     -nographic</span><br></pre></td></tr></table></figure>

<blockquote>
<p>成功后你将进入 shell！</p>
</blockquote>
<hr>
<h2 id="方式-2：使用-U-Boot-引导（更接近真实开发板流程）"><a href="#方式-2：使用-U-Boot-引导（更接近真实开发板流程）" class="headerlink" title="方式 2：使用 U-Boot 引导（更接近真实开发板流程）"></a>方式 2：使用 U-Boot 引导（更接近真实开发板流程）</h2><h3 id="启动-U-Boot："><a href="#启动-U-Boot：" class="headerlink" title="启动 U-Boot："></a>启动 U-Boot：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">    -M virt \</span><br><span class="line">    -cpu cortex-a15 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios ~/embedded-linux/u-boot/u-boot</span><br></pre></td></tr></table></figure>

<h3 id="在-U-Boot-命令行中手动加载内核："><a href="#在-U-Boot-命令行中手动加载内核：" class="headerlink" title="在 U-Boot 命令行中手动加载内核："></a>在 U-Boot 命令行中手动加载内核：</h3><p>（假设你已把 zImage, dtb, initramfs 放到 tftp 目录或使用 <code>host</code> 文件系统 —— QEMU 支持 <code>host_net_add</code> 或直接 <code>-sd</code> 加载）</p>
<p>更简单的方法是让 U-Boot 从内存加载（通过 QEMU 参数传入）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">    -M virt \</span><br><span class="line">    -cpu cortex-a15 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios ~/embedded-linux/u-boot/u-boot \</span><br><span class="line">    -kernel ~/embedded-linux/linux/arch/arm/boot/zImage \</span><br><span class="line">    -initrd ~/embedded-linux/initramfs.cpio.gz \</span><br><span class="line">    -dtb ~/embedded-linux/linux/arch/arm/boot/dts/virt.dtb \</span><br><span class="line">    -append <span class="string">&quot;console=ttyAMA0 root=/dev/ram rdinit=/init&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：QEMU 会把 <code>-kernel</code> &#x2F; <code>-initrd</code> &#x2F; <code>-dtb</code> 加载到内存，U-Boot 启动后可以通过 <code>bootz 0x40080000 - 0x43000000</code> 手动引导（地址需根据 U-Boot 输出调整）。</p>
</blockquote>
<hr>
<h2 id="✅-方式-3：ARM64-示例（aarch64）"><a href="#✅-方式-3：ARM64-示例（aarch64）" class="headerlink" title="✅ 方式 3：ARM64 示例（aarch64）"></a>✅ 方式 3：ARM64 示例（aarch64）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -M virt \</span><br><span class="line">    -cpu cortex-a57 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ~/embedded-linux/linux/arch/arm64/boot/Image \</span><br><span class="line">    -initrd ~/embedded-linux/initramfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;console=ttyAMA0 root=/dev/ram rdinit=/init&quot;</span> \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="📚-六、学习价值"><a href="#📚-六、学习价值" class="headerlink" title="📚 六、学习价值"></a>📚 六、学习价值</h1><p>通过以上步骤，你虽然没有开发板，但完整经历了：</p>
<p>✅ 交叉编译工具链使用<br>✅ U-Boot 配置与编译<br>✅ Linux 内核裁剪与编译<br>✅ 设备树理解<br>✅ 根文件系统构建（BusyBox &#x2F; init 脚本）<br>✅ QEMU 模拟运行与调试<br>✅ 启动流程分析（U-Boot → Kernel → RootFS）</p>
<hr>
<h1 id="🚀-进阶建议"><a href="#🚀-进阶建议" class="headerlink" title="🚀 进阶建议"></a>🚀 进阶建议</h1><ol>
<li><strong>替换根文件系统为 Buildroot&#x2F;Yocto 生成的完整系统</strong></li>
<li><strong>添加 NFS 根文件系统支持，实现网络挂载调试</strong></li>
<li><strong>使用 GDB + QEMU 调试内核或 U-Boot</strong></li>
<li><strong>编写自己的驱动并编译进内核</strong></li>
<li><strong>尝试 RISC-V 架构模拟（QEMU 也支持）</strong></li>
</ol>
<hr>
<h1 id="🧩-附：常见问题"><a href="#🧩-附：常见问题" class="headerlink" title="🧩 附：常见问题"></a>🧩 附：常见问题</h1><h3 id="Q：为什么不用-x86？"><a href="#Q：为什么不用-x86？" class="headerlink" title="Q：为什么不用 x86？"></a>Q：为什么不用 x86？</h3><p>A：x86 不是嵌入式主流，且 U-Boot 在 x86 上使用较少（多用 GRUB&#x2F;UEFI）。ARM 是嵌入式标准。</p>
<h3 id="Q：能否模拟真实开发板，比如-Raspberry-Pi？"><a href="#Q：能否模拟真实开发板，比如-Raspberry-Pi？" class="headerlink" title="Q：能否模拟真实开发板，比如 Raspberry Pi？"></a>Q：能否模拟真实开发板，比如 Raspberry Pi？</h3><p>A：QEMU 对树莓派支持有限。推荐使用官方 SDK 或购买开发板。但 <code>virt</code> 板足够学习系统构建。</p>
<h3 id="Q：initramfs-启动后没有网络-USB？"><a href="#Q：initramfs-启动后没有网络-USB？" class="headerlink" title="Q：initramfs 启动后没有网络&#x2F;USB？"></a>Q：initramfs 启动后没有网络&#x2F;USB？</h3><p>A：需要在内核配置中启用对应驱动，或使用更完整的根文件系统（如 Buildroot）。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的定义与组成</title>
    <url>/2025/07/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>当我们打开电脑、启动手机，或是使用智能设备时，背后都有一个 “隐形管家” 在默默工作 —— 它协调硬件资源、管理软件运行、为用户提供交互界面，这就是<strong>操作系统（Operating System，简称 OS）</strong>。本文将从基础概念出发，解析操作系统的核心组成，并结合 Windows 和 Linux 实例，带你看透这个 “隐形管家” 的工作机制。</p>
<h3 id="一、什么是操作系统？"><a href="#一、什么是操作系统？" class="headerlink" title="一、什么是操作系统？"></a>一、什么是操作系统？</h3><p>操作系统是<strong>管理计算机硬件与软件资源的系统软件</strong>，是计算机系统的核心层。它如同一个 “中间人”，一边连接着底层的 CPU、内存、硬盘等硬件，另一边对接用户和应用程序（如浏览器、办公软件），负责分配资源、调度任务、提供交互接口，让复杂的硬件操作变得简单可控。</p>
<p>简单来说，没有操作系统，用户需要直接用机器语言指令控制硬件，而有了操作系统，我们只需点击鼠标、敲击键盘，就能轻松完成各种操作。</p>
<h3 id="二、操作系统的核心功能"><a href="#二、操作系统的核心功能" class="headerlink" title="二、操作系统的核心功能"></a>二、操作系统的核心功能</h3><p>操作系统的核心目标是<strong>提高资源利用率</strong>和<strong>方便用户使用</strong>，具体包括以下功能：</p>
<ul>
<li><p><strong>进程管理</strong>：调度多个程序（进程）合理使用 CPU，避免资源冲突。</p>
</li>
<li><p><strong>内存管理</strong>：分配、回收内存空间，确保程序高效运行且不互相干扰。</p>
</li>
<li><p><strong>文件管理</strong>：管理硬盘、U 盘等存储设备中的文件，负责文件的创建、删除、读取、写入等操作。</p>
</li>
<li><p><strong>设备管理</strong>：驱动打印机、显卡、网卡等硬件设备，协调设备与 CPU、内存的数据交换。</p>
</li>
<li><p><strong>用户接口</strong>：提供图形界面（GUI）或命令行界面（CLI），方便用户与计算机交互。</p>
</li>
</ul>
<h3 id="三、操作系统的组成部分"><a href="#三、操作系统的组成部分" class="headerlink" title="三、操作系统的组成部分"></a>三、操作系统的组成部分</h3><p>操作系统是一个复杂的系统软件集合，通常由以下核心模块组成：</p>
<h4 id="1-内核（Kernel）"><a href="#1-内核（Kernel）" class="headerlink" title="1. 内核（Kernel）"></a>1. 内核（Kernel）</h4><p>内核是操作系统的<strong>核心中的核心</strong>，直接与硬件交互，负责最底层的资源管理。它运行在最高权限级别（内核态），其他程序（用户态）必须通过内核才能访问硬件。</p>
<p>内核的主要功能包括：</p>
<ul>
<li><p><strong>进程调度</strong>：决定哪个进程优先使用 CPU（如 Windows 的抢占式调度、Linux 的 CFS 调度算法）。</p>
</li>
<li><p><strong>内存管理</strong>：通过虚拟内存技术（如分页、分段）管理物理内存，隔离不同进程的内存空间。</p>
</li>
<li><p><strong>设备驱动接口</strong>：提供硬件驱动的标准接口，让不同厂商的设备能被系统识别。</p>
</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li><p>Windows 的内核为ntoskrnl.exe（Windows NT 内核），支持多线程、多任务调度，对硬件兼容性强。</p>
</li>
<li><p>Linux 的内核是开源的Linux Kernel，以高效、稳定著称，支持多种硬件架构（如 x86、ARM）。</p>
</li>
</ul>
<h4 id="2-进程管理系统"><a href="#2-进程管理系统" class="headerlink" title="2. 进程管理系统"></a>2. 进程管理系统</h4><p>进程是<strong>正在运行的程序实例</strong>，进程管理系统负责进程的创建、销毁、暂停、恢复，以及进程间的通信与同步（如通过信号量、管道、共享内存等机制）。</p>
<ul>
<li><p><strong>Windows</strong>：通过进程控制块（PCB）管理进程，支持多线程技术，进程间通信可通过消息队列、共享内存实现。</p>
</li>
<li><p><strong>Linux</strong>：将进程视为 “任务（task）”，通过fork()系统调用创建进程，进程间通信支持管道（pipe）、信号（signal）等多种方式。</p>
</li>
</ul>
<h4 id="3-内存管理系统"><a href="#3-内存管理系统" class="headerlink" title="3. 内存管理系统"></a>3. 内存管理系统</h4><p>内存管理系统负责<strong>分配、回收内存</strong>，并通过虚拟内存技术扩展可用内存空间（如将暂时不用的数据存到硬盘的交换区）。</p>
<ul>
<li><p><strong>Windows</strong>：采用分页式虚拟内存管理，每个进程拥有独立的 4GB 虚拟地址空间（32 位系统）。</p>
</li>
<li><p><strong>Linux</strong>：支持分页和分段结合的内存管理，虚拟内存交换区（swap）可动态调整。</p>
</li>
</ul>
<h4 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4. 文件系统"></a>4. 文件系统</h4><p>文件系统是<strong>管理存储设备中文件的结构</strong>，定义了文件的命名规则、存储方式、访问权限等。</p>
<ul>
<li><p><strong>Windows</strong>：常用文件系统为 NTFS，支持文件权限、加密、压缩等功能，路径格式为C:\Users\Document。</p>
</li>
<li><p><strong>Linux</strong>：默认使用 ext4 文件系统（最新为 btrfs），采用树形目录结构，根目录为&#x2F;，路径格式为&#x2F;home&#x2F;user&#x2F;doc。</p>
</li>
</ul>
<h4 id="5-设备驱动程序（Device-Drivers）"><a href="#5-设备驱动程序（Device-Drivers）" class="headerlink" title="5. 设备驱动程序（Device Drivers）"></a>5. 设备驱动程序（Device Drivers）</h4><p>驱动程序是<strong>连接操作系统与硬件的桥梁</strong>，负责将操作系统的指令转换为硬件能理解的信号（如打印机驱动、显卡驱动）。</p>
<ul>
<li><p><strong>Windows</strong>：通过 Driver Store 管理驱动，支持即插即用（PnP），用户可通过设备管理器安装 &#x2F; 更新驱动。</p>
</li>
<li><p><strong>Linux</strong>：驱动多集成在内核或通过模块（module）加载，开源社区提供了丰富的驱动支持。</p>
</li>
</ul>
<h4 id="6-用户接口（User-Interface）"><a href="#6-用户接口（User-Interface）" class="headerlink" title="6. 用户接口（User Interface）"></a>6. 用户接口（User Interface）</h4><p>用户接口是<strong>用户与操作系统交互的渠道</strong>，分为两种类型：</p>
<ul>
<li><p><strong>图形用户界面（GUI）</strong>：通过窗口、图标、菜单等可视化元素操作（如 Windows 的桌面、Linux 的 GNOME&#x2F;KDE）。</p>
</li>
<li><p><strong>命令行界面（CLI）</strong>：通过输入命令与系统交互（如 Windows 的 CMD&#x2F;PowerShell、Linux 的 Bash）。</p>
</li>
</ul>
<h3 id="四、Windows-与-Linux-的组成对比"><a href="#四、Windows-与-Linux-的组成对比" class="headerlink" title="四、Windows 与 Linux 的组成对比"></a>四、Windows 与 Linux 的组成对比</h3><p>虽然 Windows 和 Linux 的设计理念不同（闭源 vs 开源），但核心组成框架一致，差异主要体现在实现细节：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>Windows 特点</th>
<th>Linux 特点</th>
</tr>
</thead>
<tbody><tr>
<td>内核</td>
<td>闭源 NT 内核，兼容性强，支持大量硬件和软件</td>
<td>开源 Linux 内核，模块化设计，可裁剪，稳定性高</td>
</tr>
<tr>
<td>文件系统</td>
<td>主要使用 NTFS，路径区分大小写（部分场景）</td>
<td>主要使用 ext4&#x2F;btrfs，路径严格区分大小写</td>
</tr>
<tr>
<td>进程管理</td>
<td>基于线程的调度，适合桌面应用</td>
<td>基于进程的调度，适合服务器场景</td>
</tr>
<tr>
<td>用户接口</td>
<td>以 GUI（Windows 桌面）为主，CLI 为辅</td>
<td>以 CLI（Bash）为主，GUI（如 GNOME）为可选</td>
</tr>
<tr>
<td>驱动管理</td>
<td>依赖厂商提供闭源驱动，即插即用体验好</td>
<td>驱动多开源，集成度高，对老旧硬件支持更持久</td>
</tr>
</tbody></table>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>操作系统是计算机系统的 “神经中枢”，由内核、进程管理、内存管理、文件系统、设备驱动和用户接口等部分组成，它们协同工作，让硬件资源高效运转，让用户操作简单直观。</p>
<p>无论是闭源的 Windows，还是开源的 Linux，其核心目标都是为用户和应用程序提供稳定、高效的运行环境。理解操作系统的组成，不仅能帮助我们更好地使用计算机，也是深入学习计算机科学的基础。</p>
<p>下一次当你点击鼠标打开软件时，不妨想想：这个简单的操作背后，有多少操作系统的模块在默默配合呢？</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>推挽输出及其抗干扰能力</title>
    <url>/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E5%8F%8A%E5%85%B6%E6%8A%97%E5%B9%B2%E6%89%B0%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<p>本文<strong>详细讲解推挽输出（Push-Pull Output）</strong>，并重点分析其<strong>抗干扰能力为何优于开漏输出</strong>。</p>
<hr>
<h2 id="一、什么是推挽输出（Push-Pull-Output）？"><a href="#一、什么是推挽输出（Push-Pull-Output）？" class="headerlink" title="一、什么是推挽输出（Push-Pull Output）？"></a>一、什么是推挽输出（Push-Pull Output）？</h2><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>推挽输出是一种<strong>既能主动拉高、也能主动拉低输出电平</strong>的驱动结构。它由两个互补的 MOSFET（或 BJT）组成：</p>
<ul>
<li><strong>上管（P-MOS 或 PNP）</strong>：连接电源（VDD），用于“推”出高电平。</li>
<li><strong>下管（N-MOS 或 NPN）</strong>：连接地（GND），用于“拉”低电平。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> VDD</span><br><span class="line">  │</span><br><span class="line">┌─┴─┐</span><br><span class="line">│ P │  ← 上管（Pull-up device）</span><br><span class="line">└─┬─┘</span><br><span class="line">  ├─── Output</span><br><span class="line">┌─┴─┐</span><br><span class="line">│ N │  ← 下管（Pull-down device）</span><br><span class="line">└─┬─┘</span><br><span class="line">  │</span><br><span class="line"> GND</span><br></pre></td></tr></table></figure>

<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><table>
<thead>
<tr>
<th>输出状态</th>
<th>上管（P）</th>
<th>下管（N）</th>
<th>输出电平</th>
</tr>
</thead>
<tbody><tr>
<td>高电平（1）</td>
<td>导通</td>
<td>关断</td>
<td>≈ VDD（强驱动）</td>
</tr>
<tr>
<td>低电平（0）</td>
<td>关断</td>
<td>导通</td>
<td>≈ GND（强驱动）</td>
</tr>
<tr>
<td>禁止状态</td>
<td><strong>两者同时导通</strong> → 会形成直通电流（shoot-through），必须避免！</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>控制逻辑确保<strong>任何时候只有一个管子导通</strong>，从而实现高效、低功耗的双向驱动。</p>
</blockquote>
<hr>
<h2 id="二、推挽输出-vs-开漏输出：关键区别"><a href="#二、推挽输出-vs-开漏输出：关键区别" class="headerlink" title="二、推挽输出 vs 开漏输出：关键区别"></a>二、推挽输出 vs 开漏输出：关键区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>推挽输出</th>
<th>开漏输出</th>
</tr>
</thead>
<tbody><tr>
<td>高电平驱动</td>
<td>✅ 主动驱动（P-MOS 拉到 VDD）</td>
<td>❌ 被动上拉（靠电阻）</td>
</tr>
<tr>
<td>低电平驱动</td>
<td>✅ 主动拉低（N-MOS 拉到 GND）</td>
<td>✅ 主动拉低</td>
</tr>
<tr>
<td>上升&#x2F;下降沿</td>
<td>快速、陡峭</td>
<td>上升慢（RC 限制），下降快</td>
</tr>
<tr>
<td>功耗</td>
<td>静态功耗低，动态功耗较高</td>
<td>静态有漏电流（上拉电阻耗电）</td>
</tr>
<tr>
<td>多设备共享</td>
<td>❌ 不能直接并联（会短路）</td>
<td>✅ 可直接并联（线与）</td>
</tr>
<tr>
<td>抗干扰能力</td>
<td>✅ 强</td>
<td>❌ 弱（尤其高电平）</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、为什么推挽输出抗干扰能力强？"><a href="#三、为什么推挽输出抗干扰能力强？" class="headerlink" title="三、为什么推挽输出抗干扰能力强？"></a>三、为什么推挽输出抗干扰能力强？</h2><p>推挽输出在<strong>高低电平均具备强驱动能力</strong>，这是其抗干扰优势的核心。具体体现在以下几点：</p>
<h3 id="1-快速的边沿转换（Fast-Slew-Rate）"><a href="#1-快速的边沿转换（Fast-Slew-Rate）" class="headerlink" title="1. 快速的边沿转换（Fast Slew Rate）"></a>1. <strong>快速的边沿转换（Fast Slew Rate）</strong></h3><ul>
<li>由于 MOSFET 直接驱动负载，上升&#x2F;下降时间极短（纳秒级）。</li>
<li>快速跳变减少了信号在<strong>中间电平区域（如 0.8V~2.0V）的停留时间</strong>，而这个区域最容易受噪声影响导致误判。</li>
<li>对比：开漏的缓慢上升沿可能在阈值附近“徘徊”，噪声容易使其多次穿越逻辑阈值。</li>
</ul>
<blockquote>
<p>📌 <strong>抗干扰关键</strong>：信号越快通过不确定区域，越不容易被干扰误触发。</p>
</blockquote>
<hr>
<h3 id="2-低输出阻抗（Low-Output-Impedance）"><a href="#2-低输出阻抗（Low-Output-Impedance）" class="headerlink" title="2. 低输出阻抗（Low Output Impedance）"></a>2. <strong>低输出阻抗（Low Output Impedance）</strong></h3><ul>
<li>推挽输出在高&#x2F;低电平时的等效输出阻抗非常低（通常 &lt; 10Ω）。</li>
<li>根据 <strong>分压原理</strong>，外部噪声源（如耦合干扰）在低阻抗节点上产生的电压偏移很小： [ V_{noise_at_pin} \approx V_{noise} \cdot \frac{Z_{out}}{Z_{out} + Z_{noise_source}} \approx 0 ]</li>
<li>而开漏高电平时输出阻抗 ≈ 上拉电阻（如 4.7kΩ），噪声很容易在其上产生显著压降。</li>
</ul>
<p>✅ <strong>举例</strong>：<br>若一个 1V 噪声通过 100Ω 耦合到输出端：</p>
<ul>
<li>推挽输出（Zout &#x3D; 10Ω）→ 引脚噪声 ≈ 1V × 10&#x2F;(10+100) ≈ <strong>90 mV</strong></li>
<li>开漏高电平（Zout &#x3D; 4700Ω）→ 引脚噪声 ≈ 1V × 4700&#x2F;(4700+100) ≈ <strong>980 mV</strong> → 可能被误判为低电平！</li>
</ul>
<hr>
<h3 id="3-强电流驱动能力（High-Sink-Source-Current）"><a href="#3-强电流驱动能力（High-Sink-Source-Current）" class="headerlink" title="3. 强电流驱动能力（High Sink&#x2F;Source Current）"></a>3. <strong>强电流驱动能力（High Sink&#x2F;Source Current）</strong></h3><ul>
<li>推挽结构可提供几十 mA 的拉电流（source）和灌电流（sink）。</li>
<li>当干扰试图拉偏电平时，输出级能<strong>主动“纠正”电压</strong>，维持逻辑状态。</li>
<li>开漏高电平时无电流输出能力，一旦被干扰拉低，只能等上拉电阻慢慢恢复。</li>
</ul>
<hr>
<h3 id="4-对电源-地噪声的鲁棒性更强"><a href="#4-对电源-地噪声的鲁棒性更强" class="headerlink" title="4. 对电源&#x2F;地噪声的鲁棒性更强"></a>4. <strong>对电源&#x2F;地噪声的鲁棒性更强</strong></h3><ul>
<li>推挽输出直接连接 VDD&#x2F;GND，电源稳定性好时，输出电平稳定。</li>
<li>虽然地弹（ground bounce）仍会影响，但由于驱动强，影响相对可控。</li>
<li>开漏则依赖外部上拉电压，若 VDD 有纹波，高电平也会波动。</li>
</ul>
<hr>
<h2 id="四、推挽输出的缺点（为何-I²C-不用它？）"><a href="#四、推挽输出的缺点（为何-I²C-不用它？）" class="headerlink" title="四、推挽输出的缺点（为何 I²C 不用它？）"></a>四、推挽输出的缺点（为何 I²C 不用它？）</h2><p>尽管抗干扰强，但推挽<strong>不适合总线共享场景</strong>：</p>
<h3 id="❌-不能直接并联多个输出"><a href="#❌-不能直接并联多个输出" class="headerlink" title="❌ 不能直接并联多个输出"></a>❌ 不能直接并联多个输出</h3><ul>
<li>若两个推挽输出一个输出高、一个输出低 → <strong>VDD 到 GND 直通短路</strong>，大电流烧毁器件！</li>
<li>而开漏结构天然避免此问题：所有设备都只能拉低或释放，不会短路。</li>
</ul>
<blockquote>
<p>所以：<strong>SPI、UART 等点对点通信常用推挽；I²C、SMBus 等多设备总线必须用开漏</strong>。</p>
</blockquote>
<hr>
<h2 id="五、典型应用场景"><a href="#五、典型应用场景" class="headerlink" title="五、典型应用场景"></a>五、典型应用场景</h2><table>
<thead>
<tr>
<th>接口&#x2F;用途</th>
<th>输出类型</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>SPI（MOSI, SCLK）</td>
<td>推挽</td>
<td>点对点，高速，需强驱动</td>
</tr>
<tr>
<td>UART（TX）</td>
<td>推挽</td>
<td>单向发送，无需共享</td>
</tr>
<tr>
<td>GPIO 通用输出</td>
<td>可配置推挽&#x2F;开漏</td>
<td>灵活适配不同需求</td>
</tr>
<tr>
<td>I²C（SDA&#x2F;SCL）</td>
<td>开漏</td>
<td>多设备共享总线</td>
</tr>
<tr>
<td>CAN 总线</td>
<td>差分 + 开漏类</td>
<td>兼顾抗干扰与总线仲裁</td>
</tr>
</tbody></table>
<hr>
<h2 id="六、总结：推挽输出的抗干扰优势"><a href="#六、总结：推挽输出的抗干扰优势" class="headerlink" title="六、总结：推挽输出的抗干扰优势"></a>六、总结：推挽输出的抗干扰优势</h2><table>
<thead>
<tr>
<th>优势维度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>边沿速度</strong></td>
<td>快速跳变，减少噪声敏感窗口</td>
</tr>
<tr>
<td><strong>输出阻抗</strong></td>
<td>极低，抑制噪声耦合</td>
</tr>
<tr>
<td><strong>驱动能力</strong></td>
<td>主动维持电平，抵抗外部干扰</td>
</tr>
<tr>
<td><strong>信号完整性</strong></td>
<td>波形干净，适合高速通信</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>结论</strong>：在<strong>点对点、高速、高噪声环境</strong>下，推挽输出是更可靠的选择。<br>⚠️ <strong>但不可用于多主&#x2F;多从共享总线</strong>，除非配合使能控制（如三态缓冲器）。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>推挽输出</tag>
      </tags>
  </entry>
  <entry>
    <title>开漏输出及其抗干扰能力</title>
    <url>/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%8F%8A%E5%85%B6%E6%8A%97%E5%B9%B2%E6%89%B0%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<p>本文详细讲解 <strong>开漏（Open-Drain）结构</strong>，并解释 <strong>为什么其抗干扰能力相对较弱</strong>。</p>
<hr>
<h2 id="一、什么是开漏输出（Open-Drain）？"><a href="#一、什么是开漏输出（Open-Drain）？" class="headerlink" title="一、什么是开漏输出（Open-Drain）？"></a>一、什么是开漏输出（Open-Drain）？</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><p>开漏输出是一种<strong>只能主动拉低电平、不能主动输出高电平</strong>的输出结构。它本质上是一个 <strong>MOSFET（通常是 N 沟道）的漏极（Drain）直接引出作为输出端</strong>，而源极（Source）接地。</p>
<ul>
<li><strong>“开”</strong>：指漏极没有内部连接到电源（不像推挽输出那样有上拉晶体管）。</li>
<li><strong>“漏”</strong>：指 MOSFET 的漏极作为输出引脚。</li>
</ul>
<h3 id="2-电路结构示意（简化）"><a href="#2-电路结构示意（简化）" class="headerlink" title="2. 电路结构示意（简化）"></a>2. 电路结构示意（简化）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VDD</span><br><span class="line"> │</span><br><span class="line"> R (上拉电阻)</span><br><span class="line"> │</span><br><span class="line"> ├─── SDA/SCL (输出引脚)</span><br><span class="line"> │</span><br><span class="line">┌┴┐</span><br><span class="line">│ │ N-MOSFET (开关)</span><br><span class="line">└┬┘</span><br><span class="line"> │</span><br><span class="line">GND</span><br></pre></td></tr></table></figure>

<ul>
<li>当 MOSFET <strong>导通</strong>：输出引脚被拉到 GND → <strong>输出低电平（0）</strong>。</li>
<li>当 MOSFET <strong>关断</strong>：输出引脚与 GND 断开，此时靠外部上拉电阻将引脚拉到 VDD → <strong>输出高电平（1）</strong>。</li>
</ul>
<blockquote>
<p>注意：<strong>高电平不是由芯片主动驱动的，而是靠外部上拉电阻“被动”实现的</strong>。</p>
</blockquote>
<hr>
<h2 id="二、为什么-I²C-使用开漏结构？"><a href="#二、为什么-I²C-使用开漏结构？" class="headerlink" title="二、为什么 I²C 使用开漏结构？"></a>二、为什么 I²C 使用开漏结构？</h2><p>I²C 总线采用开漏结构，主要有以下原因：</p>
<ol>
<li><strong>支持多设备共享总线（线与逻辑）</strong><br>多个设备的 SDA&#x2F;SCL 可以直接连在一起。只要有一个设备拉低总线，总线就是低电平；只有所有设备都释放（高阻态），总线才是高电平。这天然实现了“<strong>线与（Wired-AND）</strong>”逻辑，避免总线冲突烧毁器件。</li>
<li><strong>支持多主设备仲裁</strong><br>在多主模式下，主设备通过监测总线电平是否与自己发送的一致来判断是否赢得总线控制权。开漏结构允许这种“边发边听”的机制。</li>
<li><strong>电平兼容性好</strong><br>不同电压域的设备可以通过选择合适的上拉电压（如 3.3V 或 5V）实现电平转换。</li>
</ol>
<hr>
<h2 id="三、为什么开漏结构抗干扰能力较弱？"><a href="#三、为什么开漏结构抗干扰能力较弱？" class="headerlink" title="三、为什么开漏结构抗干扰能力较弱？"></a>三、为什么开漏结构抗干扰能力较弱？</h2><p>虽然开漏结构有很多优点，但其<strong>高电平状态的驱动能力弱</strong>，导致在某些方面<strong>抗干扰能力较差</strong>。具体原因如下：</p>
<h3 id="1-高电平靠上拉电阻建立，上升沿缓慢"><a href="#1-高电平靠上拉电阻建立，上升沿缓慢" class="headerlink" title="1. 高电平靠上拉电阻建立，上升沿缓慢"></a>1. <strong>高电平靠上拉电阻建立，上升沿缓慢</strong></h3><ul>
<li><p>上拉电阻（如 4.7kΩ）与总线寄生电容（走线电容、引脚电容等）形成 <strong>RC 充电回路</strong>。</p>
</li>
<li><p>高电平的上升时间：<br>[ t_r \approx 2.2 \cdot R_{pull-up} \cdot C_{bus} ] 例如：R &#x3D; 4.7kΩ，C &#x3D; 100pF → 上升时间约 1μs。</p>
</li>
<li><p>缓慢的上升沿</p>
<p>更容易受到噪声干扰，可能导致：</p>
<ul>
<li>接收端误判为多次跳变（毛刺）。</li>
<li>在高速通信时，信号无法在时钟周期内稳定，造成通信错误。</li>
</ul>
</li>
</ul>
<h3 id="2-高电平驱动能力弱（高阻态）"><a href="#2-高电平驱动能力弱（高阻态）" class="headerlink" title="2. 高电平驱动能力弱（高阻态）"></a>2. <strong>高电平驱动能力弱（高阻态）</strong></h3><ul>
<li><p>当输出高电平时，芯片内部 MOSFET 关断，引脚处于<strong>高阻态</strong>，仅靠上拉电阻维持高电平。</p>
</li>
<li><p>此时若外部有</p>
<p>耦合噪声</p>
<p>（如电磁干扰、串扰、电源波动），很容易将引脚电压拉低，导致：</p>
<ul>
<li>误触发低电平（假 Start&#x2F;Stop 条件）。</li>
<li>数据位被误读为 0。</li>
</ul>
</li>
</ul>
<blockquote>
<p>相比之下，<strong>推挽输出（Push-Pull）</strong> 在高电平时由 PMOS 主动驱动到 VDD，电流能力强，能快速恢复并抵抗噪声。</p>
</blockquote>
<h3 id="3-易受地弹（Ground-Bounce）和电源噪声影响"><a href="#3-易受地弹（Ground-Bounce）和电源噪声影响" class="headerlink" title="3. 易受地弹（Ground Bounce）和电源噪声影响"></a>3. <strong>易受地弹（Ground Bounce）和电源噪声影响</strong></h3><ul>
<li>由于高电平依赖外部上拉到 VDD，若 VDD 有波动，高电平阈值也会漂移。</li>
<li>多设备同时拉低总线时，地电流突变可能引起局部地电位抬升，影响高低电平判断。</li>
</ul>
<h3 id="4-长距离传输时问题加剧"><a href="#4-长距离传输时问题加剧" class="headerlink" title="4. 长距离传输时问题加剧"></a>4. <strong>长距离传输时问题加剧</strong></h3><ul>
<li>总线越长，寄生电容越大 → 上升时间更长。</li>
<li>分布电感和电容形成天线效应，更容易拾取外部干扰。</li>
<li>因此 I²C 通常只用于<strong>板内短距离通信</strong>（一般 &lt; 30cm，高速时更短）。</li>
</ul>
<hr>
<h2 id="四、如何改善开漏总线的抗干扰能力？"><a href="#四、如何改善开漏总线的抗干扰能力？" class="headerlink" title="四、如何改善开漏总线的抗干扰能力？"></a>四、如何改善开漏总线的抗干扰能力？</h2><p>尽管有弱点，但可通过以下方式优化：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>减小上拉电阻</strong></td>
<td>加快上升沿（但会增加功耗和灌电流，需在驱动能力范围内）</td>
</tr>
<tr>
<td><strong>降低总线电容</strong></td>
<td>缩短走线、减少挂载设备数量</td>
</tr>
<tr>
<td><strong>使用 I²C 缓冲器&#x2F;电平转换器</strong></td>
<td>如 PCA9515，可延长距离并增强驱动</td>
</tr>
<tr>
<td><strong>增加滤波电容（谨慎使用）</strong></td>
<td>小电容（如 10–50pF）可滤高频噪声，但会进一步减慢上升沿</td>
</tr>
<tr>
<td><strong>软件容错</strong></td>
<td>增加重试机制、校验和等</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>开漏输出</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 优点</td>
<td>支持多设备共享、天然线与、电平兼容、避免冲突</td>
</tr>
<tr>
<td>❌ 缺点</td>
<td>高电平驱动弱、上升沿慢、抗干扰能力差、不适合长距离&#x2F;高速</td>
</tr>
<tr>
<td>📌 关键点</td>
<td><strong>高电平是“被动”的，低电平是“主动”的</strong> → 抗噪能力不对称</td>
</tr>
</tbody></table>
<p>因此，I²C 虽然广泛使用，但在<strong>高噪声环境、长距离或高速场景</strong>下，可能不如 SPI（推挽输出）或 RS-485 等差分通信可靠。</p>
<hr>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>开漏输出</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统中的AMBA总线协议：架构、演进与核心规范</title>
    <url>/2025/09/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84AMBA%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在嵌入式系统，尤其是基于ARM架构的片上系统（SoC）中，AMBA（Advanced Microcontroller Bus Architecture）总线协议是连接处理器、内存、外设的“神经中枢”。从早期的ARM7处理器到如今的多核异构SoC，AMBA协议通过不断演进，解决了片上组件间高效通信的核心问题。</p>
<p>本文将从AMBA的设计目标出发，梳理其协议家族的演进历程，详解AXI、AHB、APB等核心总线的特性与应用场景，帮助理解嵌入式SoC的内部通信机制。</p>
<h2 id="一、AMBA总线的设计目标与整体架构"><a href="#一、AMBA总线的设计目标与整体架构" class="headerlink" title="一、AMBA总线的设计目标与整体架构"></a>一、AMBA总线的设计目标与整体架构</h2><p>AMBA总线协议由ARM公司于1996年首次提出，核心目标是为嵌入式SoC提供<strong>标准化、可扩展、高性能</strong>的片上互联方案。随着SoC复杂度提升（从单一CPU到多核+GPU+NPU+外设的异构系统），AMBA协议不断迭代，但其核心设计原则始终不变：</p>
<ol>
<li><strong>模块化设计</strong>：允许不同功能模块（如CPU、DMA、外设）通过标准接口接入总线，降低设计复杂度；</li>
<li><strong>灵活扩展</strong>：支持从简单微控制器（如STM32）到高端应用处理器（如骁龙8 Gen3）的不同规模系统；</li>
<li><strong>高性能与低功耗平衡</strong>：针对不同速率的设备（如高速内存、低速传感器）提供适配的总线类型；</li>
<li><strong>向后兼容</strong>：新协议兼容旧版本，保护已有设计投资。</li>
</ol>
<h3 id="AMBA的整体架构分层"><a href="#AMBA的整体架构分层" class="headerlink" title="AMBA的整体架构分层"></a>AMBA的整体架构分层</h3><p>现代AMBA总线采用“分层架构”，按传输速率和功能分为三层，形成完整的片上通信体系：</p>
<ul>
<li><strong>高层总线</strong>：面向高性能设备（CPU、内存、GPU等），如AXI4、AXI4-Lite、AXI4-Stream；</li>
<li><strong>中层总线</strong>：面向中速设备（DMA、编码器等），如AHB（Advanced High-performance Bus）；</li>
<li><strong>低层总线</strong>：面向低速外设（UART、GPIO、I2C控制器等），如APB（Advanced Peripheral Bus）。</li>
</ul>
<p>三者通过“桥接器（Bridge）”连接，实现不同速率总线间的数据转发，例如AHB-APB桥将AHB的高速传输转换为APB的低速控制信号。</p>
<h2 id="二、AMBA协议家族的演进历程"><a href="#二、AMBA协议家族的演进历程" class="headerlink" title="二、AMBA协议家族的演进历程"></a>二、AMBA协议家族的演进历程</h2><p>AMBA协议经过多代迭代，从早期的AMBA 1.0发展到如今的AMBA 5，每代都针对SoC的新需求进行优化：</p>
<table>
<thead>
<tr>
<th>协议版本</th>
<th>发布时间</th>
<th>核心总线</th>
<th>主要改进</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>AMBA 1.0</td>
<td>1996年</td>
<td>AHB、APB</td>
<td>首次定义AHB（32位，最高50MHz）和APB，支持基本的SoC互联</td>
<td>ARM7、ARM9早期处理器</td>
</tr>
<tr>
<td>AMBA 2.0</td>
<td>1999年</td>
<td>AHB、APB</td>
<td>提升AHB速率至100MHz，增加多主设备支持，APB增加中断机制</td>
<td>ARM926EJ-S、ARM11</td>
</tr>
<tr>
<td>AMBA 3.0</td>
<td>2003年</td>
<td>AXI3、AHB-Lite、APB</td>
<td>引入AXI（多通道、突发传输，1GHz+），AHB简化为AHB-Lite</td>
<td>Cortex-A8、Cortex-M3</td>
</tr>
<tr>
<td>AMBA 4.0</td>
<td>2010年</td>
<td>AXI4、AXI4-Lite、AXI4-Stream、ACE</td>
<td>AXI4支持更大地址空间和QoS，增加ACE（缓存一致性），AXI4-Stream优化流数据传输</td>
<td>Cortex-A9、Cortex-A53</td>
</tr>
<tr>
<td>AMBA 5.0</td>
<td>2016年</td>
<td>CHI、AXI5</td>
<td>引入CHI（缓存一致性互连），支持异构多核集群，AXI5提升带宽至100GB&#x2F;s</td>
<td>Cortex-A76、Cortex-X1、异构SoC</td>
</tr>
</tbody></table>
<p>目前嵌入式领域应用最广泛的是AMBA 3.0和AMBA 4.0协议（AXI4、AHB-Lite、APB），而高端SoC已开始采用AMBA 5.0的CHI协议。</p>
<h2 id="三、核心总线协议详解"><a href="#三、核心总线协议详解" class="headerlink" title="三、核心总线协议详解"></a>三、核心总线协议详解</h2><h3 id="1-AXI4（Advanced-eXtensible-Interface-4）：高性能主总线"><a href="#1-AXI4（Advanced-eXtensible-Interface-4）：高性能主总线" class="headerlink" title="1. AXI4（Advanced eXtensible Interface 4）：高性能主总线"></a>1. AXI4（Advanced eXtensible Interface 4）：高性能主总线</h3><p>AXI4是AMBA 4.0的核心，专为高性能、高带宽设备设计，是当前中高端嵌入式SoC的“主干道”，其架构和特性如下：</p>
<h4 id="核心特性："><a href="#核心特性：" class="headerlink" title="核心特性："></a>核心特性：</h4><ul>
<li><strong>多通道传输</strong>：将地址、数据、控制信号分离为5个独立通道（读地址、读数据、写地址、写数据、写响应），支持地址和数据并行传输，提升效率；</li>
<li><strong>突发传输</strong>：支持最多256拍的突发传输（连续地址的数据传输），减少地址线切换开销，适合内存访问（如CPU读取连续数组）；</li>
<li><strong>单工&#x2F;全双工</strong>：读和写通道独立，支持全双工通信（同时读写），带宽利用率更高；</li>
<li><strong>灵活的数据宽度</strong>：支持32位、64位、128位、256位等数据宽度，可根据SoC需求配置；</li>
<li><strong>非对齐访问</strong>：硬件支持非对齐地址的数据传输（如从地址0x03读取32位数据），无需软件处理；</li>
<li><strong>QoS支持</strong>：通过QoS信号区分传输优先级，保证关键数据（如实时视频流）优先传输。</li>
</ul>
<h4 id="典型应用："><a href="#典型应用：" class="headerlink" title="典型应用："></a>典型应用：</h4><ul>
<li>CPU与DDR内存的连接；</li>
<li>GPU、NPU等高性能模块与内存的交互；</li>
<li>高速外设（如PCIe控制器、USB 3.0控制器）的数据传输。</li>
</ul>
<h4 id="时序特点："><a href="#时序特点：" class="headerlink" title="时序特点："></a>时序特点：</h4><p>AXI4采用“握手信号”机制（VALID&#x2F;READY），主设备通过VALID信号表示数据有效，从设备通过READY信号表示准备接收，双方握手成功后完成传输。这种机制允许主从设备异步工作，适应不同速率的模块。</p>
<h3 id="2-AXI4-Lite：简化版AXI，面向控制类传输"><a href="#2-AXI4-Lite：简化版AXI，面向控制类传输" class="headerlink" title="2. AXI4-Lite：简化版AXI，面向控制类传输"></a>2. AXI4-Lite：简化版AXI，面向控制类传输</h3><p>AXI4-Lite是AXI4的简化版本，移除了突发传输功能，仅支持单次传输，专为低速控制类操作设计：</p>
<h4 id="核心特性：-1"><a href="#核心特性：-1" class="headerlink" title="核心特性："></a>核心特性：</h4><ul>
<li>仅支持32位数据宽度；</li>
<li>无突发传输，每次传输1拍数据；</li>
<li>保留AXI4的5个通道，但逻辑更简单；</li>
<li>资源占用少（比AXI4节省50%以上的逻辑单元）。</li>
</ul>
<h4 id="典型应用：-1"><a href="#典型应用：-1" class="headerlink" title="典型应用："></a>典型应用：</h4><ul>
<li>外设的配置寄存器访问（如配置UART的波特率、GPIO的方向）；</li>
<li>低速设备的控制信号传输（如启动ADC转换、读取传感器状态）。</li>
</ul>
<p>在实际SoC中，CPU通常通过AXI4-Lite访问外设的控制寄存器，而数据传输则通过AXI4或AHB进行。</p>
<h3 id="3-AXI4-Stream：流数据传输专用协议"><a href="#3-AXI4-Stream：流数据传输专用协议" class="headerlink" title="3. AXI4-Stream：流数据传输专用协议"></a>3. AXI4-Stream：流数据传输专用协议</h3><p>AXI4-Stream专为连续流数据（如视频、音频、传感器数据流）设计，与AXI4的“地址+数据”模式不同，它只传输数据，不传输地址：</p>
<h4 id="核心特性：-2"><a href="#核心特性：-2" class="headerlink" title="核心特性："></a>核心特性：</h4><ul>
<li>无地址线，数据按顺序连续传输；</li>
<li>支持单数据通道或多数据通道（如RGB视频的三通道）；</li>
<li>包含数据有效（TVALID）、准备接收（TREADY）、数据结束（TLAST）信号；</li>
<li>可扩展用户自定义信号（TUSER），用于传输元数据（如视频帧同步信号）。</li>
</ul>
<h4 id="典型应用：-2"><a href="#典型应用：-2" class="headerlink" title="典型应用："></a>典型应用：</h4><ul>
<li>摄像头采集的图像数据流传输到ISP（图像信号处理器）；</li>
<li>编码器输出的视频流传输到DDR内存；</li>
<li>音频Codec与DSP之间的PCM音频流传输。</li>
</ul>
<h3 id="4-AHB-Lite：中速设备的高效互联"><a href="#4-AHB-Lite：中速设备的高效互联" class="headerlink" title="4. AHB-Lite：中速设备的高效互联"></a>4. AHB-Lite：中速设备的高效互联</h3><p>AHB-Lite是AMBA 3.0中AHB的简化版本，移除了多主设备支持，仅支持单主设备，适合中小型SoC：</p>
<h4 id="核心特性：-3"><a href="#核心特性：-3" class="headerlink" title="核心特性："></a>核心特性：</h4><ul>
<li>32位地址和数据总线（可扩展至64位）；</li>
<li>支持突发传输（最多16拍）；</li>
<li>单时钟沿操作，时序简单；</li>
<li>资源占用比AXI4少，适合低成本MCU。</li>
</ul>
<h4 id="典型应用：-3"><a href="#典型应用：-3" class="headerlink" title="典型应用："></a>典型应用：</h4><ul>
<li>中低端MCU（如STM32F4系列）的内部总线；</li>
<li>连接DMA控制器、SDIO控制器等中速外设；</li>
<li>作为AXI和APB之间的过渡总线（通过AHB-APB桥连接）。</li>
</ul>
<p>STM32F4系列微控制器就是典型的AHB-Lite架构：Cortex-M4内核通过AHB-Lite总线连接SRAM、Flash、DMA，再通过AHB-APB桥连接APB总线上的UART、SPI等外设。</p>
<h3 id="5-APB：低速外设的简单互联"><a href="#5-APB：低速外设的简单互联" class="headerlink" title="5. APB：低速外设的简单互联"></a>5. APB：低速外设的简单互联</h3><p>APB（Advanced Peripheral Bus）是AMBA中速率最低的总线，专为低速外设设计，以简单性和低功耗为核心：</p>
<h4 id="核心特性：-4"><a href="#核心特性：-4" class="headerlink" title="核心特性："></a>核心特性：</h4><ul>
<li>32位地址和数据总线（共享同一组总线，时分复用）；</li>
<li>无突发传输，每次传输需单独寻址；</li>
<li>单时钟沿操作，时序简单（仅需PADDR、PWDATA、PSEL、PENABLE等少数信号）；</li>
<li>低功耗设计，空闲时可关闭时钟。</li>
</ul>
<h4 id="典型应用：-4"><a href="#典型应用：-4" class="headerlink" title="典型应用："></a>典型应用：</h4><ul>
<li>低速外设：UART、SPI、I2C控制器、GPIO、定时器；</li>
<li>传感器接口：温湿度传感器、加速度计；</li>
<li>电源管理模块：PMIC（电源管理IC）的寄存器访问。</li>
</ul>
<p>APB通常通过“桥接器”挂在AHB或AXI总线上，由桥接器将高速总线的信号转换为APB的低速信号。例如，在ARM Cortex-A53架构中，APB总线通过AXI-APB桥连接到AXI主总线，CPU通过AXI总线访问APB外设。</p>
<h2 id="四、AMBA总线在嵌入式SoC中的典型架构"><a href="#四、AMBA总线在嵌入式SoC中的典型架构" class="headerlink" title="四、AMBA总线在嵌入式SoC中的典型架构"></a>四、AMBA总线在嵌入式SoC中的典型架构</h2><p>以一款智能摄像头SoC为例，AMBA总线的连接方式如下：</p>
<ol>
<li><strong>核心层</strong>：Cortex-A53 CPU通过AXI4总线连接DDR内存控制器，实现高速数据访问；</li>
<li><strong>高速外设层</strong>：GPU、ISP（图像信号处理器）通过AXI4总线与DDR交互，同时GPU与CPU通过ACE协议（AMBA 4.0的缓存一致性协议）保持缓存同步；</li>
<li><strong>中速外设层</strong>：DMA控制器、SDIO控制器通过AHB-Lite总线连接，负责图像数据从摄像头到DDR的搬运；</li>
<li><strong>低速外设层</strong>：UART（调试接口）、I2C（连接镜头控制芯片）、GPIO（指示灯控制）通过APB总线连接，由AHB-APB桥管理；</li>
<li><strong>流数据路径</strong>：摄像头采集的RAW图像数据通过AXI4-Stream总线直接传输到ISP，减少内存访问开销。</li>
</ol>
<p>这种分层架构既保证了高性能模块的带宽需求（如CPU与内存的AXI4连接），又简化了低速外设的设计（如APB总线上的UART），实现了“高性能与低成本”的平衡。</p>
<h2 id="五、AMBA协议的嵌入式开发实践要点"><a href="#五、AMBA协议的嵌入式开发实践要点" class="headerlink" title="五、AMBA协议的嵌入式开发实践要点"></a>五、AMBA协议的嵌入式开发实践要点</h2><p>对于嵌入式软件开发者，虽然不需要直接设计总线硬件，但理解AMBA协议有助于优化代码性能：</p>
<ol>
<li><strong>利用突发传输</strong>：在访问连续内存（如数组、帧缓存）时，使用连续地址的批量读写（如C语言中的<code>memcpy</code>），触发AXI&#x2F;AHB的突发传输，比单次读写快5~10倍；</li>
<li><strong>减少外设寄存器访问频率</strong>：APB总线速率低（通常10~50MHz），频繁读写外设寄存器（如循环中读取GPIO状态）会成为瓶颈，建议通过DMA或中断方式批量处理；</li>
<li><strong>理解缓存一致性</strong>：在多核SoC中，不同核心通过ACE协议保持缓存一致，但若直接操作外设地址（非缓存区域），需使用<code>dmb</code>（数据内存屏障）指令确保数据同步；</li>
<li><strong>外设地址映射</strong>：SoC厂商会将不同外设的寄存器映射到AXI&#x2F;AHB&#x2F;APB总线上的特定地址（如STM32的0x40000000开始为APB外设地址），开发者需通过这些地址访问外设。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AMBA总线协议是嵌入式SoC设计的基石，其分层架构（AXI4&#x2F;AHB&#x2F;APB）和多样化的协议类型，满足了从低速传感器到高性能GPU的不同通信需求。对于嵌入式开发者，理解AMBA的核心特性（如突发传输、多通道、缓存一致性）不仅能帮助更好地理解硬件架构，还能指导代码优化，提升系统性能。</p>
<p>随着异构计算和AI的发展，AMBA协议也在持续演进（如AMBA 5的CHI协议），但“标准化、可扩展、平衡性能与成本”的核心设计思想，使其仍是嵌入式领域的主流总线标准。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>AMBA总线</tag>
        <tag>片上系统</tag>
        <tag>总线协议</tag>
      </tags>
  </entry>
  <entry>
    <title>条件执行、分支预测以及编译器优化</title>
    <url>/2025/11/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C%E3%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h1><hr>
<p>“<strong>条件执行</strong>”（Conditional Execution）是某些指令集架构（特别是 <strong>ARM</strong>）中一个非常有特色的机制，但在 <strong>RISC-V</strong>、x86 等架构中并不存在（或实现方式不同）。</p>
<h2 id="一、什么是条件执行？"><a href="#一、什么是条件执行？" class="headerlink" title="一、什么是条件执行？"></a>一、什么是条件执行？</h2><blockquote>
<p><strong>条件执行</strong> 是指：<strong>一条指令是否执行，取决于当前处理器状态寄存器（如 CPSR&#x2F;FLAGS）中的某个条件标志（如 Z、C、N、V）是否满足特定条件</strong>。</p>
</blockquote>
<p>换句话说：<strong>不是通过跳转（branch）来控制流程，而是让指令“自己决定”是否生效</strong>。</p>
<hr>
<h2 id="二、以-ARM-为例（经典-ARMv7-架构）"><a href="#二、以-ARM-为例（经典-ARMv7-架构）" class="headerlink" title="二、以 ARM 为例（经典 ARMv7 架构）"></a>二、以 ARM 为例（经典 ARMv7 架构）</h2><p>在 ARM（32 位）中，<strong>几乎每条指令的末尾都可以附加一个 2 位的条件码</strong>，共 16 种条件。</p>
<h3 id="常见条件码示例："><a href="#常见条件码示例：" class="headerlink" title="常见条件码示例："></a>常见条件码示例：</h3><table>
<thead>
<tr>
<th>后缀</th>
<th>条件</th>
<th>含义</th>
<th>对应标志</th>
</tr>
</thead>
<tbody><tr>
<td><code>EQ</code></td>
<td>Equal</td>
<td>相等（Z&#x3D;1）</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Not Equal</td>
<td>不相等（Z&#x3D;0）</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Greater Than</td>
<td>有符号大于</td>
<td>(Z&#x3D;0) 且 (N&#x3D;V)</td>
</tr>
<tr>
<td><code>LT</code></td>
<td>Less Than</td>
<td>有符号小于</td>
<td>N≠V</td>
</tr>
<tr>
<td><code>CS</code>&#x2F;<code>HS</code></td>
<td>Carry Set &#x2F; Higher or Same</td>
<td>无符号 ≥</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td><code>CC</code>&#x2F;<code>LO</code></td>
<td>Carry Clear &#x2F; Lower</td>
<td>无符号 &lt;</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td><code>AL</code></td>
<td>Always</td>
<td>总是执行（默认）</td>
<td>—</td>
</tr>
</tbody></table>
<h3 id="示例代码（ARM-汇编）："><a href="#示例代码（ARM-汇编）：" class="headerlink" title="示例代码（ARM 汇编）："></a>示例代码（ARM 汇编）：</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="built_in">r1</span>        <span class="comment">; 比较 r0 和 r1，设置标志位（Z/N/C/V）</span></span><br><span class="line"><span class="keyword">addeq</span> <span class="built_in">r2</span>, <span class="built_in">r3</span>, <span class="built_in">r4</span>  <span class="comment">; 如果 r0 == r1（Z=1），则执行 r2 = r3 + r4</span></span><br><span class="line"><span class="keyword">movne</span> <span class="built_in">r5</span>, <span class="number">#0</span>      <span class="comment">; 如果 r0 != r1（Z=0），则 r5 = 0</span></span><br></pre></td></tr></table></figure>

<p>👉 <strong>注意</strong>：即使 <code>addeq</code> 不满足条件，它仍然会“执行”，但<strong>不会改变寄存器或内存</strong>，也不会触发异常，只是“空转”一个周期（现代 ARM 可能优化掉）。</p>
<hr>
<h2 id="三、条件执行的好处"><a href="#三、条件执行的好处" class="headerlink" title="三、条件执行的好处"></a>三、条件执行的好处</h2><ol>
<li><strong>避免短分支（short branches）</strong><ul>
<li>传统方式：用 <code>cmp + beq + add</code> 需要跳转，可能清空流水线</li>
<li>条件执行：直接 <code>cmp + addeq</code>，<strong>无跳转、无流水线冲刷</strong></li>
</ul>
</li>
<li><strong>提高代码密度和性能</strong><ul>
<li>少一条跳转指令</li>
<li>适合实现 <code>if-then-else</code> 中的简单操作</li>
</ul>
</li>
<li><strong>简化编译器优化</strong><ul>
<li>编译器可将简单条件语句直接映射为条件指令</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四、为什么-RISC-V-没有条件执行？"><a href="#四、为什么-RISC-V-没有条件执行？" class="headerlink" title="四、为什么 RISC-V 没有条件执行？"></a>四、为什么 RISC-V 没有条件执行？</h2><p>RISC-V 的设计哲学是 <strong>“保持基础指令集极简”</strong>，原因包括：</p>
<h3 id="1-硬件复杂度增加"><a href="#1-硬件复杂度增加" class="headerlink" title="1. 硬件复杂度增加"></a>1. <strong>硬件复杂度增加</strong></h3><ul>
<li>每条指令都要检查条件码，增加译码逻辑</li>
<li>对超标量、乱序执行处理器不利（需额外处理条件依赖）</li>
</ul>
<h3 id="2-现代处理器有更好替代方案"><a href="#2-现代处理器有更好替代方案" class="headerlink" title="2. 现代处理器有更好替代方案"></a>2. <strong>现代处理器有更好替代方案</strong></h3><ul>
<li><strong>分支预测（Branch Prediction）</strong> 非常成熟，短分支开销极低</li>
<li><strong>条件传送（Conditional Move）</strong> 或 <strong>选择指令（如 <code>csel</code>）</strong> 可在某些架构中实现类似效果（但 RISC-V 也不包含，除非通过扩展）</li>
</ul>
<h3 id="3-代码体积-vs-性能权衡"><a href="#3-代码体积-vs-性能权衡" class="headerlink" title="3. 代码体积 vs 性能权衡"></a>3. <strong>代码体积 vs 性能权衡</strong></h3><ul>
<li>条件执行虽减少跳转，但每条指令都带条件码，可能浪费编码空间</li>
<li>RISC-V 用 <strong>压缩指令扩展（C extension）</strong> 来解决代码密度问题，而非条件执行</li>
</ul>
<h3 id="RISC-V-的等效写法（用分支）："><a href="#RISC-V-的等效写法（用分支）：" class="headerlink" title="RISC-V 的等效写法（用分支）："></a>RISC-V 的等效写法（用分支）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    bne x0, x1, skip    # if (x0 != x1) goto skip</span><br><span class="line">    add x2, x3, x4      # x2 = x3 + x4</span><br><span class="line">skip:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者用编译器优化为无分支形式（如位运算技巧），但<strong>硬件不提供条件执行支持</strong>。</p>
<hr>
<h2 id="五、其他架构对比"><a href="#五、其他架构对比" class="headerlink" title="五、其他架构对比"></a>五、其他架构对比</h2><table>
<thead>
<tr>
<th>架构</th>
<th>是否支持条件执行</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ARM（32位）</strong></td>
<td>✅ 是</td>
<td>几乎所有指令可加条件后缀</td>
</tr>
<tr>
<td><strong>ARM64（AArch64）</strong></td>
<td>❌ 否</td>
<td><strong>移除了通用条件执行</strong>，仅保留条件选择指令（如 <code>csel</code>）</td>
</tr>
<tr>
<td><strong>x86</strong></td>
<td>❌ 否</td>
<td>用 <code>setcc</code>、<code>cmovcc</code>（条件传送）实现部分功能</td>
</tr>
<tr>
<td><strong>RISC-V</strong></td>
<td>❌ 否</td>
<td>完全依赖分支或软件优化</td>
</tr>
<tr>
<td><strong>MIPS</strong></td>
<td>❌ 否</td>
<td>无条件执行</td>
</tr>
</tbody></table>
<blockquote>
<p>🔸 有趣的是：<strong>ARM64 也放弃了通用条件执行</strong>，说明现代高性能设计更倾向于“简单指令 + 强大分支预测”。</p>
</blockquote>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><table>
<thead>
<tr>
<th>项目</th>
<th>条件执行（ARMv7）</th>
<th>RISC-V 方式</th>
</tr>
</thead>
<tbody><tr>
<td>控制流</td>
<td>指令自身带条件</td>
<td>显式 <code>beq</code>&#x2F;<code>bne</code> 等分支</td>
</tr>
<tr>
<td>硬件开销</td>
<td>较高（每条指令需判条件）</td>
<td>低（指令简单）</td>
</tr>
<tr>
<td>流水线影响</td>
<td>避免跳转冲刷</td>
<td>依赖分支预测</td>
</tr>
<tr>
<td>代码风格</td>
<td>紧凑、无跳转</td>
<td>清晰、显式控制流</td>
</tr>
<tr>
<td>现代趋势</td>
<td>被淘汰（ARM64 已弃用）</td>
<td>符合 RISC 简洁哲学</td>
</tr>
</tbody></table>
<hr>
<h1 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h1><p><strong>分支预测（Branch Prediction）</strong> 和 <strong>编译器优化（Compiler Optimization）</strong> 是现代计算机体系结构与软件工程中两个极其关键的技术，它们共同作用，大幅提升程序的执行效率。下面我们分别详细讲解，并说明它们如何协同工作。</p>
<hr>
<h2 id="一、分支预测（Branch-Prediction）"><a href="#一、分支预测（Branch-Prediction）" class="headerlink" title="一、分支预测（Branch Prediction）"></a>一、分支预测（Branch Prediction）</h2><h3 id="1-为什么需要分支预测？"><a href="#1-为什么需要分支预测？" class="headerlink" title="1. 为什么需要分支预测？"></a>1. 为什么需要分支预测？</h3><p>现代处理器采用 <strong>流水线（Pipeline）</strong> 技术，将一条指令的执行分为多个阶段（如取指、译码、执行、访存、写回），多条指令可以“并行”处理。</p>
<p>但遇到 <strong>条件分支指令</strong>（如 <code>if</code>、<code>for</code>、<code>while</code> 对应的 <code>beq</code>、<code>bne</code> 等）时，处理器<strong>无法立即知道下一条该取哪条指令</strong>（跳转 or 顺序执行？）。</p>
<p>如果等待分支结果再取指，会导致流水线 <strong>停顿（stall）</strong>，严重降低性能。</p>
<blockquote>
<p>📌 <strong>分支预测的目标</strong>：在分支结果确定前，<strong>猜测</strong>程序会走哪条路径，并提前取指执行。</p>
</blockquote>
<hr>
<h3 id="2-分支预测的类型"><a href="#2-分支预测的类型" class="headerlink" title="2. 分支预测的类型"></a>2. 分支预测的类型</h3><h4 id="（1）静态分支预测（Static-Branch-Prediction）"><a href="#（1）静态分支预测（Static-Branch-Prediction）" class="headerlink" title="（1）静态分支预测（Static Branch Prediction）"></a>（1）静态分支预测（Static Branch Prediction）</h4><ul>
<li><strong>不依赖运行时信息</strong>，由编译器或硬件固定规则决定。</li>
<li>常见策略：<ul>
<li><strong>总是预测不跳转</strong>（顺序执行）</li>
<li><strong>向后跳转预测为跳转</strong>（用于循环，如 <code>for</code> 的结尾跳回头部）</li>
</ul>
</li>
<li>优点：简单、零硬件开销  </li>
<li>缺点：准确率低（约 60–70%）</li>
</ul>
<h4 id="（2）动态分支预测（Dynamic-Branch-Prediction）"><a href="#（2）动态分支预测（Dynamic-Branch-Prediction）" class="headerlink" title="（2）动态分支预测（Dynamic Branch Prediction）"></a>（2）动态分支预测（Dynamic Branch Prediction）</h4><ul>
<li><strong>根据程序历史行为动态调整预测</strong>，准确率可达 90%+。</li>
<li>常见实现：</li>
</ul>
<h5 id="✅-1-位饱和计数器（1-bit-predictor）"><a href="#✅-1-位饱和计数器（1-bit-predictor）" class="headerlink" title="✅ 1 位饱和计数器（1-bit predictor）"></a>✅ 1 位饱和计数器（1-bit predictor）</h5><ul>
<li>每个分支记录“上次是否跳转”</li>
<li>缺点：频繁切换的分支（如 <code>if (rand() % 2)</code>）会反复预测错误</li>
</ul>
<h5 id="✅-2-位饱和计数器（2-bit-predictor，最常用）"><a href="#✅-2-位饱和计数器（2-bit-predictor，最常用）" class="headerlink" title="✅ 2 位饱和计数器（2-bit predictor，最常用）"></a>✅ 2 位饱和计数器（2-bit predictor，最常用）</h5><ul>
<li>状态机：<strong>强不跳 &#x2F; 弱不跳 &#x2F; 弱跳 &#x2F; 强跳</strong></li>
<li>更稳定，避免噪声干扰</li>
<li>现代 CPU（如 Intel、ARM）普遍使用</li>
</ul>
<h5 id="✅-全局历史预测（Global-History-GShare）"><a href="#✅-全局历史预测（Global-History-GShare）" class="headerlink" title="✅ 全局历史预测（Global History &#x2F; GShare）"></a>✅ 全局历史预测（Global History &#x2F; GShare）</h5><ul>
<li>不仅看当前分支历史，还看<strong>最近所有分支的行为</strong>（全局模式）</li>
<li>能捕捉 <code>if (a) &#123; if (b) ... &#125;</code> 这类相关性</li>
</ul>
<h5 id="✅-分支目标缓冲（BTB-Branch-Target-Buffer）"><a href="#✅-分支目标缓冲（BTB-Branch-Target-Buffer）" class="headerlink" title="✅ 分支目标缓冲（BTB, Branch Target Buffer）"></a>✅ 分支目标缓冲（BTB, Branch Target Buffer）</h5><ul>
<li>缓存分支指令的<strong>目标地址</strong>，避免每次计算跳转地址</li>
<li>通常与预测器配合使用</li>
</ul>
<hr>
<h3 id="3-预测错误的代价"><a href="#3-预测错误的代价" class="headerlink" title="3. 预测错误的代价"></a>3. 预测错误的代价</h3><ul>
<li><strong>清空流水线</strong>（flush pipeline）</li>
<li><strong>重新取指</strong>，浪费多个时钟周期（现代 CPU 可能损失 10–20 周期）</li>
<li>因此，<strong>高准确率预测至关重要</strong></li>
</ul>
<hr>
<h2 id="二、编译器优化（Compiler-Optimization）"><a href="#二、编译器优化（Compiler-Optimization）" class="headerlink" title="二、编译器优化（Compiler Optimization）"></a>二、编译器优化（Compiler Optimization）</h2><p>编译器（如 GCC、Clang）在将高级语言（C&#x2F;C++）翻译成机器码时，会进行一系列优化，目标是：<strong>在不改变程序语义的前提下，提升性能、减小体积、降低功耗</strong>。</p>
<h3 id="1-与分支相关的关键优化"><a href="#1-与分支相关的关键优化" class="headerlink" title="1. 与分支相关的关键优化"></a>1. 与分支相关的关键优化</h3><h4 id="（1）分支预测提示（Branch-Hinting）"><a href="#（1）分支预测提示（Branch-Hinting）" class="headerlink" title="（1）分支预测提示（Branch Hinting）"></a>（1）<strong>分支预测提示（Branch Hinting）</strong></h4><ul>
<li><p>程序员可用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_expect</span><br></pre></td></tr></table></figure>

<p>（GCC）提示“大概率走哪条路径”：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(ptr != <span class="literal">NULL</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 编译器会假设 ptr != NULL 为“很可能成立”</span></span><br><span class="line">    <span class="comment">// 从而优化指令布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器据此调整代码顺序，让<strong>更可能执行的路径连续存放</strong>，减少跳转。</p>
</li>
</ul>
<h4 id="（2）基本块重排（Basic-Block-Reordering）"><a href="#（2）基本块重排（Basic-Block-Reordering）" class="headerlink" title="（2）基本块重排（Basic Block Reordering）"></a>（2）<strong>基本块重排（Basic Block Reordering）</strong></h4><ul>
<li>将高频执行的代码块放在前面，低频（如错误处理）放在后面</li>
<li>减少跳转距离，提升指令缓存命中率</li>
</ul>
<h4 id="（3）消除冗余分支"><a href="#（3）消除冗余分支" class="headerlink" title="（3）消除冗余分支"></a>（3）<strong>消除冗余分支</strong></h4><ul>
<li><p>通过常量传播、死代码消除等，直接删掉不会执行的分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; ... &#125;  <span class="comment">// 整个块被优化掉</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（4）循环优化"><a href="#（4）循环优化" class="headerlink" title="（4）循环优化"></a>（4）<strong>循环优化</strong></h4><ul>
<li><p>循环展开（Loop Unrolling）：减少循环控制分支次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) sum += a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开后</span></span><br><span class="line">sum += a[<span class="number">0</span>]; sum += a[<span class="number">1</span>]; sum += a[<span class="number">2</span>]; sum += a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环不变量外提、强度削弱等</p>
</li>
</ul>
<h4 id="（5）条件传送（Conditional-Move）替代分支"><a href="#（5）条件传送（Conditional-Move）替代分支" class="headerlink" title="（5）条件传送（Conditional Move）替代分支"></a>（5）<strong>条件传送（Conditional Move）替代分支</strong></h4><ul>
<li><p>对于简单 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if-else</span><br></pre></td></tr></table></figure>

<p>，编译器可能生成 </p>
<p>无分支代码</p>
<p>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure>

<p>→ 编译为（x86 示例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, ebx</span><br><span class="line">cmovle eax, ebx   ; if (a &lt;= b) eax = ebx</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无跳转</strong>，避免预测错误风险</li>
<li>但 RISC-V 默认不支持 <code>cmov</code>，需用分支或位运算模拟</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三、分支预测-vs-编译器优化：如何协同？"><a href="#三、分支预测-vs-编译器优化：如何协同？" class="headerlink" title="三、分支预测 vs 编译器优化：如何协同？"></a>三、分支预测 vs 编译器优化：如何协同？</h2><table>
<thead>
<tr>
<th>场景</th>
<th>编译器能做什么</th>
<th>处理器能做什么</th>
</tr>
</thead>
<tbody><tr>
<td><strong>已知高概率分支</strong></td>
<td>用 <code>__builtin_expect</code> 提示，重排代码</td>
<td>静态预测器按“顺序执行”或“向后跳转”猜测</td>
</tr>
<tr>
<td><strong>循环结构</strong></td>
<td>循环展开、不变量外提</td>
<td>动态预测器学习“循环末尾总是跳转”</td>
</tr>
<tr>
<td><strong>简单条件赋值</strong></td>
<td>生成条件传送（若架构支持）</td>
<td>无需预测，无分支</td>
</tr>
<tr>
<td><strong>复杂分支逻辑</strong></td>
<td>尽量简化条件表达式</td>
<td>用 BTB + 2-bit 预测器跟踪历史</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>理想情况</strong>：编译器减少不必要的分支，处理器高效预测剩余分支。</p>
</blockquote>
<hr>
<h2 id="四、RISC-V-与-ARM-x86-的差异"><a href="#四、RISC-V-与-ARM-x86-的差异" class="headerlink" title="四、RISC-V 与 ARM&#x2F;x86 的差异"></a>四、RISC-V 与 ARM&#x2F;x86 的差异</h2><table>
<thead>
<tr>
<th>特性</th>
<th>RISC-V</th>
<th>ARM&#x2F;x86</th>
</tr>
</thead>
<tbody><tr>
<td><strong>条件执行</strong></td>
<td>❌ 不支持</td>
<td>ARMv7 ✅，x86 ❌</td>
</tr>
<tr>
<td><strong>条件传送指令</strong></td>
<td>❌ 基础 ISA 无（需用分支或扩展）</td>
<td>x86 ✅（<code>cmov</code>），ARM64 ✅（<code>csel</code>）</td>
</tr>
<tr>
<td><strong>编译器优化空间</strong></td>
<td>更依赖分支预测</td>
<td>可用 <code>cmov</code>&#x2F;<code>csel</code> 消除部分分支</td>
</tr>
<tr>
<td><strong>对预测器依赖</strong></td>
<td>更高</td>
<td>略低（有更多无分支选项）</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、实际影响举例"><a href="#五、实际影响举例" class="headerlink" title="五、实际影响举例"></a>五、实际影响举例</h2><h3 id="例子：错误处理路径"><a href="#例子：错误处理路径" class="headerlink" title="例子：错误处理路径"></a>例子：错误处理路径</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;Null pointer!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常处理（99% 情况）</span></span><br><span class="line">    *p = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化后</strong>：编译器将 <code>log_error</code> 块放到函数末尾，主路径无跳转</li>
<li><strong>预测器</strong>：学习到“几乎不走错误路径”，预测准确率高</li>
<li><strong>结果</strong>：主路径执行极快，几乎无流水线停顿</li>
</ul>
<hr>
<h2 id="六、总结-1"><a href="#六、总结-1" class="headerlink" title="六、总结"></a>六、总结</h2><table>
<thead>
<tr>
<th>技术</th>
<th>作用层级</th>
<th>目标</th>
<th>关键手段</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分支预测</strong></td>
<td><strong>硬件（CPU）</strong></td>
<td>减少因分支导致的流水线停顿</td>
<td>静态&#x2F;动态预测、BTB、全局历史</td>
</tr>
<tr>
<td><strong>编译器优化</strong></td>
<td><strong>软件（编译期）</strong></td>
<td>生成更高效、更少分支的代码</td>
<td>分支提示、基本块重排、循环优化、条件传送</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>现代高性能程序 &#x3D; 编译器聪明地生成代码 + CPU 聪明地执行代码</strong></p>
</blockquote>
<p>两者相辅相成：<strong>编译器尽量减少“难预测”的分支，CPU 尽力准确预测剩下的分支</strong>。</p>
<hr>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>条件执行</tag>
        <tag>分支预测</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备树详解</title>
    <url>/2025/07/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><p>Device Tree是一种描述硬件的数据结构，以便于操作系统的内核可以管理和使用这些硬件，包括CPU或CPU，内存，总线和其他一些外设。</p>
<p>Linux内核从3.x版本之后开始支持使用设备树，可以实现驱动代码与设备的硬件信息相互的隔离，减少了代码中的耦合性</p>
<p>引入设备树之前：一些与硬件设备相关的具体信息都要写在驱动代码中，如果外设发生相应的变化，那么驱动代码就需要改动。</p>
<p>引入设备树之后：通过设备树对硬件信息的抽象，驱动代码只要负责处理逻辑，而关于设备的具体信息存放到设备树文件中。如果只是硬件接口信息的变化而没有驱动逻辑的变化，开发者只需要修改设备树文件信息，不需要改写驱动代码。</p>
<h2 id="一、DTS、DTB和DTC"><a href="#一、DTS、DTB和DTC" class="headerlink" title="一、DTS、DTB和DTC"></a>一、DTS、DTB和DTC</h2><h3 id="1、DTS"><a href="#1、DTS" class="headerlink" title="1、DTS"></a>1、DTS</h3><p>设备树源码文件，硬件的相应信息都会写在.dts为后缀的文件中，每一款硬件可以单独写一份xxxx.dts</p>
<h3 id="2、DTSI"><a href="#2、DTSI" class="headerlink" title="2、DTSI"></a>2、DTSI</h3><p>对于一些相同的dts配置可以抽象到dtsi文件中，然后可以用include的方式到dts文件中<br>同一芯片可以做一个dtsi，不同的板子不同的dts，然后include同一dtsi<br>对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置</p>
<h3 id="3、DTC"><a href="#3、DTC" class="headerlink" title="3、DTC"></a>3、DTC</h3><p>dtc是编译dts的工具</p>
<h3 id="4、DTB"><a href="#4、DTB" class="headerlink" title="4、DTB"></a>4、DTB</h3><p>dts经过dtc编译之后会得到dtb文件，设备树的二进制执行文件<br>dtb通过Bootloader引导程序加载到内核。</p>
<h2 id="二、设备树框架"><a href="#二、设备树框架" class="headerlink" title="二、设备树框架"></a>二、设备树框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.根节点：\</span><br><span class="line"></span><br><span class="line">2.设备节点：nodex</span><br><span class="line"></span><br><span class="line">        ①节点名称：node</span><br><span class="line">    </span><br><span class="line">        ②节点地址：node@0, @后面即为地址</span><br><span class="line"></span><br><span class="line">3.属性：属性名称（Property   name)和属性值(Property value)</span><br><span class="line"></span><br><span class="line">4.标签</span><br></pre></td></tr></table></figure>


<p>“&#x2F;”是根节点，每个设备树文件只有一个根节点。在设备树文件中会发现有的文件下也有“&#x2F;”根节点，这两个**“&#x2F;”根节点的内容会合并成一个根节点。**</p>
<p>Linux 内核启动的时会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹</p>
<h2 id="三、DTS语法"><a href="#三、DTS语法" class="headerlink" title="三、DTS语法"></a>三、DTS语法</h2><h3 id="1、dtsi头文件"><a href="#1、dtsi头文件" class="headerlink" title="1、dtsi头文件"></a>1、dtsi头文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;dt-bindings/input/input.h&gt;</span><br><span class="line">#include &quot;imx6ull.dtsi&quot;</span><br></pre></td></tr></table></figure>


<p>设备树也支持头文件，设备树的头文件扩展名为.dtsi。在.dts 设备树文件中，还可以通过“#include”来引用.h、 .dtsi 和.dts 文件。</p>
<h3 id="2、设备节点"><a href="#2、设备节点" class="headerlink" title="2、设备节点"></a>2、设备节点</h3><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，</p>
<p>每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label: node-name@unit-address</span><br><span class="line">label:节点标签，方便访问节点：通过&amp;label访问节点，追加节点信息</span><br><span class="line">node-name：节点名字，为字符串，描述节点功能</span><br><span class="line">unit-address：设备的地址或寄存器首地址，若某个节点没有地址或者寄存器，可以省略</span><br></pre></td></tr></table></figure>


<p>设备树源码中常用的几种数据形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.字符串:  compatible = &quot;arm,cortex-a7&quot;;设置 compatible 属性的值为字符串“arm,cortex-a7”</span><br><span class="line">2.32位无符号整数：reg = &lt;0&gt;; 设置reg属性的值为0</span><br><span class="line">3.字符串列表：字符串和字符串之间采用“,”隔开</span><br><span class="line">compatible = &quot;fsl,imx6ull-gpmi-nand&quot;, &quot;fsl, imx6ul-gpmi-nand&quot;;</span><br><span class="line">设置属性 compatible 的值为“fsl,imx6ull-gpmi-nand”和“fsl, imx6ul-gpmi-nand”。</span><br></pre></td></tr></table></figure>



<h3 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h3><h4 id="compatible属性（兼容属性）"><a href="#compatible属性（兼容属性）" class="headerlink" title="compatible属性（兼容属性）"></a>compatible属性（兼容属性）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;manufacturer,model&quot; </span><br><span class="line">manufacturer：厂商名称 </span><br><span class="line">model：模块对应的驱动名字</span><br></pre></td></tr></table></figure>

<p>例：<br>imx6ull-alientekemmc.dts 中 sound 节点是 音频设备节点，采用的欧胜(WOLFSON)出品的 WM8960， sound 节点的 compatible 属性值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;;</span><br></pre></td></tr></table></figure>

<p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。</p>
<p>sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p>
<p>一般驱动程序文件会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</p>
<p>在根节点来说，Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。如果不支持的话那么这个设备就没法启动 Linux 内核。</p>
<h4 id="model属性"><a href="#model属性" class="headerlink" title="model属性"></a>model属性</h4><p>model 属性值是一个字符串，一般 model 属性描述设备模块信息。</p>
<h4 id="status属性"><a href="#status属性" class="headerlink" title="status属性"></a>status属性</h4><p>status 属性和设备状态有关的， status 属性值是字符串，描述设备的状态信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">okey	表示设备是可擦做的</span><br><span class="line">disabled	表示设备当前是不可操作的，但在未来可以变为可操作的，比如热插拔设备插入以后</span><br><span class="line">fail		表示设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作</span><br><span class="line">fail-sss	含义与fail相同，sss部分是检测到的错误内容</span><br></pre></td></tr></table></figure>



<h4 id="address-cells-和-size-cells-属性"><a href="#address-cells-和-size-cells-属性" class="headerlink" title="#address-cells 和#size-cells 属性"></a>#address-cells 和#size-cells 属性</h4><p>用于描述子节点的地址信息,reg属性的address 和 length的字长。</p>
<p>#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)</p>
<p>#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)</p>
<p>子节点的地址信息描述来自于父节点的#address-cells 和#size-cells的值，而不是该节点本身的值（当前节点的信息是描述子节点的，自己的信息在父节点里）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//每个“address length”组合表示一个地址范围，</span><br><span class="line">//其中 address 是起始地址， length 是地址长度，</span><br><span class="line">//#address-cells 表明 address 这个数据所占用的字长，</span><br><span class="line">// #size-cells 表明 length 这个数据所占用的字长.</span><br><span class="line">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</span><br></pre></td></tr></table></figure>



<h4 id="reg属性"><a href="#reg属性" class="headerlink" title="reg属性"></a>reg属性</h4><p>reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息, reg 属性的值一般是(address， length)对.</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart1: serial@02020000 &#123;</span><br><span class="line">    compatible = &quot;fsl,imx6ul-uart&quot;,</span><br><span class="line">        &quot;fsl,imx6q-uart&quot;, &quot;fsl,imx21-uart&quot;;</span><br><span class="line">    reg = &lt;0x02020000 0x4000&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;clks IMX6UL_CLK_UART1_IPG&gt;,</span><br><span class="line">        &lt;&amp;clks IMX6UL_CLK_UART1_SERIAL&gt;;</span><br><span class="line">    clock-names = &quot;ipg&quot;, &quot;per&quot;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>uart1 的父节点 aips1: aips-bus@02000000 设置了#address-cells &#x3D; &lt;1&gt;、 #sizecells &#x3D; &lt;1&gt;，因此 reg 属性中 address&#x3D;0x02020000， length&#x3D;0x4000。都是字长为1.</p>
<h4 id="ranges属性"><a href="#ranges属性" class="headerlink" title="ranges属性"></a>ranges属性</h4><p>ranges属性值可以为空或者按照( child-bus-address , parent-bus-address , length )格式编写的数字</p>
<p>ranges 是一个地址映射&#x2F;转换表， ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成。</p>
<p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长</span><br><span class="line">parent-bus-address： 父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长</span><br><span class="line">length： 子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长</span><br></pre></td></tr></table></figure>



<h4 id="特殊节点"><a href="#特殊节点" class="headerlink" title="特殊节点"></a>特殊节点</h4><p>在根节点“&#x2F;”中有两个特殊的子节点： aliases 和 chosen</p>
<p>aliases</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    can0 = &amp;flexcan1;</span><br><span class="line">    can1 = &amp;flexcan2;</span><br><span class="line">    ...</span><br><span class="line">    usbphy0 = &amp;usbphy1;</span><br><span class="line">    usbphy1 = &amp;usbphy2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。</p>
<p>但是，一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点。</p>
<p>chosen<br>chosen 不是一个真实的设备， chosen 节点主要是为了 uboot 向 Linux 内核传递数据(bootargs 参数)。</p>
<h2 id="四、OF操作函数"><a href="#四、OF操作函数" class="headerlink" title="四、OF操作函数"></a>四、OF操作函数</h2><p>Linux 内核提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_” (称为OF 函数）</p>
<h3 id="1、查找节点"><a href="#1、查找节点" class="headerlink" title="1、查找节点"></a>1、查找节点</h3><p>Linux 内核使用 device_node 结构体来描述一个节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node &#123;</span><br><span class="line">    const char *name; /* 节点名字 */</span><br><span class="line">    const char *type; /* 设备类型 */</span><br><span class="line">    phandle phandle;</span><br><span class="line">    const char *full_name; /* 节点全名 */</span><br><span class="line">    struct fwnode_handle fwnode;</span><br><span class="line"></span><br><span class="line">    struct property *properties; /* 属性 */</span><br><span class="line">    struct property *deadprops; /* removed 属性 */</span><br><span class="line">    struct device_node *parent; /* 父节点 */</span><br><span class="line">    struct device_node *child; /* 子节点</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1、通过节点名字查找指定的节点：of-find-node-by-name"><a href="#1-1、通过节点名字查找指定的节点：of-find-node-by-name" class="headerlink" title="1.1、通过节点名字查找指定的节点：of_find_node_by_name"></a>1.1、通过节点名字查找指定的节点：of_find_node_by_name</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_name(struct device_node *from,const char *name)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>name：要查找的节点名字。<br>返回值： 找到的节点，如果为 NULL 表示查找失败。</p>
<h4 id="1-2、通过-device-type-属性查找指定的节点：of-find-node-by-type"><a href="#1-2、通过-device-type-属性查找指定的节点：of-find-node-by-type" class="headerlink" title="1.2、通过 device_type 属性查找指定的节点：of_find_node_by_type"></a>1.2、通过 device_type 属性查找指定的节点：of_find_node_by_type</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的 type 字符串， device_type 属性值。<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="1-3、通过device-type-和-compatible两个属性查找指定的节点：of-find-compatible-node"><a href="#1-3、通过device-type-和-compatible两个属性查找指定的节点：of-find-compatible-node" class="headerlink" title="1.3、通过device_type 和 compatible两个属性查找指定的节点：of_find_compatible_node"></a>1.3、通过device_type 和 compatible两个属性查找指定的节点：of_find_compatible_node</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_compatible_node(struct device_node *from,</span><br><span class="line">                                            const char *type,</span><br><span class="line">                                            const char *compatible)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的 type 字符串，device_type 属性值，可以为 NULL<br>compatible： 要查找的节点所对应的 compatible 属性列表。<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="1-4、通过-of-device-id-匹配表来查找指定的节点：of-find-matching-node-and-match"><a href="#1-4、通过-of-device-id-匹配表来查找指定的节点：of-find-matching-node-and-match" class="headerlink" title="1.4、通过 of_device_id 匹配表来查找指定的节点：of_find_matching_node_and_match"></a>1.4、通过 of_device_id 匹配表来查找指定的节点：of_find_matching_node_and_match</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_matching_node_and_match(struct device_node *from,</span><br><span class="line">                                            const struct of_device_id *matches,</span><br><span class="line">                                            const struct of_device_id **match)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>matches： of_device_id 匹配表，在此匹配表里面查找节点。<br>match： 找到的匹配的 of_device_id。<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="1-5、通过路径来查找指定的节点：of-find-node-by-path"><a href="#1-5、通过路径来查找指定的节点：of-find-node-by-path" class="headerlink" title="1.5、通过路径来查找指定的节点：of_find_node_by_path"></a>1.5、通过路径来查找指定的节点：of_find_node_by_path</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline struct device_node *of_find_node_by_path(const char *path)</span><br></pre></td></tr></table></figure>

<p>path：设备树节点中绝对路径的节点名，可以使用节点的别名<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h3 id="2、获取属性值"><a href="#2、获取属性值" class="headerlink" title="2、获取属性值"></a>2、获取属性值</h3><p>Linux 内核中使用结构体 property 表示属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">    char *name; /* 属性名字 */</span><br><span class="line">    int length; /* 属性长度 */</span><br><span class="line">    void *value; /* 属性值 */</span><br><span class="line">    struct property *next; /* 下一个属性 */</span><br><span class="line">    unsigned long _flags;</span><br><span class="line">    unsigned int unique_id;</span><br><span class="line">    struct bin_attribute attr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1、查找指定的属性：of-find-property"><a href="#2-1、查找指定的属性：of-find-property" class="headerlink" title="2.1、查找指定的属性：of_find_property"></a>2.1、查找指定的属性：of_find_property</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">property *of_find_property(const struct device_node *np,</span><br><span class="line">                           const char *name,</span><br><span class="line">                           int *lenp)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>name： 属性名字。<br>lenp：属性值的字节数，一般为NULL<br>返回值： 找到的属性。</p>
<h4 id="2-2、获取属性中元素的数量-数组-：of-property-count-elems-of-size"><a href="#2-2、获取属性中元素的数量-数组-：of-property-count-elems-of-size" class="headerlink" title="2.2、获取属性中元素的数量(数组)：of_property_count_elems_of_size"></a>2.2、获取属性中元素的数量(数组)：of_property_count_elems_of_size</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_count_elems_of_size(const struct device_node *np,</span><br><span class="line">                                    const char *propname</span><br><span class="line">                                    int elem_size)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>proname： 需要统计元素数量的属性名字。<br>elem_size：元素长度。<br>返回值： 得到的属性元素数量</p>
<h4 id="2-3、从属性中获取指定标号的-u32-类型数据值-of-property-read-u32-index"><a href="#2-3、从属性中获取指定标号的-u32-类型数据值-of-property-read-u32-index" class="headerlink" title="2.3、从属性中获取指定标号的 u32 类型数据值:of_property_read_u32_index"></a>2.3、从属性中获取指定标号的 u32 类型数据值:of_property_read_u32_index</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_u32_index(const struct device_node *np,</span><br><span class="line">                                const char *propname,</span><br><span class="line">                                u32 index,</span><br><span class="line">                                u32 *out_value)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>proname： 要读取的属性名字。<br>index：要读取的值标号。<br>out_value：读取到的值<br>返回值： 0 读取成功;<br>负值: 读取失败，<br>-EINVAL 表示属性不存在<br>-ENODATA 表示没有要读取的数据，<br>-EOVERFLOW 表示属性值列表太小</p>
<h4 id="2-4、读取属性中-u8、-u16、-u32-和-u64-类型的数组数据"><a href="#2-4、读取属性中-u8、-u16、-u32-和-u64-类型的数组数据" class="headerlink" title="2.4、读取属性中 u8、 u16、 u32 和 u64 类型的数组数据"></a>2.4、读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">of_property_read_u8_array</span><br><span class="line">of_property_read_u16_array </span><br><span class="line">of_property_read_u32_array </span><br><span class="line">of_property_read_u64_array </span><br><span class="line">int of_property_read_u8_array(const struct device_node *np,</span><br><span class="line">                                const char *propname,</span><br><span class="line">                                u8 *out_values,</span><br><span class="line">                                size_t sz)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>proname： 要读取的属性名字。<br>out_value：读取到的数组值，分别为 u8、 u16、 u32 和 u64。<br>sz： 要读取的数组元素数量。<br>返回值： 0：读取成功;<br>负值: 读取失败<br>-EINVAL 表示属性不存在<br>-ENODATA 表示没有要读取的数据<br>-EOVERFLOW 表示属性值列表太小</p>
<h4 id="2-5、读取属性中字符串值：of-property-read-string"><a href="#2-5、读取属性中字符串值：of-property-read-string" class="headerlink" title="2.5、读取属性中字符串值：of_property_read_string"></a>2.5、读取属性中字符串值：of_property_read_string</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_string(struct device_node *np,</span><br><span class="line">                            const char *propname,</span><br><span class="line">                            const char **out_string)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>proname： 要读取的属性名字。<br>out_string：读取到的字符串值。<br>返回值： 0，读取成功，负值，读取失败</p>
<h4 id="2-6、获取-address-cells-属性值：of-n-addr-cells-，获取-size-cells-属性值：of-size-cells-。"><a href="#2-6、获取-address-cells-属性值：of-n-addr-cells-，获取-size-cells-属性值：of-size-cells-。" class="headerlink" title="2.6、获取 #address-cells 属性值：of_n_addr_cells ，获取 #size-cells 属性值：of_size_cells 。"></a>2.6、获取 #address-cells 属性值：of_n_addr_cells ，获取 #size-cells 属性值：of_size_cells 。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_n_addr_cells(struct device_node *np)</span><br><span class="line">int of_n_size_cells(struct device_node *np)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>返回值： 获取到的#address-cells 属性值。<br>返回值： 获取到的#size-cells 属性值。</p>
<h4 id="2-7、内存映射"><a href="#2-7、内存映射" class="headerlink" title="2.7、内存映射"></a>2.7、内存映射</h4><p>of_iomap 函数用于直接内存映射，前面通过 ioremap 函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过 of_iomap 函数来获取内存地址所对应的虚拟地址。这样就不用再去先获取reg属性值，再用属性值映射内存。</p>
<p>of_iomap 函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段， of_iomap 函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __iomem *of_iomap(struct device_node *np,  int index)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。<br>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为 0。<br>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</p>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 1</span><br><span class="line">	/* 1、寄存器地址映射 */</span><br><span class="line">	IMX6U_CCM_CCGR1 = ioremap(regdata[0], regdata[1]);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = ioremap(regdata[2], regdata[3]);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = ioremap(regdata[4], regdata[5]);</span><br><span class="line">	GPIO1_DR = ioremap(regdata[6], regdata[7]);</span><br><span class="line">	GPIO1_GDIR = ioremap(regdata[8], regdata[9]);</span><br><span class="line">#else   //第一对：起始地址+大小 --&gt;映射 这样就不用获取reg的值</span><br><span class="line">	IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, 0); </span><br><span class="line">	SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, 1);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, 2);</span><br><span class="line">	GPIO1_DR = of_iomap(dtsled.nd, 3);</span><br><span class="line">	GPIO1_GDIR = of_iomap(dtsled.nd, 4);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h4 id="2-8、of-函数在-led-init-中应用"><a href="#2-8、of-函数在-led-init-中应用" class="headerlink" title="2.8、of 函数在 led_init() 中应用"></a>2.8、of 函数在 led_init() 中应用</h4><p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ret;</span><br><span class="line">    u32 regdate[14];</span><br><span class="line">    const char *str;</span><br><span class="line">	struct property *proper;</span><br><span class="line">    /* 1 、获取设备节点： */</span><br><span class="line">    dtb_led.nd = of_find_node_by_path(&quot;/songwei_led&quot;);</span><br><span class="line">    if(dtb_led.nd == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;songwei_led node can not found!\r\n&quot;);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;songwei_led node has been found!\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* 2 、获取 compatible  属性内容 */</span><br><span class="line">    proper = of_find_property(dtb_led.nd ,&quot;compatible&quot;,NULL);</span><br><span class="line">    if(proper == NULL) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;compatible property find failed\r\n&quot;);</span><br><span class="line">    &#125; else </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;compatible = %s\r\n&quot;, (char*)proper-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* 3 、获取 status  属性内容 */</span><br><span class="line">    ret = of_property_read_string(dtb_led.nd, &quot;status&quot;, &amp;str);</span><br><span class="line">    if(ret &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;status read failed!\r\n&quot;);</span><br><span class="line">    &#125;else </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;status = %s\r\n&quot;,str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* 4 、获取 reg  属性内容 */</span><br><span class="line">    ret = of_property_read_u32_array(dtb_led.nd, &quot;reg&quot;, regdate, 10);</span><br><span class="line">    if(ret &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;reg property read failed!\r\n&quot;);</span><br><span class="line">    &#125;else </span><br><span class="line">    &#123;</span><br><span class="line">        u8 i = 0;</span><br><span class="line">        printk(&quot;reg data:\r\n&quot;);</span><br><span class="line">        for(i = 0; i &lt; 10; i++)</span><br><span class="line">            printk(&quot;%#X &quot;, regdate[i]);</span><br><span class="line">        printk(&quot;\r\n&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文是对 <strong>进程（Process）</strong> 和 <strong>线程（Thread）</strong> 的全面、深入、详细的讲解，涵盖定义、区别、实现机制、调度、通信、内存模型、优缺点、典型应用场景，以及在现代操作系统（如 Linux&#x2F;Windows）中的具体实现细节。</p>
<hr>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-什么是进程（Process）？"><a href="#1-1-什么是进程（Process）？" class="headerlink" title="1.1 什么是进程（Process）？"></a>1.1 什么是进程（Process）？</h3><p><strong>进程</strong>是操作系统进行<strong>资源分配和调度的基本单位</strong>。它是一个<strong>正在运行的程序的实例</strong>，拥有独立的地址空间、内存、文件描述符、环境变量、安全上下文（如用户ID）、信号处理机制等。</p>
<ul>
<li>每个进程在内核中都有一个唯一的 <strong>进程标识符（PID）</strong>。</li>
<li>进程是<strong>隔离的</strong>：一个进程崩溃通常不会直接影响其他进程。</li>
<li>进程启动时，操作系统为其分配：<ul>
<li>虚拟地址空间（代码段、数据段、堆、栈等）</li>
<li>文件描述符表</li>
<li>信号处理表</li>
<li>进程控制块（PCB，Process Control Block）</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 <strong>类比</strong>：进程就像一个“工厂”，拥有自己的厂房（内存空间）、设备（资源）、工人（线程）和管理制度（内核结构）。</p>
</blockquote>
<hr>
<h3 id="1-2-什么是线程（Thread）？"><a href="#1-2-什么是线程（Thread）？" class="headerlink" title="1.2 什么是线程（Thread）？"></a>1.2 什么是线程（Thread）？</h3><p><strong>线程</strong>是<strong>进程内的执行单元</strong>，是 CPU 调度的最小单位。一个进程可以包含一个或多个线程，所有线程共享进程的<strong>地址空间和资源</strong>，但每个线程拥有自己的：</p>
<ul>
<li>栈（Stack）</li>
<li>寄存器状态（包括程序计数器 PC）</li>
<li>线程局部存储（TLS）</li>
<li>信号掩码（部分系统支持）</li>
<li>线程由<strong>线程 ID（TID）</strong> 标识。</li>
<li>同一进程内的线程可以<strong>直接访问共享内存</strong>，通信效率高。</li>
</ul>
<blockquote>
<p>💡 <strong>类比</strong>：线程就像工厂里的“工人”，共用厂房和设备，但各自有工具包（栈）和任务进度（PC）。</p>
</blockquote>
<hr>
<h2 id="二、进程-vs-线程：核心区别"><a href="#二、进程-vs-线程：核心区别" class="headerlink" title="二、进程 vs 线程：核心区别"></a>二、进程 vs 线程：核心区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>进程（Process）</th>
<th>线程（Thread）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址空间</strong></td>
<td>独立（隔离）</td>
<td>共享（同一进程内）</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>大（创建&#x2F;销毁慢）</td>
<td>小（轻量级）</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>IPC（管道、消息队列、共享内存等）</td>
<td>直接读写共享内存</td>
</tr>
<tr>
<td><strong>同步机制</strong></td>
<td>无需（天然隔离）</td>
<td>需要（互斥锁、条件变量等）</td>
</tr>
<tr>
<td><strong>健壮性</strong></td>
<td>一个崩溃不影响其他进程</td>
<td>一个线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td><strong>调度单位</strong></td>
<td>是（传统系统）</td>
<td>是（现代系统中线程是调度单位）</td>
</tr>
<tr>
<td><strong>创建方式</strong></td>
<td><code>fork()</code>、<code>exec()</code>（Unix）</td>
<td><code>pthread_create()</code>、<code>std::thread</code>（C++）</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>关键点</strong>：现代操作系统（如 Linux）中，<strong>线程本质上也是“轻量级进程”</strong>，由内核统一调度。</p>
</blockquote>
<hr>
<h2 id="三、操作系统中的实现机制"><a href="#三、操作系统中的实现机制" class="headerlink" title="三、操作系统中的实现机制"></a>三、操作系统中的实现机制</h2><h3 id="3-1-Linux-中的进程与线程"><a href="#3-1-Linux-中的进程与线程" class="headerlink" title="3.1 Linux 中的进程与线程"></a>3.1 Linux 中的进程与线程</h3><p>Linux 采用 <strong>“一切皆进程”</strong> 的设计理念，使用 <strong><code>task_struct</code></strong> 结构体统一表示进程和线程。</p>
<ul>
<li><p><strong>进程创建</strong>：通过 <code>fork()</code> 系统调用，复制父进程的地址空间（写时复制 COW）。</p>
</li>
<li><p>线程创建</p>
<p>：通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure>

<p> 系统调用，传入标志如 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_FS | CLONE_FILES</span><br></pre></td></tr></table></figure>

<p> 等，表示共享地址空间、文件系统信息、文件描述符等。</p>
<ul>
<li><code>pthread_create()</code> 底层就是调用 <code>clone()</code>。</li>
</ul>
</li>
<li><p>PID 与 TID</p>
<p>：</p>
<ul>
<li>每个线程有唯一的 <strong>TID（Thread ID）</strong>。</li>
<li>同一进程内的所有线程共享同一个 <strong>TGID（Thread Group ID）</strong>，即主线程的 PID。</li>
<li><code>getpid()</code> 返回 TGID，<code>gettid()</code> 返回 TID。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 示例：<code>ps -eLf</code> 可查看所有线程，其中 <code>PID</code> 是 TGID，<code>LWP</code>（轻量级进程）是 TID。</p>
</blockquote>
<hr>
<h3 id="3-2-Windows-中的实现"><a href="#3-2-Windows-中的实现" class="headerlink" title="3.2 Windows 中的实现"></a>3.2 Windows 中的实现</h3><ul>
<li>Windows 使用 <strong>“进程 + 线程”</strong> 模型。</li>
<li>进程是资源容器，线程是执行实体。</li>
<li>创建进程：<code>CreateProcess()</code></li>
<li>创建线程：<code>CreateThread()</code></li>
<li>每个线程有独立的内核对象和用户栈。</li>
<li>线程调度由内核完成，支持优先级、亲和性等。</li>
</ul>
<hr>
<h2 id="四、内存布局（以-Linux-为例）"><a href="#四、内存布局（以-Linux-为例）" class="headerlink" title="四、内存布局（以 Linux 为例）"></a>四、内存布局（以 Linux 为例）</h2><p>一个典型进程的虚拟地址空间如下（从低地址到高地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">|        栈（Stack）     | ← 高地址，向下增长（每个线程有自己的栈）</span><br><span class="line">+------------------------+</span><br><span class="line">|        ...             |</span><br><span class="line">+------------------------+</span><br><span class="line">|        堆（Heap）      | ← 动态分配（malloc/new），向上增长（所有线程共享）</span><br><span class="line">+------------------------+</span><br><span class="line">|   BSS段（未初始化数据）|</span><br><span class="line">+------------------------+</span><br><span class="line">|   数据段（已初始化全局变量）|</span><br><span class="line">+------------------------+</span><br><span class="line">|   代码段（.text，只读） |</span><br><span class="line">+------------------------+</span><br><span class="line">|   内核空间（不可访问） |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>线程栈</strong>：通常默认 8MB（可配置），用于函数调用、局部变量。</li>
<li><strong>共享区域</strong>：堆、全局变量、代码段、打开的文件等，所有线程可见。</li>
</ul>
<hr>
<h2 id="五、线程同步与并发问题"><a href="#五、线程同步与并发问题" class="headerlink" title="五、线程同步与并发问题"></a>五、线程同步与并发问题</h2><p>由于线程共享内存，必须处理<strong>并发访问</strong>问题：</p>
<h3 id="常见同步原语："><a href="#常见同步原语：" class="headerlink" title="常见同步原语："></a>常见同步原语：</h3><table>
<thead>
<tr>
<th>原语</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>互斥锁（Mutex）</strong></td>
<td>保证临界区互斥访问</td>
</tr>
<tr>
<td><strong>条件变量（Condition Variable）</strong></td>
<td>线程间等待&#x2F;通知机制</td>
</tr>
<tr>
<td><strong>读写锁（RWLock）</strong></td>
<td>允许多读单写</td>
</tr>
<tr>
<td><strong>信号量（Semaphore）</strong></td>
<td>控制资源数量</td>
</tr>
<tr>
<td><strong>原子操作（Atomic）</strong></td>
<td>无锁编程基础（如 CAS）</td>
</tr>
</tbody></table>
<h3 id="经典问题："><a href="#经典问题：" class="headerlink" title="经典问题："></a>经典问题：</h3><ul>
<li><strong>竞态条件（Race Condition）</strong>：多个线程同时修改共享数据导致结果不确定。</li>
<li><strong>死锁（Deadlock）</strong>：多个线程互相等待对方释放锁。</li>
<li><strong>活锁（Livelock）</strong>：线程不断重试但无法前进。</li>
<li><strong>饥饿（Starvation）</strong>：某些线程长期得不到资源。</li>
</ul>
<hr>
<h2 id="六、进程间通信（IPC）-vs-线程间通信"><a href="#六、进程间通信（IPC）-vs-线程间通信" class="headerlink" title="六、进程间通信（IPC） vs 线程间通信"></a>六、进程间通信（IPC） vs 线程间通信</h2><h3 id="进程间通信（因地址空间隔离）："><a href="#进程间通信（因地址空间隔离）：" class="headerlink" title="进程间通信（因地址空间隔离）："></a>进程间通信（因地址空间隔离）：</h3><ul>
<li>管道（Pipe &#x2F; Named Pipe）</li>
<li>消息队列（Message Queue）</li>
<li>共享内存（Shared Memory）+ 信号量</li>
<li>信号（Signal）</li>
<li>套接字（Socket，包括 Unix Domain Socket）</li>
<li>内存映射文件（mmap）</li>
</ul>
<h3 id="线程间通信（因共享内存）："><a href="#线程间通信（因共享内存）：" class="headerlink" title="线程间通信（因共享内存）："></a>线程间通信（因共享内存）：</h3><ul>
<li>直接读写全局变量或堆内存</li>
<li>使用同步原语协调访问</li>
<li>条件变量通知</li>
<li>无锁队列（Lock-free Queue）</li>
</ul>
<blockquote>
<p>✅ <strong>性能对比</strong>：线程通信远快于进程通信，因为无需内核介入或内存拷贝。</p>
</blockquote>
<hr>
<h2 id="七、调度与上下文切换"><a href="#七、调度与上下文切换" class="headerlink" title="七、调度与上下文切换"></a>七、调度与上下文切换</h2><h3 id="上下文切换开销："><a href="#上下文切换开销：" class="headerlink" title="上下文切换开销："></a>上下文切换开销：</h3><ul>
<li><strong>进程切换</strong>：需切换页表（TLB flush）、地址空间、寄存器、内核栈等，开销大。</li>
<li><strong>线程切换</strong>（同进程内）：只需切换寄存器、栈指针、PC 等，<strong>不切换页表</strong>，开销小。</li>
</ul>
<h3 id="调度策略（Linux）："><a href="#调度策略（Linux）：" class="headerlink" title="调度策略（Linux）："></a>调度策略（Linux）：</h3><ul>
<li><strong>CFS（Completely Fair Scheduler）</strong>：默认调度器，基于红黑树公平分配 CPU 时间。</li>
<li>实时线程：<code>SCHED_FIFO</code>、<code>SCHED_RR</code></li>
<li>普通线程：<code>SCHED_OTHER</code></li>
</ul>
<hr>
<h2 id="八、多线程-vs-多进程：如何选择？"><a href="#八、多线程-vs-多进程：如何选择？" class="headerlink" title="八、多线程 vs 多进程：如何选择？"></a>八、多线程 vs 多进程：如何选择？</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐模型</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>高并发 I&#x2F;O（如 Web 服务器）</td>
<td>多线程 或 异步 I&#x2F;O</td>
<td>线程轻量，适合处理大量连接</td>
</tr>
<tr>
<td>CPU 密集型任务</td>
<td>多进程（或线程 + GIL 绕过）</td>
<td>避免 GIL（如 Python），或利用多核</td>
</tr>
<tr>
<td>安全性要求高（如浏览器）</td>
<td>多进程</td>
<td>一个 tab 崩溃不影响其他</td>
</tr>
<tr>
<td>实时性要求高</td>
<td>多线程 + 实时调度</td>
<td>线程切换快，响应及时</td>
</tr>
<tr>
<td>资源隔离需求强</td>
<td>多进程</td>
<td>内存、文件描述符完全隔离</td>
</tr>
</tbody></table>
<blockquote>
<p>🌰 例子：</p>
<ul>
<li><strong>Chrome 浏览器</strong>：每个标签页是一个进程（安全隔离）。</li>
<li><strong>Nginx</strong>：多进程模型（Master-Worker），每个 Worker 处理多个连接（事件驱动）。</li>
<li><strong>Java 应用</strong>：大量使用线程池处理请求。</li>
</ul>
</blockquote>
<hr>
<h2 id="九、高级话题"><a href="#九、高级话题" class="headerlink" title="九、高级话题"></a>九、高级话题</h2><h3 id="9-1-用户级线程-vs-内核级线程"><a href="#9-1-用户级线程-vs-内核级线程" class="headerlink" title="9.1 用户级线程 vs 内核级线程"></a>9.1 用户级线程 vs 内核级线程</h3><ul>
<li><strong>用户级线程（Green Threads）</strong>：由用户库管理（如早期 Java），内核 unaware，切换快但无法利用多核。</li>
<li><strong>内核级线程</strong>：由操作系统调度，可并行执行（现代系统主流）。</li>
<li><strong>混合模型（M:N）</strong>：M 个用户线程映射到 N 个内核线程（如 Go 的 Goroutine + GMP 调度器）。</li>
</ul>
<h3 id="9-2-协程（Coroutine）"><a href="#9-2-协程（Coroutine）" class="headerlink" title="9.2 协程（Coroutine）"></a>9.2 协程（Coroutine）</h3><ul>
<li>比线程更轻量，用户态调度，无抢占。</li>
<li>如 Python 的 <code>async/await</code>、Go 的 <code>goroutine</code>、Rust 的 <code>async</code>。</li>
<li>适合高并发 I&#x2F;O，但不适合 CPU 密集型。</li>
</ul>
<h3 id="9-3-线程安全与可重入"><a href="#9-3-线程安全与可重入" class="headerlink" title="9.3 线程安全与可重入"></a>9.3 线程安全与可重入</h3><ul>
<li><strong>线程安全函数</strong>：可被多个线程同时调用而不产生错误。</li>
<li><strong>可重入函数</strong>：不仅线程安全，还能在信号处理函数中安全调用（不使用静态&#x2F;全局变量）。</li>
</ul>
<hr>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>资源分配单位</td>
<td>CPU 调度单位</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>强（独立地址空间）</td>
<td>弱（共享地址空间）</td>
</tr>
<tr>
<td><strong>创建开销</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>通信效率</strong></td>
<td>低（需 IPC）</td>
<td>高（共享内存）</td>
</tr>
<tr>
<td><strong>健壮性</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>安全隔离、独立任务</td>
<td>高并发、资源共享</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>黄金法则</strong>：</p>
<ul>
<li>需要<strong>隔离与安全</strong> → 用<strong>进程</strong></li>
<li>需要<strong>性能与共享</strong> → 用<strong>线程</strong></li>
<li>需要<strong>超高并发</strong> → 考虑<strong>协程 + 事件循环</strong></li>
</ul>
</blockquote>
<hr>
<p>如果你对某个部分（如 Linux 的 <code>clone()</code> 实现、死锁检测算法、Go 的调度器等）感兴趣，我可以进一步深入讲解！</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>2移除元素</title>
    <url>/2025/11/13/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/2%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<p>个人思路：</p>
<p>单纯从解题的角度来看，可以直接遍历数组并将题目所给val全部替换成该题目所限制值的最大值50，然后使用sort函数进行排序，50由于是最大值必然在数组结尾。此外每进行一次替换则将数组的长度size-1，最终剩下的就是数组中值不等于val的元素的个数亦即数组的前k个元素。实测可以AC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int a = nums.size();</span><br><span class="line">        int count = a;</span><br><span class="line">        for(int i = 0; i &lt; a; i++)&#123;</span><br><span class="line">            if(nums[i] == val)&#123;</span><br><span class="line">                nums[i] = 50;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法一：双指针<br>思路及算法</p>
<p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        for (int right = 0; right &lt; n; right++) &#123;</span><br><span class="line">            if (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为序列的长度。我们只需要遍历该序列至多两次。</li>
<li>空间复杂度：<em>O</em>(1)。我们只需要常数的空间保存若干变量。</li>
</ul>
<p>方法二：双指针优化<br>思路</p>
<p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p>
<p>算法</p>
<p>如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int left = 0, right = nums.size();</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - 1];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟文件系统VFS</title>
    <url>/2025/09/26/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FVFS/</url>
    <content><![CDATA[<p>我们从零基础开始，一步一步来理解 <strong>虚拟文件系统（VFS，Virtual File System）</strong>。</p>
<hr>
<h2 id="一、什么是文件系统？"><a href="#一、什么是文件系统？" class="headerlink" title="一、什么是文件系统？"></a>一、什么是文件系统？</h2><p>在讲 VFS 之前，先搞清楚 <strong>文件系统（File System）</strong> 是什么。</p>
<ul>
<li><strong>文件系统</strong> 是操作系统用来组织、存储和管理磁盘（或其他存储设备）上文件的一种机制。</li>
<li>不同的操作系统、不同的存储设备，可能使用不同的文件系统。例如：<ul>
<li>Windows 常用：NTFS、FAT32</li>
<li>Linux 常用：ext4、XFS、Btrfs</li>
<li>macOS 常用：APFS、HFS+</li>
</ul>
</li>
</ul>
<p>每种文件系统都有自己的规则：怎么存文件名、怎么记录文件大小、怎么分配磁盘空间等等。</p>
<hr>
<h2 id="二、问题来了：操作系统怎么同时支持这么多文件系统？"><a href="#二、问题来了：操作系统怎么同时支持这么多文件系统？" class="headerlink" title="二、问题来了：操作系统怎么同时支持这么多文件系统？"></a>二、问题来了：操作系统怎么同时支持这么多文件系统？</h2><p>假设你用的是 Linux，你可能同时挂载了：</p>
<ul>
<li>一个 ext4 格式的硬盘（Linux 原生）</li>
<li>一个 FAT32 的 U 盘（来自 Windows）</li>
<li>一个 NTFS 的移动硬盘</li>
<li>甚至一个网络文件系统（比如 NFS）</li>
</ul>
<p>如果每个程序都要知道“这个文件在 ext4 上怎么读，那个在 FAT32 上怎么写”，那太麻烦了！</p>
<p><strong>于是，操作系统引入了一个“中间层”——这就是虚拟文件系统（VFS）。</strong></p>
<hr>
<h2 id="三、VFS-是什么？——核心思想"><a href="#三、VFS-是什么？——核心思想" class="headerlink" title="三、VFS 是什么？——核心思想"></a>三、VFS 是什么？——核心思想</h2><blockquote>
<p><strong>VFS 是一个抽象层，它为上层应用程序和内核提供统一的文件操作接口，屏蔽底层不同文件系统的差异。</strong></p>
</blockquote>
<p>你可以把它想象成一个“翻译官”或“通用插座”：</p>
<ul>
<li>应用程序说：“我要打开 &#x2F;home&#x2F;user&#x2F;file.txt”</li>
<li>VFS 说：“好的，我来处理。这个路径在哪个文件系统上？哦，在 ext4 分区上。”</li>
<li>然后 VFS 调用 ext4 文件系统的具体实现去真正打开文件。</li>
<li>如果路径是在 U 盘上（FAT32），VFS 就调用 FAT32 的实现。</li>
</ul>
<p><strong>对应用程序来说，完全感觉不到底层差异！</strong> 它只需要用统一的系统调用（如 <code>open()</code>, <code>read()</code>, <code>write()</code>）就行。</p>
<hr>
<h2 id="四、VFS-的关键组成部分（简化版）"><a href="#四、VFS-的关键组成部分（简化版）" class="headerlink" title="四、VFS 的关键组成部分（简化版）"></a>四、VFS 的关键组成部分（简化版）</h2><p>VFS 通过几个核心的“抽象对象”来统一管理不同文件系统：</p>
<h3 id="1-超级块（Superblock）"><a href="#1-超级块（Superblock）" class="headerlink" title="1. 超级块（Superblock）"></a>1. <strong>超级块（Superblock）</strong></h3><ul>
<li>描述一个<strong>已挂载的文件系统</strong>的整体信息。</li>
<li>比如：文件系统类型（ext4？FAT32？）、总大小、可用空间、挂载点等。</li>
<li>每个挂载的文件系统在 VFS 中都有一个对应的超级块。</li>
</ul>
<h3 id="2-索引节点（Inode）"><a href="#2-索引节点（Inode）" class="headerlink" title="2. 索引节点（Inode）"></a>2. <strong>索引节点（Inode）</strong></h3><ul>
<li>描述一个<strong>文件或目录的元数据</strong>（不是文件名！）。</li>
<li>包括：文件大小、权限、所有者、时间戳、数据块位置等。</li>
<li>注意：文件名并不存在 inode 里，而是存在目录项中。</li>
</ul>
<h3 id="3-目录项（Dentry，Directory-Entry）"><a href="#3-目录项（Dentry，Directory-Entry）" class="headerlink" title="3. 目录项（Dentry，Directory Entry）"></a>3. <strong>目录项（Dentry，Directory Entry）</strong></h3><ul>
<li>表示<strong>路径中的一个组件</strong>，比如 <code>/home/user/file.txt</code> 中的 <code>home</code>、<code>user</code>、<code>file.txt</code>。</li>
<li>Dentry 把<strong>文件名</strong>和对应的 <strong>inode</strong> 关联起来。</li>
<li>VFS 会缓存 dentry，加速路径查找（比如你反复访问同一个文件）。</li>
</ul>
<h3 id="4-文件对象（File）"><a href="#4-文件对象（File）" class="headerlink" title="4. 文件对象（File）"></a>4. <strong>文件对象（File）</strong></h3><ul>
<li>表示一个<strong>打开的文件实例</strong>。</li>
<li>包含：当前读写位置（文件偏移）、访问模式（只读&#x2F;读写）、指向 inode 的指针等。</li>
<li>每次你 <code>open()</code> 一个文件，内核就创建一个 file 对象。</li>
</ul>
<hr>
<h2 id="五、举个例子：打开一个文件的过程"><a href="#五、举个例子：打开一个文件的过程" class="headerlink" title="五、举个例子：打开一个文件的过程"></a>五、举个例子：打开一个文件的过程</h2><p>假设你在 Linux 中执行：</p>
<pre style="background: none"><code class="language-bash" data-language="bash" identifier="0af040d060d54a0cb45c0185e45d26fe-0" index="0" total="1">cat /mnt/usb/data.txt</code></pre>

<p>而 <code>/mnt/usb</code> 是一个 FAT32 格式的 U 盘。</p>
<p>VFS 的工作流程如下：</p>
<ol>
<li><strong>解析路径</strong>：VFS 从根目录开始，逐级查找 <code>/mnt</code> → <code>/mnt/usb</code> → <code>/mnt/usb/data.txt</code>。</li>
<li><strong>查找 dentry</strong>：每一步都查找或创建 dentry，最终找到 <code>data.txt</code> 对应的 dentry。</li>
<li><strong>获取 inode</strong>：通过 dentry 找到该文件的 inode（FAT32 文件系统会提供自己的 inode 表示）。</li>
<li><strong>创建 file 对象</strong>：调用 <code>open()</code> 系统调用，VFS 创建一个 file 对象。</li>
<li><strong>调用具体文件系统的操作</strong>：VFS 知道这个 inode 属于 FAT32 文件系统，于是调用 FAT32 的 <code>read</code> 函数来真正读取数据。</li>
<li><strong>返回数据给用户程序</strong>：<code>cat</code> 命令拿到数据并显示。</li>
</ol>
<p>整个过程，<code>cat</code> 完全不知道底层是 FAT32 还是 ext4！</p>
<hr>
<h2 id="六、为什么叫“虚拟”文件系统？"><a href="#六、为什么叫“虚拟”文件系统？" class="headerlink" title="六、为什么叫“虚拟”文件系统？"></a>六、为什么叫“虚拟”文件系统？</h2><ul>
<li>因为 VFS 本身<strong>不存储任何真实数据</strong>，也不直接管理磁盘。</li>
<li>它只是一个<strong>抽象框架</strong>，定义了“所有文件系统都应该实现哪些操作”。</li>
<li>真正干活的是具体的文件系统（ext4、FAT32 等），它们向 VFS “注册”自己的一套操作函数（比如 <code>.open</code>, <code>.read</code>, <code>.write</code>）。</li>
</ul>
<p>这就像“接口”和“实现类”的关系（如果你学过面向对象编程）。</p>
<hr>
<h2 id="七、VFS-支持的不仅仅是磁盘文件系统！"><a href="#七、VFS-支持的不仅仅是磁盘文件系统！" class="headerlink" title="七、VFS 支持的不仅仅是磁盘文件系统！"></a>七、VFS 支持的不仅仅是磁盘文件系统！</h2><p>VFS 的设计非常通用，所以 Linux 中很多“看起来像文件”的东西也通过 VFS 实现：</p>
<ul>
<li><strong>proc 文件系统（&#x2F;proc）</strong>：展示进程信息（如 <code>/proc/1234/status</code>）</li>
<li><strong>sysfs（&#x2F;sys）</strong>：展示内核和设备信息</li>
<li><strong>tmpfs</strong>：基于内存的临时文件系统</li>
<li><strong>pipe、socket</strong>：某些情况下也被抽象为文件</li>
</ul>
<p>这些都不是传统意义上的“磁盘文件”，但通过 VFS，你可以用 <code>read()</code>&#x2F;<code>write()</code> 像操作普通文件一样操作它们！</p>
<hr>
<h2 id="八、总结：VFS-的作用"><a href="#八、总结：VFS-的作用" class="headerlink" title="八、总结：VFS 的作用"></a>八、总结：VFS 的作用</h2><table>
<thead>
<tr>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一接口</strong></td>
<td>应用程序无需关心底层文件系统类型</td>
</tr>
<tr>
<td><strong>抽象隔离</strong></td>
<td>将通用操作与具体实现分离</td>
</tr>
<tr>
<td><strong>提高兼容性</strong></td>
<td>轻松支持多种文件系统共存</td>
</tr>
<tr>
<td><strong>提升性能</strong></td>
<td>通过 dentry&#x2F;inode 缓存加速路径查找</td>
</tr>
<tr>
<td><strong>扩展性强</strong></td>
<td>新文件系统只需实现 VFS 规定的接口即可接入</td>
</tr>
</tbody></table>
<hr>
<h2 id="九、类比帮助理解"><a href="#九、类比帮助理解" class="headerlink" title="九、类比帮助理解"></a>九、类比帮助理解</h2><p>想象你去不同国家旅行：</p>
<ul>
<li>在中国吃饭用筷子</li>
<li>在美国吃饭用刀叉</li>
<li>在印度可能用手</li>
</ul>
<p>但如果你有一个“万能餐具适配器”（VFS），你只需要说“我要吃饭”，它自动给你配上当地正确的餐具。</p>
<p>你（应用程序）不用学每种餐具怎么用，适配器（VFS）帮你搞定！</p>
<hr>
<p>如果你是初学者，现在只需要记住：</p>
<blockquote>
<p><strong>VFS 是 Linux 内核中一个“通用文件操作层”，让所有程序都能用同样的方式访问各种不同的文件系统。</strong></p>
</blockquote>
<p>等你以后学操作系统、Linux 内核或做系统编程时，会更深入理解它的实现细节。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>VFS</tag>
      </tags>
  </entry>
  <entry>
    <title>3删除有序数组中的重复项</title>
    <url>/2025/11/14/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/3%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></p>
<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 <code>k</code>。</p>
<p><code>nums</code> 的前 <code>k</code> 个元素应包含 <strong>排序后</strong> 的唯一数字。下标 <code>k - 1</code> 之后的剩余元素可以忽略。</p>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
<li><code>nums</code> 已按 <strong>非递减</strong> 顺序排列。</li>
</ul>
<p>使用双指针法中的快慢指针法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count = nums.size();</span><br><span class="line">        int slow = 0,fast = 0;</span><br><span class="line">        if(count == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast != count)&#123;</span><br><span class="line">            if(nums[slow] != nums[fast])&#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始使用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int slow = 0,int fast = 0;</span><br></pre></td></tr></table></figure>

<p>显示编译错误，错误原因：重复写了类型名 <code>int</code></p>
<p>在 C&#x2F;C++ 中，<strong>在同一行声明多个同类型变量时，类型名只写一次</strong>，后面用逗号分隔变量名即可。</p>
<p>如下为官方题解：</p>
<p>这道题目的要求是：对给定的有序数组 nums 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过原地修改数组的方法，使用 O(1) 的空间复杂度完成。</p>
<p>由于给定的数组 nums 是有序的，因此对于任意 i&lt;j，如果 nums[i]&#x3D;nums[j]，则对任意 i≤k≤j，必有 nums[i]&#x3D;nums[k]&#x3D;nums[j]，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。</p>
<p>如果数组 nums 的长度为 0，则数组不包含任何元素，因此返回 0。</p>
<p>当数组 nums 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0] 保持原状即可，从下标 1 开始删除重复元素。</p>
<p>定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p>
<p>假设数组 nums 的长度为 n。将快指针 fast 依次遍历从 1 到 n−1 的每个位置，对于每个位置，如果 nums[fast]！&#x3D;nums[fast−1]，说明 nums[fast] 和之前的元素都不同，因此将 nums[fast] 的值复制到 nums[slow]，然后将 slow 的值加 1，即指向下一个位置。</p>
<p>遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 slow，返回 slow 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int fast = 1, slow = 1;</span><br><span class="line">        while (fast &lt; n) &#123;</span><br><span class="line">            if (nums[fast] != nums[fast - 1]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>4删除有序数组中的重复项II</title>
    <url>/2025/11/14/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/4%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></p>
<p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明：</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按升序排列</li>
</ul>
<h4 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h4><p>在阅读本题前，读者们可以先尝试解决「<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">26. 删除有序数组中的重复项</a>」。</p>
<p>因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 <em>slow</em> 和 <em>fast</em> 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 <em>nums</em>[<em>fast</em>] 表示待检查的第一个元素，<em>nums</em>[<em>slow</em>−1] 为上一个应该被保留的元素所移动到的指定位置。</p>
<p>因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 <em>nums</em>[<em>slow</em>−2] 是否和当前待检查元素 <em>nums</em>[<em>fast</em>] 相同。当且仅当 <em>nums</em>[<em>slow</em>−2]&#x3D;<em>nums</em>[<em>fast</em>] 时，当前待检查元素 <em>nums</em>[<em>fast</em>] 不应该被保留（因为此时必然有 <em>nums</em>[<em>slow</em>−2]&#x3D;<em>n<strong>u</strong>m**s</em>[<em>slow</em>−1]&#x3D;<em>nums</em>[<em>fast</em>]）。最后，<em>slow</em> 即为处理好的数组的长度。</p>
<p>特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt;= 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int slow = 2, fast = 2;</span><br><span class="line">        while (fast &lt; n) &#123;</span><br><span class="line">            if (nums[slow - 2] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1合并两个有序数组</title>
    <url>/2025/11/13/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/1%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></p>
<p>题目：<br>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
</ul>
<p>思考：</p>
<p>初步思考使用for循环进行遍历（没办法太菜了），遍历nums2中的每一个元素并与nums1进行比较，比较之后放在合适的位置。需要注意的点是每遍历一次，nums1中需要遍历的元素数量就+1。</p>
<p>实际写的时候发现好像不行，因为使用双层for循环确实可以比较出大小，但是比较出第一个数据的大小之后不能简单地插入到数组1去，还要对插入位置后面的值进行移动。</p>
<p>最终使用三层for循环，但是最后的数组如何返回呢，编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; m + i; ++j)&#123;</span><br><span class="line">                if(nums2[i] &lt; nums1[j])&#123;</span><br><span class="line">                    for(int k = m + n -1; k &gt; j; k--)&#123;</span><br><span class="line">                        nums1[k] = nums1[k-1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums1[j] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到void类型函数无需返回只需要完成数组的合并即可。删除 return nums1;只过了很少的测试用例。</p>
<p>询问AI之后才意识到：上述代码要在nums1中找到一个比nums2[i]大的元素然后进行插入，但是找不到的时候会丢弃，应当追加在末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; m + i; ++j)&#123;</span><br><span class="line">                if(nums2[i] &lt; nums1[j])&#123;</span><br><span class="line">                    for(int k = m + n -1; k &gt; j; k--)&#123;</span><br><span class="line">                        nums1[k] = nums1[k-1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums1[j] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    nums1[m + j] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码仍然不行，因为当if不满足的时候else会重复插入，最终导致重复插入甚至数组越界。</p>
<p>求助AI，如果非要使用插入法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        // 找到 nums2[i] 应该插入的位置</span><br><span class="line">        int pos = m + i; // 默认插到最后（如果比所有都大）</span><br><span class="line">        for (int j = 0; j &lt; m + i; ++j) &#123;</span><br><span class="line">            if (nums2[i] &lt; nums1[j]) &#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 从后往前移动元素，腾出 pos 位置</span><br><span class="line">        for (int k = m + i; k &gt; pos; --k) &#123;</span><br><span class="line">            nums1[k] = nums1[k - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        nums1[pos] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述插入法还是不好理解，不够简单直观高效。</p>
<p>下面记录力扣高级题解示例</p>
<p>一、直接合并后排序</p>
<p>最直观的方法是先将数组 <em>nums</em>2 放进数组 <em>nums</em>1 的尾部，然后直接对整个数组进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        for (int i = 0; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)log(m+n))。<br>排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)log(m+n))。</p>
<p>空间复杂度：O(log(m+n))。<br>排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(log(m+n))。</p>
<p>此处好奇在力扣刷算法题和面试的时候环境一样吗，哪些函数是可以直接使用的呢？</p>
<p>在 LeetCode（力扣）的 C++ 环境中，<strong>你可以自由使用 C++ 标准库（STL）中的绝大多数函数和容器</strong>，因为其后台编译环境（通常是 GCC 9+ 或更高版本，支持 C++17 或 C++20）完整支持标准库，并且会自动包含常用头文件（即使你没写 <code>#include</code>）。</p>
<hr>
<h2 id="✅-一、可以使用的-STL-容器（常用）"><a href="#✅-一、可以使用的-STL-容器（常用）" class="headerlink" title="✅ 一、可以使用的 STL 容器（常用）"></a>✅ 一、可以使用的 STL 容器（常用）</h2><table>
<thead>
<tr>
<th>容器</th>
<th>头文件（通常可省略）</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>vector</code></td>
<td><code>&lt;vector&gt;</code></td>
<td><code>vector&lt;int&gt; v;</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>&lt;string&gt;</code></td>
<td><code>string s = &quot;hello&quot;;</code></td>
</tr>
<tr>
<td><code>deque</code></td>
<td><code>&lt;deque&gt;</code></td>
<td>双端队列</td>
</tr>
<tr>
<td><code>list</code></td>
<td><code>&lt;list&gt;</code></td>
<td>双向链表</td>
</tr>
<tr>
<td><code>queue</code> &#x2F; <code>priority_queue</code></td>
<td><code>&lt;queue&gt;</code></td>
<td>队列、优先队列（堆）</td>
</tr>
<tr>
<td><code>stack</code></td>
<td><code>&lt;stack&gt;</code></td>
<td>栈</td>
</tr>
<tr>
<td><code>set</code> &#x2F; <code>multiset</code></td>
<td><code>&lt;set&gt;</code></td>
<td>有序集合</td>
</tr>
<tr>
<td><code>unordered_set</code></td>
<td><code>&lt;unordered_set&gt;</code></td>
<td>哈希集合</td>
</tr>
<tr>
<td><code>map</code> &#x2F; <code>multimap</code></td>
<td><code>&lt;map&gt;</code></td>
<td>有序映射</td>
</tr>
<tr>
<td><code>unordered_map</code></td>
<td><code>&lt;unordered_map&gt;</code></td>
<td>哈希映射</td>
</tr>
<tr>
<td><code>pair</code> &#x2F; <code>tuple</code></td>
<td><code>&lt;utility&gt;</code>, <code>&lt;tuple&gt;</code></td>
<td><code>make_pair</code>, <code>get&lt;0&gt;(t)</code></td>
</tr>
<tr>
<td><code>array</code> (C++11)</td>
<td><code>&lt;array&gt;</code></td>
<td><code>array&lt;int,5&gt; arr;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>注意</strong>：虽然 LeetCode 通常不需要手动写 <code>#include</code>，但为了代码可读性和本地调试兼容性，<strong>建议显式包含必要头文件</strong>（尤其在复杂题目中）。</p>
</blockquote>
<hr>
<h2 id="✅-二、可以使用的常用算法函数（来自-）"><a href="#✅-二、可以使用的常用算法函数（来自-）" class="headerlink" title="✅ 二、可以使用的常用算法函数（来自 &lt;algorithm&gt;）"></a>✅ 二、可以使用的常用算法函数（来自 <code>&lt;algorithm&gt;</code>）</h2><p>LeetCode 支持几乎所有 <code>&lt;algorithm&gt;</code> 中的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>sort(first, last)</code></td>
<td>排序（快排&#x2F;混合排序）</td>
</tr>
<tr>
<td><code>stable_sort</code></td>
<td>稳定排序</td>
</tr>
<tr>
<td><code>partial_sort</code></td>
<td>部分排序</td>
</tr>
<tr>
<td><code>nth_element</code></td>
<td>快速选择第 k 小元素</td>
</tr>
<tr>
<td><code>lower_bound</code>, <code>upper_bound</code></td>
<td>二分查找边界</td>
</tr>
<tr>
<td><code>binary_search</code></td>
<td>二分查找是否存在</td>
</tr>
<tr>
<td><code>reverse</code></td>
<td>翻转区间</td>
</tr>
<tr>
<td><code>rotate</code></td>
<td>旋转数组</td>
</tr>
<tr>
<td><code>next_permutation</code>, <code>prev_permutation</code></td>
<td>全排列生成</td>
</tr>
<tr>
<td><code>min</code>, <code>max</code>, <code>min_element</code>, <code>max_element</code></td>
<td>最值相关</td>
</tr>
<tr>
<td><code>find</code>, <code>find_if</code></td>
<td>查找元素</td>
</tr>
<tr>
<td><code>count</code>, <code>count_if</code></td>
<td>计数</td>
</tr>
<tr>
<td><code>unique</code> + <code>erase</code></td>
<td>去重（需先排序）</td>
</tr>
<tr>
<td><code>merge</code></td>
<td>合并两个有序区间</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>交换（也属于 <code>&lt;utility&gt;</code>）</td>
</tr>
<tr>
<td><code>fill</code>, <code>fill_n</code></td>
<td>填充</td>
</tr>
<tr>
<td><code>copy</code>, <code>move</code></td>
<td>拷贝&#x2F;移动元素</td>
</tr>
</tbody></table>
<p>✅ 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">count</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), val);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-三、其他可用的标准库功能"><a href="#✅-三、其他可用的标准库功能" class="headerlink" title="✅ 三、其他可用的标准库功能"></a>✅ 三、其他可用的标准库功能</h2><h3 id="1-数值计算"><a href="#1-数值计算" class="headerlink" title="1. 数值计算"></a>1. <strong>数值计算</strong></h3><ul>
<li><code>&lt;numeric&gt;</code>：<code>accumulate</code>, <code>iota</code>, <code>gcd</code>（C++17）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 填充 1,2,3...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-智能指针（较少用，但支持）"><a href="#2-智能指针（较少用，但支持）" class="headerlink" title="2. 智能指针（较少用，但支持）"></a>2. <strong>智能指针（较少用，但支持）</strong></h3><ul>
<li><code>&lt;memory&gt;</code>：<code>unique_ptr</code>, <code>shared_ptr</code><blockquote>
<p>一般算法题不需要，但语法上可用。</p>
</blockquote>
</li>
</ul>
<h3 id="3-数学函数"><a href="#3-数学函数" class="headerlink" title="3. 数学函数"></a>3. <strong>数学函数</strong></h3><ul>
<li><code>&lt;cmath&gt;</code>：<code>sqrt</code>, <code>pow</code>, <code>abs</code>, <code>log</code>, <code>sin</code> 等<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="built_in">sqrt</span>(<span class="number">16</span>);</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">abs</span>(<span class="number">-5</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-输入输出（调试用）"><a href="#4-输入输出（调试用）" class="headerlink" title="4. 输入输出（调试用）"></a>4. <strong>输入输出（调试用）</strong></h3><ul>
<li>虽然不能 <code>cout</code> 提交，但<strong>在“调试”或“运行代码”时可以用</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;debug: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提交时不会影响判题（输出被忽略），但正式代码建议删除。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="⚠️-四、注意事项"><a href="#⚠️-四、注意事项" class="headerlink" title="⚠️ 四、注意事项"></a>⚠️ 四、注意事项</h2><h3 id="1-不要依赖非标准头文件"><a href="#1-不要依赖非标准头文件" class="headerlink" title="1. 不要依赖非标准头文件"></a>1. <strong>不要依赖非标准头文件</strong></h3><ul>
<li>❌ 不要写：<code>#include &lt;bits/stdc++.h&gt;</code><br>虽然 LeetCode 支持，但这是 GCC 特有，<strong>不跨平台</strong>，面试或工程中应避免。</li>
<li>✅ 正确做法：按需包含标准头文件（如 <code>&lt;vector&gt;</code>, <code>&lt;algorithm&gt;</code>）。</li>
</ul>
<h3 id="2-C-版本"><a href="#2-C-版本" class="headerlink" title="2. C++ 版本"></a>2. <strong>C++ 版本</strong></h3><ul>
<li>LeetCode 默认使用 <strong>C++17</strong>（部分支持 C++20），所以以下特性可用：<ul>
<li>结构化绑定：<code>auto [x, y] = pair;</code></li>
<li><code>std::optional</code>, <code>std::variant</code>（C++17）</li>
<li><code>string_view</code>（C++17）</li>
<li><code>gcd</code>, <code>lcm</code>（C++17）</li>
</ul>
</li>
</ul>
<h3 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3. 性能问题"></a>3. <strong>性能问题</strong></h3><ul>
<li>虽然能用 <code>sort</code>，但某些题要求 <strong>O(n)</strong> 时间，此时用 <code>sort</code>（O(n log n)）可能 <strong>超时</strong>。</li>
<li>例如：[217. 存在重复元素] 用 <code>unordered_set</code> 是 O(n)，用 <code>sort</code> 是 O(n log n)，大数据可能慢。</li>
</ul>
<hr>
<h2 id="✅-五、总结：LeetCode-中-C-的“自由度”"><a href="#✅-五、总结：LeetCode-中-C-的“自由度”" class="headerlink" title="✅ 五、总结：LeetCode 中 C++ 的“自由度”"></a>✅ 五、总结：LeetCode 中 C++ 的“自由度”</h2><table>
<thead>
<tr>
<th>类别</th>
<th>是否可用</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>所有标准 STL 容器</td>
<td>✅ 是</td>
<td>按需使用</td>
</tr>
<tr>
<td><code>&lt;algorithm&gt;</code> 算法</td>
<td>✅ 是</td>
<td>强烈推荐</td>
</tr>
<tr>
<td>数学&#x2F;数值函数</td>
<td>✅ 是</td>
<td>注意精度问题</td>
</tr>
<tr>
<td>智能指针&#x2F;高级特性</td>
<td>✅ 是</td>
<td>算法题很少需要</td>
</tr>
<tr>
<td>非标准头文件（如 <code>bits/stdc++.h</code>）</td>
<td>⚠️ 能用但不推荐</td>
<td>避免</td>
</tr>
<tr>
<td>自定义 <code>#include</code></td>
<td>✅ 可写可不写</td>
<td>建议写，提高可读性</td>
</tr>
</tbody></table>
<hr>
<h3 id="🎯-最佳实践建议："><a href="#🎯-最佳实践建议：" class="headerlink" title="🎯 最佳实践建议："></a>🎯 最佳实践建议：</h3><ol>
<li><strong>刷题阶段</strong>：大胆使用 STL，提升编码速度。</li>
<li><strong>学习阶段</strong>：尝试不用库函数手写（如手写快排、堆），理解原理。</li>
<li><strong>面试准备</strong>：知道什么时候该用（如哈希表查重），什么时候不该用（如要求原地归并）。</li>
</ol>
<p>如果你有具体题目不确定能否用某个函数，欢迎告诉我，我可以帮你判断！</p>
<p>sort函数：</p>
<p>当然可以！<code>std::sort</code> 是 C++ 标准库 <code>&lt;algorithm&gt;</code> 中最常用、最高效的排序函数之一。下面从<strong>基本用法、原理、自定义排序、注意事项</strong>等方面详细讲解。</p>
<hr>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 [first, last) 区间进行排序（左闭右开）</span></span><br><span class="line"><span class="built_in">sort</span>(first_iterator, last_iterator);</span><br></pre></td></tr></table></figure>

<h3 id="✅-示例：对-vector-排序"><a href="#✅-示例：对-vector-排序" class="headerlink" title="✅ 示例：对 vector 排序"></a>✅ 示例：对 vector 排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="comment">// 结果: &#123;1, 1, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="✅-对普通数组排序"><a href="#✅-对普通数组排序" class="headerlink" title="✅ 对普通数组排序"></a>✅ 对普通数组排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">sort</span>(arr, arr + n); <span class="comment">// arr 是首地址，arr+n 是尾后地址</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、默认排序规则"><a href="#二、默认排序规则" class="headerlink" title="二、默认排序规则"></a>二、默认排序规则</h2><ul>
<li><strong>对基本类型（int, double, char 等）</strong>：默认<strong>升序</strong>（从小到大）。</li>
<li><strong>对 string</strong>：按字典序升序。</li>
<li><strong>对 pair &#x2F; tuple</strong>：先比较第一个元素，再比较第二个，依此类推。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; words = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 结果: &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、自定义排序（重点！）"><a href="#三、自定义排序（重点！）" class="headerlink" title="三、自定义排序（重点！）"></a>三、自定义排序（重点！）</h2><p>通过传入<strong>比较函数（comparator）</strong>，可以实现任意排序逻辑。</p>
<h3 id="方法-1：使用-Lambda-表达式（推荐，C-11-）"><a href="#方法-1：使用-Lambda-表达式（推荐，C-11-）" class="headerlink" title="方法 1：使用 Lambda 表达式（推荐，C++11+）"></a>方法 1：使用 Lambda 表达式（推荐，C++11+）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 注意：返回 true 表示 a 应该排在 b 前面</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按绝对值排序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="方法-2：定义函数对象（functor）"><a href="#方法-2：定义函数对象（functor）" class="headerlink" title="方法 2：定义函数对象（functor）"></a>方法 2：定义函数对象（functor）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyComparator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">MyComparator</span>());</span><br></pre></td></tr></table></figure>

<h3 id="方法-3：普通函数指针（较少用）"><a href="#方法-3：普通函数指针（较少用）" class="headerlink" title="方法 3：普通函数指针（较少用）"></a>方法 3：普通函数指针（较少用）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、常见自定义排序场景"><a href="#四、常见自定义排序场景" class="headerlink" title="四、常见自定义排序场景"></a>四、常见自定义排序场景</h2><h3 id="1-按结构体-类成员排序"><a href="#1-按结构体-类成员排序" class="headerlink" title="1. 按结构体&#x2F;类成员排序"></a>1. 按结构体&#x2F;类成员排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Student&gt; students = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">85</span>&#125;, &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">90</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按分数降序，分数相同按名字升序</span></span><br><span class="line"><span class="built_in">sort</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), [](<span class="type">const</span> Student&amp; a, <span class="type">const</span> Student&amp; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score)</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;      <span class="comment">// 分数高的在前</span></span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;            <span class="comment">// 名字字典序小的在前</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义字符串排序（如“字典序最大拼接”）"><a href="#2-自定义字符串排序（如“字典序最大拼接”）" class="headerlink" title="2. 自定义字符串排序（如“字典序最大拼接”）"></a>2. 自定义字符串排序（如“字典序最大拼接”）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; nums = &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;34&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;9&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b &gt; b + a; <span class="comment">// &quot;3&quot;+&quot;30&quot;=&quot;330&quot; &gt; &quot;30&quot;+&quot;3&quot;=&quot;303&quot; → &quot;3&quot;排前面</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果可拼接成最大数：&quot;9534330&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、底层原理（了解即可）"><a href="#五、底层原理（了解即可）" class="headerlink" title="五、底层原理（了解即可）"></a>五、底层原理（了解即可）</h2><ul>
<li><code>std::sort</code> 通常采用 <strong>内省排序（Introsort）</strong>：<ul>
<li>结合了 <strong>快速排序（QuickSort）</strong>、<strong>堆排序（HeapSort）</strong> 和 <strong>插入排序（Insertion Sort）</strong></li>
<li>平均时间复杂度：<strong>O(n log n)</strong></li>
<li>最坏时间复杂度：<strong>O(n log n)</strong>（通过堆排序避免快排最坏 O(n²)）</li>
<li><strong>不稳定排序</strong>（相等元素的相对位置可能改变）<ul>
<li>如果需要稳定排序，用 <code>std::stable_sort</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 注意：<code>std::sort</code> 要求比较函数满足 <strong>严格弱序（strict weak ordering）</strong>，否则行为未定义！</p>
</blockquote>
<hr>
<h2 id="六、重要注意事项-⚠️"><a href="#六、重要注意事项-⚠️" class="headerlink" title="六、重要注意事项 ⚠️"></a>六、重要注意事项 ⚠️</h2><h3 id="1-比较函数必须满足：不能有相等时返回-true"><a href="#1-比较函数必须满足：不能有相等时返回-true" class="headerlink" title="1. 比较函数必须满足：不能有相等时返回 true"></a>1. 比较函数必须满足：<strong>不能有相等时返回 true</strong></h3><p>❌ 错误写法（会导致崩溃或错误）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误！当 a == b 时返回 true，违反严格弱序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt;= b; &#125;);</span><br></pre></td></tr></table></figure>
<p>✅ 正确写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> a &gt; b; <span class="comment">// 仅当 a 严格大于 b 时返回 true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-迭代器范围是-begin-end"><a href="#2-迭代器范围是-begin-end" class="headerlink" title="2. 迭代器范围是 [begin, end)"></a>2. 迭代器范围是 <strong>[begin, end)</strong></h3><ul>
<li><code>end()</code> 是<strong>尾后迭代器</strong>，不包含在排序范围内。</li>
</ul>
<h3 id="3-不支持对-list-直接使用-std-sort"><a href="#3-不支持对-list-直接使用-std-sort" class="headerlink" title="3. 不支持对 list 直接使用 std::sort"></a>3. 不支持对 <code>list</code> 直接使用 <code>std::sort</code></h3><ul>
<li><code>list</code> 有自己的成员函数：<code>myList.sort(comparator);</code></li>
</ul>
<hr>
<h2 id="七、与其他排序函数对比"><a href="#七、与其他排序函数对比" class="headerlink" title="七、与其他排序函数对比"></a>七、与其他排序函数对比</h2><table>
<thead>
<tr>
<th>函数</th>
<th>时间复杂度</th>
<th>稳定性</th>
<th>适用容器</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::sort</code></td>
<td>O(n log n)</td>
<td>❌ 不稳定</td>
<td>随机访问迭代器（vector, array, deque）</td>
</tr>
<tr>
<td><code>std::stable_sort</code></td>
<td>O(n log n) 或 O(n log²n)</td>
<td>✅ 稳定</td>
<td>同上</td>
</tr>
<tr>
<td><code>std::partial_sort</code></td>
<td>O(n log k)</td>
<td>❌</td>
<td>只需前 k 个有序</td>
</tr>
<tr>
<td><code>list::sort</code></td>
<td>O(n log n)</td>
<td>✅</td>
<td><code>std::list</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="八、LeetCode-实战技巧"><a href="#八、LeetCode-实战技巧" class="headerlink" title="八、LeetCode 实战技巧"></a>八、LeetCode 实战技巧</h2><h3 id="技巧-1：快速去重（需先排序）"><a href="#技巧-1：快速去重（需先排序）" class="headerlink" title="技巧 1：快速去重（需先排序）"></a>技巧 1：快速去重（需先排序）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="技巧-2：二维数组按行-列排序"><a href="#技巧-2：二维数组按行-列排序" class="headerlink" title="技巧 2：二维数组按行&#x2F;列排序"></a>技巧 2：二维数组按行&#x2F;列排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid = &#123;&#123;<span class="number">3</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">4</span>&#125;, &#123;<span class="number">2</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 按第一列升序</span></span><br><span class="line"><span class="built_in">sort</span>(grid.<span class="built_in">begin</span>(), grid.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td><code>&lt;algorithm&gt;</code></td>
</tr>
<tr>
<td>默认排序</td>
<td>升序</td>
</tr>
<tr>
<td>自定义排序</td>
<td>通过 lambda 或函数对象</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定（用 <code>stable_sort</code> 保稳定）</td>
</tr>
<tr>
<td>适用范围</td>
<td>支持随机访问迭代器的容器</td>
</tr>
</tbody></table>
<p>方法二：双指针法</p>
<p>方法一没有利用数组 nums 1  与 nums 2  已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)。<br>指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。</p>
<p>空间复杂度：O(m+n)。<br>需要建立长度为 m+n 的中间数组 sorted。</p>
<p>方法三：逆向双指针</p>
<p>方法二中，之所以要使用临时变量，是因为如果直接合并到数组 nums1 中，nums1中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖nums1中的元素呢？观察可知，nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进nums1 的最后面。<br>严格来说，在此遍历过程中的任意一个时刻，nums1 数组中有 m－ p1－1 个元素被放入 nums1 的后半部，nums2数组中有 n－ p2 － 1 个元素被放入 nums 的后半部，而在指针 p1 的后面， nums1 数组有 m + n－ p1 － 1 个位置。由于<br>m+ n- p1 - 1 ≥ m - p1 - 1+ n -p2 - 1等价于<br>p2 ≥ -1<br>永远成立，因此 p1 后面的位置永远足够容纳被插入的元素，不会产生 p1的元素被覆盖的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)。<br>指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)。</p>
<p>空间复杂度：O(1)。<br>直接对数组 nums 1  原地修改，不需要额外空间。</p>
]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5多数元素</title>
    <url>/2025/11/25/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/5%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></p>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li>输入保证数组中一定有一个多数元素。</li>
</ul>
<p>**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p>
<p>方法一：哈希表</p>
<p>我们知道出现次数最多的元素大于n&#x2F;2次，所以可以用哈希表来快速统计每个元素出现的次数。</p>
<p>算法：</p>
<p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p>
<p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; counts;</span><br><span class="line">        int majority = 0, cnt = 0;</span><br><span class="line">        for (int num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            if (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：排序<br>思路：</p>
<p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为n&#x2F;2的元素（下标从 0 开始）一定是众数。</p>
<p>算法：</p>
<p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。</p>
<p>对于每种情况，数组上面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 n&#x2F;2的地方有重叠。因此，无论众数是多少，返回 n&#x2F;2下标对应的值都是正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        return nums[nums.size() / 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法三：随机化<br>思路</p>
<p>因为超过n&#x2F;2 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p>
<p>算法</p>
<p>由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int candidate = nums[rand() % nums.size()];</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (int num : nums)</span><br><span class="line">                if (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            if (count &gt; nums.size() / 2)</span><br><span class="line">                return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p>摩尔投票法的核心思想是利用多数元素的特性：<strong>多数元素出现的次数大于其他所有元素出现次数的总和</strong>。</p>
<p>我们可以把多数元素看作是“支持者”，把其他元素看作是“反对者”。由于支持者的数量超过总数的一半，他们的力量足以抵消所有反对者的力量，最终依然能够留下。</p>
<h3 id="核心步骤和逻辑："><a href="#核心步骤和逻辑：" class="headerlink" title="核心步骤和逻辑："></a>核心步骤和逻辑：</h3><ol>
<li><strong>设置候选人 (<code>candidate</code>) 和计数器 (<code>count</code>)。</strong></li>
<li><strong>遍历数组：</strong><ul>
<li><strong>如果 <code>count</code> 为 0：</strong> 说明当前的候选人已经被之前的“反对者”完全抵消了，我们需要选择当前遍历到的元素作为新的候选人。</li>
<li><strong>如果当前元素等于 <code>candidate</code>：</strong> 说明找到了一个“支持者”，<code>count</code> 加 1。</li>
<li><strong>如果当前元素不等于 <code>candidate</code>：</strong> 说明找到了一个“反对者”，<code>count</code> 减 1。</li>
</ul>
</li>
</ol>
<h3 id="为什么它有效？"><a href="#为什么它有效？" class="headerlink" title="为什么它有效？"></a>为什么它有效？</h3><p>假设多数元素是 M，且它出现的次数 C_M &gt; n&#x2F;2。</p>
<ul>
<li>当 M 作为 <code>candidate</code> 时，它的每次出现都会使 <code>count</code> 增加。</li>
<li>当非 M 元素出现时，<code>count</code> 会减少。</li>
<li>由于 C_M 严格大于非 M 元素出现的总次数 $n - C_M$，因此，即使非 M 元素把 <code>count</code> 减到了 0，新的 <code>candidate</code> 最终还是会被 M 或其他非 M 元素取代，但无论如何，最终剩下的 <code>candidate</code> <strong>必然是</strong> M。</li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @brief 多数元素 - 摩尔投票法</span><br><span class="line">     * * @param nums 输入数组</span><br><span class="line">     * @return int 多数元素</span><br><span class="line">     */</span><br><span class="line">    int majorityElement(const std::vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 1. 初始化</span><br><span class="line">        // candidate: 多数元素的候选人</span><br><span class="line">        // count: 当前候选人的“票数”</span><br><span class="line">        int candidate = 0; </span><br><span class="line">        int count = 0;</span><br><span class="line">        </span><br><span class="line">        // 2. 遍历数组进行投票</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            // **情况一：如果 count 为 0**</span><br><span class="line">            // 说明当前的 candidate 已经被完全抵消了，需要重新选择一个新的候选人。</span><br><span class="line">            if (count == 0) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = 1;</span><br><span class="line">                // 注意：这里也可以写成 count = 1，因为一旦更换候选人，</span><br><span class="line">                // 此时 num 就是 candidate，所以票数至少为 1</span><br><span class="line">            &#125; </span><br><span class="line">            // **情况二：当前元素是支持者**</span><br><span class="line">            // 当前元素与候选人相同，票数加 1</span><br><span class="line">            else if (num == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; </span><br><span class="line">            // **情况三：当前元素是反对者**</span><br><span class="line">            // 当前元素与候选人不同，票数减 1</span><br><span class="line">            else &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 3. 返回结果</span><br><span class="line">        // 根据题目假设（多数元素一定存在），最终剩下的 candidate 就是多数元素。</span><br><span class="line">        return candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 示例测试</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solver;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; nums1 = &#123;2, 2, 1, 1, 1, 2, 2&#125;;</span><br><span class="line">    int result1 = solver.majorityElement(nums1);</span><br><span class="line">    std::cout &lt;&lt; &quot;输入: &#123;2, 2, 1, 1, 1, 2, 2&#125;，多数元素: &quot; &lt;&lt; result1 &lt;&lt; std::endl; // 输出 2</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; nums2 = &#123;3, 3, 1, 1, 3&#125;;</span><br><span class="line">    int result2 = solver.majorityElement(nums2);</span><br><span class="line">    std::cout &lt;&lt; &quot;输入: &#123;3, 3, 1, 1, 3&#125;，多数元素: &quot; &lt;&lt; result2 &lt;&lt; std::endl; // 输出 3</span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; nums3 = &#123;6, 5, 5&#125;;</span><br><span class="line">    int result3 = solver.majorityElement(nums3);</span><br><span class="line">    std::cout &lt;&lt; &quot;输入: &#123;6, 5, 5&#125;，多数元素: &quot; &lt;&lt; result3 &lt;&lt; std::endl; // 输出 5</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h3><ul>
<li><strong>O(n)</strong>：我们只进行了一次数组的线性遍历，每个元素只访问一次。这是解决此问题的最快时间复杂度。</li>
</ul>
<h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h3><ul>
<li><strong>O(1)</strong>：我们只使用了两个额外的变量 (<code>candidate</code> 和 <code>count</code>) 来存储状态，所需的空间与输入数组的大小 $n$ 无关。</li>
</ul>
<p>摩尔投票法是一种非常优雅且高效的算法，体现了在常数空间内解决线性时间问题的强大能力。</p>
]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>6轮转数组</title>
    <url>/2025/11/25/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/6%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></p>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h4 id="方法一：使用额外的数组"><a href="#方法一：使用额外的数组" class="headerlink" title="方法一：使用额外的数组"></a>方法一：使用额外的数组</h4><p>我们可以使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，我们遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)mod n 的位置，最后将新数组拷贝至原数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">是 C++ 中 使用 std::vector::assign 成员函数 的一种典型用法。它的作用是：</span><br><span class="line">将 nums 的内容完全替换为 newArr 中的所有元素（从 begin() 到 end()）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义并初始化一个 std::vector&lt;int&gt; 对象 的标准方式:</span><br><span class="line">vector&lt;int&gt; newArr(n);</span><br><span class="line"></span><br><span class="line">std::vector&lt;int&gt; vec1;                  // 空的vector</span><br><span class="line">std::vector&lt;int&gt; vec2(5);               // 长度为5的vector，元素默认初始化</span><br><span class="line">std::vector&lt;int&gt; vec3(5, 10);           // 长度为5的vector，元素值为10</span><br><span class="line">std::vector&lt;int&gt; vec4 = &#123;1, 2, 3, 4&#125;;   // 使用初始化列表初始化</span><br></pre></td></tr></table></figure>

<h4 id="方法二：环状替换"><a href="#方法二：环状替换" class="headerlink" title="方法二：环状替换"></a>方法二：环状替换</h4><h4 id="方法三：数组翻转"><a href="#方法三：数组翻转" class="headerlink" title="方法三：数组翻转"></a>方法三：数组翻转</h4><p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 kmodn 个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。</p>
<p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 kmodn 个元素就被移至数组头部，然后我们再翻转 [0,kmodn−1] 区间的元素和 [kmodn,n−1] 区间的元素即能得到最后的答案。</p>
]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7买卖股票的最佳时期</title>
    <url>/2025/11/25/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/7%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p>思考：</p>
<p>可以定义两个变量in和out分别保存买入价和卖出价。遍历数组，第一个元素作为买入价存入in，比较下一个元素和in，如果下一个元素更小，则更新变量in的值，否则继续遍历，如果下一个变量的值大于in，则将该值存入out作为卖出价，以此类推，遇见更小的就更新in，遇见更大的值就更新out，结束后输出out-in。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int in = 0, out = 0;</span><br><span class="line">        int count = prices.size();</span><br><span class="line">        if(count &lt; 2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        in = prices[0];</span><br><span class="line">        for(int i = 1; i &lt; count; i++)&#123;</span><br><span class="line">            if(prices[i] &lt; in)&#123;</span><br><span class="line">                in = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(prices[i] &gt; in &amp;&amp; prices[i] &gt; out)&#123;</span><br><span class="line">                out = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(out &gt; in)&#123;</span><br><span class="line">            return (out - in);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际代码编写与测试过程中发现上述方法可以找到最大利润，但是无法保证买入在卖出之前，实际上直说找到了最贵和最便宜的股票价格，不符合实际。</p>
<p>看题解发现可以通过双层循环分别确定买入价格和卖出价格，这样可以保证卖出价始终晚于买入价。</p>
<p>当然可以！下面是使用 <strong>C++</strong> 实现 LeetCode 第 121 题 “<strong>买卖股票的最佳时机</strong>” 的几种主流解法，包括 <strong>贪心算法（最优）</strong> 和 <strong>动态规划（DP）</strong>。</p>
<hr>
<h2 id="✅-方法一：贪心算法（推荐）"><a href="#✅-方法一：贪心算法（推荐）" class="headerlink" title="✅ 方法一：贪心算法（推荐）"></a>✅ 方法一：贪心算法（推荐）</h2><h3 id="📌-思路回顾："><a href="#📌-思路回顾：" class="headerlink" title="📌 思路回顾："></a>📌 思路回顾：</h3><ul>
<li>遍历每一天的价格。</li>
<li>记录到目前为止的<strong>最低买入价格</strong>。</li>
<li>每天计算如果今天卖出能获得的利润，并更新最大利润。</li>
</ul>
<h3 id="💡-C-代码："><a href="#💡-C-代码：" class="headerlink" title="💡 C++ 代码："></a>💡 C++ 代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_price = INT_MAX;   <span class="comment">// 初始化为最大整数</span></span><br><span class="line">        <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            min_price = std::<span class="built_in">min</span>(min_price, price);           <span class="comment">// 更新最低买入价</span></span><br><span class="line">            max_profit = std::<span class="built_in">max</span>(max_profit, price - min_price); <span class="comment">// 更新最大利润</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="⏱️-复杂度分析："><a href="#⏱️-复杂度分析：" class="headerlink" title="⏱️ 复杂度分析："></a>⏱️ 复杂度分析：</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<hr>
<h2 id="✅-方法二：动态规划（DP）"><a href="#✅-方法二：动态规划（DP）" class="headerlink" title="✅ 方法二：动态规划（DP）"></a>✅ 方法二：动态规划（DP）</h2><h3 id="📌-状态定义（简化版）："><a href="#📌-状态定义（简化版）：" class="headerlink" title="📌 状态定义（简化版）："></a>📌 状态定义（简化版）：</h3><ul>
<li><code>hold</code>：当前持有股票时的最大收益（其实是负值，表示花了钱）</li>
<li><code>sold</code>：当前不持有股票时的最大收益（即已卖出，真实利润）</li>
</ul>
<h3 id="💡-C-代码（空间优化版）："><a href="#💡-C-代码（空间优化版）：" class="headerlink" title="💡 C++ 代码（空间优化版）："></a>💡 C++ 代码（空间优化版）：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> hold = -prices[<span class="number">0</span>];  <span class="comment">// 第一天买入</span></span><br><span class="line">        <span class="type">int</span> sold = <span class="number">0</span>;           <span class="comment">// 第一天不买也不卖</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            hold = std::<span class="built_in">max</span>(hold, -prices[i]);          <span class="comment">// 要么继续持有，要么今天第一次买</span></span><br><span class="line">            sold = std::<span class="built_in">max</span>(sold, hold + prices[i]);    <span class="comment">// 要么继续空仓，要么今天卖出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：因为只允许一次交易，所以 <code>hold</code> 只能从 <code>0 - prices[i]</code> 来（不能由之前的 <code>sold</code> 转移而来）。</p>
</blockquote>
<h3 id="⏱️-复杂度分析：-1"><a href="#⏱️-复杂度分析：-1" class="headerlink" title="⏱️ 复杂度分析："></a>⏱️ 复杂度分析：</h3><ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<hr>
<h2 id="❌-方法三：暴力法（仅用于理解，会超时）"><a href="#❌-方法三：暴力法（仅用于理解，会超时）" class="headerlink" title="❌ 方法三：暴力法（仅用于理解，会超时）"></a>❌ 方法三：暴力法（仅用于理解，会超时）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                max_profit = std::<span class="built_in">max</span>(max_profit, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不推荐提交，LeetCode 上会 <strong>Time Limit Exceeded</strong>。</p>
</blockquote>
<hr>
<h2 id="✅-使用示例（完整可运行程序）"><a href="#✅-使用示例（完整可运行程序）" class="headerlink" title="✅ 使用示例（完整可运行程序）"></a>✅ 使用示例（完整可运行程序）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_price = INT_MAX;</span><br><span class="line">        <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            min_price = std::<span class="built_in">min</span>(min_price, p);</span><br><span class="line">            max_profit = std::<span class="built_in">max</span>(max_profit, p - min_price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; prices = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max Profit: &quot;</span> &lt;&lt; sol.<span class="built_in">maxProfit</span>(prices) &lt;&lt; std::endl; <span class="comment">// 输出: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔚-总结"><a href="#🔚-总结" class="headerlink" title="🔚 总结"></a>🔚 总结</h2><table>
<thead>
<tr>
<th>方法</th>
<th>是否推荐</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>贪心</td>
<td>✅✅✅</td>
<td>本题最优解</td>
</tr>
<tr>
<td>DP</td>
<td>✅</td>
<td>便于扩展到多笔交易等变种</td>
</tr>
<tr>
<td>暴力</td>
<td>❌</td>
<td>仅用于理解逻辑</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>8买卖股票的最佳时期</title>
    <url>/2025/11/25/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/8%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA2/</url>
    <content><![CDATA[<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。然而，你可以在 <strong>同一天</strong> 多次买卖该股票，但要确保你持有的股票不超过一股。返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。</span><br><span class="line">最大总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">最大总利润为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p>方法一：动态规划<br>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>
<p>定义状态 dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p>
<p>考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p>
<p>dp[i][0]&#x3D;max{dp[i−1][0],dp[i−1][1]+prices[i]}<br>再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：</p>
<p>dp[i][1]&#x3D;max{dp[i−1][1],dp[i−1][0]−prices[i]}<br>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][0]&#x3D;0，dp[0][1]&#x3D;−prices[0]。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        int dp[n][2];</span><br><span class="line">        dp[0][0] = 0, dp[0][1] = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1][0] 和 dp[i−1][1] 存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            int newDp0 = max(dp0, dp1 + prices[i]);</span><br><span class="line">            int newDp1 = max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为 O(1)，因此时间复杂度为 O(2n)&#x3D;O(n)。</p>
<p>空间复杂度：O(n)。我们需要开辟 O(n) 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 O(1)。</p>
]]></content>
      <categories>
        <category>面试经典150题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
