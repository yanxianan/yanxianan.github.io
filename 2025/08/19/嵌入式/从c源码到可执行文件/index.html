<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanxianan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文**全面、深入、详细**的程序编译全过程解析文章，涵盖从一个 &#96;.c&#96; 源文件如何一步步变成可执行文件的完整流程，包括预处理、编译、汇编、链接的每一个阶段，以及目标文件（Object File）的结构、符号表、重定位、静态&#x2F;动态链接机制、ELF 格式解析、加载执行等高级内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="程序编译全过程详解">
<meta property="og:url" content="https://yanxianan.github.io/2025/08/19/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%8Ec%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="蛋的博客">
<meta property="og:description" content="本文**全面、深入、详细**的程序编译全过程解析文章，涵盖从一个 &#96;.c&#96; 源文件如何一步步变成可执行文件的完整流程，包括预处理、编译、汇编、链接的每一个阶段，以及目标文件（Object File）的结构、符号表、重定位、静态&#x2F;动态链接机制、ELF 格式解析、加载执行等高级内容。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-19T02:00:00.000Z">
<meta property="article:modified_time" content="2025-08-19T07:51:03.703Z">
<meta property="article:author" content="Yxa">
<meta property="article:tag" content="可执行文件，编译">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yanxianan.github.io/2025/08/19/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%8Ec%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>程序编译全过程详解 | 蛋的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蛋的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里是蛋的学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yanxianan.github.io/2025/08/19/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%8Ec%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Yxa">
      <meta itemprop="description" content="DO SOMETHING COOL！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蛋的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序编译全过程详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-19 10:00:00 / 修改时间：15:51:03" itemprop="dateCreated datePublished" datetime="2025-08-19T10:00:00+08:00">2025-08-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          
            <div class="post-description">本文**全面、深入、详细**的程序编译全过程解析文章，涵盖从一个 `.c` 源文件如何一步步变成可执行文件的完整流程，包括预处理、编译、汇编、链接的每一个阶段，以及目标文件（Object File）的结构、符号表、重定位、静态/动态链接机制、ELF 格式解析、加载执行等高级内容。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h1 id="程序编译全过程详解：从-C-源码到可执行文件的深度剖析"><a href="#程序编译全过程详解：从-C-源码到可执行文件的深度剖析" class="headerlink" title="程序编译全过程详解：从 C 源码到可执行文件的深度剖析"></a><strong>程序编译全过程详解：从 C 源码到可执行文件的深度剖析</strong></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>当你写下一段简单的 C 代码，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>

<p>你可能以为这只是“编译”了一下。但实际上，这背后隐藏着一个极其复杂而精密的系统工程。本文将带你深入探索：<strong>一个 <code>.c</code> 源文件是如何经过一系列转换，最终变成一个可以在操作系统上运行的可执行文件的？</strong> 我们将逐层剖析预处理、编译、汇编、链接四大阶段，深入 ELF 文件结构、符号解析、重定位、动态链接机制等底层细节。</p>
<hr>
<h2 id="第一部分：程序构建的四个阶段"><a href="#第一部分：程序构建的四个阶段" class="headerlink" title="第一部分：程序构建的四个阶段"></a><strong>第一部分：程序构建的四个阶段</strong></h2><p>整个编译过程可以分为四个主要阶段：</p>
<ol>
<li><strong>预处理 (Preprocessing)</strong></li>
<li><strong>编译 (Compilation)</strong></li>
<li><strong>汇编 (Assembly)</strong></li>
<li><strong>链接 (Linking)</strong></li>
</ol>
<p>我们以 <code>gcc</code> 为例，逐步分解。</p>
<hr>
<h3 id="1-预处理-Preprocessing"><a href="#1-预处理-Preprocessing" class="headerlink" title="1. 预处理 (Preprocessing)"></a><strong>1. 预处理 (Preprocessing)</strong></h3><p><strong>目标：</strong> 将源代码中的宏、头文件、条件编译等“预处理指令”展开，生成一个纯 C 代码的 <code>.i</code> 文件。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<ul>
<li><code>#include &lt;stdio.h&gt;</code>：被替换为 <code>stdio.h</code> 的完整内容（通常在 <code>/usr/include/</code> 中）。</li>
<li><code>#define</code> 宏被展开。</li>
<li>条件编译 <code>#ifdef</code>, <code>#ifndef</code> 等被求值。</li>
<li>注释被删除。</li>
<li>行号和文件名信息被保留（用于调试）。</li>
</ul>
<p><strong><code>hello.i</code> 示例（简化）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 大量 stdio.h 内容 ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>预处理器不理解 C 语法，它只是文本替换。</li>
<li>生成的 <code>.i</code> 文件仍然是 C 语言代码，但已经“展开”了所有宏和头文件。</li>
</ul>
<hr>
<h3 id="2-编译-Compilation"><a href="#2-编译-Compilation" class="headerlink" title="2. 编译 (Compilation)"></a><strong>2. 编译 (Compilation)</strong></h3><p><strong>目标：</strong> 将预处理后的 C 代码（<code>.i</code> 文件）翻译成汇编语言（<code>.s</code> 文件）。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<p>这是最复杂的阶段，包括：</p>
<h4 id="1-词法分析-Lexical-Analysis"><a href="#1-词法分析-Lexical-Analysis" class="headerlink" title="(1) 词法分析 (Lexical Analysis)"></a><strong>(1) 词法分析 (Lexical Analysis)</strong></h4><ul>
<li>将字符流分解为“词法单元”（Tokens）：<code>int</code>, <code>main</code>, <code>(</code>, <code>)</code>, <code>&#123;</code>, <code>printf</code>, <code>(</code>, <code>&quot;Hello&quot;</code>, <code>)</code>, <code>;</code>, <code>return</code>, <code>0</code>, <code>;</code>, <code>&#125;</code>。</li>
<li>忽略空白、注释。</li>
</ul>
<h4 id="2-语法分析-Syntax-Analysis-Parsing"><a href="#2-语法分析-Syntax-Analysis-Parsing" class="headerlink" title="(2) 语法分析 (Syntax Analysis &#x2F; Parsing)"></a><strong>(2) 语法分析 (Syntax Analysis &#x2F; Parsing)</strong></h4><ul>
<li>使用上下文无关文法（CFG）构建<strong>抽象语法树（AST）</strong>。</li>
<li>例如，<code>printf(&quot;Hello, World!\n&quot;);</code> 被解析为一个函数调用节点，子节点是字符串字面量。</li>
</ul>
<h4 id="3-语义分析-Semantic-Analysis"><a href="#3-语义分析-Semantic-Analysis" class="headerlink" title="(3) 语义分析 (Semantic Analysis)"></a><strong>(3) 语义分析 (Semantic Analysis)</strong></h4><ul>
<li>检查类型是否匹配（如 <code>int x = &quot;hello&quot;;</code> 会报错）。</li>
<li>构建<strong>符号表（Symbol Table）</strong>：记录变量、函数、作用域等信息。</li>
<li>检查函数是否已声明。</li>
</ul>
<h4 id="4-中间代码生成-IR-Generation"><a href="#4-中间代码生成-IR-Generation" class="headerlink" title="(4) 中间代码生成 (IR Generation)"></a><strong>(4) 中间代码生成 (IR Generation)</strong></h4><ul>
<li>将 AST 转换为<strong>中间表示（Intermediate Representation, IR）</strong>，如 GIMPLE（GCC）、LLVM IR。</li>
<li>IR 是平台无关的，便于进行优化。</li>
</ul>
<h4 id="5-优化-Optimization"><a href="#5-优化-Optimization" class="headerlink" title="(5) 优化 (Optimization)"></a><strong>(5) 优化 (Optimization)</strong></h4><ul>
<li>在 IR 层进行各种优化：<ul>
<li>常量折叠：<code>int x = 2 + 3;</code> → <code>int x = 5;</code></li>
<li>死代码消除</li>
<li>循环优化</li>
<li>内联函数</li>
</ul>
</li>
<li>优化后重新生成汇编代码。</li>
</ul>
<h4 id="6-目标代码生成"><a href="#6-目标代码生成" class="headerlink" title="(6) 目标代码生成"></a><strong>(6) 目标代码生成</strong></h4><ul>
<li>将优化后的 IR 转换为特定架构（如 x86-64）的<strong>汇编代码</strong>。</li>
</ul>
<p><strong><code>hello.s</code> 示例（x86-64，简化）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    leaq    .LC0(%rip), %rdi     # 加载字符串地址</span><br><span class="line">    call    printf@PLT           # 调用 printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.LC0:</span><br><span class="line">    .string &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>输出是人类可读的汇编代码（<code>.s</code> 文件）。</li>
<li>此时还未分配最终内存地址。</li>
</ul>
<hr>
<h3 id="3-汇编-Assembly"><a href="#3-汇编-Assembly" class="headerlink" title="3. 汇编 (Assembly)"></a><strong>3. 汇编 (Assembly)</strong></h3><p><strong>目标：</strong> 将汇编代码（<code>.s</code>）翻译成机器码，生成<strong>目标文件（Object File）</strong>，通常是 <code>.o</code> 文件。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>或直接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<p><strong>发生了什么？</strong></p>
<ul>
<li>汇编器（如 <code>as</code>）读取 <code>.s</code> 文件。</li>
<li>将每条汇编指令翻译为对应的<strong>机器码（二进制）</strong>。</li>
<li>生成一个 <strong>ELF 格式</strong> 的目标文件 <code>hello.o</code>。</li>
</ul>
<p><strong>目标文件 <code>hello.o</code> 包含什么？</strong></p>
<p>我们使用 <code>objdump</code> 和 <code>readelf</code> 来分析：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -d hello.o      <span class="comment"># 反汇编代码段</span></span><br><span class="line">readelf -a hello.o      <span class="comment"># 查看所有信息</span></span><br></pre></td></tr></table></figure>

<h3 id="目标文件结构（ELF-格式）"><a href="#目标文件结构（ELF-格式）" class="headerlink" title="目标文件结构（ELF 格式）"></a><strong>目标文件结构（ELF 格式）</strong></h3><p>ELF（Executable and Linkable Format）是 Unix&#x2F;Linux 系统的标准可执行文件格式。</p>
<p>一个典型的 <code>.o</code> 文件包含以下关键部分：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><strong>代码段</strong>：存放编译后的机器指令（如 <code>main</code> 函数）。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td><strong>已初始化数据段</strong>：存放已初始化的全局&#x2F;静态变量（如 <code>int x = 10;</code>）。</td>
</tr>
<tr>
<td><code>.bss</code></td>
<td><strong>未初始化数据段</strong>：存放未初始化的全局&#x2F;静态变量（如 <code>int y;</code>）。在文件中不占空间，运行时由系统清零。</td>
</tr>
<tr>
<td><code>.rodata</code></td>
<td><strong>只读数据段</strong>：存放字符串常量、const 变量等。</td>
</tr>
<tr>
<td><code>.symtab</code></td>
<td><strong>符号表</strong>：记录所有函数和变量的名称、类型、作用域、所在节等。</td>
</tr>
<tr>
<td><code>.strtab</code></td>
<td><strong>字符串表</strong>：存放符号表中用到的字符串（如函数名）。</td>
</tr>
<tr>
<td><code>.rela.text</code></td>
<td><strong>重定位表（代码段）</strong>：记录代码段中哪些位置需要在链接时进行地址修正。</td>
</tr>
<tr>
<td><code>.rela.data</code></td>
<td><strong>重定位表（数据段）</strong>：同上，用于数据段。</td>
</tr>
</tbody></table>
<h4 id="符号表（-symtab）示例："><a href="#符号表（-symtab）示例：" class="headerlink" title="符号表（.symtab）示例："></a><strong>符号表（<code>.symtab</code>）示例：</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s hello.o</span><br></pre></td></tr></table></figure>
<p>输出可能包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">  0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">  1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">  2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">  5: 0000000000000000    29 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">  6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>main</code>：类型为 <code>FUNC</code>，绑定为 <code>GLOBAL</code>，位于 <code>.text</code> 节（Ndx&#x3D;1）。</li>
<li><code>printf</code>：类型为 <code>NOTYPE</code>，绑定为 <code>GLOBAL</code>，但 <code>Ndx=UND</code>（未定义），表示它将在链接时从其他地方解析。</li>
</ul>
<h4 id="重定位表（-rela-text）示例："><a href="#重定位表（-rela-text）示例：" class="headerlink" title="重定位表（.rela.text）示例："></a><strong>重定位表（<code>.rela.text</code>）示例：</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -r hello.o</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &#x27;.rela.text&#x27; at offset 0x218 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000007  000500000004 R_X86_64_PLT32    0000000000000000 printf - 4</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Offset</strong>: 在 <code>.text</code> 段中的偏移位置（0x7），即 <code>call</code> 指令的操作数位置。</li>
<li><strong>Type</strong>: <code>R_X86_64_PLT32</code>，表示这是一个 PLT（Procedure Linkage Table）相对调用。</li>
<li><strong>Sym. Name</strong>: <code>printf</code>，表示这个位置引用了 <code>printf</code> 符号。</li>
<li><strong>Addend</strong>: -4，用于计算最终地址。</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li>目标文件是<strong>可重定位文件（Relocatable Object File）</strong>。</li>
<li>它包含机器码，但地址是相对的，需要链接器进行“重定位”才能确定最终地址。</li>
<li>它可能引用外部符号（如 <code>printf</code>），这些符号在链接时解析。</li>
</ul>
<hr>
<h3 id="4-链接-Linking"><a href="#4-链接-Linking" class="headerlink" title="4. 链接 (Linking)"></a><strong>4. 链接 (Linking)</strong></h3><p><strong>目标：</strong> 将一个或多个目标文件（<code>.o</code>）和库文件（<code>.a</code>, <code>.so</code>）合并，生成一个<strong>可执行文件（Executable File）</strong> 或共享库。</p>
<p><strong>命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<p><strong>链接器（<code>ld</code>）做了什么？</strong></p>
<h4 id="1-符号解析（Symbol-Resolution）"><a href="#1-符号解析（Symbol-Resolution）" class="headerlink" title="(1) 符号解析（Symbol Resolution）"></a><strong>(1) 符号解析（Symbol Resolution）</strong></h4><ul>
<li>遍历所有输入文件（<code>hello.o</code> 和标准库如 <code>libc.a</code> 或 <code>libc.so</code>）。</li>
<li>建立全局符号表。</li>
<li>解析未定义符号：<ul>
<li><code>hello.o</code> 中 <code>printf</code> 是未定义的。</li>
<li>链接器在 <code>libc</code> 库中找到 <code>printf</code> 的定义。</li>
</ul>
</li>
<li>如果找不到，链接失败（<code>undefined reference</code> 错误）。</li>
</ul>
<h4 id="2-重定位（Relocation）"><a href="#2-重定位（Relocation）" class="headerlink" title="(2) 重定位（Relocation）"></a><strong>(2) 重定位（Relocation）</strong></h4><ul>
<li><strong>合并节（Section Merging）</strong>：<ul>
<li>所有 <code>.text</code> 节合并为一个 <code>.text</code> 段。</li>
<li>所有 <code>.data</code> 节合并为一个 <code>.data</code> 段。</li>
<li>…</li>
</ul>
</li>
<li><strong>分配运行时内存地址</strong>：<ul>
<li>链接器根据程序的内存布局（如 ELF 的 Program Headers），为每个段分配虚拟内存地址。</li>
<li>例如，<code>.text</code> 段可能被分配到 <code>0x400000</code>。</li>
</ul>
</li>
<li><strong>修正地址引用</strong>：<ul>
<li>遍历重定位表（<code>.rela.text</code>）。</li>
<li>找到 <code>call printf</code> 指令的位置。</li>
<li>计算 <code>printf</code> 的<strong>运行时地址</strong>（可能通过 PLT&#x2F;GOT 机制）。</li>
<li>将相对偏移写入该位置。</li>
</ul>
</li>
</ul>
<h4 id="3-处理库文件"><a href="#3-处理库文件" class="headerlink" title="(3) 处理库文件"></a><strong>(3) 处理库文件</strong></h4><ul>
<li><strong>静态库（<code>.a</code>）</strong>：是 <code>.o</code> 文件的归档。链接器只提取需要的 <code>.o</code> 文件（如 <code>printf.o</code>）并合并进来。生成的可执行文件包含库代码，体积大，但独立。</li>
<li><strong>共享库（<code>.so</code>）</strong>：动态链接。链接器只记录依赖（如 <code>libc.so.6</code>），不包含实际代码。运行时由<strong>动态链接器（<code>ld-linux.so</code>）</strong> 加载。</li>
</ul>
<hr>
<h2 id="第二部分：可执行文件与加载执行"><a href="#第二部分：可执行文件与加载执行" class="headerlink" title="第二部分：可执行文件与加载执行"></a><strong>第二部分：可执行文件与加载执行</strong></h2><h3 id="最终的可执行文件-hello"><a href="#最终的可执行文件-hello" class="headerlink" title="最终的可执行文件 hello"></a><strong>最终的可执行文件 <code>hello</code></strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file hello</span><br><span class="line"><span class="comment"># 输出：hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped</span></span><br></pre></td></tr></table></figure>

<p><strong>关键信息：</strong></p>
<ul>
<li><strong>ELF 可执行文件</strong>。</li>
<li><strong>动态链接</strong>：依赖共享库。</li>
<li><strong>解释器（Interpreter）</strong>：<code>/lib64/ld-linux-x86-64.so.2</code>，即动态链接器。</li>
</ul>
<h3 id="程序的加载与执行过程"><a href="#程序的加载与执行过程" class="headerlink" title="程序的加载与执行过程"></a><strong>程序的加载与执行过程</strong></h3><ol>
<li><strong>用户执行 <code>./hello</code></strong></li>
<li><strong>操作系统内核</strong>：<ul>
<li>读取文件头，识别为 ELF 文件。</li>
<li>发现需要解释器 <code>/lib64/ld-linux-x86-64.so.2</code>。</li>
</ul>
</li>
<li><strong>内核加载动态链接器</strong>：<ul>
<li>将 <code>ld-linux.so</code> 加载到内存。</li>
<li>将控制权交给它。</li>
</ul>
</li>
<li><strong>动态链接器（<code>ld-linux.so</code>）</strong>：<ul>
<li>解析 <code>hello</code> 的依赖（如 <code>libc.so.6</code>）。</li>
<li>在系统路径（<code>/lib</code>, <code>/usr/lib</code>）中查找并加载这些共享库到内存。</li>
<li>进行<strong>动态重定位</strong>（如填充 GOT 表）。</li>
<li>调用 <code>hello</code> 的初始化函数（如果有）。</li>
</ul>
</li>
<li><strong>跳转到 <code>_start</code></strong><ul>
<li>动态链接器将控制权交给程序的入口点 <code>_start</code>（由 C 运行时库 <code>crt0.o</code> 提供）。</li>
</ul>
</li>
<li><strong>C 运行时初始化</strong><ul>
<li><code>_start</code> 设置堆栈、环境变量、调用 <code>__libc_start_main</code>。</li>
<li>初始化 <code>libc</code>，调用全局构造函数（C++）。</li>
</ul>
</li>
<li><strong>调用 <code>main()</code></strong><ul>
<li>最终调用我们写的 <code>main()</code> 函数。</li>
</ul>
</li>
<li><strong>程序运行</strong></li>
<li><strong><code>main()</code> 返回</strong><ul>
<li>调用 <code>exit()</code>，清理资源，返回状态码给操作系统。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第三部分：高级主题"><a href="#第三部分：高级主题" class="headerlink" title="第三部分：高级主题"></a><strong>第三部分：高级主题</strong></h2><h3 id="1-静态链接-vs-动态链接"><a href="#1-静态链接-vs-动态链接" class="headerlink" title="1. 静态链接 vs 动态链接"></a><strong>1. 静态链接 vs 动态链接</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td>生成文件</td>
<td>包含所有代码</td>
<td>只包含自身代码，依赖外部 <code>.so</code></td>
</tr>
<tr>
<td>体积</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>启动速度</td>
<td>快（无需加载库）</td>
<td>稍慢（需加载和链接库）</td>
</tr>
<tr>
<td>内存占用</td>
<td>每个进程独立副本</td>
<td>多个进程共享同一库</td>
</tr>
<tr>
<td>更新</td>
<td>需重新编译</td>
<td>只需替换 <code>.so</code> 文件</td>
</tr>
<tr>
<td>命令</td>
<td><code>gcc -static hello.c</code></td>
<td>默认行为</td>
</tr>
</tbody></table>
<h3 id="2-PLT-Procedure-Linkage-Table-与-GOT-Global-Offset-Table"><a href="#2-PLT-Procedure-Linkage-Table-与-GOT-Global-Offset-Table" class="headerlink" title="2. PLT (Procedure Linkage Table) 与 GOT (Global Offset Table)"></a><strong>2. PLT (Procedure Linkage Table) 与 GOT (Global Offset Table)</strong></h3><p>用于实现<strong>延迟绑定（Lazy Binding）</strong>，提高启动速度。</p>
<ul>
<li><strong>GOT</strong>：存放函数的实际地址（运行时由动态链接器填充）。</li>
<li><strong>PLT</strong>：一段跳转代码。<ul>
<li>第一次调用 <code>printf</code>：<ul>
<li>跳转到 PLT 条目。</li>
<li>PLT 跳转到 GOT。</li>
<li>GOT 指向 PLT 中的“解析代码”。</li>
<li>解析代码调用动态链接器查找 <code>printf</code> 地址，写入 GOT。</li>
<li>跳转到 <code>printf</code>。</li>
</ul>
</li>
<li>后续调用：<ul>
<li>PLT → GOT → 直接跳转到 <code>printf</code>（无需解析）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-ELF-文件结构详解"><a href="#3-ELF-文件结构详解" class="headerlink" title="3. ELF 文件结构详解"></a><strong>3. ELF 文件结构详解</strong></h3><p>一个 ELF 文件包含：</p>
<ul>
<li><strong>ELF Header</strong>：描述文件类型、架构、入口点、Program Header Table 和 Section Header Table 的位置。</li>
<li><strong>Program Header Table</strong>：用于加载器，描述如何将文件映射到内存（如 <code>.text</code>, <code>.data</code> 段）。</li>
<li><strong>Section Header Table</strong>：用于链接器和调试器，描述各个节（<code>.text</code>, <code>.symtab</code> 等）。</li>
<li><strong>Segments</strong>：由 Program Headers 描述，是加载时的单位。</li>
<li><strong>Sections</strong>：由 Section Headers 描述，是链接时的单位。</li>
</ul>
<blockquote>
<p>通常，一个 Segment 包含多个 Section。</p>
</blockquote>
<h3 id="4-位置无关代码-PIC-与位置无关可执行文件-PIE"><a href="#4-位置无关代码-PIC-与位置无关可执行文件-PIE" class="headerlink" title="4. 位置无关代码 (PIC) 与位置无关可执行文件 (PIE)"></a><strong>4. 位置无关代码 (PIC) 与位置无关可执行文件 (PIE)</strong></h3><ul>
<li><strong>PIC</strong>：代码可以加载到任意内存地址执行（共享库必须是 PIC）。</li>
<li><strong>PIE</strong>：可执行文件也是 PIC，提高安全性（ASLR）。</li>
<li>编译选项：<code>-fPIC</code>（生成 PIC 目标文件），<code>-fPIE -pie</code>（生成 PIE 可执行文件）。</li>
</ul>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>从一行 <code>#include &lt;stdio.h&gt;</code> 到屏幕上打印 “Hello, World!”，背后是预处理器、编译器、汇编器、链接器、操作系统内核、动态链接器等多个组件的精密协作。理解这一过程，不仅有助于编写更高效的代码，更能深入掌握程序的运行本质。</p>
<p><strong>关键收获：</strong></p>
<ul>
<li>编译是<strong>预处理 → 编译 → 汇编 → 链接</strong>的流水线。</li>
<li>目标文件（<code>.o</code>）是<strong>可重定位</strong>的，包含代码、数据、符号表、重定位表。</li>
<li>链接器负责<strong>符号解析</strong>和<strong>重定位</strong>，合并多个目标文件。</li>
<li>可执行文件的加载依赖<strong>动态链接器</strong>，通过 <strong>PLT&#x2F;GOT</strong> 实现函数调用。</li>
<li><strong>ELF</strong> 是 Linux 下程序的“身份证”，定义了所有结构。</li>
</ul>
<p>掌握这些底层知识，你将不再只是“写代码”，而是真正“理解程序如何运行”。</p>
<hr>
<p><strong>参考文献：</strong></p>
<ol>
<li>《程序员的自我修养：链接、装载与库》—— 俞甲子、石凡、潘爱民</li>
<li>《Linkers and Loaders》—— John R. Levine</li>
<li>《Computer Systems: A Programmer’s Perspective》—— Bryant &amp; O’Hallaron</li>
<li>GCC, Binutils, Glibc 官方文档</li>
<li>ELF Specification (Tool Interface Standard)</li>
</ol>
<p><strong>工具推荐：</strong></p>
<ul>
<li><code>gcc</code>, <code>clang</code>：编译器</li>
<li><code>as</code>, <code>ld</code>：汇编器和链接器</li>
<li><code>objdump</code>, <code>readelf</code>, <code>nm</code>：二进制分析</li>
<li><code>gdb</code>：调试器</li>
<li><code>strace</code>, <code>ltrace</code>：系统调用和库调用跟踪</li>
</ul>
<blockquote>
<p>本文内容基于 x86-64 Linux 系统，其他平台（如 ARM, Windows PE）原理类似，细节略有不同。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%8C%E7%BC%96%E8%AF%91/" rel="tag"># 可执行文件，编译</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/18/Java/Java%E4%B8%AD%E7%9A%84static%E5%92%8Cfinal/" rel="prev" title="Java中的static和final">
      <i class="fa fa-chevron-left"></i> Java中的static和final
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/MySQL%E5%85%A5%E9%97%A8/" rel="next" title="MySQL入门">
      MySQL入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E-C-%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">程序编译全过程详解：从 C 源码到可执行文件的深度剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.</span> <span class="nav-text">第一部分：程序构建的四个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86-Preprocessing"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 预处理 (Preprocessing)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BC%96%E8%AF%91-Compilation"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 编译 (Compilation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-Lexical-Analysis"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">(1) 词法分析 (Lexical Analysis)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analysis-Parsing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">(2) 语法分析 (Syntax Analysis &#x2F; Parsing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-Semantic-Analysis"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">(3) 语义分析 (Semantic Analysis)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-IR-Generation"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">(4) 中间代码生成 (IR Generation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E4%BC%98%E5%8C%96-Optimization"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">(5) 优化 (Optimization)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">(6) 目标代码生成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B1%87%E7%BC%96-Assembly"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 汇编 (Assembly)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88ELF-%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="nav-number">1.2.4.</span> <span class="nav-text">目标文件结构（ELF 格式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%88-symtab%EF%BC%89%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">符号表（.symtab）示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%EF%BC%88-rela-text%EF%BC%89%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">重定位表（.rela.text）示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%93%BE%E6%8E%A5-Linking"><span class="nav-number">1.2.5.</span> <span class="nav-text">4. 链接 (Linking)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%EF%BC%88Symbol-Resolution%EF%BC%89"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">(1) 符号解析（Symbol Resolution）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88Relocation%EF%BC%89"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">(2) 重定位（Relocation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%84%E7%90%86%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">(3) 处理库文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">第二部分：可执行文件与加载执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6-hello"><span class="nav-number">1.3.1.</span> <span class="nav-text">最终的可执行文件 hello</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">程序的加载与执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">第三部分：高级主题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5-vs-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 静态链接 vs 动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-PLT-Procedure-Linkage-Table-%E4%B8%8E-GOT-Global-Offset-Table"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. PLT (Procedure Linkage Table) 与 GOT (Global Offset Table)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. ELF 文件结构详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81-PIC-%E4%B8%8E%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6-PIE"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 位置无关代码 (PIC) 与位置无关可执行文件 (PIE)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">1.5.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yxa"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yxa</p>
  <div class="site-description" itemprop="description">DO SOMETHING COOL！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanxianan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanxianan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yanxiaoan429@163.com" title="E-Mail → mailto:yanxiaoan429@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yxa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
