<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanxianan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文详细讲解进程（Process）和线程（Thread）。">
<meta property="og:type" content="article">
<meta property="og:title" content="进程和线程">
<meta property="og:url" content="https://yanxianan.github.io/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="蛋的博客">
<meta property="og:description" content="本文详细讲解进程（Process）和线程（Thread）。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-24T07:40:00.000Z">
<meta property="article:modified_time" content="2025-10-24T07:04:44.957Z">
<meta property="article:author" content="Yxa">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yanxianan.github.io/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程和线程 | 蛋的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蛋的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里是蛋的学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yanxianan.github.io/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Yxa">
      <meta itemprop="description" content="DO SOMETHING COOL！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蛋的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程和线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-24 15:40:00 / 修改时间：15:04:44" itemprop="dateCreated datePublished" datetime="2025-10-24T15:40:00+08:00">2025-10-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          
            <div class="post-description">本文详细讲解进程（Process）和线程（Thread）。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是对 <strong>进程（Process）</strong> 和 <strong>线程（Thread）</strong> 的全面、深入、详细的讲解，涵盖定义、区别、实现机制、调度、通信、内存模型、优缺点、典型应用场景，以及在现代操作系统（如 Linux&#x2F;Windows）中的具体实现细节。</p>
<hr>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-什么是进程（Process）？"><a href="#1-1-什么是进程（Process）？" class="headerlink" title="1.1 什么是进程（Process）？"></a>1.1 什么是进程（Process）？</h3><p><strong>进程</strong>是操作系统进行<strong>资源分配和调度的基本单位</strong>。它是一个<strong>正在运行的程序的实例</strong>，拥有独立的地址空间、内存、文件描述符、环境变量、安全上下文（如用户ID）、信号处理机制等。</p>
<ul>
<li>每个进程在内核中都有一个唯一的 <strong>进程标识符（PID）</strong>。</li>
<li>进程是<strong>隔离的</strong>：一个进程崩溃通常不会直接影响其他进程。</li>
<li>进程启动时，操作系统为其分配：<ul>
<li>虚拟地址空间（代码段、数据段、堆、栈等）</li>
<li>文件描述符表</li>
<li>信号处理表</li>
<li>进程控制块（PCB，Process Control Block）</li>
</ul>
</li>
</ul>
<blockquote>
<p>💡 <strong>类比</strong>：进程就像一个“工厂”，拥有自己的厂房（内存空间）、设备（资源）、工人（线程）和管理制度（内核结构）。</p>
</blockquote>
<hr>
<h3 id="1-2-什么是线程（Thread）？"><a href="#1-2-什么是线程（Thread）？" class="headerlink" title="1.2 什么是线程（Thread）？"></a>1.2 什么是线程（Thread）？</h3><p><strong>线程</strong>是<strong>进程内的执行单元</strong>，是 CPU 调度的最小单位。一个进程可以包含一个或多个线程，所有线程共享进程的<strong>地址空间和资源</strong>，但每个线程拥有自己的：</p>
<ul>
<li>栈（Stack）</li>
<li>寄存器状态（包括程序计数器 PC）</li>
<li>线程局部存储（TLS）</li>
<li>信号掩码（部分系统支持）</li>
<li>线程由<strong>线程 ID（TID）</strong> 标识。</li>
<li>同一进程内的线程可以<strong>直接访问共享内存</strong>，通信效率高。</li>
</ul>
<blockquote>
<p>💡 <strong>类比</strong>：线程就像工厂里的“工人”，共用厂房和设备，但各自有工具包（栈）和任务进度（PC）。</p>
</blockquote>
<hr>
<h2 id="二、进程-vs-线程：核心区别"><a href="#二、进程-vs-线程：核心区别" class="headerlink" title="二、进程 vs 线程：核心区别"></a>二、进程 vs 线程：核心区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>进程（Process）</th>
<th>线程（Thread）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址空间</strong></td>
<td>独立（隔离）</td>
<td>共享（同一进程内）</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>大（创建&#x2F;销毁慢）</td>
<td>小（轻量级）</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>IPC（管道、消息队列、共享内存等）</td>
<td>直接读写共享内存</td>
</tr>
<tr>
<td><strong>同步机制</strong></td>
<td>无需（天然隔离）</td>
<td>需要（互斥锁、条件变量等）</td>
</tr>
<tr>
<td><strong>健壮性</strong></td>
<td>一个崩溃不影响其他进程</td>
<td>一个线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td><strong>调度单位</strong></td>
<td>是（传统系统）</td>
<td>是（现代系统中线程是调度单位）</td>
</tr>
<tr>
<td><strong>创建方式</strong></td>
<td><code>fork()</code>、<code>exec()</code>（Unix）</td>
<td><code>pthread_create()</code>、<code>std::thread</code>（C++）</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <strong>关键点</strong>：现代操作系统（如 Linux）中，<strong>线程本质上也是“轻量级进程”</strong>，由内核统一调度。</p>
</blockquote>
<hr>
<h2 id="三、操作系统中的实现机制"><a href="#三、操作系统中的实现机制" class="headerlink" title="三、操作系统中的实现机制"></a>三、操作系统中的实现机制</h2><h3 id="3-1-Linux-中的进程与线程"><a href="#3-1-Linux-中的进程与线程" class="headerlink" title="3.1 Linux 中的进程与线程"></a>3.1 Linux 中的进程与线程</h3><p>Linux 采用 <strong>“一切皆进程”</strong> 的设计理念，使用 <strong><code>task_struct</code></strong> 结构体统一表示进程和线程。</p>
<ul>
<li><p><strong>进程创建</strong>：通过 <code>fork()</code> 系统调用，复制父进程的地址空间（写时复制 COW）。</p>
</li>
<li><p>线程创建</p>
<p>：通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone()</span><br></pre></td></tr></table></figure>

<p> 系统调用，传入标志如 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_FS | CLONE_FILES</span><br></pre></td></tr></table></figure>

<p> 等，表示共享地址空间、文件系统信息、文件描述符等。</p>
<ul>
<li><code>pthread_create()</code> 底层就是调用 <code>clone()</code>。</li>
</ul>
</li>
<li><p>PID 与 TID</p>
<p>：</p>
<ul>
<li>每个线程有唯一的 <strong>TID（Thread ID）</strong>。</li>
<li>同一进程内的所有线程共享同一个 <strong>TGID（Thread Group ID）</strong>，即主线程的 PID。</li>
<li><code>getpid()</code> 返回 TGID，<code>gettid()</code> 返回 TID。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 示例：<code>ps -eLf</code> 可查看所有线程，其中 <code>PID</code> 是 TGID，<code>LWP</code>（轻量级进程）是 TID。</p>
</blockquote>
<hr>
<h3 id="3-2-Windows-中的实现"><a href="#3-2-Windows-中的实现" class="headerlink" title="3.2 Windows 中的实现"></a>3.2 Windows 中的实现</h3><ul>
<li>Windows 使用 <strong>“进程 + 线程”</strong> 模型。</li>
<li>进程是资源容器，线程是执行实体。</li>
<li>创建进程：<code>CreateProcess()</code></li>
<li>创建线程：<code>CreateThread()</code></li>
<li>每个线程有独立的内核对象和用户栈。</li>
<li>线程调度由内核完成，支持优先级、亲和性等。</li>
</ul>
<hr>
<h2 id="四、内存布局（以-Linux-为例）"><a href="#四、内存布局（以-Linux-为例）" class="headerlink" title="四、内存布局（以 Linux 为例）"></a>四、内存布局（以 Linux 为例）</h2><p>一个典型进程的虚拟地址空间如下（从低地址到高地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">|        栈（Stack）     | ← 高地址，向下增长（每个线程有自己的栈）</span><br><span class="line">+------------------------+</span><br><span class="line">|        ...             |</span><br><span class="line">+------------------------+</span><br><span class="line">|        堆（Heap）      | ← 动态分配（malloc/new），向上增长（所有线程共享）</span><br><span class="line">+------------------------+</span><br><span class="line">|   BSS段（未初始化数据）|</span><br><span class="line">+------------------------+</span><br><span class="line">|   数据段（已初始化全局变量）|</span><br><span class="line">+------------------------+</span><br><span class="line">|   代码段（.text，只读） |</span><br><span class="line">+------------------------+</span><br><span class="line">|   内核空间（不可访问） |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>线程栈</strong>：通常默认 8MB（可配置），用于函数调用、局部变量。</li>
<li><strong>共享区域</strong>：堆、全局变量、代码段、打开的文件等，所有线程可见。</li>
</ul>
<hr>
<h2 id="五、线程同步与并发问题"><a href="#五、线程同步与并发问题" class="headerlink" title="五、线程同步与并发问题"></a>五、线程同步与并发问题</h2><p>由于线程共享内存，必须处理<strong>并发访问</strong>问题：</p>
<h3 id="常见同步原语："><a href="#常见同步原语：" class="headerlink" title="常见同步原语："></a>常见同步原语：</h3><table>
<thead>
<tr>
<th>原语</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>互斥锁（Mutex）</strong></td>
<td>保证临界区互斥访问</td>
</tr>
<tr>
<td><strong>条件变量（Condition Variable）</strong></td>
<td>线程间等待&#x2F;通知机制</td>
</tr>
<tr>
<td><strong>读写锁（RWLock）</strong></td>
<td>允许多读单写</td>
</tr>
<tr>
<td><strong>信号量（Semaphore）</strong></td>
<td>控制资源数量</td>
</tr>
<tr>
<td><strong>原子操作（Atomic）</strong></td>
<td>无锁编程基础（如 CAS）</td>
</tr>
</tbody></table>
<h3 id="经典问题："><a href="#经典问题：" class="headerlink" title="经典问题："></a>经典问题：</h3><ul>
<li><strong>竞态条件（Race Condition）</strong>：多个线程同时修改共享数据导致结果不确定。</li>
<li><strong>死锁（Deadlock）</strong>：多个线程互相等待对方释放锁。</li>
<li><strong>活锁（Livelock）</strong>：线程不断重试但无法前进。</li>
<li><strong>饥饿（Starvation）</strong>：某些线程长期得不到资源。</li>
</ul>
<hr>
<h2 id="六、进程间通信（IPC）-vs-线程间通信"><a href="#六、进程间通信（IPC）-vs-线程间通信" class="headerlink" title="六、进程间通信（IPC） vs 线程间通信"></a>六、进程间通信（IPC） vs 线程间通信</h2><h3 id="进程间通信（因地址空间隔离）："><a href="#进程间通信（因地址空间隔离）：" class="headerlink" title="进程间通信（因地址空间隔离）："></a>进程间通信（因地址空间隔离）：</h3><ul>
<li>管道（Pipe &#x2F; Named Pipe）</li>
<li>消息队列（Message Queue）</li>
<li>共享内存（Shared Memory）+ 信号量</li>
<li>信号（Signal）</li>
<li>套接字（Socket，包括 Unix Domain Socket）</li>
<li>内存映射文件（mmap）</li>
</ul>
<h3 id="线程间通信（因共享内存）："><a href="#线程间通信（因共享内存）：" class="headerlink" title="线程间通信（因共享内存）："></a>线程间通信（因共享内存）：</h3><ul>
<li>直接读写全局变量或堆内存</li>
<li>使用同步原语协调访问</li>
<li>条件变量通知</li>
<li>无锁队列（Lock-free Queue）</li>
</ul>
<blockquote>
<p>✅ <strong>性能对比</strong>：线程通信远快于进程通信，因为无需内核介入或内存拷贝。</p>
</blockquote>
<hr>
<h2 id="七、调度与上下文切换"><a href="#七、调度与上下文切换" class="headerlink" title="七、调度与上下文切换"></a>七、调度与上下文切换</h2><h3 id="上下文切换开销："><a href="#上下文切换开销：" class="headerlink" title="上下文切换开销："></a>上下文切换开销：</h3><ul>
<li><strong>进程切换</strong>：需切换页表（TLB flush）、地址空间、寄存器、内核栈等，开销大。</li>
<li><strong>线程切换</strong>（同进程内）：只需切换寄存器、栈指针、PC 等，<strong>不切换页表</strong>，开销小。</li>
</ul>
<h3 id="调度策略（Linux）："><a href="#调度策略（Linux）：" class="headerlink" title="调度策略（Linux）："></a>调度策略（Linux）：</h3><ul>
<li><strong>CFS（Completely Fair Scheduler）</strong>：默认调度器，基于红黑树公平分配 CPU 时间。</li>
<li>实时线程：<code>SCHED_FIFO</code>、<code>SCHED_RR</code></li>
<li>普通线程：<code>SCHED_OTHER</code></li>
</ul>
<hr>
<h2 id="八、多线程-vs-多进程：如何选择？"><a href="#八、多线程-vs-多进程：如何选择？" class="headerlink" title="八、多线程 vs 多进程：如何选择？"></a>八、多线程 vs 多进程：如何选择？</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐模型</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>高并发 I&#x2F;O（如 Web 服务器）</td>
<td>多线程 或 异步 I&#x2F;O</td>
<td>线程轻量，适合处理大量连接</td>
</tr>
<tr>
<td>CPU 密集型任务</td>
<td>多进程（或线程 + GIL 绕过）</td>
<td>避免 GIL（如 Python），或利用多核</td>
</tr>
<tr>
<td>安全性要求高（如浏览器）</td>
<td>多进程</td>
<td>一个 tab 崩溃不影响其他</td>
</tr>
<tr>
<td>实时性要求高</td>
<td>多线程 + 实时调度</td>
<td>线程切换快，响应及时</td>
</tr>
<tr>
<td>资源隔离需求强</td>
<td>多进程</td>
<td>内存、文件描述符完全隔离</td>
</tr>
</tbody></table>
<blockquote>
<p>🌰 例子：</p>
<ul>
<li><strong>Chrome 浏览器</strong>：每个标签页是一个进程（安全隔离）。</li>
<li><strong>Nginx</strong>：多进程模型（Master-Worker），每个 Worker 处理多个连接（事件驱动）。</li>
<li><strong>Java 应用</strong>：大量使用线程池处理请求。</li>
</ul>
</blockquote>
<hr>
<h2 id="九、高级话题"><a href="#九、高级话题" class="headerlink" title="九、高级话题"></a>九、高级话题</h2><h3 id="9-1-用户级线程-vs-内核级线程"><a href="#9-1-用户级线程-vs-内核级线程" class="headerlink" title="9.1 用户级线程 vs 内核级线程"></a>9.1 用户级线程 vs 内核级线程</h3><ul>
<li><strong>用户级线程（Green Threads）</strong>：由用户库管理（如早期 Java），内核 unaware，切换快但无法利用多核。</li>
<li><strong>内核级线程</strong>：由操作系统调度，可并行执行（现代系统主流）。</li>
<li><strong>混合模型（M:N）</strong>：M 个用户线程映射到 N 个内核线程（如 Go 的 Goroutine + GMP 调度器）。</li>
</ul>
<h3 id="9-2-协程（Coroutine）"><a href="#9-2-协程（Coroutine）" class="headerlink" title="9.2 协程（Coroutine）"></a>9.2 协程（Coroutine）</h3><ul>
<li>比线程更轻量，用户态调度，无抢占。</li>
<li>如 Python 的 <code>async/await</code>、Go 的 <code>goroutine</code>、Rust 的 <code>async</code>。</li>
<li>适合高并发 I&#x2F;O，但不适合 CPU 密集型。</li>
</ul>
<h3 id="9-3-线程安全与可重入"><a href="#9-3-线程安全与可重入" class="headerlink" title="9.3 线程安全与可重入"></a>9.3 线程安全与可重入</h3><ul>
<li><strong>线程安全函数</strong>：可被多个线程同时调用而不产生错误。</li>
<li><strong>可重入函数</strong>：不仅线程安全，还能在信号处理函数中安全调用（不使用静态&#x2F;全局变量）。</li>
</ul>
<hr>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>资源分配单位</td>
<td>CPU 调度单位</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>强（独立地址空间）</td>
<td>弱（共享地址空间）</td>
</tr>
<tr>
<td><strong>创建开销</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>通信效率</strong></td>
<td>低（需 IPC）</td>
<td>高（共享内存）</td>
</tr>
<tr>
<td><strong>健壮性</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>安全隔离、独立任务</td>
<td>高并发、资源共享</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>黄金法则</strong>：</p>
<ul>
<li>需要<strong>隔离与安全</strong> → 用<strong>进程</strong></li>
<li>需要<strong>性能与共享</strong> → 用<strong>线程</strong></li>
<li>需要<strong>超高并发</strong> → 考虑<strong>协程 + 事件循环</strong></li>
</ul>
</blockquote>
<hr>
<p>如果你对某个部分（如 Linux 的 <code>clone()</code> 实现、死锁检测算法、Go 的调度器等）感兴趣，我可以进一步深入讲解！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"># 嵌入式</a>
              <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"># 进程</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/10/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/SPI%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="prev" title="SPI串行通信协议">
      <i class="fa fa-chevron-left"></i> SPI串行通信协议
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/10/27/C_C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="next" title="C++ 中的智能指针">
      C++ 中的智能指针 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">一、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89%EF%BC%9F"><span class="nav-text">1.1 什么是进程（Process）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%EF%BC%9F"><span class="nav-text">1.2 什么是线程（Thread）？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B-vs-%E7%BA%BF%E7%A8%8B%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-text">二、进程 vs 线程：核心区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">三、操作系统中的实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Linux-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.1 Linux 中的进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Windows-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2 Windows 中的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%88%E4%BB%A5-Linux-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-text">四、内存布局（以 Linux 为例）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">五、线程同步与并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%EF%BC%9A"><span class="nav-text">常见同步原语：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-text">经典问题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89-vs-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">六、进程间通信（IPC） vs 线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E5%9B%A0%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%9A%94%E7%A6%BB%EF%BC%89%EF%BC%9A"><span class="nav-text">进程间通信（因地址空间隔离）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E5%9B%A0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%89%EF%BC%9A"><span class="nav-text">线程间通信（因共享内存）：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%B0%83%E5%BA%A6%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">七、调度与上下文切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80%EF%BC%9A"><span class="nav-text">上下文切换开销：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%EF%BC%88Linux%EF%BC%89%EF%BC%9A"><span class="nav-text">调度策略（Linux）：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B-vs-%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-text">八、多线程 vs 多进程：如何选择？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98"><span class="nav-text">九、高级话题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B-vs-%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-text">9.1 用户级线程 vs 内核级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89"><span class="nav-text">9.2 协程（Coroutine）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">9.3 线程安全与可重入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">十、总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yxa"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yxa</p>
  <div class="site-description" itemprop="description">DO SOMETHING COOL！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanxianan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanxianan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yanxiaoan429@163.com" title="E-Mail → mailto:yanxiaoan429@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yxa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!-- ҳ����С���� --> <script type="text/javascript" src="/js/clicklove.js"></script>